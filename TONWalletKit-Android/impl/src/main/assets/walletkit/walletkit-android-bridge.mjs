function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      var isInstance = false;
      try {
        isInstance = this instanceof a3;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a2, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a2;
}
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer2[offset + i];
    i += d;
    e = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s2 * 128;
  };
  return ieee754;
}
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base64 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf2 = createBuffer(length);
      const actual = buf2.write(string, encoding);
      if (actual !== length) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf2[i] = array[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x2 = a2.length;
      let y2 = b2.length;
      for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
        if (a2[i] !== b2[i]) {
          x2 = a2[i];
          y2 = b2[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2)) buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m) {
      const i = b2[n];
      b2[n] = b2[m];
      b2[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y2 = targetCopy[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string, offset, length) {
      return blitBuffer(utf8ToBytes2(string, buf2.length - offset), buf2, offset, length);
    }
    function asciiWrite(buf2, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf2, offset, length);
    }
    function base64Write(buf2, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf2, offset, length);
    }
    function ucs2Write(buf2, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf2.length - offset), buf2, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base64.fromByteArray(buf2);
      } else {
        return base64.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes = buf2.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4);
      }
      ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8);
      }
      ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    const errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var bufferExports = requireBuffer();
var LogLevel$1 = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["OFF"] = 0] = "OFF";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 3] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 4] = "DEBUG";
  return LogLevel2;
})(LogLevel$1 || {});
const logWindow = window;
const consoleRef = globalThis.console;
function getCurrentLogLevel() {
  var _a;
  const levelStr = logWindow.__WALLETKIT_LOG_LEVEL__ || "OFF";
  return (_a = LogLevel$1[levelStr]) != null ? _a : 0;
}
const info = (...args) => {
  var _a;
  if (getCurrentLogLevel() >= 3) {
    (_a = consoleRef == null ? void 0 : consoleRef.log) == null ? void 0 : _a.call(consoleRef, "[WalletKit]", ...args);
  }
};
const warn = (...args) => {
  var _a;
  if (getCurrentLogLevel() >= 2) {
    (_a = consoleRef == null ? void 0 : consoleRef.warn) == null ? void 0 : _a.call(consoleRef, "[WalletKit]", ...args);
  }
};
const error = (...args) => {
  var _a;
  if (getCurrentLogLevel() >= 1) {
    (_a = consoleRef == null ? void 0 : consoleRef.error) == null ? void 0 : _a.call(consoleRef, "[WalletKit]", ...args);
  }
};
function ensureBuffer(scope) {
  if (typeof scope.Buffer === "undefined") {
    Object.defineProperty(scope, "Buffer", {
      value: bufferExports.Buffer,
      writable: true,
      configurable: true
    });
  }
}
function setupNativeBridge() {
  const scope = window;
  ensureBuffer(scope);
  const bridge = scope.WalletKitNative;
  if (!bridge) {
    warn("[walletkitBridge] WalletKitNative bridge not found, storage will not be available");
    return;
  }
  if (typeof bridge.storageGet !== "function" || typeof bridge.storageSet !== "function" || typeof bridge.storageRemove !== "function" || typeof bridge.storageClear !== "function") {
    warn("[walletkitBridge] Bridge is missing storage methods, WalletKitNativeStorage will not be available");
    return;
  }
  try {
    const nativeStorage = {
      getItem(key) {
        try {
          const value = bridge.storageGet(key);
          return value === void 0 || value === null ? null : String(value);
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.getItem:", err);
          return null;
        }
      },
      setItem(key, value) {
        try {
          bridge.storageSet(key, String(value));
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.setItem:", err);
        }
      },
      removeItem(key) {
        try {
          bridge.storageRemove(key);
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.removeItem:", err);
        }
      },
      clear() {
        try {
          bridge.storageClear();
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.clear:", err);
        }
      }
    };
    if (typeof scope.WalletKitNativeStorage === "undefined") {
      Object.defineProperty(scope, "WalletKitNativeStorage", {
        value: nativeStorage,
        writable: false,
        configurable: true
      });
    } else {
      warn("[walletkitBridge] WalletKitNativeStorage already present, not overriding");
    }
  } catch (err) {
    error("[walletkitBridge] Failed to expose WalletKitNativeStorage:", err);
  }
}
setupNativeBridge();
var __async$c = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const walletKitModulePromise = Promise.resolve().then(() => index);
let TonWalletKit$1 = null;
let CreateTonMnemonic$1 = null;
let MnemonicToKeyPair$1 = null;
let Signer$1 = null;
let DefaultSignature$1 = null;
let WalletV4R2Adapter$1 = null;
let WalletV5R1Adapter$1 = null;
function ensureWalletKitLoaded() {
  return __async$c(this, null, function* () {
    var _a, _b, _c, _d, _e, _f;
    if (TonWalletKit$1 && Signer$1 && MnemonicToKeyPair$1 && DefaultSignature$1 && WalletV4R2Adapter$1 && WalletV5R1Adapter$1) {
      return;
    }
    if (!TonWalletKit$1 || !Signer$1 || !MnemonicToKeyPair$1 || !DefaultSignature$1 || !WalletV4R2Adapter$1 || !WalletV5R1Adapter$1) {
      const module = yield walletKitModulePromise;
      if (!module.TonWalletKit) {
        throw new Error("Failed to load TonWalletKit module");
      }
      TonWalletKit$1 = module.TonWalletKit;
      CreateTonMnemonic$1 = (_a = module.CreateTonMnemonic) != null ? _a : CreateTonMnemonic$1;
      MnemonicToKeyPair$1 = (_b = module.MnemonicToKeyPair) != null ? _b : MnemonicToKeyPair$1;
      Signer$1 = (_c = module.Signer) != null ? _c : Signer$1;
      DefaultSignature$1 = (_d = module.DefaultSignature) != null ? _d : DefaultSignature$1;
      WalletV4R2Adapter$1 = (_e = module.WalletV4R2Adapter) != null ? _e : WalletV4R2Adapter$1;
      WalletV5R1Adapter$1 = (_f = module.WalletV5R1Adapter) != null ? _f : WalletV5R1Adapter$1;
    }
  });
}
var naclUtil$1 = { exports: {} };
var naclUtil = naclUtil$1.exports;
var hasRequiredNaclUtil;
function requireNaclUtil() {
  if (hasRequiredNaclUtil) return naclUtil$1.exports;
  hasRequiredNaclUtil = 1;
  (function(module) {
    (function(root, f2) {
      if (module.exports) module.exports = f2();
      else if (root.nacl) root.nacl.util = f2();
      else {
        root.nacl = {};
        root.nacl.util = f2();
      }
    })(naclUtil, function() {
      var util2 = {};
      function validateBase64(s2) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
          throw new TypeError("invalid encoding");
        }
      }
      util2.decodeUTF8 = function(s2) {
        if (typeof s2 !== "string") throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s2)), b2 = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++) b2[i] = d.charCodeAt(i);
        return b2;
      };
      util2.encodeUTF8 = function(arr) {
        var i, s2 = [];
        for (i = 0; i < arr.length; i++) s2.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s2.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util2.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
          };
        } else {
          util2.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
          };
        }
      } else {
        util2.encodeBase64 = function(arr) {
          var i, s2 = [], len = arr.length;
          for (i = 0; i < len; i++) s2.push(String.fromCharCode(arr[i]));
          return btoa(s2.join(""));
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          var i, d = atob(s2), b2 = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++) b2[i] = d.charCodeAt(i);
          return b2;
        };
      }
      return util2;
    });
  })(naclUtil$1);
  return naclUtil$1.exports;
}
var naclUtilExports = requireNaclUtil();
const nacl$1 = /* @__PURE__ */ getDefaultExportFromCjs(naclUtilExports);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl2) {
      var gf = function(init2) {
        var i, r = new Float64Array(16);
        if (init2) for (i = 0; i < init2.length; i++) r[i] = init2[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i, h2, l) {
        x2[i] = h2 >> 24 & 255;
        x2[i + 1] = h2 >> 16 & 255;
        x2[i + 2] = h2 >> 8 & 255;
        x2[i + 3] = h2 & 255;
        x2[i + 4] = l >> 24 & 255;
        x2[i + 5] = l >> 16 & 255;
        x2[i + 6] = l >> 8 & 255;
        x2[i + 7] = l & 255;
      }
      function vn(x2, xi, y2, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x2[xi + i] ^ y2[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 16);
      }
      function crypto_verify_32(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 32);
      }
      function core_salsa20(o4, p2, k2, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x1 >>> 0 & 255;
        o4[5] = x1 >>> 8 & 255;
        o4[6] = x1 >>> 16 & 255;
        o4[7] = x1 >>> 24 & 255;
        o4[8] = x2 >>> 0 & 255;
        o4[9] = x2 >>> 8 & 255;
        o4[10] = x2 >>> 16 & 255;
        o4[11] = x2 >>> 24 & 255;
        o4[12] = x3 >>> 0 & 255;
        o4[13] = x3 >>> 8 & 255;
        o4[14] = x3 >>> 16 & 255;
        o4[15] = x3 >>> 24 & 255;
        o4[16] = x4 >>> 0 & 255;
        o4[17] = x4 >>> 8 & 255;
        o4[18] = x4 >>> 16 & 255;
        o4[19] = x4 >>> 24 & 255;
        o4[20] = x5 >>> 0 & 255;
        o4[21] = x5 >>> 8 & 255;
        o4[22] = x5 >>> 16 & 255;
        o4[23] = x5 >>> 24 & 255;
        o4[24] = x6 >>> 0 & 255;
        o4[25] = x6 >>> 8 & 255;
        o4[26] = x6 >>> 16 & 255;
        o4[27] = x6 >>> 24 & 255;
        o4[28] = x7 >>> 0 & 255;
        o4[29] = x7 >>> 8 & 255;
        o4[30] = x7 >>> 16 & 255;
        o4[31] = x7 >>> 24 & 255;
        o4[32] = x8 >>> 0 & 255;
        o4[33] = x8 >>> 8 & 255;
        o4[34] = x8 >>> 16 & 255;
        o4[35] = x8 >>> 24 & 255;
        o4[36] = x9 >>> 0 & 255;
        o4[37] = x9 >>> 8 & 255;
        o4[38] = x9 >>> 16 & 255;
        o4[39] = x9 >>> 24 & 255;
        o4[40] = x10 >>> 0 & 255;
        o4[41] = x10 >>> 8 & 255;
        o4[42] = x10 >>> 16 & 255;
        o4[43] = x10 >>> 24 & 255;
        o4[44] = x11 >>> 0 & 255;
        o4[45] = x11 >>> 8 & 255;
        o4[46] = x11 >>> 16 & 255;
        o4[47] = x11 >>> 24 & 255;
        o4[48] = x12 >>> 0 & 255;
        o4[49] = x12 >>> 8 & 255;
        o4[50] = x12 >>> 16 & 255;
        o4[51] = x12 >>> 24 & 255;
        o4[52] = x13 >>> 0 & 255;
        o4[53] = x13 >>> 8 & 255;
        o4[54] = x13 >>> 16 & 255;
        o4[55] = x13 >>> 24 & 255;
        o4[56] = x14 >>> 0 & 255;
        o4[57] = x14 >>> 8 & 255;
        o4[58] = x14 >>> 16 & 255;
        o4[59] = x14 >>> 24 & 255;
        o4[60] = x15 >>> 0 & 255;
        o4[61] = x15 >>> 8 & 255;
        o4[62] = x15 >>> 16 & 255;
        o4[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o4, p2, k2, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x5 >>> 0 & 255;
        o4[5] = x5 >>> 8 & 255;
        o4[6] = x5 >>> 16 & 255;
        o4[7] = x5 >>> 24 & 255;
        o4[8] = x10 >>> 0 & 255;
        o4[9] = x10 >>> 8 & 255;
        o4[10] = x10 >>> 16 & 255;
        o4[11] = x10 >>> 24 & 255;
        o4[12] = x15 >>> 0 & 255;
        o4[13] = x15 >>> 8 & 255;
        o4[14] = x15 >>> 16 & 255;
        o4[15] = x15 >>> 24 & 255;
        o4[16] = x6 >>> 0 & 255;
        o4[17] = x6 >>> 8 & 255;
        o4[18] = x6 >>> 16 & 255;
        o4[19] = x6 >>> 24 & 255;
        o4[20] = x7 >>> 0 & 255;
        o4[21] = x7 >>> 8 & 255;
        o4[22] = x7 >>> 16 & 255;
        o4[23] = x7 >>> 24 & 255;
        o4[24] = x8 >>> 0 & 255;
        o4[25] = x8 >>> 8 & 255;
        o4[26] = x8 >>> 16 & 255;
        o4[27] = x8 >>> 24 & 255;
        o4[28] = x9 >>> 0 & 255;
        o4[29] = x9 >>> 8 & 255;
        o4[30] = x9 >>> 16 & 255;
        o4[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k2, c) {
        core_salsa20(out, inp, k2, c);
      }
      function crypto_core_hsalsa20(out, inp, k2, c) {
        core_hsalsa20(out, inp, k2, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b2, n, k2) {
        var z = new Uint8Array(16), x2 = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z, k2, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x2[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z, k2, sigma);
          for (i = 0; i < b2; i++) c[cpos + i] = m[mpos + i] ^ x2[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b2, n, k2) {
        var z = new Uint8Array(16), x2 = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z, k2, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x2[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z, k2, sigma);
          for (i = 0; i < b2; i++) c[cpos + i] = x2[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k2, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s2);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k2, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s2);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f2, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i = 1; i < 8; i++) {
          f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
          this.h[i] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k2) {
        var s2 = new poly1305(k2);
        s2.update(m, mpos, n);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m, mpos, n, k2) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m, mpos, n, k2);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c, m, d, n, k2) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k2);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k2) {
        var i;
        var x2 = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x2, 0, 32, n, k2);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x2) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k2);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a2) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a2[i] | 0;
      }
      function car25519(o4) {
        var i, v2, c = 1;
        for (i = 0; i < 16; i++) {
          v2 = o4[i] + c + 65535;
          c = Math.floor(v2 / 65536);
          o4[i] = v2 - c * 65536;
        }
        o4[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p2, q, b2) {
        var t, c = ~(b2 - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p2[i] ^ q[i]);
          p2[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o4, n) {
        var i, j, b2;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b2 = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b2);
        }
        for (i = 0; i < 16; i++) {
          o4[2 * i] = t[i] & 255;
          o4[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a2, b2) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a2);
        pack25519(d, b2);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a2) {
        var d = new Uint8Array(32);
        pack25519(d, a2);
        return d[0] & 1;
      }
      function unpack25519(o4, n) {
        var i;
        for (i = 0; i < 16; i++) o4[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o4[15] &= 32767;
      }
      function A(o4, a2, b2) {
        for (var i = 0; i < 16; i++) o4[i] = a2[i] + b2[i];
      }
      function Z(o4, a2, b2) {
        for (var i = 0; i < 16; i++) o4[i] = a2[i] - b2[i];
      }
      function M2(o4, a2, b2) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v2 = a2[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b22;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a2[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b22;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a2[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b22;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a2[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b22;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a2[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b22;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a2[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b22;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a2[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b22;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a2[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b22;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a2[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b22;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a2[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b22;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a2[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b22;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a2[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b22;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a2[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b22;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a2[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b22;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a2[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b22;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a2[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b22;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o4[0] = t0;
        o4[1] = t1;
        o4[2] = t2;
        o4[3] = t3;
        o4[4] = t4;
        o4[5] = t5;
        o4[6] = t6;
        o4[7] = t7;
        o4[8] = t8;
        o4[9] = t9;
        o4[10] = t10;
        o4[11] = t11;
        o4[12] = t12;
        o4[13] = t13;
        o4[14] = t14;
        o4[15] = t15;
      }
      function S2(o4, a2) {
        M2(o4, a2, a2);
      }
      function inv25519(o4, i) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 2 && a2 !== 4) M2(c, c, i);
        }
        for (a2 = 0; a2 < 16; a2++) o4[a2] = c[a2];
      }
      function pow2523(o4, i) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 1) M2(c, c, i);
        }
        for (a2 = 0; a2 < 16; a2++) o4[a2] = c[a2];
      }
      function crypto_scalarmult(q, n, p2) {
        var z = new Uint8Array(32);
        var x2 = new Float64Array(80), r, i;
        var a2 = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f2 = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x2, p2);
        for (i = 0; i < 16; i++) {
          b2[i] = x2[i];
          d[i] = a2[i] = c[i] = 0;
        }
        a2[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a2, b2, r);
          sel25519(c, d, r);
          A(e, a2, c);
          Z(a2, a2, c);
          A(c, b2, d);
          Z(b2, b2, d);
          S2(d, e);
          S2(f2, a2);
          M2(a2, c, a2);
          M2(c, b2, e);
          A(e, a2, c);
          Z(a2, a2, c);
          S2(b2, a2);
          Z(c, d, f2);
          M2(a2, c, _121665);
          A(a2, a2, d);
          M2(c, c, a2);
          M2(a2, d, f2);
          M2(d, b2, x2);
          S2(b2, e);
          sel25519(a2, b2, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x2[i + 16] = a2[i];
          x2[i + 32] = c[i];
          x2[i + 48] = b2[i];
          x2[i + 64] = d[i];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k2, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k2, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_afternm(c, m, d, n, k2);
      }
      function crypto_box_open(m, c, d, n, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_open_afternm(m, c, d, n, k2);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h2, l, a2, b2, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = K[i * 2];
            l = K[i * 2 + 1];
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i % 16];
            l = wl[i % 16];
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a2 & 65535 | b2 << 16;
            h2 = th;
            l = tl;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a2 & 65535 | b2 << 16;
            h2 = bh3;
            l = bl3;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a2 & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h2 = wh[j];
                l = wl[j];
                a2 = l & 65535;
                b2 = l >>> 16;
                c = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                b2 += a2 >>> 16;
                c += b2 >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a2 & 65535 | b2 << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a2 & 65535 | b2 << 16;
          h2 = ah1;
          l = al1;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a2 & 65535 | b2 << 16;
          h2 = ah2;
          l = al2;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a2 & 65535 | b2 << 16;
          h2 = ah3;
          l = al3;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a2 & 65535 | b2 << 16;
          h2 = ah4;
          l = al4;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a2 & 65535 | b2 << 16;
          h2 = ah5;
          l = al5;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a2 & 65535 | b2 << 16;
          h2 = ah6;
          l = al6;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a2 & 65535 | b2 << 16;
          h2 = ah7;
          l = al7;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a2 & 65535 | b2 << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x2[i] = m[b2 - n + i];
        x2[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x2[n - 9] = 0;
        ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh, hl, x2, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add2(p2, q) {
        var a2 = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g = gf(), h2 = gf(), t = gf();
        Z(a2, p2[1], p2[0]);
        Z(t, q[1], q[0]);
        M2(a2, a2, t);
        A(b2, p2[0], p2[1]);
        A(t, q[0], q[1]);
        M2(b2, b2, t);
        M2(c, p2[3], q[3]);
        M2(c, c, D22);
        M2(d, p2[2], q[2]);
        A(d, d, d);
        Z(e, b2, a2);
        Z(f2, d, c);
        A(g, d, c);
        A(h2, b2, a2);
        M2(p2[0], e, f2);
        M2(p2[1], h2, g);
        M2(p2[2], g, f2);
        M2(p2[3], e, h2);
      }
      function cswap(p2, q, b2) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p2[i], q[i], b2);
        }
      }
      function pack(r, p2) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p2[2]);
        M2(tx, p2[0], zi);
        M2(ty, p2[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q, s2) {
        var b2, i;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i = 255; i >= 0; --i) {
          b2 = s2[i / 8 | 0] >> (i & 7) & 1;
          cswap(p2, q, b2);
          add2(q, p2);
          add2(p2, p2);
          cswap(p2, q, b2);
        }
      }
      function scalarbase(p2, s2) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X, Y);
        scalarmult(p2, q, s2);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p2, d);
        pack(pk, p2);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x2) {
        var carry, i, j, k2;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k2 = i - 12; j < k2; ++j) {
            x2[j] += carry - 16 * x2[i] * L[j - (i - 32)];
            carry = Math.floor((x2[j] + 128) / 256);
            x2[j] -= carry * 256;
          }
          x2[j] += carry;
          x2[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x2[j] += carry - (x2[31] >> 4) * L[j];
          carry = x2[j] >> 8;
          x2[j] &= 255;
        }
        for (j = 0; j < 32; j++) x2[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x2[i + 1] += x2[i] >> 8;
          r[i] = x2[i] & 255;
        }
      }
      function reduce(r) {
        var x2 = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x2[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x2);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x2 = new Float64Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p2, r);
        pack(sm, p2);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i = 0; i < 64; i++) x2[i] = 0;
        for (i = 0; i < 32; i++) x2[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x2[i + j] += h2[i] * d[j];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r, p2) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p2);
        S2(num, r[1]);
        M2(den, num, D2);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r[0], t, den);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r[0], r[0], I2);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p2[31] >> 7) Z(r[0], gf0, r[0]);
        M2(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h2, m, n);
        reduce(h2);
        scalarmult(p2, q, h2);
        scalarbase(q, sm.subarray(32));
        add2(p2, q);
        pack(t, p2);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D2,
        L,
        pack25519,
        unpack25519,
        M: M2,
        A,
        S: S2,
        Z,
        pow2523,
        add: add2,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k2, n) {
        if (k2.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b2 = new Uint8Array(n);
        randombytes(b2, n);
        return b2;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p2) {
        checkArrayTypes(n, p2);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p2);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k2);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k2, publicKey, secretKey);
        return k2;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k2);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0) return false;
        if (x2.length !== y2.length) return false;
        return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x2, n) {
            var i, v2 = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x2[i] = v2[i];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$0;
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x2, n) {
              var i, v2 = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x2[i] = v2[i];
              cleanup(v2);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
var naclFastExports = requireNaclFast();
const f = /* @__PURE__ */ getDefaultExportFromCjs(naclFastExports);
var CONNECT_EVENT_ERROR_CODES;
(function(CONNECT_EVENT_ERROR_CODES2) {
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES2) {
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(SEND_TRANSACTION_ERROR_CODES2) {
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(SIGN_DATA_ERROR_CODES2) {
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(DISCONNECT_ERROR_CODES2) {
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["MAINNET"] = "-239";
  CHAIN2["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));
function encodeUint8Array(value, urlSafe) {
  const encoded = nacl$1.encodeBase64(value);
  if (!urlSafe) {
    return encoded;
  }
  return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
  if (urlSafe) {
    value = decodeURIComponent(value);
  }
  return nacl$1.decodeBase64(value);
}
function encode(value, urlSafe = false) {
  let uint8Array;
  if (value instanceof Uint8Array) {
    uint8Array = value;
  } else {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    uint8Array = nacl$1.decodeUTF8(value);
  }
  return encodeUint8Array(uint8Array, urlSafe);
}
function decode(value, urlSafe = false) {
  const decodedUint8Array = decodeToUint8Array(value, urlSafe);
  return {
    toString() {
      return nacl$1.encodeUTF8(decodedUint8Array);
    },
    toObject() {
      try {
        return JSON.parse(nacl$1.encodeUTF8(decodedUint8Array));
      } catch (e) {
        return null;
      }
    },
    toUint8Array() {
      return decodedUint8Array;
    }
  };
}
const Base64 = {
  encode,
  decode
};
function concatUint8Arrays(buffer1, buffer2) {
  const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
  mergedArray.set(buffer1);
  mergedArray.set(buffer2, buffer1.length);
  return mergedArray;
}
function splitToUint8Arrays(array, index2) {
  if (index2 >= array.length) {
    throw new Error("Index is out of buffer");
  }
  const subArray1 = array.slice(0, index2);
  const subArray2 = array.slice(index2);
  return [subArray1, subArray2];
}
function toHexString(byteArray) {
  let hexString = "";
  byteArray.forEach((byte) => {
    hexString += ("0" + (byte & 255).toString(16)).slice(-2);
  });
  return hexString;
}
function hexToByteArray(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error(`Cannot convert ${hexString} to bytesArray`);
  }
  const result = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
  }
  return result;
}
class SessionCrypto {
  constructor(keyPair) {
    this.nonceLength = 24;
    this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
    this.sessionId = toHexString(this.keyPair.publicKey);
  }
  createKeypair() {
    return f.box.keyPair();
  }
  createKeypairFromString(keyPair) {
    return {
      publicKey: hexToByteArray(keyPair.publicKey),
      secretKey: hexToByteArray(keyPair.secretKey)
    };
  }
  createNonce() {
    return f.randomBytes(this.nonceLength);
  }
  encrypt(message, receiverPublicKey) {
    const encodedMessage = new TextEncoder().encode(message);
    const nonce = this.createNonce();
    const encrypted = f.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
    return concatUint8Arrays(nonce, encrypted);
  }
  decrypt(message, senderPublicKey) {
    const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
    const decrypted = f.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
    if (!decrypted) {
      throw new Error(`Decryption error: 
 message: ${message.toString()} 
 sender pubkey: ${senderPublicKey.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    }
    return new TextDecoder().decode(decrypted);
  }
  stringifyKeypair() {
    return {
      publicKey: toHexString(this.keyPair.publicKey),
      secretKey: toHexString(this.keyPair.secretKey)
    };
  }
}
var dist$1 = {};
var Address = {};
var symbol_inspect;
var hasRequiredSymbol_inspect;
function requireSymbol_inspect() {
  if (hasRequiredSymbol_inspect) return symbol_inspect;
  hasRequiredSymbol_inspect = 1;
  const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
  symbol_inspect = SymbolInspect;
  return symbol_inspect;
}
var crc16 = {};
var hasRequiredCrc16;
function requireCrc16() {
  if (hasRequiredCrc16) return crc16;
  hasRequiredCrc16 = 1;
  Object.defineProperty(crc16, "__esModule", { value: true });
  crc16.crc16 = void 0;
  function crc16$1(data) {
    const poly = 4129;
    let reg = 0;
    const message = Buffer.alloc(data.length + 2);
    message.set(data);
    for (let byte of message) {
      let mask = 128;
      while (mask > 0) {
        reg <<= 1;
        if (byte & mask) {
          reg += 1;
        }
        mask >>= 1;
        if (reg > 65535) {
          reg &= 65535;
          reg ^= poly;
        }
      }
    }
    return Buffer.from([Math.floor(reg / 256), reg % 256]);
  }
  crc16.crc16 = crc16$1;
  return crc16;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return Address;
  hasRequiredAddress = 1;
  var __importDefault = Address && Address.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Address, "__esModule", { value: true });
  Address.address = Address.Address = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const crc16_1 = requireCrc16();
  const bounceable_tag = 17;
  const non_bounceable_tag = 81;
  const test_flag = 128;
  function parseFriendlyAddress(src) {
    if (typeof src === "string" && !Address$1.isFriendly(src)) {
      throw new Error("Unknown address type");
    }
    const data = Buffer.isBuffer(src) ? src : Buffer.from(src, "base64");
    if (data.length !== 36) {
      throw new Error("Unknown address type: byte length is not equal to 36");
    }
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
      throw new Error("Invalid checksum: " + src);
    }
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
      isTestOnly = true;
      tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag)
      throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 255) {
      workchain = -1;
    } else {
      workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return { isTestOnly, isBounceable, workchain, hashPart };
  }
  let Address$1 = class Address2 {
    static isAddress(src) {
      return src instanceof Address2;
    }
    static isFriendly(source) {
      if (source.length !== 48) {
        return false;
      }
      if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
        return false;
      }
      return true;
    }
    static isRaw(source) {
      if (source.indexOf(":") === -1) {
        return false;
      }
      let [wc, hash] = source.split(":");
      if (!Number.isInteger(parseFloat(wc))) {
        return false;
      }
      if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
        return false;
      }
      if (hash.length !== 64) {
        return false;
      }
      return true;
    }
    static normalize(source) {
      if (typeof source === "string") {
        return Address2.parse(source).toString();
      } else {
        return source.toString();
      }
    }
    static parse(source) {
      if (Address2.isFriendly(source)) {
        return this.parseFriendly(source).address;
      } else if (Address2.isRaw(source)) {
        return this.parseRaw(source);
      } else {
        throw new Error("Unknown address type: " + source);
      }
    }
    static parseRaw(source) {
      let workChain = parseInt(source.split(":")[0]);
      let hash = Buffer.from(source.split(":")[1], "hex");
      return new Address2(workChain, hash);
    }
    static parseFriendly(source) {
      if (Buffer.isBuffer(source)) {
        let r = parseFriendlyAddress(source);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      } else {
        let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
        let r = parseFriendlyAddress(addr);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      }
    }
    constructor(workChain, hash) {
      this.toRawString = () => {
        return this.workChain + ":" + this.hash.toString("hex");
      };
      this.toRaw = () => {
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(this.hash);
        addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
        return addressWithChecksum;
      };
      this.toStringBuffer = (args) => {
        let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
        let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
        let tag = bounceable ? bounceable_tag : non_bounceable_tag;
        if (testOnly) {
          tag |= test_flag;
        }
        const addr = Buffer.alloc(34);
        addr[0] = tag;
        addr[1] = this.workChain;
        addr.set(this.hash, 2);
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(addr);
        addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
        return addressWithChecksum;
      };
      this.toString = (args) => {
        let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
        let buffer2 = this.toStringBuffer(args);
        if (urlSafe) {
          return buffer2.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
        } else {
          return buffer2.toString("base64");
        }
      };
      this[_a] = () => this.toString();
      if (hash.length !== 32) {
        throw new Error("Invalid address hash length: " + hash.length);
      }
      this.workChain = workChain;
      this.hash = hash;
      Object.freeze(this);
    }
    equals(src) {
      if (src.workChain !== this.workChain) {
        return false;
      }
      return src.hash.equals(this.hash);
    }
  };
  Address.Address = Address$1;
  _a = symbol_inspect_1.default;
  function address(src) {
    return Address$1.parse(src);
  }
  Address.address = address;
  return Address;
}
var ExternalAddress = {};
var hasRequiredExternalAddress;
function requireExternalAddress() {
  if (hasRequiredExternalAddress) return ExternalAddress;
  hasRequiredExternalAddress = 1;
  var __importDefault = ExternalAddress && ExternalAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(ExternalAddress, "__esModule", { value: true });
  ExternalAddress.ExternalAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let ExternalAddress$1 = class ExternalAddress2 {
    static isAddress(src) {
      return src instanceof ExternalAddress2;
    }
    constructor(value, bits) {
      this[_a] = () => this.toString();
      this.value = value;
      this.bits = bits;
    }
    toString() {
      return `External<${this.bits}:${this.value}>`;
    }
  };
  ExternalAddress.ExternalAddress = ExternalAddress$1;
  _a = symbol_inspect_1.default;
  return ExternalAddress;
}
var ADNLAddress = {};
var base32 = {};
var hasRequiredBase32;
function requireBase32() {
  if (hasRequiredBase32) return base32;
  hasRequiredBase32 = 1;
  Object.defineProperty(base32, "__esModule", { value: true });
  base32.base32Decode = base32.base32Encode = void 0;
  const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  function base32Encode(buffer2) {
    const length = buffer2.byteLength;
    let bits = 0;
    let value = 0;
    let output = "";
    for (let i = 0; i < length; i++) {
      value = value << 8 | buffer2[i];
      bits += 8;
      while (bits >= 5) {
        output += alphabet[value >>> bits - 5 & 31];
        bits -= 5;
      }
    }
    if (bits > 0) {
      output += alphabet[value << 5 - bits & 31];
    }
    return output;
  }
  base32.base32Encode = base32Encode;
  function readChar(alphabet2, char) {
    const idx = alphabet2.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index2 = 0;
    const output = Buffer.alloc(length * 5 / 8 | 0);
    for (let i = 0; i < length; i++) {
      value = value << 5 | readChar(alphabet, cleanedInput[i]);
      bits += 5;
      if (bits >= 8) {
        output[index2++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output;
  }
  base32.base32Decode = base32Decode;
  return base32;
}
var hasRequiredADNLAddress;
function requireADNLAddress() {
  if (hasRequiredADNLAddress) return ADNLAddress;
  hasRequiredADNLAddress = 1;
  var __importDefault = ADNLAddress && ADNLAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(ADNLAddress, "__esModule", { value: true });
  ADNLAddress.ADNLAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const base32_1 = requireBase32();
  const crc16_1 = requireCrc16();
  let ADNLAddress$1 = class ADNLAddress2 {
    static parseFriendly(src) {
      if (src.length !== 55) {
        throw Error("Invalid address");
      }
      src = "f" + src;
      let decoded = (0, base32_1.base32Decode)(src);
      if (decoded[0] !== 45) {
        throw Error("Invalid address");
      }
      let gotHash = decoded.slice(33);
      let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
      if (!hash.equals(gotHash)) {
        throw Error("Invalid address");
      }
      return new ADNLAddress2(decoded.slice(1, 33));
    }
    static parseRaw(src) {
      const data = Buffer.from(src, "base64");
      return new ADNLAddress2(data);
    }
    constructor(address) {
      this.toRaw = () => {
        return this.address.toString("hex").toUpperCase();
      };
      this.toString = () => {
        let data = Buffer.concat([Buffer.from([45]), this.address]);
        let hash = (0, crc16_1.crc16)(data);
        data = Buffer.concat([data, hash]);
        return (0, base32_1.base32Encode)(data).slice(1);
      };
      this[_a] = () => this.toString();
      if (address.length !== 32) {
        throw Error("Invalid address");
      }
      this.address = address;
    }
    equals(b2) {
      return this.address.equals(b2.address);
    }
  };
  ADNLAddress.ADNLAddress = ADNLAddress$1;
  _a = symbol_inspect_1.default;
  return ADNLAddress;
}
var contractAddress = {};
var Builder = {};
var BitBuilder = {};
var BitString = {};
var paddedBits = {};
var hasRequiredPaddedBits;
function requirePaddedBits() {
  if (hasRequiredPaddedBits) return paddedBits;
  hasRequiredPaddedBits = 1;
  Object.defineProperty(paddedBits, "__esModule", { value: true });
  paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const BitString_1 = requireBitString();
  function bitsToPaddedBuffer(bits) {
    let builder2 = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder2.writeBits(bits);
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for (let i = 0; i < padding; i++) {
      if (i === 0) {
        builder2.writeBit(1);
      } else {
        builder2.writeBit(0);
      }
    }
    return builder2.buffer();
  }
  paddedBits.bitsToPaddedBuffer = bitsToPaddedBuffer;
  function paddedBufferToBits(buff) {
    let bitLen = 0;
    for (let i = buff.length - 1; i >= 0; i--) {
      if (buff[i] !== 0) {
        const testByte = buff[i];
        let bitPos = testByte & -testByte;
        if ((bitPos & 1) == 0) {
          bitPos = Math.log2(bitPos) + 1;
        }
        if (i > 0) {
          bitLen = i << 3;
        }
        bitLen += 8 - bitPos;
        break;
      }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
  }
  paddedBits.paddedBufferToBits = paddedBufferToBits;
  return paddedBits;
}
var hasRequiredBitString;
function requireBitString() {
  if (hasRequiredBitString) return BitString;
  hasRequiredBitString = 1;
  var __importDefault = BitString && BitString.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(BitString, "__esModule", { value: true });
  BitString.BitString = void 0;
  const paddedBits_1 = requirePaddedBits();
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let BitString$1 = class BitString2 {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/
    static isBitString(src) {
      return src instanceof BitString2;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */
    constructor(data, offset, length) {
      this[_a] = () => this.toString();
      if (length < 0) {
        throw new Error(`Length ${length} is out of bounds`);
      }
      this._length = length;
      this._data = data;
      this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */
    at(index2) {
      if (index2 >= this._length) {
        throw new Error(`Index ${index2} > ${this._length} is out of bounds`);
      }
      if (index2 < 0) {
        throw new Error(`Index ${index2} < 0 is out of bounds`);
      }
      let byteIndex = this._offset + index2 >> 3;
      let bitIndex = 7 - (this._offset + index2) % 8;
      return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */
    substring(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset(${offset}) < 0 is out of bounds`);
      }
      if (length === 0) {
        return BitString2.EMPTY;
      }
      if (offset + length > this._length) {
        throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
      }
      return new BitString2(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */
    subbuffer(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset + length > this._length) {
        throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
      }
      if (length % 8 !== 0) {
        return null;
      }
      if ((this._offset + offset) % 8 !== 0) {
        return null;
      }
      let start = this._offset + offset >> 3;
      let end = start + (length >> 3);
      return this._data.subarray(start, end);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */
    equals(b2) {
      if (this._length !== b2._length) {
        return false;
      }
      for (let i = 0; i < this._length; i++) {
        if (this.at(i) !== b2.at(i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */
    toString() {
      const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
      if (this._length % 4 === 0) {
        const s2 = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
        if (this._length % 8 === 0) {
          return s2;
        } else {
          return s2.substring(0, s2.length - 1);
        }
      } else {
        const hex = padded.toString("hex").toUpperCase();
        if (this._length % 8 <= 4) {
          return hex.substring(0, hex.length - 1) + "_";
        } else {
          return hex + "_";
        }
      }
    }
  };
  BitString.BitString = BitString$1;
  _a = symbol_inspect_1.default;
  BitString$1.EMPTY = new BitString$1(Buffer.alloc(0), 0, 0);
  return BitString;
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
  if (hasRequiredBitBuilder) return BitBuilder;
  hasRequiredBitBuilder = 1;
  Object.defineProperty(BitBuilder, "__esModule", { value: true });
  BitBuilder.BitBuilder = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  const BitString_1 = requireBitString();
  let BitBuilder$1 = class BitBuilder {
    constructor(size = 1023) {
      this._buffer = Buffer.alloc(Math.ceil(size / 8));
      this._length = 0;
    }
    /**
     * Current number of bits written
     */
    get length() {
      return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */
    writeBit(value) {
      let n = this._length;
      if (n > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
        this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
      }
      this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */
    writeBits(src) {
      for (let i = 0; i < src.length; i++) {
        this.writeBit(src.at(i));
      }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */
    writeBuffer(src) {
      if (this._length % 8 === 0) {
        if (this._length + src.length * 8 > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        src.copy(this._buffer, this._length / 8);
        this._length += src.length * 8;
      } else {
        for (let i = 0; i < src.length; i++) {
          this.writeUint(src[i], 8);
        }
      }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeUint(value, bits) {
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      const v2 = BigInt(value);
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      const vBits = 1n << BigInt(bits);
      if (v2 < 0 || v2 >= vBits) {
        throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
      }
      if (this._length + bits > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      const tillByte = 8 - this._length % 8;
      if (tillByte > 0) {
        const bidx = Math.floor(this._length / 8);
        if (bits < tillByte) {
          const wb = Number(v2);
          this._buffer[bidx] |= wb << tillByte - bits;
          this._length += bits;
        } else {
          const wb = Number(v2 >> BigInt(bits - tillByte));
          this._buffer[bidx] |= wb;
          this._length += tillByte;
        }
      }
      bits -= tillByte;
      while (bits > 0) {
        if (bits >= 8) {
          this._buffer[this._length / 8] = Number(v2 >> BigInt(bits - 8) & 0xffn);
          this._length += 8;
          bits -= 8;
        } else {
          this._buffer[this._length / 8] = Number(v2 << BigInt(8 - bits) & 0xffn);
          this._length += bits;
          bits = 0;
        }
      }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      if (bits === 1) {
        if (v2 !== -1n && v2 !== 0n) {
          throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
        } else {
          this.writeBit(v2 === -1n);
          return;
        }
      }
      let vBits = 1n << BigInt(bits) - 1n;
      if (v2 < -vBits || v2 >= vBits) {
        throw Error(`value is out of range for ${bits} bits. Got ${value}`);
      }
      if (v2 < 0) {
        this.writeBit(true);
        v2 = vBits + v2;
      } else {
        this.writeBit(false);
      }
      this.writeUint(v2, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarUint(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 < 0) {
        throw Error(`value is negative. Got ${value}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      const sizeBytes = Math.ceil(v2.toString(2).length / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeUint(v2, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      const sizeBytes = Math.ceil((v22.toString(2).length + 1) / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeInt(v2, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */
    writeCoins(amount) {
      this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */
    writeAddress(address) {
      if (address === null || address === void 0) {
        this.writeUint(0, 2);
        return;
      }
      if (Address_1.Address.isAddress(address)) {
        this.writeUint(2, 2);
        this.writeUint(0, 1);
        this.writeInt(address.workChain, 8);
        this.writeBuffer(address.hash);
        return;
      }
      if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
        this.writeUint(1, 2);
        this.writeUint(address.bits, 9);
        this.writeUint(address.value, address.bits);
        return;
      }
      throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */
    build() {
      return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */
    buffer() {
      if (this._length % 8 !== 0) {
        throw new Error("BitBuilder buffer is not byte aligned");
      }
      return this._buffer.subarray(0, this._length / 8);
    }
  };
  BitBuilder.BitBuilder = BitBuilder$1;
  return BitBuilder;
}
var Cell = {};
var CellType = {};
var hasRequiredCellType;
function requireCellType() {
  if (hasRequiredCellType) return CellType;
  hasRequiredCellType = 1;
  Object.defineProperty(CellType, "__esModule", { value: true });
  CellType.CellType = void 0;
  var CellType$1;
  (function(CellType2) {
    CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
    CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
    CellType2[CellType2["Library"] = 2] = "Library";
    CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
    CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
  })(CellType$1 || (CellType.CellType = CellType$1 = {}));
  return CellType;
}
var Slice = {};
var Dictionary = {};
var generateMerkleProof = {};
var readUnaryLength = {};
var hasRequiredReadUnaryLength;
function requireReadUnaryLength() {
  if (hasRequiredReadUnaryLength) return readUnaryLength;
  hasRequiredReadUnaryLength = 1;
  Object.defineProperty(readUnaryLength, "__esModule", { value: true });
  readUnaryLength.readUnaryLength = void 0;
  function readUnaryLength$1(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  readUnaryLength.readUnaryLength = readUnaryLength$1;
  return readUnaryLength;
}
var exoticMerkleProof = {};
var BitReader = {};
var hasRequiredBitReader;
function requireBitReader() {
  if (hasRequiredBitReader) return BitReader;
  hasRequiredBitReader = 1;
  Object.defineProperty(BitReader, "__esModule", { value: true });
  BitReader.BitReader = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  let BitReader$1 = class BitReader2 {
    constructor(bits, offset = 0) {
      this._checkpoints = [];
      this._bits = bits;
      this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
      return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
      return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
      if (bits < 0 || this._offset + bits > this._bits.length) {
        throw new Error(`Index ${this._offset + bits} is out of bounds`);
      }
      this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
      if (this._checkpoints.length > 0) {
        this._offset = this._checkpoints.pop();
      } else {
        this._offset = 0;
      }
    }
    /**
     * Save checkpoint
     */
    save() {
      this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
      let r = this._bits.at(this._offset);
      this._offset++;
      return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
      return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
      let r = this._bits.substring(this._offset, bits);
      this._offset += bits;
      return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
      return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
      let buf2 = this._preloadBuffer(bytes, this._offset);
      this._offset += bytes * 8;
      return buf2;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
      return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
      return this._toSafeInteger(this.loadUintBig(bits), "loadUintBig");
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
      let loaded = this.preloadUintBig(bits);
      this._offset += bits;
      return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
      return this._toSafeInteger(this._preloadUint(bits, this._offset), "preloadUintBig");
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
      return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return this._toSafeInteger(res, "loadUintBig");
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
      return this._toSafeInteger(this._preloadInt(bits, this._offset), "preloadIntBig");
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
      return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadUintBig(size * 8), "loadVarUintBig");
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), "preloadVarUintBig");
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadIntBig(size * 8), "loadVarIntBig");
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), "preloadVarIntBig");
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
      return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
      return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address: " + type);
      }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else if (type === 3) {
        throw Error("Unsupported");
      } else {
        throw Error("Unreachable");
      }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
      if (bits % 8 !== 0) {
        throw new Error("Invalid number of bits");
      }
      let length = bits;
      while (true) {
        if (this._bits.at(this._offset + length - 1)) {
          length--;
          break;
        } else {
          length--;
        }
      }
      let r = this._bits.substring(this._offset, length);
      this._offset += bits;
      return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
      return new BitReader2(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let sign2 = this._bits.at(offset);
      let res = 0n;
      for (let i = 0; i < bits - 1; i++) {
        if (this._bits.at(offset + 1 + i)) {
          res += 1n << BigInt(bits - i - 1 - 1);
        }
      }
      if (sign2) {
        res = res - (1n << BigInt(bits - 1));
      }
      return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let res = 0n;
      for (let i = 0; i < bits; i++) {
        if (this._bits.at(offset + i)) {
          res += 1n << BigInt(bits - i - 1);
        }
      }
      return res;
    }
    _preloadBuffer(bytes, offset) {
      let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
      if (fastBuffer) {
        return fastBuffer;
      }
      let buf2 = Buffer.alloc(bytes);
      for (let i = 0; i < bytes; i++) {
        buf2[i] = Number(this._preloadUint(8, offset + i * 8));
      }
      return buf2;
    }
    _loadInternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 2) {
        throw Error("Invalid address");
      }
      let rewrite_pfx = void 0;
      let rewrite_depth = void 0;
      if (this._preloadUint(1, this._offset + 2) !== 0n) {
        rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
        rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
        this._offset += 5 + rewrite_depth;
      }
      let wc = Number(this._preloadInt(8, this._offset + 3));
      let hash = this._preloadBuffer(32, this._offset + 11);
      if (rewrite_depth !== void 0 && rewrite_pfx !== void 0) {
        let pfx = Number(rewrite_pfx);
        let byteIndex = 0;
        let bitIndex = 0;
        let bitsRemaining = rewrite_depth;
        while (bitsRemaining > 0) {
          let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
          let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
          let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
          hash[byteIndex] = hash[byteIndex] & ~mask | bits;
          bitsRemaining -= bitsInThisByte;
          bitIndex += bitsInThisByte;
          if (bitIndex === 8) {
            byteIndex++;
            bitIndex = 0;
          }
        }
      }
      this._offset += 267;
      return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 1) {
        throw Error("Invalid address");
      }
      let bits = Number(this._preloadUint(9, this._offset + 2));
      let value = this._preloadUint(bits, this._offset + 11);
      this._offset += 11 + bits;
      return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src, alt) {
      if (BigInt(Number.MAX_SAFE_INTEGER) < src || src < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new TypeError(`${src} is out of safe integer range. Use ${alt} instead`);
      }
      return Number(src);
    }
  };
  BitReader.BitReader = BitReader$1;
  return BitReader;
}
var hasRequiredExoticMerkleProof;
function requireExoticMerkleProof() {
  if (hasRequiredExoticMerkleProof) return exoticMerkleProof;
  hasRequiredExoticMerkleProof = 1;
  Object.defineProperty(exoticMerkleProof, "__esModule", { value: true });
  exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
  const BitReader_1 = requireBitReader();
  const Builder_1 = requireBuilder$1();
  function exoticMerkleProof$1(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
      throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
      throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 3) {
      throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    const proofHash = reader2.loadBuffer(32);
    const proofDepth = reader2.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
      throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
      throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
    }
    return {
      proofDepth,
      proofHash
    };
  }
  exoticMerkleProof.exoticMerkleProof = exoticMerkleProof$1;
  function convertToMerkleProof(c) {
    return (0, Builder_1.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
  }
  exoticMerkleProof.convertToMerkleProof = convertToMerkleProof;
  return exoticMerkleProof;
}
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
  if (hasRequiredGenerateMerkleProof) return generateMerkleProof;
  hasRequiredGenerateMerkleProof = 1;
  Object.defineProperty(generateMerkleProof, "__esModule", { value: true });
  generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
  const Builder_1 = requireBuilder$1();
  const readUnaryLength_1 = requireReadUnaryLength();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  function convertToPrunedBranch(c) {
    return (0, Builder_1.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
  }
  function doGenerateMerkleProof(prefix, slice, n, keys) {
    const originalCell = slice.asCell();
    if (keys.length == 0) {
      return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      return originalCell;
    } else {
      let sl = originalCell.beginParse();
      let left = sl.loadRef();
      let right = sl.loadRef();
      if (!left.isExotic) {
        const leftKeys = keys.filter((key) => {
          return pp + "0" === key.slice(0, pp.length + 1);
        });
        left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, leftKeys);
      }
      if (!right.isExotic) {
        const rightKeys = keys.filter((key) => {
          return pp + "1" === key.slice(0, pp.length + 1);
        });
        right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, rightKeys);
      }
      return (0, Builder_1.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
  }
  function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key) => {
      if (!dict.has(key)) {
        throw new Error(`Trying to generate merkle proof for a missing key "${key}"`);
      }
    });
    const s2 = (0, Builder_1.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof("", s2, keyObject.bits, keys.map((key) => keyObject.serialize(key).toString(2).padStart(keyObject.bits, "0")));
  }
  generateMerkleProof.generateMerkleProofDirect = generateMerkleProofDirect;
  function generateMerkleProof$1(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
  }
  generateMerkleProof.generateMerkleProof = generateMerkleProof$1;
  return generateMerkleProof;
}
var generateMerkleUpdate = {};
var hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
  if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate;
  hasRequiredGenerateMerkleUpdate = 1;
  Object.defineProperty(generateMerkleUpdate, "__esModule", { value: true });
  generateMerkleUpdate.generateMerkleUpdate = void 0;
  const Builder_1 = requireBuilder$1();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_1.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
  }
  function generateMerkleUpdate$1(dict, key, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
    dict.set(key, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
  }
  generateMerkleUpdate.generateMerkleUpdate = generateMerkleUpdate$1;
  return generateMerkleUpdate;
}
var parseDict = {};
var hasRequiredParseDict;
function requireParseDict() {
  if (hasRequiredParseDict) return parseDict;
  hasRequiredParseDict = 1;
  Object.defineProperty(parseDict, "__esModule", { value: true });
  parseDict.parseDict = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  function doParse(prefix, slice, n, res, extractor) {
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = readUnaryLength2(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      res.set(BigInt("0b" + pp), extractor(slice));
    } else {
      let left = slice.loadRef();
      let right = slice.loadRef();
      if (!left.isExotic) {
        doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
      }
      if (!right.isExotic) {
        doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
      }
    }
  }
  function parseDict$1(sc, keySize, extractor) {
    let res = /* @__PURE__ */ new Map();
    if (sc) {
      doParse("", sc, keySize, res, extractor);
    }
    return res;
  }
  parseDict.parseDict = parseDict$1;
  return parseDict;
}
var serializeDict = {};
var findCommonPrefix = {};
var hasRequiredFindCommonPrefix;
function requireFindCommonPrefix() {
  if (hasRequiredFindCommonPrefix) return findCommonPrefix;
  hasRequiredFindCommonPrefix = 1;
  Object.defineProperty(findCommonPrefix, "__esModule", { value: true });
  findCommonPrefix.findCommonPrefix = void 0;
  function findCommonPrefix$1(src, startPos = 0) {
    if (src.length === 0) {
      return "";
    }
    let r = src[0].slice(startPos);
    for (let i = 1; i < src.length; i++) {
      const s2 = src[i];
      while (s2.indexOf(r, startPos) !== startPos) {
        r = r.substring(0, r.length - 1);
        if (r === "") {
          return r;
        }
      }
    }
    return r;
  }
  findCommonPrefix.findCommonPrefix = findCommonPrefix$1;
  return findCommonPrefix;
}
var hasRequiredSerializeDict;
function requireSerializeDict() {
  if (hasRequiredSerializeDict) return serializeDict;
  hasRequiredSerializeDict = 1;
  Object.defineProperty(serializeDict, "__esModule", { value: true });
  serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
  const Builder_1 = requireBuilder$1();
  const findCommonPrefix_1 = requireFindCommonPrefix();
  function pad(src, size) {
    while (src.length < size) {
      src = "0" + src;
    }
    return src;
  }
  function forkMap(src, prefixLen) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    let left = /* @__PURE__ */ new Map();
    let right = /* @__PURE__ */ new Map();
    for (let [k2, d] of src.entries()) {
      if (k2[prefixLen] === "0") {
        left.set(k2, d);
      } else {
        right.set(k2, d);
      }
    }
    if (left.size === 0) {
      throw Error("Internal inconsistency. Left emtpy.");
    }
    if (right.size === 0) {
      throw Error("Internal inconsistency. Right emtpy.");
    }
    return { left, right };
  }
  function buildNode(src, prefixLen) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    if (src.size === 1) {
      return { type: "leaf", value: Array.from(src.values())[0] };
    }
    let { left, right } = forkMap(src, prefixLen);
    return {
      type: "fork",
      left: buildEdge(left, prefixLen + 1),
      right: buildEdge(right, prefixLen + 1)
    };
  }
  function buildEdge(src, prefixLen = 0) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);
    return { label, node: buildNode(src, label.length + prefixLen) };
  }
  function buildTree(src, keyLength) {
    let converted = /* @__PURE__ */ new Map();
    for (let k2 of Array.from(src.keys())) {
      const padded = pad(k2.toString(2), keyLength);
      converted.set(padded, src.get(k2));
    }
    return buildEdge(converted);
  }
  serializeDict.buildTree = buildTree;
  function writeLabelShort(src, to) {
    to.storeBit(0);
    for (let i = 0; i < src.length; i++) {
      to.storeBit(1);
    }
    to.storeBit(0);
    if (src.length > 0) {
      to.storeUint(BigInt("0b" + src), src.length);
    }
    return to;
  }
  serializeDict.writeLabelShort = writeLabelShort;
  function labelShortLength(src) {
    return 1 + src.length + 1 + src.length;
  }
  function writeLabelLong(src, keyLength, to) {
    to.storeBit(1);
    to.storeBit(0);
    let length = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(src.length, length);
    if (src.length > 0) {
      to.storeUint(BigInt("0b" + src), src.length);
    }
    return to;
  }
  serializeDict.writeLabelLong = writeLabelLong;
  function labelLongLength(src, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
  }
  function writeLabelSame(value, length, keyLength, to) {
    to.storeBit(1);
    to.storeBit(1);
    to.storeBit(value);
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(length, lenLen);
  }
  serializeDict.writeLabelSame = writeLabelSame;
  function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
  }
  function isSame(src) {
    if (src.length === 0 || src.length === 1) {
      return true;
    }
    for (let i = 1; i < src.length; i++) {
      if (src[i] !== src[0]) {
        return false;
      }
    }
    return true;
  }
  function detectLabelType(src, keyLength) {
    let kind = "short";
    let kindLength = labelShortLength(src);
    let longLength = labelLongLength(src, keyLength);
    if (longLength < kindLength) {
      kindLength = longLength;
      kind = "long";
    }
    if (isSame(src)) {
      let sameLength = labelSameLength(keyLength);
      if (sameLength < kindLength) {
        kindLength = sameLength;
        kind = "same";
      }
    }
    return kind;
  }
  serializeDict.detectLabelType = detectLabelType;
  function writeLabel(src, keyLength, to) {
    let type = detectLabelType(src, keyLength);
    if (type === "short") {
      writeLabelShort(src, to);
    } else if (type === "long") {
      writeLabelLong(src, keyLength, to);
    } else if (type === "same") {
      writeLabelSame(src[0] === "1", src.length, keyLength, to);
    }
  }
  function writeNode(src, keyLength, serializer, to) {
    if (src.type === "leaf") {
      serializer(src.value, to);
    }
    if (src.type === "fork") {
      const leftCell = (0, Builder_1.beginCell)();
      const rightCell = (0, Builder_1.beginCell)();
      writeEdge(src.left, keyLength - 1, serializer, leftCell);
      writeEdge(src.right, keyLength - 1, serializer, rightCell);
      to.storeRef(leftCell);
      to.storeRef(rightCell);
    }
  }
  function writeEdge(src, keyLength, serializer, to) {
    writeLabel(src.label, keyLength, to);
    writeNode(src.node, keyLength - src.label.length, serializer, to);
  }
  function serializeDict$1(src, keyLength, serializer, to) {
    const tree = buildTree(src, keyLength);
    writeEdge(tree, keyLength, serializer, to);
  }
  serializeDict.serializeDict = serializeDict$1;
  return serializeDict;
}
var internalKeySerializer = {};
var hasRequiredInternalKeySerializer;
function requireInternalKeySerializer() {
  if (hasRequiredInternalKeySerializer) return internalKeySerializer;
  hasRequiredInternalKeySerializer = 1;
  Object.defineProperty(internalKeySerializer, "__esModule", { value: true });
  internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
  const Address_1 = requireAddress();
  const BitString_1 = requireBitString();
  const paddedBits_1 = requirePaddedBits();
  function serializeInternalKey(value) {
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw Error("Invalid key type: not a safe integer: " + value);
      }
      return "n:" + value.toString(10);
    } else if (typeof value === "bigint") {
      return "b:" + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
      return "a:" + value.toString();
    } else if (Buffer.isBuffer(value)) {
      return "f:" + value.toString("hex");
    } else if (BitString_1.BitString.isBitString(value)) {
      return "B:" + value.toString();
    } else {
      throw Error("Invalid key type");
    }
  }
  internalKeySerializer.serializeInternalKey = serializeInternalKey;
  function deserializeInternalKey(value) {
    let k2 = value.slice(0, 2);
    let v2 = value.slice(2);
    if (k2 === "n:") {
      return parseInt(v2, 10);
    } else if (k2 === "b:") {
      return BigInt(v2);
    } else if (k2 === "a:") {
      return Address_1.Address.parse(v2);
    } else if (k2 === "f:") {
      return Buffer.from(v2, "hex");
    } else if (k2 === "B:") {
      const lastDash = v2.slice(-1) == "_";
      const isPadded = lastDash || v2.length % 2 != 0;
      if (isPadded) {
        let charLen = lastDash ? v2.length - 1 : v2.length;
        const padded = v2.substr(0, charLen) + "0";
        if (!lastDash && (charLen & 1) !== 0) {
          return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
        } else {
          return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
        }
      } else {
        return new BitString_1.BitString(Buffer.from(v2, "hex"), 0, v2.length << 2);
      }
    }
    throw Error("Invalid key type: " + k2);
  }
  internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
  return internalKeySerializer;
}
var hasRequiredDictionary;
function requireDictionary() {
  if (hasRequiredDictionary) return Dictionary;
  hasRequiredDictionary = 1;
  Object.defineProperty(Dictionary, "__esModule", { value: true });
  Dictionary.Dictionary = void 0;
  const Address_1 = requireAddress();
  const Builder_1 = requireBuilder$1();
  const Cell_1 = requireCell();
  const BitString_1 = requireBitString();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  const generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
  const parseDict_1 = requireParseDict();
  const serializeDict_1 = requireSerializeDict();
  const internalKeySerializer_1 = requireInternalKeySerializer();
  let Dictionary$1 = class Dictionary2 {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key, value) {
      if (key && value) {
        return new Dictionary2(/* @__PURE__ */ new Map(), key, value);
      } else {
        return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
      }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key, value, sc) {
      let slice;
      if (sc instanceof Cell_1.Cell) {
        if (sc.isExotic) {
          return Dictionary2.empty(key, value);
        }
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let cell = slice.loadMaybeRef();
      if (cell && !cell.isExotic) {
        return Dictionary2.loadDirect(key, value, cell.beginParse());
      } else {
        return Dictionary2.empty(key, value);
      }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key, value, sc) {
      if (!sc) {
        return Dictionary2.empty(key, value);
      }
      let slice;
      if (sc instanceof Cell_1.Cell) {
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
      let prepare = /* @__PURE__ */ new Map();
      for (let [k2, v2] of values) {
        prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k2)), v2);
      }
      return new Dictionary2(prepare, key, value);
    }
    constructor(values, key, value) {
      this._key = key;
      this._value = value;
      this._map = values;
    }
    get size() {
      return this._map.size;
    }
    get(key) {
      return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    has(key) {
      return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    set(key, value) {
      this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
      return this;
    }
    delete(key) {
      const k2 = (0, internalKeySerializer_1.serializeInternalKey)(key);
      return this._map.delete(k2);
    }
    clear() {
      this._map.clear();
    }
    *[Symbol.iterator]() {
      for (const [k2, v2] of this._map) {
        const key = (0, internalKeySerializer_1.deserializeInternalKey)(k2);
        yield [key, v2];
      }
    }
    keys() {
      return Array.from(this._map.keys()).map((v2) => (0, internalKeySerializer_1.deserializeInternalKey)(v2));
    }
    values() {
      return Array.from(this._map.values());
    }
    store(builder2, key, value) {
      if (this._map.size === 0) {
        builder2.storeBit(0);
      } else {
        let resolvedKey = this._key;
        if (key !== null && key !== void 0) {
          resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k2, v2] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
        }
        builder2.storeBit(1);
        let dd = (0, Builder_1.beginCell)();
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
        builder2.storeRef(dd.endCell());
      }
    }
    storeDirect(builder2, key, value) {
      if (this._map.size === 0) {
        throw Error("Cannot store empty dictionary directly");
      }
      let resolvedKey = this._key;
      if (key !== null && key !== void 0) {
        resolvedKey = key;
      }
      let resolvedValue = this._value;
      if (value !== null && value !== void 0) {
        resolvedValue = value;
      }
      if (!resolvedKey) {
        throw Error("Key serializer is not defined");
      }
      if (!resolvedValue) {
        throw Error("Value serializer is not defined");
      }
      let prepared = /* @__PURE__ */ new Map();
      for (const [k2, v2] of this._map) {
        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
      }
      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder2);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */
    generateMerkleProof(keys) {
      return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */
    generateMerkleProofDirect(keys) {
      return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key, newValue) {
      return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
    }
  };
  Dictionary.Dictionary = Dictionary$1;
  Dictionary$1.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
      return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
      return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
      return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
      return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
      return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
      return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
      return createBitStringKey(bits);
    }
  };
  Dictionary$1.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
      return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
      return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
      return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
      return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
      return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
      return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
      return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
      return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
      return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
      return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
      return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key, value) => {
      return createDictionaryValue(key, value);
    }
  };
  function createAddressKey() {
    return {
      bits: 267,
      serialize: (src) => {
        if (!Address_1.Address.isAddress(src)) {
          throw Error("Key is not an address");
        }
        return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
      },
      parse: (src) => {
        return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
      }
    };
  }
  function createBigIntKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "bigint") {
          throw Error("Key is not a bigint");
        }
        return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
      }
    };
  }
  function createIntKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src)) {
          throw Error("Key is not a safe integer: " + src);
        }
        return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
      }
    };
  }
  function createBigUintKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "bigint") {
          throw Error("Key is not a bigint");
        }
        if (src < 0) {
          throw Error("Key is negative: " + src);
        }
        return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      }
    };
  }
  function createUintKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src)) {
          throw Error("Key is not a safe integer: " + src);
        }
        if (src < 0) {
          throw Error("Key is negative: " + src);
        }
        return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
      }
    };
  }
  function createBufferKey(bytes) {
    return {
      bits: bytes * 8,
      serialize: (src) => {
        if (!Buffer.isBuffer(src)) {
          throw Error("Key is not a buffer");
        }
        return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
      },
      parse: (src) => {
        return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
      }
    };
  }
  function createBitStringKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (!BitString_1.BitString.isBitString(src))
          throw Error("Key is not a BitString");
        return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
      }
    };
  }
  function createIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadInt(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadIntBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigVarIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeVarInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadVarIntBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigVarUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeVarUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadVarUintBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadUint(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadUintBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBooleanValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeBit(src);
      },
      parse: (src) => {
        let value = src.loadBit();
        src.endParse();
        return value;
      }
    };
  }
  function createAddressValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeAddress(src);
      },
      parse: (src) => {
        let addr = src.loadAddress();
        src.endParse();
        return addr;
      }
    };
  }
  function createCellValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeRef(src);
      },
      parse: (src) => {
        let value = src.loadRef();
        src.endParse();
        return value;
      }
    };
  }
  function createDictionaryValue(key, value) {
    return {
      serialize: (src, buidler) => {
        src.store(buidler);
      },
      parse: (src) => {
        let dict = Dictionary$1.load(key, value, src);
        src.endParse();
        return dict;
      }
    };
  }
  function createBufferValue(size) {
    return {
      serialize: (src, buidler) => {
        if (src.length !== size) {
          throw Error("Invalid buffer size");
        }
        buidler.storeBuffer(src);
      },
      parse: (src) => {
        let value = src.loadBuffer(size);
        src.endParse();
        return value;
      }
    };
  }
  function createBitStringValue(bits) {
    return {
      serialize: (src, builder2) => {
        if (src.length !== bits) {
          throw Error("Invalid BitString size");
        }
        builder2.storeBits(src);
      },
      parse: (src) => {
        let value = src.loadBits(bits);
        src.endParse();
        return value;
      }
    };
  }
  return Dictionary;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  Object.defineProperty(strings, "__esModule", { value: true });
  strings.writeString = strings.stringToCell = strings.readString = void 0;
  const Builder_1 = requireBuilder$1();
  function readBuffer(slice) {
    if (slice.remainingBits % 8 !== 0) {
      throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
      throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    let res;
    if (slice.remainingBits === 0) {
      res = Buffer.alloc(0);
    } else {
      res = slice.loadBuffer(slice.remainingBits / 8);
    }
    if (slice.remainingRefs === 1) {
      res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
    }
    return res;
  }
  function readString(slice) {
    return readBuffer(slice).toString();
  }
  strings.readString = readString;
  function writeBuffer(src, builder2) {
    if (src.length > 0) {
      let bytes = Math.floor(builder2.availableBits / 8);
      if (src.length > bytes) {
        let a2 = src.subarray(0, bytes);
        let t = src.subarray(bytes);
        builder2 = builder2.storeBuffer(a2);
        let bb = (0, Builder_1.beginCell)();
        writeBuffer(t, bb);
        builder2 = builder2.storeRef(bb.endCell());
      } else {
        builder2 = builder2.storeBuffer(src);
      }
    }
  }
  function stringToCell(src) {
    let builder2 = (0, Builder_1.beginCell)();
    writeBuffer(Buffer.from(src), builder2);
    return builder2.endCell();
  }
  strings.stringToCell = stringToCell;
  function writeString(src, builder2) {
    writeBuffer(Buffer.from(src), builder2);
  }
  strings.writeString = writeString;
  return strings;
}
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice) return Slice;
  hasRequiredSlice = 1;
  var __importDefault = Slice && Slice.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Slice, "__esModule", { value: true });
  Slice.Slice = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const Dictionary_1 = requireDictionary();
  const Builder_1 = requireBuilder$1();
  const strings_1 = requireStrings();
  let Slice$1 = class Slice2 {
    constructor(reader2, refs) {
      this[_a] = () => this.toString();
      this._reader = reader2.clone();
      this._refs = [...refs];
      this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */
    get remainingBits() {
      return this._reader.remaining;
    }
    /**
     * Get offset bits
     */
    get offsetBits() {
      return this._reader.offset;
    }
    /**
     * Get remaining refs
     */
    get remainingRefs() {
      return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */
    get offsetRefs() {
      return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */
    skip(bits) {
      this._reader.skip(bits);
      return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */
    loadBit() {
      return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */
    preloadBit() {
      return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */
    loadBoolean() {
      return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */
    loadMaybeBoolean() {
      if (this.loadBit()) {
        return this.loadBoolean();
      } else {
        return null;
      }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    loadBits(bits) {
      return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    preloadBits(bits) {
      return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUint(bits) {
      return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUintBig(bits) {
      return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUint(bits) {
      return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUintBig(bits) {
      return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUint(bits) {
      if (this.loadBit()) {
        return this.loadUint(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUintBig(bits) {
      if (this.loadBit()) {
        return this.loadUintBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadInt(bits) {
      return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadIntBig(bits) {
      return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadInt(bits) {
      return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadIntBig(bits) {
      return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeInt(bits) {
      if (this.loadBit()) {
        return this.loadInt(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeIntBig(bits) {
      if (this.loadBit()) {
        return this.loadIntBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUint(bits) {
      return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUintBig(bits) {
      return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUint(bits) {
      return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUintBig(bits) {
      return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarInt(bits) {
      return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarIntBig(bits) {
      return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarInt(bits) {
      return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarIntBig(bits) {
      return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */
    loadCoins() {
      return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */
    preloadCoins() {
      return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */
    loadMaybeCoins() {
      if (this._reader.loadBit()) {
        return this._reader.loadCoins();
      } else {
        return null;
      }
    }
    /**
     * Load internal Address
     * @returns Address
     */
    loadAddress() {
      return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */
    loadMaybeAddress() {
      return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */
    loadAddressAny() {
      return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */
    loadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */
    preloadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */
    loadMaybeRef() {
      if (this.loadBit()) {
        return this.loadRef();
      } else {
        return null;
      }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */
    preloadMaybeRef() {
      if (this.preloadBit()) {
        return this.preloadRef();
      } else {
        return null;
      }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    loadBuffer(bytes) {
      return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    preloadBuffer(bytes) {
      return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */
    loadStringTail() {
      return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */
    loadMaybeStringTail() {
      if (this.loadBit()) {
        return (0, strings_1.readString)(this);
      } else {
        return null;
      }
    }
    /**
     * Load string tail from ref
     * @returns string
     */
    loadStringRefTail() {
      return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */
    loadMaybeStringRefTail() {
      const ref = this.loadMaybeRef();
      if (ref) {
        return (0, strings_1.readString)(ref.beginParse());
      } else {
        return null;
      }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDict(key, value) {
      return Dictionary_1.Dictionary.load(key, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDictDirect(key, value) {
      return Dictionary_1.Dictionary.loadDirect(key, value, this);
    }
    /**
     * Checks if slice is empty
     */
    endParse() {
      if (this.remainingBits > 0 || this.remainingRefs > 0) {
        throw new Error("Slice is not empty");
      }
    }
    /**
     * Convert slice to cell
     */
    asCell() {
      return (0, Builder_1.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */
    asBuilder() {
      return (0, Builder_1.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */
    clone(fromStart = false) {
      if (fromStart) {
        let reader2 = this._reader.clone();
        reader2.reset();
        return new Slice2(reader2, this._refs);
      } else {
        let res = new Slice2(this._reader, this._refs);
        res._refsOffset = this._refsOffset;
        return res;
      }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */
    toString() {
      return this.asCell().toString();
    }
  };
  Slice.Slice = Slice$1;
  _a = symbol_inspect_1.default;
  return Slice;
}
var resolveExotic = {};
var exoticLibrary = {};
var hasRequiredExoticLibrary;
function requireExoticLibrary() {
  if (hasRequiredExoticLibrary) return exoticLibrary;
  hasRequiredExoticLibrary = 1;
  Object.defineProperty(exoticLibrary, "__esModule", { value: true });
  exoticLibrary.exoticLibrary = void 0;
  const BitReader_1 = requireBitReader();
  function exoticLibrary$1(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256;
    if (bits.length !== size) {
      throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 2) {
      throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
  }
  exoticLibrary.exoticLibrary = exoticLibrary$1;
  return exoticLibrary;
}
var exoticMerkleUpdate = {};
var hasRequiredExoticMerkleUpdate;
function requireExoticMerkleUpdate() {
  if (hasRequiredExoticMerkleUpdate) return exoticMerkleUpdate;
  hasRequiredExoticMerkleUpdate = 1;
  Object.defineProperty(exoticMerkleUpdate, "__esModule", { value: true });
  exoticMerkleUpdate.exoticMerkleUpdate = void 0;
  const BitReader_1 = requireBitReader();
  function exoticMerkleUpdate$1(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
      throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
      throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 4) {
      throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader2.loadBuffer(32);
    const proofHash2 = reader2.loadBuffer(32);
    const proofDepth1 = reader2.loadUint(16);
    const proofDepth2 = reader2.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
    }
    return {
      proofDepth1,
      proofDepth2,
      proofHash1,
      proofHash2
    };
  }
  exoticMerkleUpdate.exoticMerkleUpdate = exoticMerkleUpdate$1;
  return exoticMerkleUpdate;
}
var exoticPruned = {};
var LevelMask = {};
var hasRequiredLevelMask;
function requireLevelMask() {
  if (hasRequiredLevelMask) return LevelMask;
  hasRequiredLevelMask = 1;
  Object.defineProperty(LevelMask, "__esModule", { value: true });
  LevelMask.LevelMask = void 0;
  let LevelMask$1 = class LevelMask2 {
    constructor(mask = 0) {
      this._mask = 0;
      this._mask = mask;
      this._hashIndex = countSetBits(this._mask);
      this._hashCount = this._hashIndex + 1;
    }
    get value() {
      return this._mask;
    }
    get level() {
      return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
      return this._hashIndex;
    }
    get hashCount() {
      return this._hashCount;
    }
    apply(level) {
      return new LevelMask2(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
      let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
      return res;
    }
  };
  LevelMask.LevelMask = LevelMask$1;
  function countSetBits(n) {
    n = n - (n >> 1 & 1431655765);
    n = (n & 858993459) + (n >> 2 & 858993459);
    return (n + (n >> 4) & 252645135) * 16843009 >> 24;
  }
  return LevelMask;
}
var hasRequiredExoticPruned;
function requireExoticPruned() {
  if (hasRequiredExoticPruned) return exoticPruned;
  hasRequiredExoticPruned = 1;
  Object.defineProperty(exoticPruned, "__esModule", { value: true });
  exoticPruned.exoticPruned = void 0;
  const BitReader_1 = requireBitReader();
  const LevelMask_1 = requireLevelMask();
  function exoticPruned$1(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.loadUint(8);
    if (type !== 1) {
      throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    if (refs.length !== 0) {
      throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    let mask;
    if (bits.length === 280) {
      mask = new LevelMask_1.LevelMask(1);
    } else {
      mask = new LevelMask_1.LevelMask(reader2.loadUint(8));
      if (mask.level < 1 || mask.level > 3) {
        throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
      }
      const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
      }
    }
    let pruned = [];
    let hashes = [];
    let depths = [];
    for (let i = 0; i < mask.level; i++) {
      hashes.push(reader2.loadBuffer(32));
    }
    for (let i = 0; i < mask.level; i++) {
      depths.push(reader2.loadUint(16));
    }
    for (let i = 0; i < mask.level; i++) {
      pruned.push({
        depth: depths[i],
        hash: hashes[i]
      });
    }
    return {
      mask: mask.value,
      pruned
    };
  }
  exoticPruned.exoticPruned = exoticPruned$1;
  return exoticPruned;
}
var hasRequiredResolveExotic;
function requireResolveExotic() {
  if (hasRequiredResolveExotic) return resolveExotic;
  hasRequiredResolveExotic = 1;
  Object.defineProperty(resolveExotic, "__esModule", { value: true });
  resolveExotic.resolveExotic = void 0;
  const BitReader_1 = requireBitReader();
  const CellType_1 = requireCellType();
  const exoticLibrary_1 = requireExoticLibrary();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticPruned_1 = requireExoticPruned();
  const LevelMask_1 = requireLevelMask();
  function resolvePruned(bits, refs) {
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for (let i = 0; i < pruned.pruned.length; i++) {
      depths.push(pruned.pruned[i].depth);
      hashes.push(pruned.pruned[i].hash);
    }
    return {
      type: CellType_1.CellType.PrunedBranch,
      depths,
      hashes,
      mask
    };
  }
  function resolveLibrary(bits, refs) {
    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
      type: CellType_1.CellType.Library,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleProof(bits, refs) {
    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
      type: CellType_1.CellType.MerkleProof,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleUpdate(bits, refs) {
    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
      type: CellType_1.CellType.MerkleUpdate,
      depths,
      hashes,
      mask
    };
  }
  function resolveExotic$1(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.preloadUint(8);
    if (type === 1) {
      return resolvePruned(bits, refs);
    }
    if (type === 2) {
      return resolveLibrary(bits, refs);
    }
    if (type === 3) {
      return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
      return resolveMerkleUpdate(bits, refs);
    }
    throw Error("Invalid exotic cell type: " + type);
  }
  resolveExotic.resolveExotic = resolveExotic$1;
  return resolveExotic;
}
var wonderCalculator = {};
var descriptor = {};
var hasRequiredDescriptor;
function requireDescriptor() {
  if (hasRequiredDescriptor) return descriptor;
  hasRequiredDescriptor = 1;
  Object.defineProperty(descriptor, "__esModule", { value: true });
  descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
  const CellType_1 = requireCellType();
  const paddedBits_1 = requirePaddedBits();
  function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
  }
  descriptor.getRefsDescriptor = getRefsDescriptor;
  function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
  }
  descriptor.getBitsDescriptor = getBitsDescriptor;
  function getRepr(originalBits, bits, refs, level, levelMask, type) {
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    for (const c of refs) {
      let childDepth;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childDepth = c.depth(level + 1);
      } else {
        childDepth = c.depth(level);
      }
      repr[reprCursor++] = Math.floor(childDepth / 256);
      repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs) {
      let childHash;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childHash = c.hash(level + 1);
      } else {
        childHash = c.hash(level);
      }
      childHash.copy(repr, reprCursor);
      reprCursor += 32;
    }
    return repr;
  }
  descriptor.getRepr = getRepr;
  return descriptor;
}
var dist = {};
var sha256$1 = {};
var sha$1 = { exports: {} };
var sha = sha$1.exports;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1.exports;
  hasRequiredSha = 1;
  (function(module, exports) {
    !(function(n, r) {
      module.exports = r();
    })(sha, (function() {
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o5, u2, f3 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s3 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1) o5 = (u2 = i2 + w2) >>> 2, f3.length <= o5 && f3.push(0), f3[o5] |= n2[i2] << 8 * (s3 + e2 * (u2 % 4));
        return { value: f3, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o5, u2, f3;
                if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
                var w2 = r3 || [0], s3 = (t4 = t4 || 0) >>> 3, a3 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o5 = parseInt(n3.substr(i3, 2), 16), isNaN(o5)) throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f3 = (i3 >>> 1) + s3) >>> 2; w2.length <= u2; ) w2.push(0);
                  w2[u2] |= o5 << 8 * (a3 + e3 * (f3 % 4));
                }
                return { value: w2, binLen: 4 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3, i3) {
                var o5, u2, f3, w2, s3, a3, h3, c2, v3 = 0, A2 = t4 || [0], E3 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3) for (h3 = -1 === i3 ? 3 : 0, f3 = 0; f3 < n3.length; f3 += 1) for (u2 = [], 128 > (o5 = n3.charCodeAt(f3)) ? u2.push(o5) : 2048 > o5 ? (u2.push(192 | o5 >>> 6), u2.push(128 | 63 & o5)) : 55296 > o5 || 57344 <= o5 ? u2.push(224 | o5 >>> 12, 128 | o5 >>> 6 & 63, 128 | 63 & o5) : (f3 += 1, o5 = 65536 + ((1023 & o5) << 10 | 1023 & n3.charCodeAt(f3)), u2.push(240 | o5 >>> 18, 128 | o5 >>> 12 & 63, 128 | o5 >>> 6 & 63, 128 | 63 & o5)), w2 = 0; w2 < u2.length; w2 += 1) {
                  for (s3 = (a3 = v3 + E3) >>> 2; A2.length <= s3; ) A2.push(0);
                  A2[s3] |= u2[w2] << 8 * (h3 + i3 * (a3 % 4)), v3 += 1;
                }
                else for (h3 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f3 = 0; f3 < n3.length; f3 += 1) {
                  for (o5 = n3.charCodeAt(f3), true === c2 && (o5 = (w2 = 255 & o5) << 8 | o5 >>> 8), s3 = (a3 = v3 + E3) >>> 2; A2.length <= s3; ) A2.push(0);
                  A2[s3] |= o5 << 8 * (h3 + i3 * (a3 % 4)), v3 += 2;
                }
                return { value: A2, binLen: 8 * v3 + e3 };
              })(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return (function(r3, t4, e4, i3) {
                var o5, u2, f3, w2, s3, a3, h3 = 0, c2 = t4 || [0], v3 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E3 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E3 && E3 < r3.length) throw new Error("Invalid '=' found in base-64 string");
                for (o5 = 0; o5 < r3.length; o5 += 4) {
                  for (w2 = r3.substr(o5, 4), f3 = 0, u2 = 0; u2 < w2.length; u2 += 1) f3 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                    for (s3 = (a3 = h3 + v3) >>> 2; c2.length <= s3; ) c2.push(0);
                    c2[s3] |= (f3 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a3 % 4)), h3 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h3 + e4 };
              })(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o5, u2, f3, w2 = r3 || [0], s3 = (t4 = t4 || 0) >>> 3, a3 = -1 === e3 ? 3 : 0;
                for (o5 = 0; o5 < n3.length; o5 += 1) i3 = n3.charCodeAt(o5), u2 = (f3 = o5 + s3) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a3 + e3 * (f3 % 4));
                return { value: w2, binLen: 8 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return (function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              })(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return (function(n3, r3, t3, e3) {
                var i3, o5, u2 = "", f3 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f3; i3 += 1) o5 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o5 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o5);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              })(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return (function(r4, t3, e3, i3) {
                var o5, u2, f3, w2, s3, a3 = "", h3 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o5 = 0; o5 < h3; o5 += 3) for (w2 = o5 + 1 < h3 ? r4[o5 + 1 >>> 2] : 0, s3 = o5 + 2 < h3 ? r4[o5 + 2 >>> 2] : 0, f3 = (r4[o5 >>> 2] >>> 8 * (c2 + e3 * (o5 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o5 + 1) % 4)) & 255) << 8 | s3 >>> 8 * (c2 + e3 * ((o5 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1) a3 += 8 * o5 + 6 * u2 <= t3 ? n.charAt(f3 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a3;
              })(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3, o5 = "", u2 = r3 / 8, f3 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f3 + t3 * (e3 % 4)) & 255, o5 += String.fromCharCode(i3);
                return o5;
              })(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o5 = new ArrayBuffer(i3), u2 = new Uint8Array(o5), f3 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (f3 + t3 * (e3 % 4)) & 255;
                return o5;
              })(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o5 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (o5 + t3 * (e3 % 4)) & 255;
                return u2;
              })(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o4 = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f2 = "Chosen SHA variant is not supported";
      function w(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o5 = r2.binLen >>> 3, u2 = i2 << 3, f3 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o5; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f3;
          return (n2.value.length << 2) - 4 >= o5 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s2(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a2(n2, r2, e2, i2) {
        var o5 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2) throw new Error(o5);
          return i2;
        }
        if (void 0 === r2.value || !r2.format) throw new Error(o5);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h2 = (function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o5 = i2.binLen, u2 = i2.value, f3 = o5 >>> 5;
          for (r2 = 0; r2 < f3; r2 += e2) t2 + this.S <= o5 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o5 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o5 = this.U, u2 = s2(r2);
          if (this.T) {
            if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
            o5 = u2.outputLen;
          }
          var f3 = e(n3, o5, this.C, u2);
          if (this.A && this.F) return f3(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o5), t2 = 1; t2 < this.numRounds; t2 += 1) this.T && o5 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o5 % 32), i2 = this.K(i2, o5, 0, this.L(this.o), o5);
          return f3(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g) throw new Error("Variant does not support HMAC");
          if (this.h) throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
          if (this.A) throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; ) n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1) this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s2(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      })(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v2(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E2(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b2(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S2(n2) {
        return E2(n2, 2) ^ E2(n2, 13) ^ E2(n2, 22);
      }
      function p2(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y2(n2, r2, t2, e2, i2) {
        var o5 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o5 >>> 16)) << 16 | 65535 & o5;
      }
      function R(n2) {
        return E2(n2, 7) ^ E2(n2, 18) ^ l(n2, 3);
      }
      function U2(n2) {
        return E2(n2, 6) ^ E2(n2, 11) ^ E2(n2, 25);
      }
      function T10(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w2, s3 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o5 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1) s3[w2] = w2 < 16 ? n2[w2] : A(s3[w2 - 3] ^ s3[w2 - 8] ^ s3[w2 - 14] ^ s3[w2 - 16], 1), f3 = w2 < 20 ? y2(A(t2, 5), H(e2, i2, o5), u2, 1518500249, s3[w2]) : w2 < 40 ? y2(A(t2, 5), b2(e2, i2, o5), u2, 1859775393, s3[w2]) : w2 < 60 ? y2(A(t2, 5), d(e2, i2, o5), u2, 2400959708, s3[w2]) : y2(A(t2, 5), b2(e2, i2, o5), u2, 3395469782, s3[w2]), u2 = o5, o5 = i2, i2 = A(e2, 30), e2 = t2, t2 = f3;
        return r2[0] = p2(t2, r2[0]), r2[1] = p2(e2, r2[1]), r2[2] = p2(i2, r2[2]), r2[3] = p2(o5, r2[3]), r2[4] = p2(u2, r2[4]), r2;
      }
      function F(n2, r2, t2, e2) {
        for (var i2, o5 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o5; ) n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o5] = 4294967295 & u2, n2[o5 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = C2(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-1" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).g = true, o5.F = o5.Y, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = C2, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = T10, o5.K = F, o5.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o5.S = 512, o5.U = 160, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2);
      function B2(n2) {
        return "SHA-224" == n2 ? o4.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o5, u2, f3, w2, s3, a3, h3, c2, v3, A2, b3 = [];
        for (t2 = r2[0], e2 = r2[1], o5 = r2[2], u2 = r2[3], f3 = r2[4], w2 = r2[5], s3 = r2[6], a3 = r2[7], v3 = 0; v3 < 64; v3 += 1) b3[v3] = v3 < 16 ? n2[v3] : m(E2(A2 = b3[v3 - 2], 17) ^ E2(A2, 19) ^ l(A2, 10), b3[v3 - 7], R(b3[v3 - 15]), b3[v3 - 16]), h3 = y2(a3, U2(f3), H(f3, w2, s3), i[v3], b3[v3]), c2 = p2(S2(t2), d(t2, e2, o5)), a3 = s3, s3 = w2, w2 = f3, f3 = p2(u2, h3), u2 = o5, o5 = e2, e2 = t2, t2 = p2(h3, c2);
        return r2[0] = p2(t2, r2[0]), r2[1] = p2(e2, r2[1]), r2[2] = p2(o5, r2[2]), r2[3] = p2(u2, r2[3]), r2[4] = p2(f3, r2[4]), r2[5] = p2(w2, r2[5]), r2[6] = p2(s3, r2[6]), r2[7] = p2(a3, r2[7]), r2;
      }
      var g = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).F = o5.Y, o5.g = true, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = L, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = B2, o5.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o6, u3 = 15 + (r4 + 65 >>> 9 << 4), f3 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f3, n4[u3 - 1] = f3 / 4294967296 | 0, o6 = 0; o6 < n4.length; o6 += 16) e4 = L(n4.slice(o6, o6 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            })(n3, t2, e3, i3, r3);
          }, o5.m = B2(r3), o5.S = 512, o5.U = "SHA-224" === r3 ? 224 : 256, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2), k2 = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k2(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k2(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k2(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k2(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I2(n2, r2) {
        return new k2(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M2(n2, r2, t2) {
        return new k2(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X(n2, r2, t2) {
        return new k2(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z(n2) {
        var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O2(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k2((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j(n2, r2, t2, e2) {
        var i2, o5;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o5 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o5 >>> 16), o5 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k2((65535 & o5) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o5, u2;
        o5 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f3 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o5 >>> 16))) << 16 | 65535 & o5;
        return o5 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o5 >>> 16), new k2((65535 & u2) << 16 | 65535 & o5, f3);
      }
      function P2(n2, r2) {
        return new k2(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x2(n2) {
        var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I2(n2, 7);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V(n2) {
        var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z = [new k2(i[0], 3609767458), new k2(i[1], 602891725), new k2(i[2], 3964484399), new k2(i[3], 2173295548), new k2(i[4], 4081628472), new k2(i[5], 3053834265), new k2(i[6], 2937671579), new k2(i[7], 3664609560), new k2(i[8], 2734883394), new k2(i[9], 1164996542), new k2(i[10], 1323610764), new k2(i[11], 3590304994), new k2(i[12], 4068182383), new k2(i[13], 991336113), new k2(i[14], 633803317), new k2(i[15], 3479774868), new k2(i[16], 2666613458), new k2(i[17], 944711139), new k2(i[18], 2341262773), new k2(i[19], 2007800933), new k2(i[20], 1495990901), new k2(i[21], 1856431235), new k2(i[22], 3175218132), new k2(i[23], 2198950837), new k2(i[24], 3999719339), new k2(i[25], 766784016), new k2(i[26], 2566594879), new k2(i[27], 3203337956), new k2(i[28], 1034457026), new k2(i[29], 2466948901), new k2(i[30], 3758326383), new k2(i[31], 168717936), new k2(i[32], 1188179964), new k2(i[33], 1546045734), new k2(i[34], 1522805485), new k2(i[35], 2643833823), new k2(i[36], 2343527390), new k2(i[37], 1014477480), new k2(i[38], 1206759142), new k2(i[39], 344077627), new k2(i[40], 1290863460), new k2(i[41], 3158454273), new k2(i[42], 3505952657), new k2(i[43], 106217008), new k2(i[44], 3606008344), new k2(i[45], 1432725776), new k2(i[46], 1467031594), new k2(i[47], 851169720), new k2(i[48], 3100823752), new k2(i[49], 1363258195), new k2(i[50], 3750685593), new k2(i[51], 3785050280), new k2(i[52], 3318307427), new k2(i[53], 3812723403), new k2(i[54], 2003034995), new k2(i[55], 3602036899), new k2(i[56], 1575990012), new k2(i[57], 1125592928), new k2(i[58], 2716904306), new k2(i[59], 442776044), new k2(i[60], 593698344), new k2(i[61], 3733110249), new k2(i[62], 2999351573), new k2(i[63], 3815920427), new k2(3391569614, 3928383900), new k2(3515267271, 566280711), new k2(3940187606, 3454069534), new k2(4118630271, 4000239992), new k2(116418474, 1914138554), new k2(174292421, 2731055270), new k2(289380356, 3203993006), new k2(460393269, 320620315), new k2(685471733, 587496836), new k2(852142971, 1086792851), new k2(1017036298, 365543100), new k2(1126000580, 2618297676), new k2(1288033470, 3409855158), new k2(1501505948, 4234509866), new k2(1607167915, 987167468), new k2(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k2(3418070365, o4[0]), new k2(1654270250, o4[1]), new k2(2438529370, o4[2]), new k2(355462360, o4[3]), new k2(1731405415, o4[4]), new k2(41048885895, o4[5]), new k2(3675008525, o4[6]), new k2(1203062813, o4[7])] : [new k2(u[0], 4089235720), new k2(u[1], 2227873595), new k2(u[2], 4271175723), new k2(u[3], 1595750129), new k2(u[4], 2917565137), new k2(u[5], 725511199), new k2(u[6], 4215389547), new k2(u[7], 327033209)];
      }
      function D2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w2, s3, a3, h3, c2, v3, A2, E3, l2, b3, H2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o5 = r2[3], u2 = r2[4], f3 = r2[5], w2 = r2[6], s3 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v3 = 2 * c2, H2[c2] = new k2(n2[v3], n2[v3 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E3 = void 0, l2 = void 0, b3 = void 0, E3 = N(A2, 19), l2 = N(A2, 61), b3 = I2(A2, 6), new k2(E3.N ^ l2.N ^ b3.N, E3.I ^ l2.I ^ b3.I)), H2[c2 - 7], x2(H2[c2 - 15]), H2[c2 - 16]), a3 = _(s3, V(u2), M2(u2, f3, w2), Z[c2], H2[c2]), h3 = O2(z(t2), X(t2, e2, i2)), s3 = w2, w2 = f3, f3 = u2, u2 = O2(o5, a3), o5 = i2, i2 = e2, e2 = t2, t2 = O2(a3, h3);
        return r2[0] = O2(t2, r2[0]), r2[1] = O2(e2, r2[1]), r2[2] = O2(i2, r2[2]), r2[3] = O2(o5, r2[3]), r2[4] = O2(u2, r2[4]), r2[5] = O2(f3, r2[5]), r2[6] = O2(w2, r2[6]), r2[7] = O2(s3, r2[7]), r2;
      }
      var G2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).F = o5.Y, o5.g = true, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = D2, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = q, o5.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o6, u3 = 31 + (r4 + 129 >>> 10 << 5), f3 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f3, n4[u3 - 1] = f3 / 4294967296 | 0, o6 = 0; o6 < n4.length; o6 += 32) e4 = D2(n4.slice(o6, o6 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            })(n3, t2, e3, i3, r3);
          }, o5.m = q(r3), o5.S = 1024, o5.U = "SHA-384" === r3 ? 384 : 512, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2), J = [new k2(0, 1), new k2(0, 32898), new k2(2147483648, 32906), new k2(2147483648, 2147516416), new k2(0, 32907), new k2(0, 2147483649), new k2(2147483648, 2147516545), new k2(2147483648, 32777), new k2(0, 138), new k2(0, 136), new k2(0, 2147516425), new k2(0, 2147483658), new k2(0, 2147516555), new k2(2147483648, 139), new k2(2147483648, 32905), new k2(2147483648, 32771), new k2(2147483648, 32770), new k2(2147483648, 128), new k2(0, 32778), new k2(2147483648, 2147483658), new k2(2147483648, 2147516545), new k2(2147483648, 32896), new k2(0, 2147483649), new k2(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new k2(0, 0), new k2(0, 0), new k2(0, 0), new k2(0, 0), new k2(0, 0)];
        return t2;
      }
      function $(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w2, s3, a3, h3 = [], c2 = [];
        if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P2(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k2(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o5 = W(), e2 = 0; e2 < 5; e2 += 1) h3[e2] = (u2 = r2[e2][0], f3 = r2[e2][1], w2 = r2[e2][2], s3 = r2[e2][3], a3 = r2[e2][4], new k2(u2.N ^ f3.N ^ w2.N ^ s3.N ^ a3.N, u2.I ^ f3.I ^ w2.I ^ s3.I ^ a3.I));
          for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = P2(h3[(e2 + 4) % 5], Y(h3[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o5[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(o5[e2][i2], new k2(~o5[(e2 + 1) % 5][i2].N & o5[(e2 + 2) % 5][i2].N, ~o5[(e2 + 1) % 5][i2].I & o5[(e2 + 2) % 5][i2].I));
          r2[0][0] = P2(r2[0][0], J[t2]);
        }
        return r2;
      }
      function rn(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o5 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o5[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn(n2) {
        return w(rn(n2.binLen), n2);
      }
      function en(n2, r2) {
        var t2, e2 = rn(r2), i2 = r2 >>> 2, o5 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o5; t2++) e2.value.push(0);
        return e2.value;
      }
      var on = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this, u2 = 6, w2 = 0, s3 = i2 || {};
          if (1 !== (o5 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s3.kmacKey || s3.hmacKey) throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o5.o || "CSHAKE256" === o5.o) throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o5.C = 1, o5.p = t(o5.t, o5.i, o5.C), o5.R = nn, o5.B = $, o5.L = W, o5.m = W(), o5.T = false, r3) {
            case "SHA3-224":
              o5.S = w2 = 1152, o5.U = 224, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-256":
              o5.S = w2 = 1088, o5.U = 256, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-384":
              o5.S = w2 = 832, o5.U = 384, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-512":
              o5.S = w2 = 576, o5.U = 512, o5.g = true, o5.F = o5.Y;
              break;
            case "SHAKE128":
              u2 = 31, o5.S = w2 = 1344, o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o5.S = w2 = 1088, o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "KMAC128":
              u2 = 4, o5.S = w2 = 1344, o5.M(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = o5.X;
              break;
            case "KMAC256":
              u2 = 4, o5.S = w2 = 1088, o5.M(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = o5.X;
              break;
            case "CSHAKE128":
              o5.S = w2 = 1344, u2 = o5.O(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "CSHAKE256":
              o5.S = w2 = 1088, u2 = o5.O(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            default:
              throw new Error(f2);
          }
          return o5.K = function(n3, r4, t2, e3, i3) {
            return (function(n4, r5, t3, e4, i4, o6, u3) {
              var f3, w3, s4 = 0, a3 = [], h3 = i4 >>> 5, c2 = r5 >>> 5;
              for (f3 = 0; f3 < c2 && r5 >= i4; f3 += h3) e4 = nn(n4.slice(f3, f3 + h3), e4), r5 -= i4;
              for (n4 = n4.slice(f3), r5 %= i4; n4.length < h3; ) n4.push(0);
              for (n4[(f3 = r5 >>> 3) >> 2] ^= o6 << f3 % 4 * 8, n4[h3 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a3.length < u3 && (w3 = e4[s4 % 5][s4 / 5 | 0], a3.push(w3.I), !(32 * a3.length >= u3)); ) a3.push(w3.N), 0 == 64 * (s4 += 1) % i4 && (nn(null, e4), s4 = 0);
              return a3;
            })(n3, r4, 0, e3, w2, u2, i3);
          }, s3.hmacKey && o5.k(a2("hmacKey", s3.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = (function(n4) {
            var r4 = n4 || {};
            return { funcName: a2("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a2("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w(tn(t2.funcName), tn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en(e2, this.S >>> 3), o5 = 0; o5 < i2.length; o5 += this.S >>> 5) this.m = this.R(i2.slice(o5, o5 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = (function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a2("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a2("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5) this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w({ value: this.u.slice(), binLen: this.s }, (function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o5 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o5[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          })(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      })(h2);
      return (function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3) this.j = new K(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3) this.j = new g(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3) this.j = new G2(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(f2);
            this.j = new on(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      })();
    }));
  })(sha$1);
  return sha$1.exports;
}
var browser = {};
var getSecureRandom$1 = {};
var hasRequiredGetSecureRandom$1;
function requireGetSecureRandom$1() {
  if (hasRequiredGetSecureRandom$1) return getSecureRandom$1;
  hasRequiredGetSecureRandom$1 = 1;
  Object.defineProperty(getSecureRandom$1, "__esModule", { value: true });
  getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
  function getSecureRandomBytes(size) {
    return Buffer.from(window.crypto.getRandomValues(new Uint8Array(size)));
  }
  getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes;
  function getSecureRandomWords(size) {
    return window.crypto.getRandomValues(new Uint16Array(size));
  }
  getSecureRandom$1.getSecureRandomWords = getSecureRandomWords;
  return getSecureRandom$1;
}
var hmac_sha512$1 = {};
var hasRequiredHmac_sha512$1;
function requireHmac_sha512$1() {
  if (hasRequiredHmac_sha512$1) return hmac_sha512$1;
  hasRequiredHmac_sha512$1 = 1;
  Object.defineProperty(hmac_sha512$1, "__esModule", { value: true });
  hmac_sha512$1.hmac_sha512 = void 0;
  async function hmac_sha5122(key, data) {
    let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
    const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
    return Buffer.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
  }
  hmac_sha512$1.hmac_sha512 = hmac_sha5122;
  return hmac_sha512$1;
}
var pbkdf2_sha512$1 = {};
var hasRequiredPbkdf2_sha512$1;
function requirePbkdf2_sha512$1() {
  if (hasRequiredPbkdf2_sha512$1) return pbkdf2_sha512$1;
  hasRequiredPbkdf2_sha512$1 = 1;
  Object.defineProperty(pbkdf2_sha512$1, "__esModule", { value: true });
  pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
  async function pbkdf2_sha5122(key, salt, iterations, keyLen) {
    const keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
    const saltBuffer = typeof salt === "string" ? Buffer.from(salt, "utf-8") : salt;
    const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
    const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
    return Buffer.from(derivedBits);
  }
  pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha5122;
  return pbkdf2_sha512$1;
}
var sha256 = {};
var hasRequiredSha256$1;
function requireSha256$1() {
  if (hasRequiredSha256$1) return sha256;
  hasRequiredSha256$1 = 1;
  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.sha256 = void 0;
  async function sha256$12(source) {
    if (typeof source === "string") {
      return Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(source, "utf-8")));
    }
    return Buffer.from(await crypto.subtle.digest("SHA-256", source));
  }
  sha256.sha256 = sha256$12;
  return sha256;
}
var sha512$2 = {};
var hasRequiredSha512$1;
function requireSha512$1() {
  if (hasRequiredSha512$1) return sha512$2;
  hasRequiredSha512$1 = 1;
  Object.defineProperty(sha512$2, "__esModule", { value: true });
  sha512$2.sha512 = void 0;
  async function sha5122(source) {
    if (typeof source === "string") {
      return Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(source, "utf-8")));
    }
    return Buffer.from(await crypto.subtle.digest("SHA-512", source));
  }
  sha512$2.sha512 = sha5122;
  return sha512$2;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = requireGetSecureRandom$1();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = requireHmac_sha512$1();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512$1();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = requireSha256$1();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = requireSha512$1();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  })(browser);
  return browser;
}
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1;
  hasRequiredSha256 = 1;
  var __importDefault = sha256$1 && sha256$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha256$1, "__esModule", { value: true });
  sha256$1.sha256 = sha256$1.sha256_fallback = sha256$1.sha256_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireBrowser();
  function sha256_sync(source) {
    let src;
    if (typeof source === "string") {
      src = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-256", "HEX");
    hasher.update(src);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha256$1.sha256_sync = sha256_sync;
  async function sha256_fallback(source) {
    return sha256_sync(source);
  }
  sha256$1.sha256_fallback = sha256_fallback;
  function sha2562(source) {
    return (0, crypto_primitives_1.sha256)(source);
  }
  sha256$1.sha256 = sha2562;
  return sha256$1;
}
var sha512$1 = {};
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var __importDefault = sha512$1 && sha512$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha512$1, "__esModule", { value: true });
  sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireBrowser();
  function sha512_sync(source) {
    let src;
    if (typeof source === "string") {
      src = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-512", "HEX");
    hasher.update(src);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha512$1.sha512_sync = sha512_sync;
  async function sha512_fallback(source) {
    return sha512_sync(source);
  }
  sha512$1.sha512_fallback = sha512_fallback;
  async function sha5122(source) {
    return (0, crypto_primitives_1.sha512)(source);
  }
  sha512$1.sha512 = sha5122;
  return sha512$1;
}
var pbkdf2_sha512 = {};
var hasRequiredPbkdf2_sha512;
function requirePbkdf2_sha512() {
  if (hasRequiredPbkdf2_sha512) return pbkdf2_sha512;
  hasRequiredPbkdf2_sha512 = 1;
  Object.defineProperty(pbkdf2_sha512, "__esModule", { value: true });
  pbkdf2_sha512.pbkdf2_sha512 = void 0;
  const crypto_primitives_1 = requireBrowser();
  function pbkdf2_sha512$12(key, salt, iterations, keyLen) {
    return (0, crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
  }
  pbkdf2_sha512.pbkdf2_sha512 = pbkdf2_sha512$12;
  return pbkdf2_sha512;
}
var hmac_sha512 = {};
var hasRequiredHmac_sha512;
function requireHmac_sha512() {
  if (hasRequiredHmac_sha512) return hmac_sha512;
  hasRequiredHmac_sha512 = 1;
  var __importDefault = hmac_sha512 && hmac_sha512.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(hmac_sha512, "__esModule", { value: true });
  hmac_sha512.hmac_sha512 = hmac_sha512.hmac_sha512_fallback = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireBrowser();
  async function hmac_sha512_fallback(key, data) {
    let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const shaObj = new jssha_1.default("SHA-512", "HEX", {
      hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
    });
    shaObj.update(dataBuffer.toString("hex"));
    const hmac2 = shaObj.getHash("HEX");
    return Buffer.from(hmac2, "hex");
  }
  hmac_sha512.hmac_sha512_fallback = hmac_sha512_fallback;
  function hmac_sha512$12(key, data) {
    return (0, crypto_primitives_1.hmac_sha512)(key, data);
  }
  hmac_sha512.hmac_sha512 = hmac_sha512$12;
  return hmac_sha512;
}
var getSecureRandom = {};
var hasRequiredGetSecureRandom;
function requireGetSecureRandom() {
  if (hasRequiredGetSecureRandom) return getSecureRandom;
  hasRequiredGetSecureRandom = 1;
  Object.defineProperty(getSecureRandom, "__esModule", { value: true });
  getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
  const crypto_primitives_1 = requireBrowser();
  async function getSecureRandomBytes(size) {
    return (0, crypto_primitives_1.getSecureRandomBytes)(size);
  }
  getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
  async function getSecureRandomWords(size) {
    return getSecureRandomWords();
  }
  getSecureRandom.getSecureRandomWords = getSecureRandomWords;
  async function getSecureRandomNumber(min, max) {
    let range = max - min;
    var bitsNeeded = Math.ceil(Math.log2(range));
    if (bitsNeeded > 53) {
      throw new Error("Range is too large");
    }
    var bytesNeeded = Math.ceil(bitsNeeded / 8);
    var mask = Math.pow(2, bitsNeeded) - 1;
    while (true) {
      let res = await getSecureRandomBytes(bitsNeeded);
      let power = (bytesNeeded - 1) * 8;
      let numberValue = 0;
      for (var i = 0; i < bytesNeeded; i++) {
        numberValue += res[i] * Math.pow(2, power);
        power -= 8;
      }
      numberValue = numberValue & mask;
      if (numberValue >= range) {
        continue;
      }
      return min + numberValue;
    }
  }
  getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
  return getSecureRandom;
}
var newSecureWords = {};
var wordlist$1 = {};
var hasRequiredWordlist$1;
function requireWordlist$1() {
  if (hasRequiredWordlist$1) return wordlist$1;
  hasRequiredWordlist$1 = 1;
  Object.defineProperty(wordlist$1, "__esModule", { value: true });
  wordlist$1.wordlist = void 0;
  wordlist$1.wordlist = [
    "abacus",
    "abdomen",
    "abdominal",
    "abide",
    "abiding",
    "ability",
    "ablaze",
    "able",
    "abnormal",
    "abrasion",
    "abrasive",
    "abreast",
    "abridge",
    "abroad",
    "abruptly",
    "absence",
    "absentee",
    "absently",
    "absinthe",
    "absolute",
    "absolve",
    "abstain",
    "abstract",
    "absurd",
    "accent",
    "acclaim",
    "acclimate",
    "accompany",
    "account",
    "accuracy",
    "accurate",
    "accustom",
    "acetone",
    "achiness",
    "aching",
    "acid",
    "acorn",
    "acquaint",
    "acquire",
    "acre",
    "acrobat",
    "acronym",
    "acting",
    "action",
    "activate",
    "activator",
    "active",
    "activism",
    "activist",
    "activity",
    "actress",
    "acts",
    "acutely",
    "acuteness",
    "aeration",
    "aerobics",
    "aerosol",
    "aerospace",
    "afar",
    "affair",
    "affected",
    "affecting",
    "affection",
    "affidavit",
    "affiliate",
    "affirm",
    "affix",
    "afflicted",
    "affluent",
    "afford",
    "affront",
    "aflame",
    "afloat",
    "aflutter",
    "afoot",
    "afraid",
    "afterglow",
    "afterlife",
    "aftermath",
    "aftermost",
    "afternoon",
    "aged",
    "ageless",
    "agency",
    "agenda",
    "agent",
    "aggregate",
    "aghast",
    "agile",
    "agility",
    "aging",
    "agnostic",
    "agonize",
    "agonizing",
    "agony",
    "agreeable",
    "agreeably",
    "agreed",
    "agreeing",
    "agreement",
    "aground",
    "ahead",
    "ahoy",
    "aide",
    "aids",
    "aim",
    "ajar",
    "alabaster",
    "alarm",
    "albatross",
    "album",
    "alfalfa",
    "algebra",
    "algorithm",
    "alias",
    "alibi",
    "alienable",
    "alienate",
    "aliens",
    "alike",
    "alive",
    "alkaline",
    "alkalize",
    "almanac",
    "almighty",
    "almost",
    "aloe",
    "aloft",
    "aloha",
    "alone",
    "alongside",
    "aloof",
    "alphabet",
    "alright",
    "although",
    "altitude",
    "alto",
    "aluminum",
    "alumni",
    "always",
    "amaretto",
    "amaze",
    "amazingly",
    "amber",
    "ambiance",
    "ambiguity",
    "ambiguous",
    "ambition",
    "ambitious",
    "ambulance",
    "ambush",
    "amendable",
    "amendment",
    "amends",
    "amenity",
    "amiable",
    "amicably",
    "amid",
    "amigo",
    "amino",
    "amiss",
    "ammonia",
    "ammonium",
    "amnesty",
    "amniotic",
    "among",
    "amount",
    "amperage",
    "ample",
    "amplifier",
    "amplify",
    "amply",
    "amuck",
    "amulet",
    "amusable",
    "amused",
    "amusement",
    "amuser",
    "amusing",
    "anaconda",
    "anaerobic",
    "anagram",
    "anatomist",
    "anatomy",
    "anchor",
    "anchovy",
    "ancient",
    "android",
    "anemia",
    "anemic",
    "aneurism",
    "anew",
    "angelfish",
    "angelic",
    "anger",
    "angled",
    "angler",
    "angles",
    "angling",
    "angrily",
    "angriness",
    "anguished",
    "angular",
    "animal",
    "animate",
    "animating",
    "animation",
    "animator",
    "anime",
    "animosity",
    "ankle",
    "annex",
    "annotate",
    "announcer",
    "annoying",
    "annually",
    "annuity",
    "anointer",
    "another",
    "answering",
    "antacid",
    "antarctic",
    "anteater",
    "antelope",
    "antennae",
    "anthem",
    "anthill",
    "anthology",
    "antibody",
    "antics",
    "antidote",
    "antihero",
    "antiquely",
    "antiques",
    "antiquity",
    "antirust",
    "antitoxic",
    "antitrust",
    "antiviral",
    "antivirus",
    "antler",
    "antonym",
    "antsy",
    "anvil",
    "anybody",
    "anyhow",
    "anymore",
    "anyone",
    "anyplace",
    "anything",
    "anytime",
    "anyway",
    "anywhere",
    "aorta",
    "apache",
    "apostle",
    "appealing",
    "appear",
    "appease",
    "appeasing",
    "appendage",
    "appendix",
    "appetite",
    "appetizer",
    "applaud",
    "applause",
    "apple",
    "appliance",
    "applicant",
    "applied",
    "apply",
    "appointee",
    "appraisal",
    "appraiser",
    "apprehend",
    "approach",
    "approval",
    "approve",
    "apricot",
    "april",
    "apron",
    "aptitude",
    "aptly",
    "aqua",
    "aqueduct",
    "arbitrary",
    "arbitrate",
    "ardently",
    "area",
    "arena",
    "arguable",
    "arguably",
    "argue",
    "arise",
    "armadillo",
    "armband",
    "armchair",
    "armed",
    "armful",
    "armhole",
    "arming",
    "armless",
    "armoire",
    "armored",
    "armory",
    "armrest",
    "army",
    "aroma",
    "arose",
    "around",
    "arousal",
    "arrange",
    "array",
    "arrest",
    "arrival",
    "arrive",
    "arrogance",
    "arrogant",
    "arson",
    "art",
    "ascend",
    "ascension",
    "ascent",
    "ascertain",
    "ashamed",
    "ashen",
    "ashes",
    "ashy",
    "aside",
    "askew",
    "asleep",
    "asparagus",
    "aspect",
    "aspirate",
    "aspire",
    "aspirin",
    "astonish",
    "astound",
    "astride",
    "astrology",
    "astronaut",
    "astronomy",
    "astute",
    "atlantic",
    "atlas",
    "atom",
    "atonable",
    "atop",
    "atrium",
    "atrocious",
    "atrophy",
    "attach",
    "attain",
    "attempt",
    "attendant",
    "attendee",
    "attention",
    "attentive",
    "attest",
    "attic",
    "attire",
    "attitude",
    "attractor",
    "attribute",
    "atypical",
    "auction",
    "audacious",
    "audacity",
    "audible",
    "audibly",
    "audience",
    "audio",
    "audition",
    "augmented",
    "august",
    "authentic",
    "author",
    "autism",
    "autistic",
    "autograph",
    "automaker",
    "automated",
    "automatic",
    "autopilot",
    "available",
    "avalanche",
    "avatar",
    "avenge",
    "avenging",
    "avenue",
    "average",
    "aversion",
    "avert",
    "aviation",
    "aviator",
    "avid",
    "avoid",
    "await",
    "awaken",
    "award",
    "aware",
    "awhile",
    "awkward",
    "awning",
    "awoke",
    "awry",
    "axis",
    "babble",
    "babbling",
    "babied",
    "baboon",
    "backache",
    "backboard",
    "backboned",
    "backdrop",
    "backed",
    "backer",
    "backfield",
    "backfire",
    "backhand",
    "backing",
    "backlands",
    "backlash",
    "backless",
    "backlight",
    "backlit",
    "backlog",
    "backpack",
    "backpedal",
    "backrest",
    "backroom",
    "backshift",
    "backside",
    "backslid",
    "backspace",
    "backspin",
    "backstab",
    "backstage",
    "backtalk",
    "backtrack",
    "backup",
    "backward",
    "backwash",
    "backwater",
    "backyard",
    "bacon",
    "bacteria",
    "bacterium",
    "badass",
    "badge",
    "badland",
    "badly",
    "badness",
    "baffle",
    "baffling",
    "bagel",
    "bagful",
    "baggage",
    "bagged",
    "baggie",
    "bagginess",
    "bagging",
    "baggy",
    "bagpipe",
    "baguette",
    "baked",
    "bakery",
    "bakeshop",
    "baking",
    "balance",
    "balancing",
    "balcony",
    "balmy",
    "balsamic",
    "bamboo",
    "banana",
    "banish",
    "banister",
    "banjo",
    "bankable",
    "bankbook",
    "banked",
    "banker",
    "banking",
    "banknote",
    "bankroll",
    "banner",
    "bannister",
    "banshee",
    "banter",
    "barbecue",
    "barbed",
    "barbell",
    "barber",
    "barcode",
    "barge",
    "bargraph",
    "barista",
    "baritone",
    "barley",
    "barmaid",
    "barman",
    "barn",
    "barometer",
    "barrack",
    "barracuda",
    "barrel",
    "barrette",
    "barricade",
    "barrier",
    "barstool",
    "bartender",
    "barterer",
    "bash",
    "basically",
    "basics",
    "basil",
    "basin",
    "basis",
    "basket",
    "batboy",
    "batch",
    "bath",
    "baton",
    "bats",
    "battalion",
    "battered",
    "battering",
    "battery",
    "batting",
    "battle",
    "bauble",
    "bazooka",
    "blabber",
    "bladder",
    "blade",
    "blah",
    "blame",
    "blaming",
    "blanching",
    "blandness",
    "blank",
    "blaspheme",
    "blasphemy",
    "blast",
    "blatancy",
    "blatantly",
    "blazer",
    "blazing",
    "bleach",
    "bleak",
    "bleep",
    "blemish",
    "blend",
    "bless",
    "blighted",
    "blimp",
    "bling",
    "blinked",
    "blinker",
    "blinking",
    "blinks",
    "blip",
    "blissful",
    "blitz",
    "blizzard",
    "bloated",
    "bloating",
    "blob",
    "blog",
    "bloomers",
    "blooming",
    "blooper",
    "blot",
    "blouse",
    "blubber",
    "bluff",
    "bluish",
    "blunderer",
    "blunt",
    "blurb",
    "blurred",
    "blurry",
    "blurt",
    "blush",
    "blustery",
    "boaster",
    "boastful",
    "boasting",
    "boat",
    "bobbed",
    "bobbing",
    "bobble",
    "bobcat",
    "bobsled",
    "bobtail",
    "bodacious",
    "body",
    "bogged",
    "boggle",
    "bogus",
    "boil",
    "bok",
    "bolster",
    "bolt",
    "bonanza",
    "bonded",
    "bonding",
    "bondless",
    "boned",
    "bonehead",
    "boneless",
    "bonelike",
    "boney",
    "bonfire",
    "bonnet",
    "bonsai",
    "bonus",
    "bony",
    "boogeyman",
    "boogieman",
    "book",
    "boondocks",
    "booted",
    "booth",
    "bootie",
    "booting",
    "bootlace",
    "bootleg",
    "boots",
    "boozy",
    "borax",
    "boring",
    "borough",
    "borrower",
    "borrowing",
    "boss",
    "botanical",
    "botanist",
    "botany",
    "botch",
    "both",
    "bottle",
    "bottling",
    "bottom",
    "bounce",
    "bouncing",
    "bouncy",
    "bounding",
    "boundless",
    "bountiful",
    "bovine",
    "boxcar",
    "boxer",
    "boxing",
    "boxlike",
    "boxy",
    "breach",
    "breath",
    "breeches",
    "breeching",
    "breeder",
    "breeding",
    "breeze",
    "breezy",
    "brethren",
    "brewery",
    "brewing",
    "briar",
    "bribe",
    "brick",
    "bride",
    "bridged",
    "brigade",
    "bright",
    "brilliant",
    "brim",
    "bring",
    "brink",
    "brisket",
    "briskly",
    "briskness",
    "bristle",
    "brittle",
    "broadband",
    "broadcast",
    "broaden",
    "broadly",
    "broadness",
    "broadside",
    "broadways",
    "broiler",
    "broiling",
    "broken",
    "broker",
    "bronchial",
    "bronco",
    "bronze",
    "bronzing",
    "brook",
    "broom",
    "brought",
    "browbeat",
    "brownnose",
    "browse",
    "browsing",
    "bruising",
    "brunch",
    "brunette",
    "brunt",
    "brush",
    "brussels",
    "brute",
    "brutishly",
    "bubble",
    "bubbling",
    "bubbly",
    "buccaneer",
    "bucked",
    "bucket",
    "buckle",
    "buckshot",
    "buckskin",
    "bucktooth",
    "buckwheat",
    "buddhism",
    "buddhist",
    "budding",
    "buddy",
    "budget",
    "buffalo",
    "buffed",
    "buffer",
    "buffing",
    "buffoon",
    "buggy",
    "bulb",
    "bulge",
    "bulginess",
    "bulgur",
    "bulk",
    "bulldog",
    "bulldozer",
    "bullfight",
    "bullfrog",
    "bullhorn",
    "bullion",
    "bullish",
    "bullpen",
    "bullring",
    "bullseye",
    "bullwhip",
    "bully",
    "bunch",
    "bundle",
    "bungee",
    "bunion",
    "bunkbed",
    "bunkhouse",
    "bunkmate",
    "bunny",
    "bunt",
    "busboy",
    "bush",
    "busily",
    "busload",
    "bust",
    "busybody",
    "buzz",
    "cabana",
    "cabbage",
    "cabbie",
    "cabdriver",
    "cable",
    "caboose",
    "cache",
    "cackle",
    "cacti",
    "cactus",
    "caddie",
    "caddy",
    "cadet",
    "cadillac",
    "cadmium",
    "cage",
    "cahoots",
    "cake",
    "calamari",
    "calamity",
    "calcium",
    "calculate",
    "calculus",
    "caliber",
    "calibrate",
    "calm",
    "caloric",
    "calorie",
    "calzone",
    "camcorder",
    "cameo",
    "camera",
    "camisole",
    "camper",
    "campfire",
    "camping",
    "campsite",
    "campus",
    "canal",
    "canary",
    "cancel",
    "candied",
    "candle",
    "candy",
    "cane",
    "canine",
    "canister",
    "cannabis",
    "canned",
    "canning",
    "cannon",
    "cannot",
    "canola",
    "canon",
    "canopener",
    "canopy",
    "canteen",
    "canyon",
    "capable",
    "capably",
    "capacity",
    "cape",
    "capillary",
    "capital",
    "capitol",
    "capped",
    "capricorn",
    "capsize",
    "capsule",
    "caption",
    "captivate",
    "captive",
    "captivity",
    "capture",
    "caramel",
    "carat",
    "caravan",
    "carbon",
    "cardboard",
    "carded",
    "cardiac",
    "cardigan",
    "cardinal",
    "cardstock",
    "carefully",
    "caregiver",
    "careless",
    "caress",
    "caretaker",
    "cargo",
    "caring",
    "carless",
    "carload",
    "carmaker",
    "carnage",
    "carnation",
    "carnival",
    "carnivore",
    "carol",
    "carpenter",
    "carpentry",
    "carpool",
    "carport",
    "carried",
    "carrot",
    "carrousel",
    "carry",
    "cartel",
    "cartload",
    "carton",
    "cartoon",
    "cartridge",
    "cartwheel",
    "carve",
    "carving",
    "carwash",
    "cascade",
    "case",
    "cash",
    "casing",
    "casino",
    "casket",
    "cassette",
    "casually",
    "casualty",
    "catacomb",
    "catalog",
    "catalyst",
    "catalyze",
    "catapult",
    "cataract",
    "catatonic",
    "catcall",
    "catchable",
    "catcher",
    "catching",
    "catchy",
    "caterer",
    "catering",
    "catfight",
    "catfish",
    "cathedral",
    "cathouse",
    "catlike",
    "catnap",
    "catnip",
    "catsup",
    "cattail",
    "cattishly",
    "cattle",
    "catty",
    "catwalk",
    "caucasian",
    "caucus",
    "causal",
    "causation",
    "cause",
    "causing",
    "cauterize",
    "caution",
    "cautious",
    "cavalier",
    "cavalry",
    "caviar",
    "cavity",
    "cedar",
    "celery",
    "celestial",
    "celibacy",
    "celibate",
    "celtic",
    "cement",
    "census",
    "ceramics",
    "ceremony",
    "certainly",
    "certainty",
    "certified",
    "certify",
    "cesarean",
    "cesspool",
    "chafe",
    "chaffing",
    "chain",
    "chair",
    "chalice",
    "challenge",
    "chamber",
    "chamomile",
    "champion",
    "chance",
    "change",
    "channel",
    "chant",
    "chaos",
    "chaperone",
    "chaplain",
    "chapped",
    "chaps",
    "chapter",
    "character",
    "charbroil",
    "charcoal",
    "charger",
    "charging",
    "chariot",
    "charity",
    "charm",
    "charred",
    "charter",
    "charting",
    "chase",
    "chasing",
    "chaste",
    "chastise",
    "chastity",
    "chatroom",
    "chatter",
    "chatting",
    "chatty",
    "cheating",
    "cheddar",
    "cheek",
    "cheer",
    "cheese",
    "cheesy",
    "chef",
    "chemicals",
    "chemist",
    "chemo",
    "cherisher",
    "cherub",
    "chess",
    "chest",
    "chevron",
    "chevy",
    "chewable",
    "chewer",
    "chewing",
    "chewy",
    "chief",
    "chihuahua",
    "childcare",
    "childhood",
    "childish",
    "childless",
    "childlike",
    "chili",
    "chill",
    "chimp",
    "chip",
    "chirping",
    "chirpy",
    "chitchat",
    "chivalry",
    "chive",
    "chloride",
    "chlorine",
    "choice",
    "chokehold",
    "choking",
    "chomp",
    "chooser",
    "choosing",
    "choosy",
    "chop",
    "chosen",
    "chowder",
    "chowtime",
    "chrome",
    "chubby",
    "chuck",
    "chug",
    "chummy",
    "chump",
    "chunk",
    "churn",
    "chute",
    "cider",
    "cilantro",
    "cinch",
    "cinema",
    "cinnamon",
    "circle",
    "circling",
    "circular",
    "circulate",
    "circus",
    "citable",
    "citadel",
    "citation",
    "citizen",
    "citric",
    "citrus",
    "city",
    "civic",
    "civil",
    "clad",
    "claim",
    "clambake",
    "clammy",
    "clamor",
    "clamp",
    "clamshell",
    "clang",
    "clanking",
    "clapped",
    "clapper",
    "clapping",
    "clarify",
    "clarinet",
    "clarity",
    "clash",
    "clasp",
    "class",
    "clatter",
    "clause",
    "clavicle",
    "claw",
    "clay",
    "clean",
    "clear",
    "cleat",
    "cleaver",
    "cleft",
    "clench",
    "clergyman",
    "clerical",
    "clerk",
    "clever",
    "clicker",
    "client",
    "climate",
    "climatic",
    "cling",
    "clinic",
    "clinking",
    "clip",
    "clique",
    "cloak",
    "clobber",
    "clock",
    "clone",
    "cloning",
    "closable",
    "closure",
    "clothes",
    "clothing",
    "cloud",
    "clover",
    "clubbed",
    "clubbing",
    "clubhouse",
    "clump",
    "clumsily",
    "clumsy",
    "clunky",
    "clustered",
    "clutch",
    "clutter",
    "coach",
    "coagulant",
    "coastal",
    "coaster",
    "coasting",
    "coastland",
    "coastline",
    "coat",
    "coauthor",
    "cobalt",
    "cobbler",
    "cobweb",
    "cocoa",
    "coconut",
    "cod",
    "coeditor",
    "coerce",
    "coexist",
    "coffee",
    "cofounder",
    "cognition",
    "cognitive",
    "cogwheel",
    "coherence",
    "coherent",
    "cohesive",
    "coil",
    "coke",
    "cola",
    "cold",
    "coleslaw",
    "coliseum",
    "collage",
    "collapse",
    "collar",
    "collected",
    "collector",
    "collide",
    "collie",
    "collision",
    "colonial",
    "colonist",
    "colonize",
    "colony",
    "colossal",
    "colt",
    "coma",
    "come",
    "comfort",
    "comfy",
    "comic",
    "coming",
    "comma",
    "commence",
    "commend",
    "comment",
    "commerce",
    "commode",
    "commodity",
    "commodore",
    "common",
    "commotion",
    "commute",
    "commuting",
    "compacted",
    "compacter",
    "compactly",
    "compactor",
    "companion",
    "company",
    "compare",
    "compel",
    "compile",
    "comply",
    "component",
    "composed",
    "composer",
    "composite",
    "compost",
    "composure",
    "compound",
    "compress",
    "comprised",
    "computer",
    "computing",
    "comrade",
    "concave",
    "conceal",
    "conceded",
    "concept",
    "concerned",
    "concert",
    "conch",
    "concierge",
    "concise",
    "conclude",
    "concrete",
    "concur",
    "condense",
    "condiment",
    "condition",
    "condone",
    "conducive",
    "conductor",
    "conduit",
    "cone",
    "confess",
    "confetti",
    "confidant",
    "confident",
    "confider",
    "confiding",
    "configure",
    "confined",
    "confining",
    "confirm",
    "conflict",
    "conform",
    "confound",
    "confront",
    "confused",
    "confusing",
    "confusion",
    "congenial",
    "congested",
    "congrats",
    "congress",
    "conical",
    "conjoined",
    "conjure",
    "conjuror",
    "connected",
    "connector",
    "consensus",
    "consent",
    "console",
    "consoling",
    "consonant",
    "constable",
    "constant",
    "constrain",
    "constrict",
    "construct",
    "consult",
    "consumer",
    "consuming",
    "contact",
    "container",
    "contempt",
    "contend",
    "contented",
    "contently",
    "contents",
    "contest",
    "context",
    "contort",
    "contour",
    "contrite",
    "control",
    "contusion",
    "convene",
    "convent",
    "copartner",
    "cope",
    "copied",
    "copier",
    "copilot",
    "coping",
    "copious",
    "copper",
    "copy",
    "coral",
    "cork",
    "cornball",
    "cornbread",
    "corncob",
    "cornea",
    "corned",
    "corner",
    "cornfield",
    "cornflake",
    "cornhusk",
    "cornmeal",
    "cornstalk",
    "corny",
    "coronary",
    "coroner",
    "corporal",
    "corporate",
    "corral",
    "correct",
    "corridor",
    "corrode",
    "corroding",
    "corrosive",
    "corsage",
    "corset",
    "cortex",
    "cosigner",
    "cosmetics",
    "cosmic",
    "cosmos",
    "cosponsor",
    "cost",
    "cottage",
    "cotton",
    "couch",
    "cough",
    "could",
    "countable",
    "countdown",
    "counting",
    "countless",
    "country",
    "county",
    "courier",
    "covenant",
    "cover",
    "coveted",
    "coveting",
    "coyness",
    "cozily",
    "coziness",
    "cozy",
    "crabbing",
    "crabgrass",
    "crablike",
    "crabmeat",
    "cradle",
    "cradling",
    "crafter",
    "craftily",
    "craftsman",
    "craftwork",
    "crafty",
    "cramp",
    "cranberry",
    "crane",
    "cranial",
    "cranium",
    "crank",
    "crate",
    "crave",
    "craving",
    "crawfish",
    "crawlers",
    "crawling",
    "crayfish",
    "crayon",
    "crazed",
    "crazily",
    "craziness",
    "crazy",
    "creamed",
    "creamer",
    "creamlike",
    "crease",
    "creasing",
    "creatable",
    "create",
    "creation",
    "creative",
    "creature",
    "credible",
    "credibly",
    "credit",
    "creed",
    "creme",
    "creole",
    "crepe",
    "crept",
    "crescent",
    "crested",
    "cresting",
    "crestless",
    "crevice",
    "crewless",
    "crewman",
    "crewmate",
    "crib",
    "cricket",
    "cried",
    "crier",
    "crimp",
    "crimson",
    "cringe",
    "cringing",
    "crinkle",
    "crinkly",
    "crisped",
    "crisping",
    "crisply",
    "crispness",
    "crispy",
    "criteria",
    "critter",
    "croak",
    "crock",
    "crook",
    "croon",
    "crop",
    "cross",
    "crouch",
    "crouton",
    "crowbar",
    "crowd",
    "crown",
    "crucial",
    "crudely",
    "crudeness",
    "cruelly",
    "cruelness",
    "cruelty",
    "crumb",
    "crummiest",
    "crummy",
    "crumpet",
    "crumpled",
    "cruncher",
    "crunching",
    "crunchy",
    "crusader",
    "crushable",
    "crushed",
    "crusher",
    "crushing",
    "crust",
    "crux",
    "crying",
    "cryptic",
    "crystal",
    "cubbyhole",
    "cube",
    "cubical",
    "cubicle",
    "cucumber",
    "cuddle",
    "cuddly",
    "cufflink",
    "culinary",
    "culminate",
    "culpable",
    "culprit",
    "cultivate",
    "cultural",
    "culture",
    "cupbearer",
    "cupcake",
    "cupid",
    "cupped",
    "cupping",
    "curable",
    "curator",
    "curdle",
    "cure",
    "curfew",
    "curing",
    "curled",
    "curler",
    "curliness",
    "curling",
    "curly",
    "curry",
    "curse",
    "cursive",
    "cursor",
    "curtain",
    "curtly",
    "curtsy",
    "curvature",
    "curve",
    "curvy",
    "cushy",
    "cusp",
    "cussed",
    "custard",
    "custodian",
    "custody",
    "customary",
    "customer",
    "customize",
    "customs",
    "cut",
    "cycle",
    "cyclic",
    "cycling",
    "cyclist",
    "cylinder",
    "cymbal",
    "cytoplasm",
    "cytoplast",
    "dab",
    "dad",
    "daffodil",
    "dagger",
    "daily",
    "daintily",
    "dainty",
    "dairy",
    "daisy",
    "dallying",
    "dance",
    "dancing",
    "dandelion",
    "dander",
    "dandruff",
    "dandy",
    "danger",
    "dangle",
    "dangling",
    "daredevil",
    "dares",
    "daringly",
    "darkened",
    "darkening",
    "darkish",
    "darkness",
    "darkroom",
    "darling",
    "darn",
    "dart",
    "darwinism",
    "dash",
    "dastardly",
    "data",
    "datebook",
    "dating",
    "daughter",
    "daunting",
    "dawdler",
    "dawn",
    "daybed",
    "daybreak",
    "daycare",
    "daydream",
    "daylight",
    "daylong",
    "dayroom",
    "daytime",
    "dazzler",
    "dazzling",
    "deacon",
    "deafening",
    "deafness",
    "dealer",
    "dealing",
    "dealmaker",
    "dealt",
    "dean",
    "debatable",
    "debate",
    "debating",
    "debit",
    "debrief",
    "debtless",
    "debtor",
    "debug",
    "debunk",
    "decade",
    "decaf",
    "decal",
    "decathlon",
    "decay",
    "deceased",
    "deceit",
    "deceiver",
    "deceiving",
    "december",
    "decency",
    "decent",
    "deception",
    "deceptive",
    "decibel",
    "decidable",
    "decimal",
    "decimeter",
    "decipher",
    "deck",
    "declared",
    "decline",
    "decode",
    "decompose",
    "decorated",
    "decorator",
    "decoy",
    "decrease",
    "decree",
    "dedicate",
    "dedicator",
    "deduce",
    "deduct",
    "deed",
    "deem",
    "deepen",
    "deeply",
    "deepness",
    "deface",
    "defacing",
    "defame",
    "default",
    "defeat",
    "defection",
    "defective",
    "defendant",
    "defender",
    "defense",
    "defensive",
    "deferral",
    "deferred",
    "defiance",
    "defiant",
    "defile",
    "defiling",
    "define",
    "definite",
    "deflate",
    "deflation",
    "deflator",
    "deflected",
    "deflector",
    "defog",
    "deforest",
    "defraud",
    "defrost",
    "deftly",
    "defuse",
    "defy",
    "degraded",
    "degrading",
    "degrease",
    "degree",
    "dehydrate",
    "deity",
    "dejected",
    "delay",
    "delegate",
    "delegator",
    "delete",
    "deletion",
    "delicacy",
    "delicate",
    "delicious",
    "delighted",
    "delirious",
    "delirium",
    "deliverer",
    "delivery",
    "delouse",
    "delta",
    "deluge",
    "delusion",
    "deluxe",
    "demanding",
    "demeaning",
    "demeanor",
    "demise",
    "democracy",
    "democrat",
    "demote",
    "demotion",
    "demystify",
    "denatured",
    "deniable",
    "denial",
    "denim",
    "denote",
    "dense",
    "density",
    "dental",
    "dentist",
    "denture",
    "deny",
    "deodorant",
    "deodorize",
    "departed",
    "departure",
    "depict",
    "deplete",
    "depletion",
    "deplored",
    "deploy",
    "deport",
    "depose",
    "depraved",
    "depravity",
    "deprecate",
    "depress",
    "deprive",
    "depth",
    "deputize",
    "deputy",
    "derail",
    "deranged",
    "derby",
    "derived",
    "desecrate",
    "deserve",
    "deserving",
    "designate",
    "designed",
    "designer",
    "designing",
    "deskbound",
    "desktop",
    "deskwork",
    "desolate",
    "despair",
    "despise",
    "despite",
    "destiny",
    "destitute",
    "destruct",
    "detached",
    "detail",
    "detection",
    "detective",
    "detector",
    "detention",
    "detergent",
    "detest",
    "detonate",
    "detonator",
    "detoxify",
    "detract",
    "deuce",
    "devalue",
    "deviancy",
    "deviant",
    "deviate",
    "deviation",
    "deviator",
    "device",
    "devious",
    "devotedly",
    "devotee",
    "devotion",
    "devourer",
    "devouring",
    "devoutly",
    "dexterity",
    "dexterous",
    "diabetes",
    "diabetic",
    "diabolic",
    "diagnoses",
    "diagnosis",
    "diagram",
    "dial",
    "diameter",
    "diaper",
    "diaphragm",
    "diary",
    "dice",
    "dicing",
    "dictate",
    "dictation",
    "dictator",
    "difficult",
    "diffused",
    "diffuser",
    "diffusion",
    "diffusive",
    "dig",
    "dilation",
    "diligence",
    "diligent",
    "dill",
    "dilute",
    "dime",
    "diminish",
    "dimly",
    "dimmed",
    "dimmer",
    "dimness",
    "dimple",
    "diner",
    "dingbat",
    "dinghy",
    "dinginess",
    "dingo",
    "dingy",
    "dining",
    "dinner",
    "diocese",
    "dioxide",
    "diploma",
    "dipped",
    "dipper",
    "dipping",
    "directed",
    "direction",
    "directive",
    "directly",
    "directory",
    "direness",
    "dirtiness",
    "disabled",
    "disagree",
    "disallow",
    "disarm",
    "disarray",
    "disaster",
    "disband",
    "disbelief",
    "disburse",
    "discard",
    "discern",
    "discharge",
    "disclose",
    "discolor",
    "discount",
    "discourse",
    "discover",
    "discuss",
    "disdain",
    "disengage",
    "disfigure",
    "disgrace",
    "dish",
    "disinfect",
    "disjoin",
    "disk",
    "dislike",
    "disliking",
    "dislocate",
    "dislodge",
    "disloyal",
    "dismantle",
    "dismay",
    "dismiss",
    "dismount",
    "disobey",
    "disorder",
    "disown",
    "disparate",
    "disparity",
    "dispatch",
    "dispense",
    "dispersal",
    "dispersed",
    "disperser",
    "displace",
    "display",
    "displease",
    "disposal",
    "dispose",
    "disprove",
    "dispute",
    "disregard",
    "disrupt",
    "dissuade",
    "distance",
    "distant",
    "distaste",
    "distill",
    "distinct",
    "distort",
    "distract",
    "distress",
    "district",
    "distrust",
    "ditch",
    "ditto",
    "ditzy",
    "dividable",
    "divided",
    "dividend",
    "dividers",
    "dividing",
    "divinely",
    "diving",
    "divinity",
    "divisible",
    "divisibly",
    "division",
    "divisive",
    "divorcee",
    "dizziness",
    "dizzy",
    "doable",
    "docile",
    "dock",
    "doctrine",
    "document",
    "dodge",
    "dodgy",
    "doily",
    "doing",
    "dole",
    "dollar",
    "dollhouse",
    "dollop",
    "dolly",
    "dolphin",
    "domain",
    "domelike",
    "domestic",
    "dominion",
    "dominoes",
    "donated",
    "donation",
    "donator",
    "donor",
    "donut",
    "doodle",
    "doorbell",
    "doorframe",
    "doorknob",
    "doorman",
    "doormat",
    "doornail",
    "doorpost",
    "doorstep",
    "doorstop",
    "doorway",
    "doozy",
    "dork",
    "dormitory",
    "dorsal",
    "dosage",
    "dose",
    "dotted",
    "doubling",
    "douche",
    "dove",
    "down",
    "dowry",
    "doze",
    "drab",
    "dragging",
    "dragonfly",
    "dragonish",
    "dragster",
    "drainable",
    "drainage",
    "drained",
    "drainer",
    "drainpipe",
    "dramatic",
    "dramatize",
    "drank",
    "drapery",
    "drastic",
    "draw",
    "dreaded",
    "dreadful",
    "dreadlock",
    "dreamboat",
    "dreamily",
    "dreamland",
    "dreamless",
    "dreamlike",
    "dreamt",
    "dreamy",
    "drearily",
    "dreary",
    "drench",
    "dress",
    "drew",
    "dribble",
    "dried",
    "drier",
    "drift",
    "driller",
    "drilling",
    "drinkable",
    "drinking",
    "dripping",
    "drippy",
    "drivable",
    "driven",
    "driver",
    "driveway",
    "driving",
    "drizzle",
    "drizzly",
    "drone",
    "drool",
    "droop",
    "drop-down",
    "dropbox",
    "dropkick",
    "droplet",
    "dropout",
    "dropper",
    "drove",
    "drown",
    "drowsily",
    "drudge",
    "drum",
    "dry",
    "dubbed",
    "dubiously",
    "duchess",
    "duckbill",
    "ducking",
    "duckling",
    "ducktail",
    "ducky",
    "duct",
    "dude",
    "duffel",
    "dugout",
    "duh",
    "duke",
    "duller",
    "dullness",
    "duly",
    "dumping",
    "dumpling",
    "dumpster",
    "duo",
    "dupe",
    "duplex",
    "duplicate",
    "duplicity",
    "durable",
    "durably",
    "duration",
    "duress",
    "during",
    "dusk",
    "dust",
    "dutiful",
    "duty",
    "duvet",
    "dwarf",
    "dweeb",
    "dwelled",
    "dweller",
    "dwelling",
    "dwindle",
    "dwindling",
    "dynamic",
    "dynamite",
    "dynasty",
    "dyslexia",
    "dyslexic",
    "each",
    "eagle",
    "earache",
    "eardrum",
    "earflap",
    "earful",
    "earlobe",
    "early",
    "earmark",
    "earmuff",
    "earphone",
    "earpiece",
    "earplugs",
    "earring",
    "earshot",
    "earthen",
    "earthlike",
    "earthling",
    "earthly",
    "earthworm",
    "earthy",
    "earwig",
    "easeful",
    "easel",
    "easiest",
    "easily",
    "easiness",
    "easing",
    "eastbound",
    "eastcoast",
    "easter",
    "eastward",
    "eatable",
    "eaten",
    "eatery",
    "eating",
    "eats",
    "ebay",
    "ebony",
    "ebook",
    "ecard",
    "eccentric",
    "echo",
    "eclair",
    "eclipse",
    "ecologist",
    "ecology",
    "economic",
    "economist",
    "economy",
    "ecosphere",
    "ecosystem",
    "edge",
    "edginess",
    "edging",
    "edgy",
    "edition",
    "editor",
    "educated",
    "education",
    "educator",
    "eel",
    "effective",
    "effects",
    "efficient",
    "effort",
    "eggbeater",
    "egging",
    "eggnog",
    "eggplant",
    "eggshell",
    "egomaniac",
    "egotism",
    "egotistic",
    "either",
    "eject",
    "elaborate",
    "elastic",
    "elated",
    "elbow",
    "eldercare",
    "elderly",
    "eldest",
    "electable",
    "election",
    "elective",
    "elephant",
    "elevate",
    "elevating",
    "elevation",
    "elevator",
    "eleven",
    "elf",
    "eligible",
    "eligibly",
    "eliminate",
    "elite",
    "elitism",
    "elixir",
    "elk",
    "ellipse",
    "elliptic",
    "elm",
    "elongated",
    "elope",
    "eloquence",
    "eloquent",
    "elsewhere",
    "elude",
    "elusive",
    "elves",
    "email",
    "embargo",
    "embark",
    "embassy",
    "embattled",
    "embellish",
    "ember",
    "embezzle",
    "emblaze",
    "emblem",
    "embody",
    "embolism",
    "emboss",
    "embroider",
    "emcee",
    "emerald",
    "emergency",
    "emission",
    "emit",
    "emote",
    "emoticon",
    "emotion",
    "empathic",
    "empathy",
    "emperor",
    "emphases",
    "emphasis",
    "emphasize",
    "emphatic",
    "empirical",
    "employed",
    "employee",
    "employer",
    "emporium",
    "empower",
    "emptier",
    "emptiness",
    "empty",
    "emu",
    "enable",
    "enactment",
    "enamel",
    "enchanted",
    "enchilada",
    "encircle",
    "enclose",
    "enclosure",
    "encode",
    "encore",
    "encounter",
    "encourage",
    "encroach",
    "encrust",
    "encrypt",
    "endanger",
    "endeared",
    "endearing",
    "ended",
    "ending",
    "endless",
    "endnote",
    "endocrine",
    "endorphin",
    "endorse",
    "endowment",
    "endpoint",
    "endurable",
    "endurance",
    "enduring",
    "energetic",
    "energize",
    "energy",
    "enforced",
    "enforcer",
    "engaged",
    "engaging",
    "engine",
    "engorge",
    "engraved",
    "engraver",
    "engraving",
    "engross",
    "engulf",
    "enhance",
    "enigmatic",
    "enjoyable",
    "enjoyably",
    "enjoyer",
    "enjoying",
    "enjoyment",
    "enlarged",
    "enlarging",
    "enlighten",
    "enlisted",
    "enquirer",
    "enrage",
    "enrich",
    "enroll",
    "enslave",
    "ensnare",
    "ensure",
    "entail",
    "entangled",
    "entering",
    "entertain",
    "enticing",
    "entire",
    "entitle",
    "entity",
    "entomb",
    "entourage",
    "entrap",
    "entree",
    "entrench",
    "entrust",
    "entryway",
    "entwine",
    "enunciate",
    "envelope",
    "enviable",
    "enviably",
    "envious",
    "envision",
    "envoy",
    "envy",
    "enzyme",
    "epic",
    "epidemic",
    "epidermal",
    "epidermis",
    "epidural",
    "epilepsy",
    "epileptic",
    "epilogue",
    "epiphany",
    "episode",
    "equal",
    "equate",
    "equation",
    "equator",
    "equinox",
    "equipment",
    "equity",
    "equivocal",
    "eradicate",
    "erasable",
    "erased",
    "eraser",
    "erasure",
    "ergonomic",
    "errand",
    "errant",
    "erratic",
    "error",
    "erupt",
    "escalate",
    "escalator",
    "escapable",
    "escapade",
    "escapist",
    "escargot",
    "eskimo",
    "esophagus",
    "espionage",
    "espresso",
    "esquire",
    "essay",
    "essence",
    "essential",
    "establish",
    "estate",
    "esteemed",
    "estimate",
    "estimator",
    "estranged",
    "estrogen",
    "etching",
    "eternal",
    "eternity",
    "ethanol",
    "ether",
    "ethically",
    "ethics",
    "euphemism",
    "evacuate",
    "evacuee",
    "evade",
    "evaluate",
    "evaluator",
    "evaporate",
    "evasion",
    "evasive",
    "even",
    "everglade",
    "evergreen",
    "everybody",
    "everyday",
    "everyone",
    "evict",
    "evidence",
    "evident",
    "evil",
    "evoke",
    "evolution",
    "evolve",
    "exact",
    "exalted",
    "example",
    "excavate",
    "excavator",
    "exceeding",
    "exception",
    "excess",
    "exchange",
    "excitable",
    "exciting",
    "exclaim",
    "exclude",
    "excluding",
    "exclusion",
    "exclusive",
    "excretion",
    "excretory",
    "excursion",
    "excusable",
    "excusably",
    "excuse",
    "exemplary",
    "exemplify",
    "exemption",
    "exerciser",
    "exert",
    "exes",
    "exfoliate",
    "exhale",
    "exhaust",
    "exhume",
    "exile",
    "existing",
    "exit",
    "exodus",
    "exonerate",
    "exorcism",
    "exorcist",
    "expand",
    "expanse",
    "expansion",
    "expansive",
    "expectant",
    "expedited",
    "expediter",
    "expel",
    "expend",
    "expenses",
    "expensive",
    "expert",
    "expire",
    "expiring",
    "explain",
    "expletive",
    "explicit",
    "explode",
    "exploit",
    "explore",
    "exploring",
    "exponent",
    "exporter",
    "exposable",
    "expose",
    "exposure",
    "express",
    "expulsion",
    "exquisite",
    "extended",
    "extending",
    "extent",
    "extenuate",
    "exterior",
    "external",
    "extinct",
    "extortion",
    "extradite",
    "extras",
    "extrovert",
    "extrude",
    "extruding",
    "exuberant",
    "fable",
    "fabric",
    "fabulous",
    "facebook",
    "facecloth",
    "facedown",
    "faceless",
    "facelift",
    "faceplate",
    "faceted",
    "facial",
    "facility",
    "facing",
    "facsimile",
    "faction",
    "factoid",
    "factor",
    "factsheet",
    "factual",
    "faculty",
    "fade",
    "fading",
    "failing",
    "falcon",
    "fall",
    "false",
    "falsify",
    "fame",
    "familiar",
    "family",
    "famine",
    "famished",
    "fanatic",
    "fancied",
    "fanciness",
    "fancy",
    "fanfare",
    "fang",
    "fanning",
    "fantasize",
    "fantastic",
    "fantasy",
    "fascism",
    "fastball",
    "faster",
    "fasting",
    "fastness",
    "faucet",
    "favorable",
    "favorably",
    "favored",
    "favoring",
    "favorite",
    "fax",
    "feast",
    "federal",
    "fedora",
    "feeble",
    "feed",
    "feel",
    "feisty",
    "feline",
    "felt-tip",
    "feminine",
    "feminism",
    "feminist",
    "feminize",
    "femur",
    "fence",
    "fencing",
    "fender",
    "ferment",
    "fernlike",
    "ferocious",
    "ferocity",
    "ferret",
    "ferris",
    "ferry",
    "fervor",
    "fester",
    "festival",
    "festive",
    "festivity",
    "fetal",
    "fetch",
    "fever",
    "fiber",
    "fiction",
    "fiddle",
    "fiddling",
    "fidelity",
    "fidgeting",
    "fidgety",
    "fifteen",
    "fifth",
    "fiftieth",
    "fifty",
    "figment",
    "figure",
    "figurine",
    "filing",
    "filled",
    "filler",
    "filling",
    "film",
    "filter",
    "filth",
    "filtrate",
    "finale",
    "finalist",
    "finalize",
    "finally",
    "finance",
    "financial",
    "finch",
    "fineness",
    "finer",
    "finicky",
    "finished",
    "finisher",
    "finishing",
    "finite",
    "finless",
    "finlike",
    "fiscally",
    "fit",
    "five",
    "flaccid",
    "flagman",
    "flagpole",
    "flagship",
    "flagstick",
    "flagstone",
    "flail",
    "flakily",
    "flaky",
    "flame",
    "flammable",
    "flanked",
    "flanking",
    "flannels",
    "flap",
    "flaring",
    "flashback",
    "flashbulb",
    "flashcard",
    "flashily",
    "flashing",
    "flashy",
    "flask",
    "flatbed",
    "flatfoot",
    "flatly",
    "flatness",
    "flatten",
    "flattered",
    "flatterer",
    "flattery",
    "flattop",
    "flatware",
    "flatworm",
    "flavored",
    "flavorful",
    "flavoring",
    "flaxseed",
    "fled",
    "fleshed",
    "fleshy",
    "flick",
    "flier",
    "flight",
    "flinch",
    "fling",
    "flint",
    "flip",
    "flirt",
    "float",
    "flock",
    "flogging",
    "flop",
    "floral",
    "florist",
    "floss",
    "flounder",
    "flyable",
    "flyaway",
    "flyer",
    "flying",
    "flyover",
    "flypaper",
    "foam",
    "foe",
    "fog",
    "foil",
    "folic",
    "folk",
    "follicle",
    "follow",
    "fondling",
    "fondly",
    "fondness",
    "fondue",
    "font",
    "food",
    "fool",
    "footage",
    "football",
    "footbath",
    "footboard",
    "footer",
    "footgear",
    "foothill",
    "foothold",
    "footing",
    "footless",
    "footman",
    "footnote",
    "footpad",
    "footpath",
    "footprint",
    "footrest",
    "footsie",
    "footsore",
    "footwear",
    "footwork",
    "fossil",
    "foster",
    "founder",
    "founding",
    "fountain",
    "fox",
    "foyer",
    "fraction",
    "fracture",
    "fragile",
    "fragility",
    "fragment",
    "fragrance",
    "fragrant",
    "frail",
    "frame",
    "framing",
    "frantic",
    "fraternal",
    "frayed",
    "fraying",
    "frays",
    "freckled",
    "freckles",
    "freebase",
    "freebee",
    "freebie",
    "freedom",
    "freefall",
    "freehand",
    "freeing",
    "freeload",
    "freely",
    "freemason",
    "freeness",
    "freestyle",
    "freeware",
    "freeway",
    "freewill",
    "freezable",
    "freezing",
    "freight",
    "french",
    "frenzied",
    "frenzy",
    "frequency",
    "frequent",
    "fresh",
    "fretful",
    "fretted",
    "friction",
    "friday",
    "fridge",
    "fried",
    "friend",
    "frighten",
    "frightful",
    "frigidity",
    "frigidly",
    "frill",
    "fringe",
    "frisbee",
    "frisk",
    "fritter",
    "frivolous",
    "frolic",
    "from",
    "front",
    "frostbite",
    "frosted",
    "frostily",
    "frosting",
    "frostlike",
    "frosty",
    "froth",
    "frown",
    "frozen",
    "fructose",
    "frugality",
    "frugally",
    "fruit",
    "frustrate",
    "frying",
    "gab",
    "gaffe",
    "gag",
    "gainfully",
    "gaining",
    "gains",
    "gala",
    "gallantly",
    "galleria",
    "gallery",
    "galley",
    "gallon",
    "gallows",
    "gallstone",
    "galore",
    "galvanize",
    "gambling",
    "game",
    "gaming",
    "gamma",
    "gander",
    "gangly",
    "gangrene",
    "gangway",
    "gap",
    "garage",
    "garbage",
    "garden",
    "gargle",
    "garland",
    "garlic",
    "garment",
    "garnet",
    "garnish",
    "garter",
    "gas",
    "gatherer",
    "gathering",
    "gating",
    "gauging",
    "gauntlet",
    "gauze",
    "gave",
    "gawk",
    "gazing",
    "gear",
    "gecko",
    "geek",
    "geiger",
    "gem",
    "gender",
    "generic",
    "generous",
    "genetics",
    "genre",
    "gentile",
    "gentleman",
    "gently",
    "gents",
    "geography",
    "geologic",
    "geologist",
    "geology",
    "geometric",
    "geometry",
    "geranium",
    "gerbil",
    "geriatric",
    "germicide",
    "germinate",
    "germless",
    "germproof",
    "gestate",
    "gestation",
    "gesture",
    "getaway",
    "getting",
    "getup",
    "giant",
    "gibberish",
    "giblet",
    "giddily",
    "giddiness",
    "giddy",
    "gift",
    "gigabyte",
    "gigahertz",
    "gigantic",
    "giggle",
    "giggling",
    "giggly",
    "gigolo",
    "gilled",
    "gills",
    "gimmick",
    "girdle",
    "giveaway",
    "given",
    "giver",
    "giving",
    "gizmo",
    "gizzard",
    "glacial",
    "glacier",
    "glade",
    "gladiator",
    "gladly",
    "glamorous",
    "glamour",
    "glance",
    "glancing",
    "glandular",
    "glare",
    "glaring",
    "glass",
    "glaucoma",
    "glazing",
    "gleaming",
    "gleeful",
    "glider",
    "gliding",
    "glimmer",
    "glimpse",
    "glisten",
    "glitch",
    "glitter",
    "glitzy",
    "gloater",
    "gloating",
    "gloomily",
    "gloomy",
    "glorified",
    "glorifier",
    "glorify",
    "glorious",
    "glory",
    "gloss",
    "glove",
    "glowing",
    "glowworm",
    "glucose",
    "glue",
    "gluten",
    "glutinous",
    "glutton",
    "gnarly",
    "gnat",
    "goal",
    "goatskin",
    "goes",
    "goggles",
    "going",
    "goldfish",
    "goldmine",
    "goldsmith",
    "golf",
    "goliath",
    "gonad",
    "gondola",
    "gone",
    "gong",
    "good",
    "gooey",
    "goofball",
    "goofiness",
    "goofy",
    "google",
    "goon",
    "gopher",
    "gore",
    "gorged",
    "gorgeous",
    "gory",
    "gosling",
    "gossip",
    "gothic",
    "gotten",
    "gout",
    "gown",
    "grab",
    "graceful",
    "graceless",
    "gracious",
    "gradation",
    "graded",
    "grader",
    "gradient",
    "grading",
    "gradually",
    "graduate",
    "graffiti",
    "grafted",
    "grafting",
    "grain",
    "granddad",
    "grandkid",
    "grandly",
    "grandma",
    "grandpa",
    "grandson",
    "granite",
    "granny",
    "granola",
    "grant",
    "granular",
    "grape",
    "graph",
    "grapple",
    "grappling",
    "grasp",
    "grass",
    "gratified",
    "gratify",
    "grating",
    "gratitude",
    "gratuity",
    "gravel",
    "graveness",
    "graves",
    "graveyard",
    "gravitate",
    "gravity",
    "gravy",
    "gray",
    "grazing",
    "greasily",
    "greedily",
    "greedless",
    "greedy",
    "green",
    "greeter",
    "greeting",
    "grew",
    "greyhound",
    "grid",
    "grief",
    "grievance",
    "grieving",
    "grievous",
    "grill",
    "grimace",
    "grimacing",
    "grime",
    "griminess",
    "grimy",
    "grinch",
    "grinning",
    "grip",
    "gristle",
    "grit",
    "groggily",
    "groggy",
    "groin",
    "groom",
    "groove",
    "grooving",
    "groovy",
    "grope",
    "ground",
    "grouped",
    "grout",
    "grove",
    "grower",
    "growing",
    "growl",
    "grub",
    "grudge",
    "grudging",
    "grueling",
    "gruffly",
    "grumble",
    "grumbling",
    "grumbly",
    "grumpily",
    "grunge",
    "grunt",
    "guacamole",
    "guidable",
    "guidance",
    "guide",
    "guiding",
    "guileless",
    "guise",
    "gulf",
    "gullible",
    "gully",
    "gulp",
    "gumball",
    "gumdrop",
    "gumminess",
    "gumming",
    "gummy",
    "gurgle",
    "gurgling",
    "guru",
    "gush",
    "gusto",
    "gusty",
    "gutless",
    "guts",
    "gutter",
    "guy",
    "guzzler",
    "gyration",
    "habitable",
    "habitant",
    "habitat",
    "habitual",
    "hacked",
    "hacker",
    "hacking",
    "hacksaw",
    "had",
    "haggler",
    "haiku",
    "half",
    "halogen",
    "halt",
    "halved",
    "halves",
    "hamburger",
    "hamlet",
    "hammock",
    "hamper",
    "hamster",
    "hamstring",
    "handbag",
    "handball",
    "handbook",
    "handbrake",
    "handcart",
    "handclap",
    "handclasp",
    "handcraft",
    "handcuff",
    "handed",
    "handful",
    "handgrip",
    "handgun",
    "handheld",
    "handiness",
    "handiwork",
    "handlebar",
    "handled",
    "handler",
    "handling",
    "handmade",
    "handoff",
    "handpick",
    "handprint",
    "handrail",
    "handsaw",
    "handset",
    "handsfree",
    "handshake",
    "handstand",
    "handwash",
    "handwork",
    "handwoven",
    "handwrite",
    "handyman",
    "hangnail",
    "hangout",
    "hangover",
    "hangup",
    "hankering",
    "hankie",
    "hanky",
    "haphazard",
    "happening",
    "happier",
    "happiest",
    "happily",
    "happiness",
    "happy",
    "harbor",
    "hardcopy",
    "hardcore",
    "hardcover",
    "harddisk",
    "hardened",
    "hardener",
    "hardening",
    "hardhat",
    "hardhead",
    "hardiness",
    "hardly",
    "hardness",
    "hardship",
    "hardware",
    "hardwired",
    "hardwood",
    "hardy",
    "harmful",
    "harmless",
    "harmonica",
    "harmonics",
    "harmonize",
    "harmony",
    "harness",
    "harpist",
    "harsh",
    "harvest",
    "hash",
    "hassle",
    "haste",
    "hastily",
    "hastiness",
    "hasty",
    "hatbox",
    "hatchback",
    "hatchery",
    "hatchet",
    "hatching",
    "hatchling",
    "hate",
    "hatless",
    "hatred",
    "haunt",
    "haven",
    "hazard",
    "hazelnut",
    "hazily",
    "haziness",
    "hazing",
    "hazy",
    "headache",
    "headband",
    "headboard",
    "headcount",
    "headdress",
    "headed",
    "header",
    "headfirst",
    "headgear",
    "heading",
    "headlamp",
    "headless",
    "headlock",
    "headphone",
    "headpiece",
    "headrest",
    "headroom",
    "headscarf",
    "headset",
    "headsman",
    "headstand",
    "headstone",
    "headway",
    "headwear",
    "heap",
    "heat",
    "heave",
    "heavily",
    "heaviness",
    "heaving",
    "hedge",
    "hedging",
    "heftiness",
    "hefty",
    "helium",
    "helmet",
    "helper",
    "helpful",
    "helping",
    "helpless",
    "helpline",
    "hemlock",
    "hemstitch",
    "hence",
    "henchman",
    "henna",
    "herald",
    "herbal",
    "herbicide",
    "herbs",
    "heritage",
    "hermit",
    "heroics",
    "heroism",
    "herring",
    "herself",
    "hertz",
    "hesitancy",
    "hesitant",
    "hesitate",
    "hexagon",
    "hexagram",
    "hubcap",
    "huddle",
    "huddling",
    "huff",
    "hug",
    "hula",
    "hulk",
    "hull",
    "human",
    "humble",
    "humbling",
    "humbly",
    "humid",
    "humiliate",
    "humility",
    "humming",
    "hummus",
    "humongous",
    "humorist",
    "humorless",
    "humorous",
    "humpback",
    "humped",
    "humvee",
    "hunchback",
    "hundredth",
    "hunger",
    "hungrily",
    "hungry",
    "hunk",
    "hunter",
    "hunting",
    "huntress",
    "huntsman",
    "hurdle",
    "hurled",
    "hurler",
    "hurling",
    "hurray",
    "hurricane",
    "hurried",
    "hurry",
    "hurt",
    "husband",
    "hush",
    "husked",
    "huskiness",
    "hut",
    "hybrid",
    "hydrant",
    "hydrated",
    "hydration",
    "hydrogen",
    "hydroxide",
    "hyperlink",
    "hypertext",
    "hyphen",
    "hypnoses",
    "hypnosis",
    "hypnotic",
    "hypnotism",
    "hypnotist",
    "hypnotize",
    "hypocrisy",
    "hypocrite",
    "ibuprofen",
    "ice",
    "iciness",
    "icing",
    "icky",
    "icon",
    "icy",
    "idealism",
    "idealist",
    "idealize",
    "ideally",
    "idealness",
    "identical",
    "identify",
    "identity",
    "ideology",
    "idiocy",
    "idiom",
    "idly",
    "igloo",
    "ignition",
    "ignore",
    "iguana",
    "illicitly",
    "illusion",
    "illusive",
    "image",
    "imaginary",
    "imagines",
    "imaging",
    "imbecile",
    "imitate",
    "imitation",
    "immature",
    "immerse",
    "immersion",
    "imminent",
    "immobile",
    "immodest",
    "immorally",
    "immortal",
    "immovable",
    "immovably",
    "immunity",
    "immunize",
    "impaired",
    "impale",
    "impart",
    "impatient",
    "impeach",
    "impeding",
    "impending",
    "imperfect",
    "imperial",
    "impish",
    "implant",
    "implement",
    "implicate",
    "implicit",
    "implode",
    "implosion",
    "implosive",
    "imply",
    "impolite",
    "important",
    "importer",
    "impose",
    "imposing",
    "impotence",
    "impotency",
    "impotent",
    "impound",
    "imprecise",
    "imprint",
    "imprison",
    "impromptu",
    "improper",
    "improve",
    "improving",
    "improvise",
    "imprudent",
    "impulse",
    "impulsive",
    "impure",
    "impurity",
    "iodine",
    "iodize",
    "ion",
    "ipad",
    "iphone",
    "ipod",
    "irate",
    "irk",
    "iron",
    "irregular",
    "irrigate",
    "irritable",
    "irritably",
    "irritant",
    "irritate",
    "islamic",
    "islamist",
    "isolated",
    "isolating",
    "isolation",
    "isotope",
    "issue",
    "issuing",
    "italicize",
    "italics",
    "item",
    "itinerary",
    "itunes",
    "ivory",
    "ivy",
    "jab",
    "jackal",
    "jacket",
    "jackknife",
    "jackpot",
    "jailbird",
    "jailbreak",
    "jailer",
    "jailhouse",
    "jalapeno",
    "jam",
    "janitor",
    "january",
    "jargon",
    "jarring",
    "jasmine",
    "jaundice",
    "jaunt",
    "java",
    "jawed",
    "jawless",
    "jawline",
    "jaws",
    "jaybird",
    "jaywalker",
    "jazz",
    "jeep",
    "jeeringly",
    "jellied",
    "jelly",
    "jersey",
    "jester",
    "jet",
    "jiffy",
    "jigsaw",
    "jimmy",
    "jingle",
    "jingling",
    "jinx",
    "jitters",
    "jittery",
    "job",
    "jockey",
    "jockstrap",
    "jogger",
    "jogging",
    "john",
    "joining",
    "jokester",
    "jokingly",
    "jolliness",
    "jolly",
    "jolt",
    "jot",
    "jovial",
    "joyfully",
    "joylessly",
    "joyous",
    "joyride",
    "joystick",
    "jubilance",
    "jubilant",
    "judge",
    "judgingly",
    "judicial",
    "judiciary",
    "judo",
    "juggle",
    "juggling",
    "jugular",
    "juice",
    "juiciness",
    "juicy",
    "jujitsu",
    "jukebox",
    "july",
    "jumble",
    "jumbo",
    "jump",
    "junction",
    "juncture",
    "june",
    "junior",
    "juniper",
    "junkie",
    "junkman",
    "junkyard",
    "jurist",
    "juror",
    "jury",
    "justice",
    "justifier",
    "justify",
    "justly",
    "justness",
    "juvenile",
    "kabob",
    "kangaroo",
    "karaoke",
    "karate",
    "karma",
    "kebab",
    "keenly",
    "keenness",
    "keep",
    "keg",
    "kelp",
    "kennel",
    "kept",
    "kerchief",
    "kerosene",
    "kettle",
    "kick",
    "kiln",
    "kilobyte",
    "kilogram",
    "kilometer",
    "kilowatt",
    "kilt",
    "kimono",
    "kindle",
    "kindling",
    "kindly",
    "kindness",
    "kindred",
    "kinetic",
    "kinfolk",
    "king",
    "kinship",
    "kinsman",
    "kinswoman",
    "kissable",
    "kisser",
    "kissing",
    "kitchen",
    "kite",
    "kitten",
    "kitty",
    "kiwi",
    "kleenex",
    "knapsack",
    "knee",
    "knelt",
    "knickers",
    "knoll",
    "koala",
    "kooky",
    "kosher",
    "krypton",
    "kudos",
    "kung",
    "labored",
    "laborer",
    "laboring",
    "laborious",
    "labrador",
    "ladder",
    "ladies",
    "ladle",
    "ladybug",
    "ladylike",
    "lagged",
    "lagging",
    "lagoon",
    "lair",
    "lake",
    "lance",
    "landed",
    "landfall",
    "landfill",
    "landing",
    "landlady",
    "landless",
    "landline",
    "landlord",
    "landmark",
    "landmass",
    "landmine",
    "landowner",
    "landscape",
    "landside",
    "landslide",
    "language",
    "lankiness",
    "lanky",
    "lantern",
    "lapdog",
    "lapel",
    "lapped",
    "lapping",
    "laptop",
    "lard",
    "large",
    "lark",
    "lash",
    "lasso",
    "last",
    "latch",
    "late",
    "lather",
    "latitude",
    "latrine",
    "latter",
    "latticed",
    "launch",
    "launder",
    "laundry",
    "laurel",
    "lavender",
    "lavish",
    "laxative",
    "lazily",
    "laziness",
    "lazy",
    "lecturer",
    "left",
    "legacy",
    "legal",
    "legend",
    "legged",
    "leggings",
    "legible",
    "legibly",
    "legislate",
    "lego",
    "legroom",
    "legume",
    "legwarmer",
    "legwork",
    "lemon",
    "lend",
    "length",
    "lens",
    "lent",
    "leotard",
    "lesser",
    "letdown",
    "lethargic",
    "lethargy",
    "letter",
    "lettuce",
    "level",
    "leverage",
    "levers",
    "levitate",
    "levitator",
    "liability",
    "liable",
    "liberty",
    "librarian",
    "library",
    "licking",
    "licorice",
    "lid",
    "life",
    "lifter",
    "lifting",
    "liftoff",
    "ligament",
    "likely",
    "likeness",
    "likewise",
    "liking",
    "lilac",
    "lilly",
    "lily",
    "limb",
    "limeade",
    "limelight",
    "limes",
    "limit",
    "limping",
    "limpness",
    "line",
    "lingo",
    "linguini",
    "linguist",
    "lining",
    "linked",
    "linoleum",
    "linseed",
    "lint",
    "lion",
    "lip",
    "liquefy",
    "liqueur",
    "liquid",
    "lisp",
    "list",
    "litigate",
    "litigator",
    "litmus",
    "litter",
    "little",
    "livable",
    "lived",
    "lively",
    "liver",
    "livestock",
    "lividly",
    "living",
    "lizard",
    "lubricant",
    "lubricate",
    "lucid",
    "luckily",
    "luckiness",
    "luckless",
    "lucrative",
    "ludicrous",
    "lugged",
    "lukewarm",
    "lullaby",
    "lumber",
    "luminance",
    "luminous",
    "lumpiness",
    "lumping",
    "lumpish",
    "lunacy",
    "lunar",
    "lunchbox",
    "luncheon",
    "lunchroom",
    "lunchtime",
    "lung",
    "lurch",
    "lure",
    "luridness",
    "lurk",
    "lushly",
    "lushness",
    "luster",
    "lustfully",
    "lustily",
    "lustiness",
    "lustrous",
    "lusty",
    "luxurious",
    "luxury",
    "lying",
    "lyrically",
    "lyricism",
    "lyricist",
    "lyrics",
    "macarena",
    "macaroni",
    "macaw",
    "mace",
    "machine",
    "machinist",
    "magazine",
    "magenta",
    "maggot",
    "magical",
    "magician",
    "magma",
    "magnesium",
    "magnetic",
    "magnetism",
    "magnetize",
    "magnifier",
    "magnify",
    "magnitude",
    "magnolia",
    "mahogany",
    "maimed",
    "majestic",
    "majesty",
    "majorette",
    "majority",
    "makeover",
    "maker",
    "makeshift",
    "making",
    "malformed",
    "malt",
    "mama",
    "mammal",
    "mammary",
    "mammogram",
    "manager",
    "managing",
    "manatee",
    "mandarin",
    "mandate",
    "mandatory",
    "mandolin",
    "manger",
    "mangle",
    "mango",
    "mangy",
    "manhandle",
    "manhole",
    "manhood",
    "manhunt",
    "manicotti",
    "manicure",
    "manifesto",
    "manila",
    "mankind",
    "manlike",
    "manliness",
    "manly",
    "manmade",
    "manned",
    "mannish",
    "manor",
    "manpower",
    "mantis",
    "mantra",
    "manual",
    "many",
    "map",
    "marathon",
    "marauding",
    "marbled",
    "marbles",
    "marbling",
    "march",
    "mardi",
    "margarine",
    "margarita",
    "margin",
    "marigold",
    "marina",
    "marine",
    "marital",
    "maritime",
    "marlin",
    "marmalade",
    "maroon",
    "married",
    "marrow",
    "marry",
    "marshland",
    "marshy",
    "marsupial",
    "marvelous",
    "marxism",
    "mascot",
    "masculine",
    "mashed",
    "mashing",
    "massager",
    "masses",
    "massive",
    "mastiff",
    "matador",
    "matchbook",
    "matchbox",
    "matcher",
    "matching",
    "matchless",
    "material",
    "maternal",
    "maternity",
    "math",
    "mating",
    "matriarch",
    "matrimony",
    "matrix",
    "matron",
    "matted",
    "matter",
    "maturely",
    "maturing",
    "maturity",
    "mauve",
    "maverick",
    "maximize",
    "maximum",
    "maybe",
    "mayday",
    "mayflower",
    "moaner",
    "moaning",
    "mobile",
    "mobility",
    "mobilize",
    "mobster",
    "mocha",
    "mocker",
    "mockup",
    "modified",
    "modify",
    "modular",
    "modulator",
    "module",
    "moisten",
    "moistness",
    "moisture",
    "molar",
    "molasses",
    "mold",
    "molecular",
    "molecule",
    "molehill",
    "mollusk",
    "mom",
    "monastery",
    "monday",
    "monetary",
    "monetize",
    "moneybags",
    "moneyless",
    "moneywise",
    "mongoose",
    "mongrel",
    "monitor",
    "monkhood",
    "monogamy",
    "monogram",
    "monologue",
    "monopoly",
    "monorail",
    "monotone",
    "monotype",
    "monoxide",
    "monsieur",
    "monsoon",
    "monstrous",
    "monthly",
    "monument",
    "moocher",
    "moodiness",
    "moody",
    "mooing",
    "moonbeam",
    "mooned",
    "moonlight",
    "moonlike",
    "moonlit",
    "moonrise",
    "moonscape",
    "moonshine",
    "moonstone",
    "moonwalk",
    "mop",
    "morale",
    "morality",
    "morally",
    "morbidity",
    "morbidly",
    "morphine",
    "morphing",
    "morse",
    "mortality",
    "mortally",
    "mortician",
    "mortified",
    "mortify",
    "mortuary",
    "mosaic",
    "mossy",
    "most",
    "mothball",
    "mothproof",
    "motion",
    "motivate",
    "motivator",
    "motive",
    "motocross",
    "motor",
    "motto",
    "mountable",
    "mountain",
    "mounted",
    "mounting",
    "mourner",
    "mournful",
    "mouse",
    "mousiness",
    "moustache",
    "mousy",
    "mouth",
    "movable",
    "move",
    "movie",
    "moving",
    "mower",
    "mowing",
    "much",
    "muck",
    "mud",
    "mug",
    "mulberry",
    "mulch",
    "mule",
    "mulled",
    "mullets",
    "multiple",
    "multiply",
    "multitask",
    "multitude",
    "mumble",
    "mumbling",
    "mumbo",
    "mummified",
    "mummify",
    "mummy",
    "mumps",
    "munchkin",
    "mundane",
    "municipal",
    "muppet",
    "mural",
    "murkiness",
    "murky",
    "murmuring",
    "muscular",
    "museum",
    "mushily",
    "mushiness",
    "mushroom",
    "mushy",
    "music",
    "musket",
    "muskiness",
    "musky",
    "mustang",
    "mustard",
    "muster",
    "mustiness",
    "musty",
    "mutable",
    "mutate",
    "mutation",
    "mute",
    "mutilated",
    "mutilator",
    "mutiny",
    "mutt",
    "mutual",
    "muzzle",
    "myself",
    "myspace",
    "mystified",
    "mystify",
    "myth",
    "nacho",
    "nag",
    "nail",
    "name",
    "naming",
    "nanny",
    "nanometer",
    "nape",
    "napkin",
    "napped",
    "napping",
    "nappy",
    "narrow",
    "nastily",
    "nastiness",
    "national",
    "native",
    "nativity",
    "natural",
    "nature",
    "naturist",
    "nautical",
    "navigate",
    "navigator",
    "navy",
    "nearby",
    "nearest",
    "nearly",
    "nearness",
    "neatly",
    "neatness",
    "nebula",
    "nebulizer",
    "nectar",
    "negate",
    "negation",
    "negative",
    "neglector",
    "negligee",
    "negligent",
    "negotiate",
    "nemeses",
    "nemesis",
    "neon",
    "nephew",
    "nerd",
    "nervous",
    "nervy",
    "nest",
    "net",
    "neurology",
    "neuron",
    "neurosis",
    "neurotic",
    "neuter",
    "neutron",
    "never",
    "next",
    "nibble",
    "nickname",
    "nicotine",
    "niece",
    "nifty",
    "nimble",
    "nimbly",
    "nineteen",
    "ninetieth",
    "ninja",
    "nintendo",
    "ninth",
    "nuclear",
    "nuclei",
    "nucleus",
    "nugget",
    "nullify",
    "number",
    "numbing",
    "numbly",
    "numbness",
    "numeral",
    "numerate",
    "numerator",
    "numeric",
    "numerous",
    "nuptials",
    "nursery",
    "nursing",
    "nurture",
    "nutcase",
    "nutlike",
    "nutmeg",
    "nutrient",
    "nutshell",
    "nuttiness",
    "nutty",
    "nuzzle",
    "nylon",
    "oaf",
    "oak",
    "oasis",
    "oat",
    "obedience",
    "obedient",
    "obituary",
    "object",
    "obligate",
    "obliged",
    "oblivion",
    "oblivious",
    "oblong",
    "obnoxious",
    "oboe",
    "obscure",
    "obscurity",
    "observant",
    "observer",
    "observing",
    "obsessed",
    "obsession",
    "obsessive",
    "obsolete",
    "obstacle",
    "obstinate",
    "obstruct",
    "obtain",
    "obtrusive",
    "obtuse",
    "obvious",
    "occultist",
    "occupancy",
    "occupant",
    "occupier",
    "occupy",
    "ocean",
    "ocelot",
    "octagon",
    "octane",
    "october",
    "octopus",
    "ogle",
    "oil",
    "oink",
    "ointment",
    "okay",
    "old",
    "olive",
    "olympics",
    "omega",
    "omen",
    "ominous",
    "omission",
    "omit",
    "omnivore",
    "onboard",
    "oncoming",
    "ongoing",
    "onion",
    "online",
    "onlooker",
    "only",
    "onscreen",
    "onset",
    "onshore",
    "onslaught",
    "onstage",
    "onto",
    "onward",
    "onyx",
    "oops",
    "ooze",
    "oozy",
    "opacity",
    "opal",
    "open",
    "operable",
    "operate",
    "operating",
    "operation",
    "operative",
    "operator",
    "opium",
    "opossum",
    "opponent",
    "oppose",
    "opposing",
    "opposite",
    "oppressed",
    "oppressor",
    "opt",
    "opulently",
    "osmosis",
    "other",
    "otter",
    "ouch",
    "ought",
    "ounce",
    "outage",
    "outback",
    "outbid",
    "outboard",
    "outbound",
    "outbreak",
    "outburst",
    "outcast",
    "outclass",
    "outcome",
    "outdated",
    "outdoors",
    "outer",
    "outfield",
    "outfit",
    "outflank",
    "outgoing",
    "outgrow",
    "outhouse",
    "outing",
    "outlast",
    "outlet",
    "outline",
    "outlook",
    "outlying",
    "outmatch",
    "outmost",
    "outnumber",
    "outplayed",
    "outpost",
    "outpour",
    "output",
    "outrage",
    "outrank",
    "outreach",
    "outright",
    "outscore",
    "outsell",
    "outshine",
    "outshoot",
    "outsider",
    "outskirts",
    "outsmart",
    "outsource",
    "outspoken",
    "outtakes",
    "outthink",
    "outward",
    "outweigh",
    "outwit",
    "oval",
    "ovary",
    "oven",
    "overact",
    "overall",
    "overarch",
    "overbid",
    "overbill",
    "overbite",
    "overblown",
    "overboard",
    "overbook",
    "overbuilt",
    "overcast",
    "overcoat",
    "overcome",
    "overcook",
    "overcrowd",
    "overdraft",
    "overdrawn",
    "overdress",
    "overdrive",
    "overdue",
    "overeager",
    "overeater",
    "overexert",
    "overfed",
    "overfeed",
    "overfill",
    "overflow",
    "overfull",
    "overgrown",
    "overhand",
    "overhang",
    "overhaul",
    "overhead",
    "overhear",
    "overheat",
    "overhung",
    "overjoyed",
    "overkill",
    "overlabor",
    "overlaid",
    "overlap",
    "overlay",
    "overload",
    "overlook",
    "overlord",
    "overlying",
    "overnight",
    "overpass",
    "overpay",
    "overplant",
    "overplay",
    "overpower",
    "overprice",
    "overrate",
    "overreach",
    "overreact",
    "override",
    "overripe",
    "overrule",
    "overrun",
    "overshoot",
    "overshot",
    "oversight",
    "oversized",
    "oversleep",
    "oversold",
    "overspend",
    "overstate",
    "overstay",
    "overstep",
    "overstock",
    "overstuff",
    "oversweet",
    "overtake",
    "overthrow",
    "overtime",
    "overtly",
    "overtone",
    "overture",
    "overturn",
    "overuse",
    "overvalue",
    "overview",
    "overwrite",
    "owl",
    "oxford",
    "oxidant",
    "oxidation",
    "oxidize",
    "oxidizing",
    "oxygen",
    "oxymoron",
    "oyster",
    "ozone",
    "paced",
    "pacemaker",
    "pacific",
    "pacifier",
    "pacifism",
    "pacifist",
    "pacify",
    "padded",
    "padding",
    "paddle",
    "paddling",
    "padlock",
    "pagan",
    "pager",
    "paging",
    "pajamas",
    "palace",
    "palatable",
    "palm",
    "palpable",
    "palpitate",
    "paltry",
    "pampered",
    "pamperer",
    "pampers",
    "pamphlet",
    "panama",
    "pancake",
    "pancreas",
    "panda",
    "pandemic",
    "pang",
    "panhandle",
    "panic",
    "panning",
    "panorama",
    "panoramic",
    "panther",
    "pantomime",
    "pantry",
    "pants",
    "pantyhose",
    "paparazzi",
    "papaya",
    "paper",
    "paprika",
    "papyrus",
    "parabola",
    "parachute",
    "parade",
    "paradox",
    "paragraph",
    "parakeet",
    "paralegal",
    "paralyses",
    "paralysis",
    "paralyze",
    "paramedic",
    "parameter",
    "paramount",
    "parasail",
    "parasite",
    "parasitic",
    "parcel",
    "parched",
    "parchment",
    "pardon",
    "parish",
    "parka",
    "parking",
    "parkway",
    "parlor",
    "parmesan",
    "parole",
    "parrot",
    "parsley",
    "parsnip",
    "partake",
    "parted",
    "parting",
    "partition",
    "partly",
    "partner",
    "partridge",
    "party",
    "passable",
    "passably",
    "passage",
    "passcode",
    "passenger",
    "passerby",
    "passing",
    "passion",
    "passive",
    "passivism",
    "passover",
    "passport",
    "password",
    "pasta",
    "pasted",
    "pastel",
    "pastime",
    "pastor",
    "pastrami",
    "pasture",
    "pasty",
    "patchwork",
    "patchy",
    "paternal",
    "paternity",
    "path",
    "patience",
    "patient",
    "patio",
    "patriarch",
    "patriot",
    "patrol",
    "patronage",
    "patronize",
    "pauper",
    "pavement",
    "paver",
    "pavestone",
    "pavilion",
    "paving",
    "pawing",
    "payable",
    "payback",
    "paycheck",
    "payday",
    "payee",
    "payer",
    "paying",
    "payment",
    "payphone",
    "payroll",
    "pebble",
    "pebbly",
    "pecan",
    "pectin",
    "peculiar",
    "peddling",
    "pediatric",
    "pedicure",
    "pedigree",
    "pedometer",
    "pegboard",
    "pelican",
    "pellet",
    "pelt",
    "pelvis",
    "penalize",
    "penalty",
    "pencil",
    "pendant",
    "pending",
    "penholder",
    "penknife",
    "pennant",
    "penniless",
    "penny",
    "penpal",
    "pension",
    "pentagon",
    "pentagram",
    "pep",
    "perceive",
    "percent",
    "perch",
    "percolate",
    "perennial",
    "perfected",
    "perfectly",
    "perfume",
    "periscope",
    "perish",
    "perjurer",
    "perjury",
    "perkiness",
    "perky",
    "perm",
    "peroxide",
    "perpetual",
    "perplexed",
    "persecute",
    "persevere",
    "persuaded",
    "persuader",
    "pesky",
    "peso",
    "pessimism",
    "pessimist",
    "pester",
    "pesticide",
    "petal",
    "petite",
    "petition",
    "petri",
    "petroleum",
    "petted",
    "petticoat",
    "pettiness",
    "petty",
    "petunia",
    "phantom",
    "phobia",
    "phoenix",
    "phonebook",
    "phoney",
    "phonics",
    "phoniness",
    "phony",
    "phosphate",
    "photo",
    "phrase",
    "phrasing",
    "placard",
    "placate",
    "placidly",
    "plank",
    "planner",
    "plant",
    "plasma",
    "plaster",
    "plastic",
    "plated",
    "platform",
    "plating",
    "platinum",
    "platonic",
    "platter",
    "platypus",
    "plausible",
    "plausibly",
    "playable",
    "playback",
    "player",
    "playful",
    "playgroup",
    "playhouse",
    "playing",
    "playlist",
    "playmaker",
    "playmate",
    "playoff",
    "playpen",
    "playroom",
    "playset",
    "plaything",
    "playtime",
    "plaza",
    "pleading",
    "pleat",
    "pledge",
    "plentiful",
    "plenty",
    "plethora",
    "plexiglas",
    "pliable",
    "plod",
    "plop",
    "plot",
    "plow",
    "ploy",
    "pluck",
    "plug",
    "plunder",
    "plunging",
    "plural",
    "plus",
    "plutonium",
    "plywood",
    "poach",
    "pod",
    "poem",
    "poet",
    "pogo",
    "pointed",
    "pointer",
    "pointing",
    "pointless",
    "pointy",
    "poise",
    "poison",
    "poker",
    "poking",
    "polar",
    "police",
    "policy",
    "polio",
    "polish",
    "politely",
    "polka",
    "polo",
    "polyester",
    "polygon",
    "polygraph",
    "polymer",
    "poncho",
    "pond",
    "pony",
    "popcorn",
    "pope",
    "poplar",
    "popper",
    "poppy",
    "popsicle",
    "populace",
    "popular",
    "populate",
    "porcupine",
    "pork",
    "porous",
    "porridge",
    "portable",
    "portal",
    "portfolio",
    "porthole",
    "portion",
    "portly",
    "portside",
    "poser",
    "posh",
    "posing",
    "possible",
    "possibly",
    "possum",
    "postage",
    "postal",
    "postbox",
    "postcard",
    "posted",
    "poster",
    "posting",
    "postnasal",
    "posture",
    "postwar",
    "pouch",
    "pounce",
    "pouncing",
    "pound",
    "pouring",
    "pout",
    "powdered",
    "powdering",
    "powdery",
    "power",
    "powwow",
    "pox",
    "praising",
    "prance",
    "prancing",
    "pranker",
    "prankish",
    "prankster",
    "prayer",
    "praying",
    "preacher",
    "preaching",
    "preachy",
    "preamble",
    "precinct",
    "precise",
    "precision",
    "precook",
    "precut",
    "predator",
    "predefine",
    "predict",
    "preface",
    "prefix",
    "preflight",
    "preformed",
    "pregame",
    "pregnancy",
    "pregnant",
    "preheated",
    "prelaunch",
    "prelaw",
    "prelude",
    "premiere",
    "premises",
    "premium",
    "prenatal",
    "preoccupy",
    "preorder",
    "prepaid",
    "prepay",
    "preplan",
    "preppy",
    "preschool",
    "prescribe",
    "preseason",
    "preset",
    "preshow",
    "president",
    "presoak",
    "press",
    "presume",
    "presuming",
    "preteen",
    "pretended",
    "pretender",
    "pretense",
    "pretext",
    "pretty",
    "pretzel",
    "prevail",
    "prevalent",
    "prevent",
    "preview",
    "previous",
    "prewar",
    "prewashed",
    "prideful",
    "pried",
    "primal",
    "primarily",
    "primary",
    "primate",
    "primer",
    "primp",
    "princess",
    "print",
    "prior",
    "prism",
    "prison",
    "prissy",
    "pristine",
    "privacy",
    "private",
    "privatize",
    "prize",
    "proactive",
    "probable",
    "probably",
    "probation",
    "probe",
    "probing",
    "probiotic",
    "problem",
    "procedure",
    "process",
    "proclaim",
    "procreate",
    "procurer",
    "prodigal",
    "prodigy",
    "produce",
    "product",
    "profane",
    "profanity",
    "professed",
    "professor",
    "profile",
    "profound",
    "profusely",
    "progeny",
    "prognosis",
    "program",
    "progress",
    "projector",
    "prologue",
    "prolonged",
    "promenade",
    "prominent",
    "promoter",
    "promotion",
    "prompter",
    "promptly",
    "prone",
    "prong",
    "pronounce",
    "pronto",
    "proofing",
    "proofread",
    "proofs",
    "propeller",
    "properly",
    "property",
    "proponent",
    "proposal",
    "propose",
    "props",
    "prorate",
    "protector",
    "protegee",
    "proton",
    "prototype",
    "protozoan",
    "protract",
    "protrude",
    "proud",
    "provable",
    "proved",
    "proven",
    "provided",
    "provider",
    "providing",
    "province",
    "proving",
    "provoke",
    "provoking",
    "provolone",
    "prowess",
    "prowler",
    "prowling",
    "proximity",
    "proxy",
    "prozac",
    "prude",
    "prudishly",
    "prune",
    "pruning",
    "pry",
    "psychic",
    "public",
    "publisher",
    "pucker",
    "pueblo",
    "pug",
    "pull",
    "pulmonary",
    "pulp",
    "pulsate",
    "pulse",
    "pulverize",
    "puma",
    "pumice",
    "pummel",
    "punch",
    "punctual",
    "punctuate",
    "punctured",
    "pungent",
    "punisher",
    "punk",
    "pupil",
    "puppet",
    "puppy",
    "purchase",
    "pureblood",
    "purebred",
    "purely",
    "pureness",
    "purgatory",
    "purge",
    "purging",
    "purifier",
    "purify",
    "purist",
    "puritan",
    "purity",
    "purple",
    "purplish",
    "purposely",
    "purr",
    "purse",
    "pursuable",
    "pursuant",
    "pursuit",
    "purveyor",
    "pushcart",
    "pushchair",
    "pusher",
    "pushiness",
    "pushing",
    "pushover",
    "pushpin",
    "pushup",
    "pushy",
    "putdown",
    "putt",
    "puzzle",
    "puzzling",
    "pyramid",
    "pyromania",
    "python",
    "quack",
    "quadrant",
    "quail",
    "quaintly",
    "quake",
    "quaking",
    "qualified",
    "qualifier",
    "qualify",
    "quality",
    "qualm",
    "quantum",
    "quarrel",
    "quarry",
    "quartered",
    "quarterly",
    "quarters",
    "quartet",
    "quench",
    "query",
    "quicken",
    "quickly",
    "quickness",
    "quicksand",
    "quickstep",
    "quiet",
    "quill",
    "quilt",
    "quintet",
    "quintuple",
    "quirk",
    "quit",
    "quiver",
    "quizzical",
    "quotable",
    "quotation",
    "quote",
    "rabid",
    "race",
    "racing",
    "racism",
    "rack",
    "racoon",
    "radar",
    "radial",
    "radiance",
    "radiantly",
    "radiated",
    "radiation",
    "radiator",
    "radio",
    "radish",
    "raffle",
    "raft",
    "rage",
    "ragged",
    "raging",
    "ragweed",
    "raider",
    "railcar",
    "railing",
    "railroad",
    "railway",
    "raisin",
    "rake",
    "raking",
    "rally",
    "ramble",
    "rambling",
    "ramp",
    "ramrod",
    "ranch",
    "rancidity",
    "random",
    "ranged",
    "ranger",
    "ranging",
    "ranked",
    "ranking",
    "ransack",
    "ranting",
    "rants",
    "rare",
    "rarity",
    "rascal",
    "rash",
    "rasping",
    "ravage",
    "raven",
    "ravine",
    "raving",
    "ravioli",
    "ravishing",
    "reabsorb",
    "reach",
    "reacquire",
    "reaction",
    "reactive",
    "reactor",
    "reaffirm",
    "ream",
    "reanalyze",
    "reappear",
    "reapply",
    "reappoint",
    "reapprove",
    "rearrange",
    "rearview",
    "reason",
    "reassign",
    "reassure",
    "reattach",
    "reawake",
    "rebalance",
    "rebate",
    "rebel",
    "rebirth",
    "reboot",
    "reborn",
    "rebound",
    "rebuff",
    "rebuild",
    "rebuilt",
    "reburial",
    "rebuttal",
    "recall",
    "recant",
    "recapture",
    "recast",
    "recede",
    "recent",
    "recess",
    "recharger",
    "recipient",
    "recital",
    "recite",
    "reckless",
    "reclaim",
    "recliner",
    "reclining",
    "recluse",
    "reclusive",
    "recognize",
    "recoil",
    "recollect",
    "recolor",
    "reconcile",
    "reconfirm",
    "reconvene",
    "recopy",
    "record",
    "recount",
    "recoup",
    "recovery",
    "recreate",
    "rectal",
    "rectangle",
    "rectified",
    "rectify",
    "recycled",
    "recycler",
    "recycling",
    "reemerge",
    "reenact",
    "reenter",
    "reentry",
    "reexamine",
    "referable",
    "referee",
    "reference",
    "refill",
    "refinance",
    "refined",
    "refinery",
    "refining",
    "refinish",
    "reflected",
    "reflector",
    "reflex",
    "reflux",
    "refocus",
    "refold",
    "reforest",
    "reformat",
    "reformed",
    "reformer",
    "reformist",
    "refract",
    "refrain",
    "refreeze",
    "refresh",
    "refried",
    "refueling",
    "refund",
    "refurbish",
    "refurnish",
    "refusal",
    "refuse",
    "refusing",
    "refutable",
    "refute",
    "regain",
    "regalia",
    "regally",
    "reggae",
    "regime",
    "region",
    "register",
    "registrar",
    "registry",
    "regress",
    "regretful",
    "regroup",
    "regular",
    "regulate",
    "regulator",
    "rehab",
    "reheat",
    "rehire",
    "rehydrate",
    "reimburse",
    "reissue",
    "reiterate",
    "rejoice",
    "rejoicing",
    "rejoin",
    "rekindle",
    "relapse",
    "relapsing",
    "relatable",
    "related",
    "relation",
    "relative",
    "relax",
    "relay",
    "relearn",
    "release",
    "relenting",
    "reliable",
    "reliably",
    "reliance",
    "reliant",
    "relic",
    "relieve",
    "relieving",
    "relight",
    "relish",
    "relive",
    "reload",
    "relocate",
    "relock",
    "reluctant",
    "rely",
    "remake",
    "remark",
    "remarry",
    "rematch",
    "remedial",
    "remedy",
    "remember",
    "reminder",
    "remindful",
    "remission",
    "remix",
    "remnant",
    "remodeler",
    "remold",
    "remorse",
    "remote",
    "removable",
    "removal",
    "removed",
    "remover",
    "removing",
    "rename",
    "renderer",
    "rendering",
    "rendition",
    "renegade",
    "renewable",
    "renewably",
    "renewal",
    "renewed",
    "renounce",
    "renovate",
    "renovator",
    "rentable",
    "rental",
    "rented",
    "renter",
    "reoccupy",
    "reoccur",
    "reopen",
    "reorder",
    "repackage",
    "repacking",
    "repaint",
    "repair",
    "repave",
    "repaying",
    "repayment",
    "repeal",
    "repeated",
    "repeater",
    "repent",
    "rephrase",
    "replace",
    "replay",
    "replica",
    "reply",
    "reporter",
    "repose",
    "repossess",
    "repost",
    "repressed",
    "reprimand",
    "reprint",
    "reprise",
    "reproach",
    "reprocess",
    "reproduce",
    "reprogram",
    "reps",
    "reptile",
    "reptilian",
    "repugnant",
    "repulsion",
    "repulsive",
    "repurpose",
    "reputable",
    "reputably",
    "request",
    "require",
    "requisite",
    "reroute",
    "rerun",
    "resale",
    "resample",
    "rescuer",
    "reseal",
    "research",
    "reselect",
    "reseller",
    "resemble",
    "resend",
    "resent",
    "reset",
    "reshape",
    "reshoot",
    "reshuffle",
    "residence",
    "residency",
    "resident",
    "residual",
    "residue",
    "resigned",
    "resilient",
    "resistant",
    "resisting",
    "resize",
    "resolute",
    "resolved",
    "resonant",
    "resonate",
    "resort",
    "resource",
    "respect",
    "resubmit",
    "result",
    "resume",
    "resupply",
    "resurface",
    "resurrect",
    "retail",
    "retainer",
    "retaining",
    "retake",
    "retaliate",
    "retention",
    "rethink",
    "retinal",
    "retired",
    "retiree",
    "retiring",
    "retold",
    "retool",
    "retorted",
    "retouch",
    "retrace",
    "retract",
    "retrain",
    "retread",
    "retreat",
    "retrial",
    "retrieval",
    "retriever",
    "retry",
    "return",
    "retying",
    "retype",
    "reunion",
    "reunite",
    "reusable",
    "reuse",
    "reveal",
    "reveler",
    "revenge",
    "revenue",
    "reverb",
    "revered",
    "reverence",
    "reverend",
    "reversal",
    "reverse",
    "reversing",
    "reversion",
    "revert",
    "revisable",
    "revise",
    "revision",
    "revisit",
    "revivable",
    "revival",
    "reviver",
    "reviving",
    "revocable",
    "revoke",
    "revolt",
    "revolver",
    "revolving",
    "reward",
    "rewash",
    "rewind",
    "rewire",
    "reword",
    "rework",
    "rewrap",
    "rewrite",
    "rhyme",
    "ribbon",
    "ribcage",
    "rice",
    "riches",
    "richly",
    "richness",
    "rickety",
    "ricotta",
    "riddance",
    "ridden",
    "ride",
    "riding",
    "rifling",
    "rift",
    "rigging",
    "rigid",
    "rigor",
    "rimless",
    "rimmed",
    "rind",
    "rink",
    "rinse",
    "rinsing",
    "riot",
    "ripcord",
    "ripeness",
    "ripening",
    "ripping",
    "ripple",
    "rippling",
    "riptide",
    "rise",
    "rising",
    "risk",
    "risotto",
    "ritalin",
    "ritzy",
    "rival",
    "riverbank",
    "riverbed",
    "riverboat",
    "riverside",
    "riveter",
    "riveting",
    "roamer",
    "roaming",
    "roast",
    "robbing",
    "robe",
    "robin",
    "robotics",
    "robust",
    "rockband",
    "rocker",
    "rocket",
    "rockfish",
    "rockiness",
    "rocking",
    "rocklike",
    "rockslide",
    "rockstar",
    "rocky",
    "rogue",
    "roman",
    "romp",
    "rope",
    "roping",
    "roster",
    "rosy",
    "rotten",
    "rotting",
    "rotunda",
    "roulette",
    "rounding",
    "roundish",
    "roundness",
    "roundup",
    "roundworm",
    "routine",
    "routing",
    "rover",
    "roving",
    "royal",
    "rubbed",
    "rubber",
    "rubbing",
    "rubble",
    "rubdown",
    "ruby",
    "ruckus",
    "rudder",
    "rug",
    "ruined",
    "rule",
    "rumble",
    "rumbling",
    "rummage",
    "rumor",
    "runaround",
    "rundown",
    "runner",
    "running",
    "runny",
    "runt",
    "runway",
    "rupture",
    "rural",
    "ruse",
    "rush",
    "rust",
    "rut",
    "sabbath",
    "sabotage",
    "sacrament",
    "sacred",
    "sacrifice",
    "sadden",
    "saddlebag",
    "saddled",
    "saddling",
    "sadly",
    "sadness",
    "safari",
    "safeguard",
    "safehouse",
    "safely",
    "safeness",
    "saffron",
    "saga",
    "sage",
    "sagging",
    "saggy",
    "said",
    "saint",
    "sake",
    "salad",
    "salami",
    "salaried",
    "salary",
    "saline",
    "salon",
    "saloon",
    "salsa",
    "salt",
    "salutary",
    "salute",
    "salvage",
    "salvaging",
    "salvation",
    "same",
    "sample",
    "sampling",
    "sanction",
    "sanctity",
    "sanctuary",
    "sandal",
    "sandbag",
    "sandbank",
    "sandbar",
    "sandblast",
    "sandbox",
    "sanded",
    "sandfish",
    "sanding",
    "sandlot",
    "sandpaper",
    "sandpit",
    "sandstone",
    "sandstorm",
    "sandworm",
    "sandy",
    "sanitary",
    "sanitizer",
    "sank",
    "santa",
    "sapling",
    "sappiness",
    "sappy",
    "sarcasm",
    "sarcastic",
    "sardine",
    "sash",
    "sasquatch",
    "sassy",
    "satchel",
    "satiable",
    "satin",
    "satirical",
    "satisfied",
    "satisfy",
    "saturate",
    "saturday",
    "sauciness",
    "saucy",
    "sauna",
    "savage",
    "savanna",
    "saved",
    "savings",
    "savior",
    "savor",
    "saxophone",
    "say",
    "scabbed",
    "scabby",
    "scalded",
    "scalding",
    "scale",
    "scaling",
    "scallion",
    "scallop",
    "scalping",
    "scam",
    "scandal",
    "scanner",
    "scanning",
    "scant",
    "scapegoat",
    "scarce",
    "scarcity",
    "scarecrow",
    "scared",
    "scarf",
    "scarily",
    "scariness",
    "scarring",
    "scary",
    "scavenger",
    "scenic",
    "schedule",
    "schematic",
    "scheme",
    "scheming",
    "schilling",
    "schnapps",
    "scholar",
    "science",
    "scientist",
    "scion",
    "scoff",
    "scolding",
    "scone",
    "scoop",
    "scooter",
    "scope",
    "scorch",
    "scorebook",
    "scorecard",
    "scored",
    "scoreless",
    "scorer",
    "scoring",
    "scorn",
    "scorpion",
    "scotch",
    "scoundrel",
    "scoured",
    "scouring",
    "scouting",
    "scouts",
    "scowling",
    "scrabble",
    "scraggly",
    "scrambled",
    "scrambler",
    "scrap",
    "scratch",
    "scrawny",
    "screen",
    "scribble",
    "scribe",
    "scribing",
    "scrimmage",
    "script",
    "scroll",
    "scrooge",
    "scrounger",
    "scrubbed",
    "scrubber",
    "scruffy",
    "scrunch",
    "scrutiny",
    "scuba",
    "scuff",
    "sculptor",
    "sculpture",
    "scurvy",
    "scuttle",
    "secluded",
    "secluding",
    "seclusion",
    "second",
    "secrecy",
    "secret",
    "sectional",
    "sector",
    "secular",
    "securely",
    "security",
    "sedan",
    "sedate",
    "sedation",
    "sedative",
    "sediment",
    "seduce",
    "seducing",
    "segment",
    "seismic",
    "seizing",
    "seldom",
    "selected",
    "selection",
    "selective",
    "selector",
    "self",
    "seltzer",
    "semantic",
    "semester",
    "semicolon",
    "semifinal",
    "seminar",
    "semisoft",
    "semisweet",
    "senate",
    "senator",
    "send",
    "senior",
    "senorita",
    "sensation",
    "sensitive",
    "sensitize",
    "sensually",
    "sensuous",
    "sepia",
    "september",
    "septic",
    "septum",
    "sequel",
    "sequence",
    "sequester",
    "series",
    "sermon",
    "serotonin",
    "serpent",
    "serrated",
    "serve",
    "service",
    "serving",
    "sesame",
    "sessions",
    "setback",
    "setting",
    "settle",
    "settling",
    "setup",
    "sevenfold",
    "seventeen",
    "seventh",
    "seventy",
    "severity",
    "shabby",
    "shack",
    "shaded",
    "shadily",
    "shadiness",
    "shading",
    "shadow",
    "shady",
    "shaft",
    "shakable",
    "shakily",
    "shakiness",
    "shaking",
    "shaky",
    "shale",
    "shallot",
    "shallow",
    "shame",
    "shampoo",
    "shamrock",
    "shank",
    "shanty",
    "shape",
    "shaping",
    "share",
    "sharpener",
    "sharper",
    "sharpie",
    "sharply",
    "sharpness",
    "shawl",
    "sheath",
    "shed",
    "sheep",
    "sheet",
    "shelf",
    "shell",
    "shelter",
    "shelve",
    "shelving",
    "sherry",
    "shield",
    "shifter",
    "shifting",
    "shiftless",
    "shifty",
    "shimmer",
    "shimmy",
    "shindig",
    "shine",
    "shingle",
    "shininess",
    "shining",
    "shiny",
    "ship",
    "shirt",
    "shivering",
    "shock",
    "shone",
    "shoplift",
    "shopper",
    "shopping",
    "shoptalk",
    "shore",
    "shortage",
    "shortcake",
    "shortcut",
    "shorten",
    "shorter",
    "shorthand",
    "shortlist",
    "shortly",
    "shortness",
    "shorts",
    "shortwave",
    "shorty",
    "shout",
    "shove",
    "showbiz",
    "showcase",
    "showdown",
    "shower",
    "showgirl",
    "showing",
    "showman",
    "shown",
    "showoff",
    "showpiece",
    "showplace",
    "showroom",
    "showy",
    "shrank",
    "shrapnel",
    "shredder",
    "shredding",
    "shrewdly",
    "shriek",
    "shrill",
    "shrimp",
    "shrine",
    "shrink",
    "shrivel",
    "shrouded",
    "shrubbery",
    "shrubs",
    "shrug",
    "shrunk",
    "shucking",
    "shudder",
    "shuffle",
    "shuffling",
    "shun",
    "shush",
    "shut",
    "shy",
    "siamese",
    "siberian",
    "sibling",
    "siding",
    "sierra",
    "siesta",
    "sift",
    "sighing",
    "silenced",
    "silencer",
    "silent",
    "silica",
    "silicon",
    "silk",
    "silliness",
    "silly",
    "silo",
    "silt",
    "silver",
    "similarly",
    "simile",
    "simmering",
    "simple",
    "simplify",
    "simply",
    "sincere",
    "sincerity",
    "singer",
    "singing",
    "single",
    "singular",
    "sinister",
    "sinless",
    "sinner",
    "sinuous",
    "sip",
    "siren",
    "sister",
    "sitcom",
    "sitter",
    "sitting",
    "situated",
    "situation",
    "sixfold",
    "sixteen",
    "sixth",
    "sixties",
    "sixtieth",
    "sixtyfold",
    "sizable",
    "sizably",
    "size",
    "sizing",
    "sizzle",
    "sizzling",
    "skater",
    "skating",
    "skedaddle",
    "skeletal",
    "skeleton",
    "skeptic",
    "sketch",
    "skewed",
    "skewer",
    "skid",
    "skied",
    "skier",
    "skies",
    "skiing",
    "skilled",
    "skillet",
    "skillful",
    "skimmed",
    "skimmer",
    "skimming",
    "skimpily",
    "skincare",
    "skinhead",
    "skinless",
    "skinning",
    "skinny",
    "skintight",
    "skipper",
    "skipping",
    "skirmish",
    "skirt",
    "skittle",
    "skydiver",
    "skylight",
    "skyline",
    "skype",
    "skyrocket",
    "skyward",
    "slab",
    "slacked",
    "slacker",
    "slacking",
    "slackness",
    "slacks",
    "slain",
    "slam",
    "slander",
    "slang",
    "slapping",
    "slapstick",
    "slashed",
    "slashing",
    "slate",
    "slather",
    "slaw",
    "sled",
    "sleek",
    "sleep",
    "sleet",
    "sleeve",
    "slept",
    "sliceable",
    "sliced",
    "slicer",
    "slicing",
    "slick",
    "slider",
    "slideshow",
    "sliding",
    "slighted",
    "slighting",
    "slightly",
    "slimness",
    "slimy",
    "slinging",
    "slingshot",
    "slinky",
    "slip",
    "slit",
    "sliver",
    "slobbery",
    "slogan",
    "sloped",
    "sloping",
    "sloppily",
    "sloppy",
    "slot",
    "slouching",
    "slouchy",
    "sludge",
    "slug",
    "slum",
    "slurp",
    "slush",
    "sly",
    "small",
    "smartly",
    "smartness",
    "smasher",
    "smashing",
    "smashup",
    "smell",
    "smelting",
    "smile",
    "smilingly",
    "smirk",
    "smite",
    "smith",
    "smitten",
    "smock",
    "smog",
    "smoked",
    "smokeless",
    "smokiness",
    "smoking",
    "smoky",
    "smolder",
    "smooth",
    "smother",
    "smudge",
    "smudgy",
    "smuggler",
    "smuggling",
    "smugly",
    "smugness",
    "snack",
    "snagged",
    "snaking",
    "snap",
    "snare",
    "snarl",
    "snazzy",
    "sneak",
    "sneer",
    "sneeze",
    "sneezing",
    "snide",
    "sniff",
    "snippet",
    "snipping",
    "snitch",
    "snooper",
    "snooze",
    "snore",
    "snoring",
    "snorkel",
    "snort",
    "snout",
    "snowbird",
    "snowboard",
    "snowbound",
    "snowcap",
    "snowdrift",
    "snowdrop",
    "snowfall",
    "snowfield",
    "snowflake",
    "snowiness",
    "snowless",
    "snowman",
    "snowplow",
    "snowshoe",
    "snowstorm",
    "snowsuit",
    "snowy",
    "snub",
    "snuff",
    "snuggle",
    "snugly",
    "snugness",
    "speak",
    "spearfish",
    "spearhead",
    "spearman",
    "spearmint",
    "species",
    "specimen",
    "specked",
    "speckled",
    "specks",
    "spectacle",
    "spectator",
    "spectrum",
    "speculate",
    "speech",
    "speed",
    "spellbind",
    "speller",
    "spelling",
    "spendable",
    "spender",
    "spending",
    "spent",
    "spew",
    "sphere",
    "spherical",
    "sphinx",
    "spider",
    "spied",
    "spiffy",
    "spill",
    "spilt",
    "spinach",
    "spinal",
    "spindle",
    "spinner",
    "spinning",
    "spinout",
    "spinster",
    "spiny",
    "spiral",
    "spirited",
    "spiritism",
    "spirits",
    "spiritual",
    "splashed",
    "splashing",
    "splashy",
    "splatter",
    "spleen",
    "splendid",
    "splendor",
    "splice",
    "splicing",
    "splinter",
    "splotchy",
    "splurge",
    "spoilage",
    "spoiled",
    "spoiler",
    "spoiling",
    "spoils",
    "spoken",
    "spokesman",
    "sponge",
    "spongy",
    "sponsor",
    "spoof",
    "spookily",
    "spooky",
    "spool",
    "spoon",
    "spore",
    "sporting",
    "sports",
    "sporty",
    "spotless",
    "spotlight",
    "spotted",
    "spotter",
    "spotting",
    "spotty",
    "spousal",
    "spouse",
    "spout",
    "sprain",
    "sprang",
    "sprawl",
    "spray",
    "spree",
    "sprig",
    "spring",
    "sprinkled",
    "sprinkler",
    "sprint",
    "sprite",
    "sprout",
    "spruce",
    "sprung",
    "spry",
    "spud",
    "spur",
    "sputter",
    "spyglass",
    "squabble",
    "squad",
    "squall",
    "squander",
    "squash",
    "squatted",
    "squatter",
    "squatting",
    "squeak",
    "squealer",
    "squealing",
    "squeamish",
    "squeegee",
    "squeeze",
    "squeezing",
    "squid",
    "squiggle",
    "squiggly",
    "squint",
    "squire",
    "squirt",
    "squishier",
    "squishy",
    "stability",
    "stabilize",
    "stable",
    "stack",
    "stadium",
    "staff",
    "stage",
    "staging",
    "stagnant",
    "stagnate",
    "stainable",
    "stained",
    "staining",
    "stainless",
    "stalemate",
    "staleness",
    "stalling",
    "stallion",
    "stamina",
    "stammer",
    "stamp",
    "stand",
    "stank",
    "staple",
    "stapling",
    "starboard",
    "starch",
    "stardom",
    "stardust",
    "starfish",
    "stargazer",
    "staring",
    "stark",
    "starless",
    "starlet",
    "starlight",
    "starlit",
    "starring",
    "starry",
    "starship",
    "starter",
    "starting",
    "startle",
    "startling",
    "startup",
    "starved",
    "starving",
    "stash",
    "state",
    "static",
    "statistic",
    "statue",
    "stature",
    "status",
    "statute",
    "statutory",
    "staunch",
    "stays",
    "steadfast",
    "steadier",
    "steadily",
    "steadying",
    "steam",
    "steed",
    "steep",
    "steerable",
    "steering",
    "steersman",
    "stegosaur",
    "stellar",
    "stem",
    "stench",
    "stencil",
    "step",
    "stereo",
    "sterile",
    "sterility",
    "sterilize",
    "sterling",
    "sternness",
    "sternum",
    "stew",
    "stick",
    "stiffen",
    "stiffly",
    "stiffness",
    "stifle",
    "stifling",
    "stillness",
    "stilt",
    "stimulant",
    "stimulate",
    "stimuli",
    "stimulus",
    "stinger",
    "stingily",
    "stinging",
    "stingray",
    "stingy",
    "stinking",
    "stinky",
    "stipend",
    "stipulate",
    "stir",
    "stitch",
    "stock",
    "stoic",
    "stoke",
    "stole",
    "stomp",
    "stonewall",
    "stoneware",
    "stonework",
    "stoning",
    "stony",
    "stood",
    "stooge",
    "stool",
    "stoop",
    "stoplight",
    "stoppable",
    "stoppage",
    "stopped",
    "stopper",
    "stopping",
    "stopwatch",
    "storable",
    "storage",
    "storeroom",
    "storewide",
    "storm",
    "stout",
    "stove",
    "stowaway",
    "stowing",
    "straddle",
    "straggler",
    "strained",
    "strainer",
    "straining",
    "strangely",
    "stranger",
    "strangle",
    "strategic",
    "strategy",
    "stratus",
    "straw",
    "stray",
    "streak",
    "stream",
    "street",
    "strength",
    "strenuous",
    "strep",
    "stress",
    "stretch",
    "strewn",
    "stricken",
    "strict",
    "stride",
    "strife",
    "strike",
    "striking",
    "strive",
    "striving",
    "strobe",
    "strode",
    "stroller",
    "strongbox",
    "strongly",
    "strongman",
    "struck",
    "structure",
    "strudel",
    "struggle",
    "strum",
    "strung",
    "strut",
    "stubbed",
    "stubble",
    "stubbly",
    "stubborn",
    "stucco",
    "stuck",
    "student",
    "studied",
    "studio",
    "study",
    "stuffed",
    "stuffing",
    "stuffy",
    "stumble",
    "stumbling",
    "stump",
    "stung",
    "stunned",
    "stunner",
    "stunning",
    "stunt",
    "stupor",
    "sturdily",
    "sturdy",
    "styling",
    "stylishly",
    "stylist",
    "stylized",
    "stylus",
    "suave",
    "subarctic",
    "subatomic",
    "subdivide",
    "subdued",
    "subduing",
    "subfloor",
    "subgroup",
    "subheader",
    "subject",
    "sublease",
    "sublet",
    "sublevel",
    "sublime",
    "submarine",
    "submerge",
    "submersed",
    "submitter",
    "subpanel",
    "subpar",
    "subplot",
    "subprime",
    "subscribe",
    "subscript",
    "subsector",
    "subside",
    "subsiding",
    "subsidize",
    "subsidy",
    "subsoil",
    "subsonic",
    "substance",
    "subsystem",
    "subtext",
    "subtitle",
    "subtly",
    "subtotal",
    "subtract",
    "subtype",
    "suburb",
    "subway",
    "subwoofer",
    "subzero",
    "succulent",
    "such",
    "suction",
    "sudden",
    "sudoku",
    "suds",
    "sufferer",
    "suffering",
    "suffice",
    "suffix",
    "suffocate",
    "suffrage",
    "sugar",
    "suggest",
    "suing",
    "suitable",
    "suitably",
    "suitcase",
    "suitor",
    "sulfate",
    "sulfide",
    "sulfite",
    "sulfur",
    "sulk",
    "sullen",
    "sulphate",
    "sulphuric",
    "sultry",
    "superbowl",
    "superglue",
    "superhero",
    "superior",
    "superjet",
    "superman",
    "supermom",
    "supernova",
    "supervise",
    "supper",
    "supplier",
    "supply",
    "support",
    "supremacy",
    "supreme",
    "surcharge",
    "surely",
    "sureness",
    "surface",
    "surfacing",
    "surfboard",
    "surfer",
    "surgery",
    "surgical",
    "surging",
    "surname",
    "surpass",
    "surplus",
    "surprise",
    "surreal",
    "surrender",
    "surrogate",
    "surround",
    "survey",
    "survival",
    "survive",
    "surviving",
    "survivor",
    "sushi",
    "suspect",
    "suspend",
    "suspense",
    "sustained",
    "sustainer",
    "swab",
    "swaddling",
    "swagger",
    "swampland",
    "swan",
    "swapping",
    "swarm",
    "sway",
    "swear",
    "sweat",
    "sweep",
    "swell",
    "swept",
    "swerve",
    "swifter",
    "swiftly",
    "swiftness",
    "swimmable",
    "swimmer",
    "swimming",
    "swimsuit",
    "swimwear",
    "swinger",
    "swinging",
    "swipe",
    "swirl",
    "switch",
    "swivel",
    "swizzle",
    "swooned",
    "swoop",
    "swoosh",
    "swore",
    "sworn",
    "swung",
    "sycamore",
    "sympathy",
    "symphonic",
    "symphony",
    "symptom",
    "synapse",
    "syndrome",
    "synergy",
    "synopses",
    "synopsis",
    "synthesis",
    "synthetic",
    "syrup",
    "system",
    "t-shirt",
    "tabasco",
    "tabby",
    "tableful",
    "tables",
    "tablet",
    "tableware",
    "tabloid",
    "tackiness",
    "tacking",
    "tackle",
    "tackling",
    "tacky",
    "taco",
    "tactful",
    "tactical",
    "tactics",
    "tactile",
    "tactless",
    "tadpole",
    "taekwondo",
    "tag",
    "tainted",
    "take",
    "taking",
    "talcum",
    "talisman",
    "tall",
    "talon",
    "tamale",
    "tameness",
    "tamer",
    "tamper",
    "tank",
    "tanned",
    "tannery",
    "tanning",
    "tantrum",
    "tapeless",
    "tapered",
    "tapering",
    "tapestry",
    "tapioca",
    "tapping",
    "taps",
    "tarantula",
    "target",
    "tarmac",
    "tarnish",
    "tarot",
    "tartar",
    "tartly",
    "tartness",
    "task",
    "tassel",
    "taste",
    "tastiness",
    "tasting",
    "tasty",
    "tattered",
    "tattle",
    "tattling",
    "tattoo",
    "taunt",
    "tavern",
    "thank",
    "that",
    "thaw",
    "theater",
    "theatrics",
    "thee",
    "theft",
    "theme",
    "theology",
    "theorize",
    "thermal",
    "thermos",
    "thesaurus",
    "these",
    "thesis",
    "thespian",
    "thicken",
    "thicket",
    "thickness",
    "thieving",
    "thievish",
    "thigh",
    "thimble",
    "thing",
    "think",
    "thinly",
    "thinner",
    "thinness",
    "thinning",
    "thirstily",
    "thirsting",
    "thirsty",
    "thirteen",
    "thirty",
    "thong",
    "thorn",
    "those",
    "thousand",
    "thrash",
    "thread",
    "threaten",
    "threefold",
    "thrift",
    "thrill",
    "thrive",
    "thriving",
    "throat",
    "throbbing",
    "throng",
    "throttle",
    "throwaway",
    "throwback",
    "thrower",
    "throwing",
    "thud",
    "thumb",
    "thumping",
    "thursday",
    "thus",
    "thwarting",
    "thyself",
    "tiara",
    "tibia",
    "tidal",
    "tidbit",
    "tidiness",
    "tidings",
    "tidy",
    "tiger",
    "tighten",
    "tightly",
    "tightness",
    "tightrope",
    "tightwad",
    "tigress",
    "tile",
    "tiling",
    "till",
    "tilt",
    "timid",
    "timing",
    "timothy",
    "tinderbox",
    "tinfoil",
    "tingle",
    "tingling",
    "tingly",
    "tinker",
    "tinkling",
    "tinsel",
    "tinsmith",
    "tint",
    "tinwork",
    "tiny",
    "tipoff",
    "tipped",
    "tipper",
    "tipping",
    "tiptoeing",
    "tiptop",
    "tiring",
    "tissue",
    "trace",
    "tracing",
    "track",
    "traction",
    "tractor",
    "trade",
    "trading",
    "tradition",
    "traffic",
    "tragedy",
    "trailing",
    "trailside",
    "train",
    "traitor",
    "trance",
    "tranquil",
    "transfer",
    "transform",
    "translate",
    "transpire",
    "transport",
    "transpose",
    "trapdoor",
    "trapeze",
    "trapezoid",
    "trapped",
    "trapper",
    "trapping",
    "traps",
    "trash",
    "travel",
    "traverse",
    "travesty",
    "tray",
    "treachery",
    "treading",
    "treadmill",
    "treason",
    "treat",
    "treble",
    "tree",
    "trekker",
    "tremble",
    "trembling",
    "tremor",
    "trench",
    "trend",
    "trespass",
    "triage",
    "trial",
    "triangle",
    "tribesman",
    "tribunal",
    "tribune",
    "tributary",
    "tribute",
    "triceps",
    "trickery",
    "trickily",
    "tricking",
    "trickle",
    "trickster",
    "tricky",
    "tricolor",
    "tricycle",
    "trident",
    "tried",
    "trifle",
    "trifocals",
    "trillion",
    "trilogy",
    "trimester",
    "trimmer",
    "trimming",
    "trimness",
    "trinity",
    "trio",
    "tripod",
    "tripping",
    "triumph",
    "trivial",
    "trodden",
    "trolling",
    "trombone",
    "trophy",
    "tropical",
    "tropics",
    "trouble",
    "troubling",
    "trough",
    "trousers",
    "trout",
    "trowel",
    "truce",
    "truck",
    "truffle",
    "trump",
    "trunks",
    "trustable",
    "trustee",
    "trustful",
    "trusting",
    "trustless",
    "truth",
    "try",
    "tubby",
    "tubeless",
    "tubular",
    "tucking",
    "tuesday",
    "tug",
    "tuition",
    "tulip",
    "tumble",
    "tumbling",
    "tummy",
    "turban",
    "turbine",
    "turbofan",
    "turbojet",
    "turbulent",
    "turf",
    "turkey",
    "turmoil",
    "turret",
    "turtle",
    "tusk",
    "tutor",
    "tutu",
    "tux",
    "tweak",
    "tweed",
    "tweet",
    "tweezers",
    "twelve",
    "twentieth",
    "twenty",
    "twerp",
    "twice",
    "twiddle",
    "twiddling",
    "twig",
    "twilight",
    "twine",
    "twins",
    "twirl",
    "twistable",
    "twisted",
    "twister",
    "twisting",
    "twisty",
    "twitch",
    "twitter",
    "tycoon",
    "tying",
    "tyke",
    "udder",
    "ultimate",
    "ultimatum",
    "ultra",
    "umbilical",
    "umbrella",
    "umpire",
    "unabashed",
    "unable",
    "unadorned",
    "unadvised",
    "unafraid",
    "unaired",
    "unaligned",
    "unaltered",
    "unarmored",
    "unashamed",
    "unaudited",
    "unawake",
    "unaware",
    "unbaked",
    "unbalance",
    "unbeaten",
    "unbend",
    "unbent",
    "unbiased",
    "unbitten",
    "unblended",
    "unblessed",
    "unblock",
    "unbolted",
    "unbounded",
    "unboxed",
    "unbraided",
    "unbridle",
    "unbroken",
    "unbuckled",
    "unbundle",
    "unburned",
    "unbutton",
    "uncanny",
    "uncapped",
    "uncaring",
    "uncertain",
    "unchain",
    "unchanged",
    "uncharted",
    "uncheck",
    "uncivil",
    "unclad",
    "unclaimed",
    "unclamped",
    "unclasp",
    "uncle",
    "unclip",
    "uncloak",
    "unclog",
    "unclothed",
    "uncoated",
    "uncoiled",
    "uncolored",
    "uncombed",
    "uncommon",
    "uncooked",
    "uncork",
    "uncorrupt",
    "uncounted",
    "uncouple",
    "uncouth",
    "uncover",
    "uncross",
    "uncrown",
    "uncrushed",
    "uncured",
    "uncurious",
    "uncurled",
    "uncut",
    "undamaged",
    "undated",
    "undaunted",
    "undead",
    "undecided",
    "undefined",
    "underage",
    "underarm",
    "undercoat",
    "undercook",
    "undercut",
    "underdog",
    "underdone",
    "underfed",
    "underfeed",
    "underfoot",
    "undergo",
    "undergrad",
    "underhand",
    "underline",
    "underling",
    "undermine",
    "undermost",
    "underpaid",
    "underpass",
    "underpay",
    "underrate",
    "undertake",
    "undertone",
    "undertook",
    "undertow",
    "underuse",
    "underwear",
    "underwent",
    "underwire",
    "undesired",
    "undiluted",
    "undivided",
    "undocked",
    "undoing",
    "undone",
    "undrafted",
    "undress",
    "undrilled",
    "undusted",
    "undying",
    "unearned",
    "unearth",
    "unease",
    "uneasily",
    "uneasy",
    "uneatable",
    "uneaten",
    "unedited",
    "unelected",
    "unending",
    "unengaged",
    "unenvied",
    "unequal",
    "unethical",
    "uneven",
    "unexpired",
    "unexposed",
    "unfailing",
    "unfair",
    "unfasten",
    "unfazed",
    "unfeeling",
    "unfiled",
    "unfilled",
    "unfitted",
    "unfitting",
    "unfixable",
    "unfixed",
    "unflawed",
    "unfocused",
    "unfold",
    "unfounded",
    "unframed",
    "unfreeze",
    "unfrosted",
    "unfrozen",
    "unfunded",
    "unglazed",
    "ungloved",
    "unglue",
    "ungodly",
    "ungraded",
    "ungreased",
    "unguarded",
    "unguided",
    "unhappily",
    "unhappy",
    "unharmed",
    "unhealthy",
    "unheard",
    "unhearing",
    "unheated",
    "unhelpful",
    "unhidden",
    "unhinge",
    "unhitched",
    "unholy",
    "unhook",
    "unicorn",
    "unicycle",
    "unified",
    "unifier",
    "uniformed",
    "uniformly",
    "unify",
    "unimpeded",
    "uninjured",
    "uninstall",
    "uninsured",
    "uninvited",
    "union",
    "uniquely",
    "unisexual",
    "unison",
    "unissued",
    "unit",
    "universal",
    "universe",
    "unjustly",
    "unkempt",
    "unkind",
    "unknotted",
    "unknowing",
    "unknown",
    "unlaced",
    "unlatch",
    "unlawful",
    "unleaded",
    "unlearned",
    "unleash",
    "unless",
    "unleveled",
    "unlighted",
    "unlikable",
    "unlimited",
    "unlined",
    "unlinked",
    "unlisted",
    "unlit",
    "unlivable",
    "unloaded",
    "unloader",
    "unlocked",
    "unlocking",
    "unlovable",
    "unloved",
    "unlovely",
    "unloving",
    "unluckily",
    "unlucky",
    "unmade",
    "unmanaged",
    "unmanned",
    "unmapped",
    "unmarked",
    "unmasked",
    "unmasking",
    "unmatched",
    "unmindful",
    "unmixable",
    "unmixed",
    "unmolded",
    "unmoral",
    "unmovable",
    "unmoved",
    "unmoving",
    "unnamable",
    "unnamed",
    "unnatural",
    "unneeded",
    "unnerve",
    "unnerving",
    "unnoticed",
    "unopened",
    "unopposed",
    "unpack",
    "unpadded",
    "unpaid",
    "unpainted",
    "unpaired",
    "unpaved",
    "unpeeled",
    "unpicked",
    "unpiloted",
    "unpinned",
    "unplanned",
    "unplanted",
    "unpleased",
    "unpledged",
    "unplowed",
    "unplug",
    "unpopular",
    "unproven",
    "unquote",
    "unranked",
    "unrated",
    "unraveled",
    "unreached",
    "unread",
    "unreal",
    "unreeling",
    "unrefined",
    "unrelated",
    "unrented",
    "unrest",
    "unretired",
    "unrevised",
    "unrigged",
    "unripe",
    "unrivaled",
    "unroasted",
    "unrobed",
    "unroll",
    "unruffled",
    "unruly",
    "unrushed",
    "unsaddle",
    "unsafe",
    "unsaid",
    "unsalted",
    "unsaved",
    "unsavory",
    "unscathed",
    "unscented",
    "unscrew",
    "unsealed",
    "unseated",
    "unsecured",
    "unseeing",
    "unseemly",
    "unseen",
    "unselect",
    "unselfish",
    "unsent",
    "unsettled",
    "unshackle",
    "unshaken",
    "unshaved",
    "unshaven",
    "unsheathe",
    "unshipped",
    "unsightly",
    "unsigned",
    "unskilled",
    "unsliced",
    "unsmooth",
    "unsnap",
    "unsocial",
    "unsoiled",
    "unsold",
    "unsolved",
    "unsorted",
    "unspoiled",
    "unspoken",
    "unstable",
    "unstaffed",
    "unstamped",
    "unsteady",
    "unsterile",
    "unstirred",
    "unstitch",
    "unstopped",
    "unstuck",
    "unstuffed",
    "unstylish",
    "unsubtle",
    "unsubtly",
    "unsuited",
    "unsure",
    "unsworn",
    "untagged",
    "untainted",
    "untaken",
    "untamed",
    "untangled",
    "untapped",
    "untaxed",
    "unthawed",
    "unthread",
    "untidy",
    "untie",
    "until",
    "untimed",
    "untimely",
    "untitled",
    "untoasted",
    "untold",
    "untouched",
    "untracked",
    "untrained",
    "untreated",
    "untried",
    "untrimmed",
    "untrue",
    "untruth",
    "unturned",
    "untwist",
    "untying",
    "unusable",
    "unused",
    "unusual",
    "unvalued",
    "unvaried",
    "unvarying",
    "unveiled",
    "unveiling",
    "unvented",
    "unviable",
    "unvisited",
    "unvocal",
    "unwanted",
    "unwarlike",
    "unwary",
    "unwashed",
    "unwatched",
    "unweave",
    "unwed",
    "unwelcome",
    "unwell",
    "unwieldy",
    "unwilling",
    "unwind",
    "unwired",
    "unwitting",
    "unwomanly",
    "unworldly",
    "unworn",
    "unworried",
    "unworthy",
    "unwound",
    "unwoven",
    "unwrapped",
    "unwritten",
    "unzip",
    "upbeat",
    "upchuck",
    "upcoming",
    "upcountry",
    "update",
    "upfront",
    "upgrade",
    "upheaval",
    "upheld",
    "uphill",
    "uphold",
    "uplifted",
    "uplifting",
    "upload",
    "upon",
    "upper",
    "upright",
    "uprising",
    "upriver",
    "uproar",
    "uproot",
    "upscale",
    "upside",
    "upstage",
    "upstairs",
    "upstart",
    "upstate",
    "upstream",
    "upstroke",
    "upswing",
    "uptake",
    "uptight",
    "uptown",
    "upturned",
    "upward",
    "upwind",
    "uranium",
    "urban",
    "urchin",
    "urethane",
    "urgency",
    "urgent",
    "urging",
    "urologist",
    "urology",
    "usable",
    "usage",
    "useable",
    "used",
    "uselessly",
    "user",
    "usher",
    "usual",
    "utensil",
    "utility",
    "utilize",
    "utmost",
    "utopia",
    "utter",
    "vacancy",
    "vacant",
    "vacate",
    "vacation",
    "vagabond",
    "vagrancy",
    "vagrantly",
    "vaguely",
    "vagueness",
    "valiant",
    "valid",
    "valium",
    "valley",
    "valuables",
    "value",
    "vanilla",
    "vanish",
    "vanity",
    "vanquish",
    "vantage",
    "vaporizer",
    "variable",
    "variably",
    "varied",
    "variety",
    "various",
    "varmint",
    "varnish",
    "varsity",
    "varying",
    "vascular",
    "vaseline",
    "vastly",
    "vastness",
    "veal",
    "vegan",
    "veggie",
    "vehicular",
    "velcro",
    "velocity",
    "velvet",
    "vendetta",
    "vending",
    "vendor",
    "veneering",
    "vengeful",
    "venomous",
    "ventricle",
    "venture",
    "venue",
    "venus",
    "verbalize",
    "verbally",
    "verbose",
    "verdict",
    "verify",
    "verse",
    "version",
    "versus",
    "vertebrae",
    "vertical",
    "vertigo",
    "very",
    "vessel",
    "vest",
    "veteran",
    "veto",
    "vexingly",
    "viability",
    "viable",
    "vibes",
    "vice",
    "vicinity",
    "victory",
    "video",
    "viewable",
    "viewer",
    "viewing",
    "viewless",
    "viewpoint",
    "vigorous",
    "village",
    "villain",
    "vindicate",
    "vineyard",
    "vintage",
    "violate",
    "violation",
    "violator",
    "violet",
    "violin",
    "viper",
    "viral",
    "virtual",
    "virtuous",
    "virus",
    "visa",
    "viscosity",
    "viscous",
    "viselike",
    "visible",
    "visibly",
    "vision",
    "visiting",
    "visitor",
    "visor",
    "vista",
    "vitality",
    "vitalize",
    "vitally",
    "vitamins",
    "vivacious",
    "vividly",
    "vividness",
    "vixen",
    "vocalist",
    "vocalize",
    "vocally",
    "vocation",
    "voice",
    "voicing",
    "void",
    "volatile",
    "volley",
    "voltage",
    "volumes",
    "voter",
    "voting",
    "voucher",
    "vowed",
    "vowel",
    "voyage",
    "wackiness",
    "wad",
    "wafer",
    "waffle",
    "waged",
    "wager",
    "wages",
    "waggle",
    "wagon",
    "wake",
    "waking",
    "walk",
    "walmart",
    "walnut",
    "walrus",
    "waltz",
    "wand",
    "wannabe",
    "wanted",
    "wanting",
    "wasabi",
    "washable",
    "washbasin",
    "washboard",
    "washbowl",
    "washcloth",
    "washday",
    "washed",
    "washer",
    "washhouse",
    "washing",
    "washout",
    "washroom",
    "washstand",
    "washtub",
    "wasp",
    "wasting",
    "watch",
    "water",
    "waviness",
    "waving",
    "wavy",
    "whacking",
    "whacky",
    "wham",
    "wharf",
    "wheat",
    "whenever",
    "whiff",
    "whimsical",
    "whinny",
    "whiny",
    "whisking",
    "whoever",
    "whole",
    "whomever",
    "whoopee",
    "whooping",
    "whoops",
    "why",
    "wick",
    "widely",
    "widen",
    "widget",
    "widow",
    "width",
    "wieldable",
    "wielder",
    "wife",
    "wifi",
    "wikipedia",
    "wildcard",
    "wildcat",
    "wilder",
    "wildfire",
    "wildfowl",
    "wildland",
    "wildlife",
    "wildly",
    "wildness",
    "willed",
    "willfully",
    "willing",
    "willow",
    "willpower",
    "wilt",
    "wimp",
    "wince",
    "wincing",
    "wind",
    "wing",
    "winking",
    "winner",
    "winnings",
    "winter",
    "wipe",
    "wired",
    "wireless",
    "wiring",
    "wiry",
    "wisdom",
    "wise",
    "wish",
    "wisplike",
    "wispy",
    "wistful",
    "wizard",
    "wobble",
    "wobbling",
    "wobbly",
    "wok",
    "wolf",
    "wolverine",
    "womanhood",
    "womankind",
    "womanless",
    "womanlike",
    "womanly",
    "womb",
    "woof",
    "wooing",
    "wool",
    "woozy",
    "word",
    "work",
    "worried",
    "worrier",
    "worrisome",
    "worry",
    "worsening",
    "worshiper",
    "worst",
    "wound",
    "woven",
    "wow",
    "wrangle",
    "wrath",
    "wreath",
    "wreckage",
    "wrecker",
    "wrecking",
    "wrench",
    "wriggle",
    "wriggly",
    "wrinkle",
    "wrinkly",
    "wrist",
    "writing",
    "written",
    "wrongdoer",
    "wronged",
    "wrongful",
    "wrongly",
    "wrongness",
    "wrought",
    "xbox",
    "xerox",
    "yahoo",
    "yam",
    "yanking",
    "yapping",
    "yard",
    "yarn",
    "yeah",
    "yearbook",
    "yearling",
    "yearly",
    "yearning",
    "yeast",
    "yelling",
    "yelp",
    "yen",
    "yesterday",
    "yiddish",
    "yield",
    "yin",
    "yippee",
    "yo-yo",
    "yodel",
    "yoga",
    "yogurt",
    "yonder",
    "yoyo",
    "yummy",
    "zap",
    "zealous",
    "zebra",
    "zen",
    "zeppelin",
    "zero",
    "zestfully",
    "zesty",
    "zigzagged",
    "zipfile",
    "zipping",
    "zippy",
    "zips",
    "zit",
    "zodiac",
    "zombie",
    "zone",
    "zoning",
    "zookeeper",
    "zoologist",
    "zoology",
    "zoom"
  ];
  return wordlist$1;
}
var hasRequiredNewSecureWords;
function requireNewSecureWords() {
  if (hasRequiredNewSecureWords) return newSecureWords;
  hasRequiredNewSecureWords = 1;
  Object.defineProperty(newSecureWords, "__esModule", { value: true });
  newSecureWords.newSecureWords = void 0;
  const getSecureRandom_1 = requireGetSecureRandom();
  const wordlist_1 = requireWordlist$1();
  async function newSecureWords$1(size = 6) {
    let words = [];
    for (let i = 0; i < size; i++) {
      words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
    }
    return words;
  }
  newSecureWords.newSecureWords = newSecureWords$1;
  return newSecureWords;
}
var newSecurePassphrase = {};
var hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
  if (hasRequiredNewSecurePassphrase) return newSecurePassphrase;
  hasRequiredNewSecurePassphrase = 1;
  Object.defineProperty(newSecurePassphrase, "__esModule", { value: true });
  newSecurePassphrase.newSecurePassphrase = void 0;
  const __1 = requireDist$1();
  async function newSecurePassphrase$1(size = 6) {
    return (await (0, __1.newSecureWords)(size)).join("-");
  }
  newSecurePassphrase.newSecurePassphrase = newSecurePassphrase$1;
  return newSecurePassphrase;
}
var mnemonic = {};
var binary = {};
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  Object.defineProperty(binary, "__esModule", { value: true });
  binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  binary.lpad = lpad;
  function bytesToBits(bytes) {
    let res = "";
    for (let i = 0; i < bytes.length; i++) {
      let x2 = bytes.at(i);
      res += lpad(x2.toString(2), "0", 8);
    }
    return res;
  }
  binary.bytesToBits = bytesToBits;
  function bitsToBytes(src) {
    if (src.length % 8 !== 0) {
      throw Error("Uneven bits");
    }
    let res = [];
    while (src.length > 0) {
      res.push(parseInt(src.slice(0, 8), 2));
      src = src.slice(8);
    }
    return Buffer.from(res);
  }
  binary.bitsToBytes = bitsToBytes;
  return binary;
}
var wordlist = {};
var hasRequiredWordlist;
function requireWordlist() {
  if (hasRequiredWordlist) return wordlist;
  hasRequiredWordlist = 1;
  Object.defineProperty(wordlist, "__esModule", { value: true });
  wordlist.wordlist = void 0;
  const EN = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  wordlist.wordlist = EN;
  return wordlist;
}
var hasRequiredMnemonic;
function requireMnemonic() {
  if (hasRequiredMnemonic) return mnemonic;
  hasRequiredMnemonic = 1;
  var __importDefault = mnemonic && mnemonic.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(mnemonic, "__esModule", { value: true });
  mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  const getSecureRandom_1 = requireGetSecureRandom();
  const hmac_sha512_1 = requireHmac_sha512();
  const pbkdf2_sha512_1 = requirePbkdf2_sha512();
  const binary_1 = requireBinary();
  const wordlist_1 = requireWordlist();
  const PBKDF_ITERATIONS = 1e5;
  async function isPasswordNeeded(mnemonicArray) {
    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
    return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
  }
  function normalizeMnemonic(src) {
    return src.map((v2) => v2.toLowerCase().trim());
  }
  async function isBasicSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
    return seed[0] == 0;
  }
  async function isPasswordSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
    return seed[0] == 1;
  }
  async function mnemonicToEntropy(mnemonicArray, password) {
    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
  }
  mnemonic.mnemonicToEntropy = mnemonicToEntropy;
  async function mnemonicToSeed2(mnemonicArray, seed, password) {
    const entropy = await mnemonicToEntropy(mnemonicArray, password);
    return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
  }
  mnemonic.mnemonicToSeed = mnemonicToSeed2;
  async function mnemonicToPrivateKey(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    const seed = await mnemonicToSeed2(mnemonicArray, "TON default seed", password);
    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
  async function mnemonicToWalletKey(mnemonicArray, password) {
    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
    let seedSecret = seedPk.secretKey.slice(0, 32);
    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
  async function mnemonicToHDSeed(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    return await mnemonicToSeed2(mnemonicArray, "TON HD Keys seed", password);
  }
  mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
  async function mnemonicValidate(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    for (let word of mnemonicArray) {
      if (wordlist_1.wordlist.indexOf(word) < 0) {
        return false;
      }
    }
    if (password && password.length > 0) {
      if (!await isPasswordNeeded(mnemonicArray)) {
        return false;
      }
    }
    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
  }
  mnemonic.mnemonicValidate = mnemonicValidate;
  async function mnemonicNew(wordsCount = 24, password) {
    let mnemonicArray = [];
    while (true) {
      mnemonicArray = [];
      for (let i = 0; i < wordsCount; i++) {
        let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
        mnemonicArray.push(wordlist_1.wordlist[ind]);
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          continue;
        }
      }
      if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
        continue;
      }
      break;
    }
    return mnemonicArray;
  }
  mnemonic.mnemonicNew = mnemonicNew;
  function bytesToMnemonicIndexes(src, wordsCount) {
    let bits = (0, binary_1.bytesToBits)(src);
    let indexes = [];
    for (let i = 0; i < wordsCount; i++) {
      let sl = bits.slice(i * 11, i * 11 + 11);
      indexes.push(parseInt(sl, 2));
    }
    return indexes;
  }
  mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
  function bytesToMnemonics(src, wordsCount) {
    let mnemonics2 = bytesToMnemonicIndexes(src, wordsCount);
    let res = [];
    for (let m of mnemonics2) {
      res.push(wordlist_1.wordlist[m]);
    }
    return res;
  }
  mnemonic.bytesToMnemonics = bytesToMnemonics;
  function mnemonicIndexesToBytes(src) {
    let res = "";
    for (let s2 of src) {
      if (!Number.isSafeInteger(s2)) {
        throw Error("Invalid input");
      }
      if (s2 < 0 || s2 >= 2028) {
        throw Error("Invalid input");
      }
      res += (0, binary_1.lpad)(s2.toString(2), "0", 11);
    }
    while (res.length % 8 !== 0) {
      res = res + "0";
    }
    return (0, binary_1.bitsToBytes)(res);
  }
  mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
  async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
    const bytesLength = Math.ceil(wordsCount * 11 / 8);
    let currentSeed = seed;
    while (true) {
      let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
      let mnemonics2 = bytesToMnemonics(entropy, wordsCount);
      if (await mnemonicValidate(mnemonics2, password)) {
        return mnemonics2;
      }
      currentSeed = entropy;
    }
  }
  mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
  return mnemonic;
}
var nacl = {};
var hasRequiredNacl;
function requireNacl() {
  if (hasRequiredNacl) return nacl;
  hasRequiredNacl = 1;
  var __importDefault = nacl && nacl.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(nacl, "__esModule", { value: true });
  nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  function keyPairFromSecretKey(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSecretKey = keyPairFromSecretKey;
  function keyPairFromSeed(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSeed = keyPairFromSeed;
  function sign2(data, secretKey) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
  }
  nacl.sign = sign2;
  function signVerify(data, signature, publicKey) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
  }
  nacl.signVerify = signVerify;
  function sealBox(data, nonce, key) {
    return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
  }
  nacl.sealBox = sealBox;
  function openBox(data, nonce, key) {
    let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
    if (!res) {
      return null;
    }
    return Buffer.from(res);
  }
  nacl.openBox = openBox;
  return nacl;
}
var ed25519 = {};
var hasRequiredEd25519;
function requireEd25519() {
  if (hasRequiredEd25519) return ed25519;
  hasRequiredEd25519 = 1;
  Object.defineProperty(ed25519, "__esModule", { value: true });
  ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const ED25519_CURVE = "ed25519 seed";
  const HARDENED_OFFSET = 2147483648;
  async function getED25519MasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
  async function deriveED25519HardenedKey(parent, index2) {
    if (index2 >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index2 + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
  async function deriveEd25519Path(seed, path) {
    let state = await getED25519MasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index2 = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveED25519HardenedKey(state, index2);
    }
    return state.key;
  }
  ed25519.deriveEd25519Path = deriveEd25519Path;
  return ed25519;
}
var symmetric = {};
var hasRequiredSymmetric;
function requireSymmetric() {
  if (hasRequiredSymmetric) return symmetric;
  hasRequiredSymmetric = 1;
  Object.defineProperty(symmetric, "__esModule", { value: true });
  symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const SYMMETRIC_SEED = "Symmetric key seed";
  async function getSymmetricMasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
    const IL = I2.slice(32);
    const IR = I2.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
  async function deriveSymmetricHardenedKey(parent, offset) {
    const data = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(offset)]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(32);
    const IR = I2.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
  async function deriveSymmetricPath(seed, path) {
    let state = await getSymmetricMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index2 = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveSymmetricHardenedKey(state, index2);
    }
    return state.key;
  }
  symmetric.deriveSymmetricPath = deriveSymmetricPath;
  return symmetric;
}
var mnemonics = {};
var hasRequiredMnemonics;
function requireMnemonics() {
  if (hasRequiredMnemonics) return mnemonics;
  hasRequiredMnemonics = 1;
  Object.defineProperty(mnemonics, "__esModule", { value: true });
  mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
  const mnemonic_1 = requireMnemonic();
  const hmac_sha512_1 = requireHmac_sha512();
  const HARDENED_OFFSET = 2147483648;
  const MNEMONICS_SEED = "TON Mnemonics HD seed";
  async function getMnemonicsMasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
  async function deriveMnemonicHardenedKey(parent, index2) {
    if (index2 >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index2 + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
  async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
    let state = await getMnemonicsMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index2 = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveMnemonicHardenedKey(state, index2);
    }
    return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
  }
  mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
  return mnemonics;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist;
  hasRequiredDist$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = requireSha256();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = requireSha512();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = requireHmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = requireGetSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var newSecureWords_1 = requireNewSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = requireNewSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
    var mnemonic_1 = requireMnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToHDSeed;
    } });
    var wordlist_1 = requireWordlist();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = requireNacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    var nacl_2 = requireNacl();
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSeed;
    } });
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var ed25519_1 = requireEd25519();
    Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
      return ed25519_1.getED25519MasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
      return ed25519_1.deriveED25519HardenedKey;
    } });
    Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
      return ed25519_1.deriveEd25519Path;
    } });
    var symmetric_1 = requireSymmetric();
    Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
      return symmetric_1.getSymmetricMasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricHardenedKey;
    } });
    Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricPath;
    } });
    var mnemonics_1 = requireMnemonics();
    Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicsPath;
    } });
    Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicHardenedKey;
    } });
    Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
      return mnemonics_1.getMnemonicsMasterKeyFromSeed;
    } });
  })(dist);
  return dist;
}
var hasRequiredWonderCalculator;
function requireWonderCalculator() {
  if (hasRequiredWonderCalculator) return wonderCalculator;
  hasRequiredWonderCalculator = 1;
  Object.defineProperty(wonderCalculator, "__esModule", { value: true });
  wonderCalculator.wonderCalculator = void 0;
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const LevelMask_1 = requireLevelMask();
  const exoticPruned_1 = requireExoticPruned();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const descriptor_1 = requireDescriptor();
  const crypto_1 = requireDist$1();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticLibrary_1 = requireExoticLibrary();
  function wonderCalculator$1(type, bits, refs) {
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
      let mask = 0;
      for (let r of refs) {
        mask = mask | r.mask.value;
      }
      levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
      pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
      (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
      (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
      (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      levelMask = new LevelMask_1.LevelMask();
    } else {
      throw new Error("Unsupported exotic type");
    }
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
      if (!levelMask.isSignificant(levelI)) {
        continue;
      }
      if (hashI < hashIOffset) {
        hashI++;
        continue;
      }
      let currentBits;
      if (hashI === hashIOffset) {
        if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid");
        }
        currentBits = bits;
      } else {
        if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid: " + levelI + ", " + type);
        }
        currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
      }
      let currentDepth = 0;
      for (let c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(levelI + 1);
        } else {
          childDepth = c.depth(levelI);
        }
        currentDepth = Math.max(currentDepth, childDepth);
      }
      if (refs.length > 0) {
        currentDepth++;
      }
      let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
      let hash = (0, crypto_1.sha256_sync)(repr);
      let destI = hashI - hashIOffset;
      depths[destI] = currentDepth;
      hashes[destI] = hash;
      hashI++;
    }
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
      for (let i = 0; i < 4; i++) {
        const { hashIndex } = levelMask.apply(i);
        const { hashIndex: thisHashIndex } = levelMask;
        if (hashIndex !== thisHashIndex) {
          resolvedHashes.push(pruned.pruned[hashIndex].hash);
          resolvedDepths.push(pruned.pruned[hashIndex].depth);
        } else {
          resolvedHashes.push(hashes[0]);
          resolvedDepths.push(depths[0]);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
        resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
      }
    }
    return {
      mask: levelMask,
      hashes: resolvedHashes,
      depths: resolvedDepths
    };
  }
  wonderCalculator.wonderCalculator = wonderCalculator$1;
  return wonderCalculator;
}
var serialization = {};
var topologicalSort = {};
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort;
  hasRequiredTopologicalSort = 1;
  Object.defineProperty(topologicalSort, "__esModule", { value: true });
  topologicalSort.topologicalSort = void 0;
  function topologicalSort$1(src) {
    let pending = [src];
    let allCells = /* @__PURE__ */ new Map();
    let notPermCells = /* @__PURE__ */ new Set();
    let sorted = [];
    while (pending.length > 0) {
      const cells = [...pending];
      pending = [];
      for (let cell of cells) {
        const hash = cell.hash().toString("hex");
        if (allCells.has(hash)) {
          continue;
        }
        notPermCells.add(hash);
        allCells.set(hash, { cell, refs: cell.refs.map((v2) => v2.hash().toString("hex")) });
        for (let r of cell.refs) {
          pending.push(r);
        }
      }
    }
    let tempMark = /* @__PURE__ */ new Set();
    function visit(hash) {
      if (!notPermCells.has(hash)) {
        return;
      }
      if (tempMark.has(hash)) {
        throw Error("Not a DAG");
      }
      tempMark.add(hash);
      let refs = allCells.get(hash).refs;
      for (let ci = refs.length - 1; ci >= 0; ci--) {
        visit(refs[ci]);
      }
      sorted.push(hash);
      tempMark.delete(hash);
      notPermCells.delete(hash);
    }
    while (notPermCells.size > 0) {
      const id = Array.from(notPermCells)[0];
      visit(id);
    }
    let indexes = /* @__PURE__ */ new Map();
    for (let i = 0; i < sorted.length; i++) {
      indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      let ent = sorted[i];
      const rrr = allCells.get(ent);
      result.push({ cell: rrr.cell, refs: rrr.refs.map((v2) => indexes.get(v2)) });
    }
    return result;
  }
  topologicalSort.topologicalSort = topologicalSort$1;
  return topologicalSort;
}
var bitsForNumber = {};
var hasRequiredBitsForNumber;
function requireBitsForNumber() {
  if (hasRequiredBitsForNumber) return bitsForNumber;
  hasRequiredBitsForNumber = 1;
  Object.defineProperty(bitsForNumber, "__esModule", { value: true });
  bitsForNumber.bitsForNumber = void 0;
  function bitsForNumber$1(src, mode) {
    let v2 = BigInt(src);
    if (mode === "int") {
      if (v2 === 0n || v2 === -1n) {
        return 1;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      return v22.toString(2).length + 1;
    } else if (mode === "uint") {
      if (v2 < 0) {
        throw Error(`value is negative. Got ${src}`);
      }
      return v2.toString(2).length;
    } else {
      throw Error(`invalid mode. Got ${mode}`);
    }
  }
  bitsForNumber.bitsForNumber = bitsForNumber$1;
  return bitsForNumber;
}
var crc32c = {};
var hasRequiredCrc32c;
function requireCrc32c() {
  if (hasRequiredCrc32c) return crc32c;
  hasRequiredCrc32c = 1;
  Object.defineProperty(crc32c, "__esModule", { value: true });
  crc32c.crc32c = void 0;
  const POLY = 2197175160;
  function crc32c$1(source) {
    let crc = 0 ^ 4294967295;
    for (let n = 0; n < source.length; n++) {
      crc ^= source[n];
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 4294967295;
    let res = Buffer.alloc(4);
    res.writeInt32LE(crc);
    return res;
  }
  crc32c.crc32c = crc32c$1;
  return crc32c;
}
var hasRequiredSerialization;
function requireSerialization() {
  if (hasRequiredSerialization) return serialization;
  hasRequiredSerialization = 1;
  Object.defineProperty(serialization, "__esModule", { value: true });
  serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
  const BitReader_1 = requireBitReader();
  const BitString_1 = requireBitString();
  const Cell_1 = requireCell();
  const topologicalSort_1 = requireTopologicalSort();
  const bitsForNumber_1 = requireBitsForNumber();
  const BitBuilder_1 = requireBitBuilder();
  const descriptor_1 = requireDescriptor();
  const paddedBits_1 = requirePaddedBits();
  const crc32c_1 = requireCrc32c();
  function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
  }
  function getHashesCountFromMask(mask) {
    let n = 0;
    for (let i = 0; i < 3; i++) {
      n += mask & 1;
      mask = mask >> 1;
    }
    return n + 1;
  }
  function readCell(reader2, sizeBytes) {
    const d1 = reader2.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    const d2 = reader2.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader2.skip(hashesSize * 8);
    reader2.skip(depthSize * 8);
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
      if (paddingAdded) {
        bits = reader2.loadPaddedBits(dataBytesize * 8);
      } else {
        bits = reader2.loadBits(dataBytesize * 8);
      }
    }
    let refs = [];
    for (let i = 0; i < refsCount; i++) {
      refs.push(reader2.loadUint(sizeBytes * 8));
    }
    return {
      bits,
      refs,
      exotic
    };
  }
  function calcCellSize(cell, sizeBytes) {
    return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
  }
  function parseBoc(src) {
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
    let magic = reader2.loadUint(32);
    if (magic === 1761568243) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index2 = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root: [0]
      };
    } else if (magic === 2898503464) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index2 = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      let crc32 = reader2.loadBuffer(4);
      if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
        throw Error("Invalid CRC32C");
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root: [0]
      };
    } else if (magic === 3052313714) {
      let hasIdx = reader2.loadUint(1);
      let hasCrc32c = reader2.loadUint(1);
      reader2.loadUint(1);
      reader2.loadUint(2);
      let size = reader2.loadUint(3);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let root = [];
      for (let i = 0; i < roots; i++) {
        root.push(reader2.loadUint(size * 8));
      }
      let index2 = null;
      if (hasIdx) {
        index2 = reader2.loadBuffer(cells * offBytes);
      }
      let cellData = reader2.loadBuffer(totalCellSize);
      if (hasCrc32c) {
        let crc32 = reader2.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root
      };
    } else {
      throw Error("Invalid magic");
    }
  }
  serialization.parseBoc = parseBoc;
  function deserializeBoc(src) {
    let boc = parseBoc(src);
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    let cells = [];
    for (let i = 0; i < boc.cells; i++) {
      let cll = readCell(reader2, boc.size);
      cells.push({ ...cll, result: null });
    }
    for (let i = cells.length - 1; i >= 0; i--) {
      if (cells[i].result) {
        throw Error("Impossible");
      }
      let refs = [];
      for (let r of cells[i].refs) {
        if (!cells[r].result) {
          throw Error("Invalid BOC file");
        }
        refs.push(cells[r].result);
      }
      cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
    }
    let roots = [];
    for (let i = 0; i < boc.root.length; i++) {
      roots.push(cells[boc.root[i]].result);
    }
    return roots;
  }
  serialization.deserializeBoc = deserializeBoc;
  function writeCellToBuilder(cell, refs, sizeBytes, to) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to.writeUint(d1, 8);
    to.writeUint(d2, 8);
    to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs) {
      to.writeUint(r, sizeBytes * 8);
    }
  }
  function serializeBoc(root, opts) {
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
    let totalCellSize = 0;
    let index2 = [];
    for (let c of allCells) {
      let sz = calcCellSize(c.cell, sizeBytes);
      totalCellSize += sz;
      index2.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    let builder2 = new BitBuilder_1.BitBuilder(totalSize);
    builder2.writeUint(3052313714, 32);
    builder2.writeBit(has_idx);
    builder2.writeBit(has_crc32c);
    builder2.writeBit(has_cache_bits);
    builder2.writeUint(flags, 2);
    builder2.writeUint(sizeBytes, 3);
    builder2.writeUint(offsetBytes, 8);
    builder2.writeUint(cellsNum, sizeBytes * 8);
    builder2.writeUint(1, sizeBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    builder2.writeUint(totalCellSize, offsetBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    if (has_idx) {
      for (let i = 0; i < cellsNum; i++) {
        builder2.writeUint(index2[i], offsetBytes * 8);
      }
    }
    for (let i = 0; i < cellsNum; i++) {
      writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder2);
    }
    if (has_crc32c) {
      let crc32 = (0, crc32c_1.crc32c)(builder2.buffer());
      builder2.writeBuffer(crc32);
    }
    let res = builder2.buffer();
    if (res.length !== totalSize / 8) {
      throw Error("Internal error");
    }
    return res;
  }
  serialization.serializeBoc = serializeBoc;
  return serialization;
}
var hasRequiredCell;
function requireCell() {
  if (hasRequiredCell) return Cell;
  hasRequiredCell = 1;
  var __importDefault = Cell && Cell.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Cell, "__esModule", { value: true });
  Cell.Cell = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const Slice_1 = requireSlice();
  const resolveExotic_1 = requireResolveExotic();
  const wonderCalculator_1 = requireWonderCalculator();
  const serialization_1 = requireSerialization();
  const BitReader_1 = requireBitReader();
  const Builder_1 = requireBuilder$1();
  let Cell$1 = class Cell2 {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */
    static fromBoc(src) {
      return (0, serialization_1.deserializeBoc)(src);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */
    static fromBase64(src) {
      let parsed = Cell2.fromBoc(Buffer.from(src, "base64"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */
    static fromHex(src) {
      let parsed = Cell2.fromBoc(Buffer.from(src, "hex"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    constructor(opts) {
      this._hashes = [];
      this._depths = [];
      this.beginParse = (allowExotic = false) => {
        if (this.isExotic && !allowExotic) {
          throw new Error("Exotic cells cannot be parsed");
        }
        return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
      };
      this.hash = (level = 3) => {
        return this._hashes[Math.min(this._hashes.length - 1, level)];
      };
      this.depth = (level = 3) => {
        return this._depths[Math.min(this._depths.length - 1, level)];
      };
      this.level = () => {
        return this.mask.level;
      };
      this.equals = (other) => {
        return this.hash().equals(other.hash());
      };
      this[_a] = () => this.toString();
      let bits = BitString_1.BitString.EMPTY;
      if (opts && opts.bits) {
        bits = opts.bits;
      }
      let refs = [];
      if (opts && opts.refs) {
        refs = [...opts.refs];
      }
      let hashes;
      let depths;
      let mask;
      let type = CellType_1.CellType.Ordinary;
      if (opts && opts.exotic) {
        let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
        let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = resolved.type;
      } else {
        if (refs.length > 4) {
          throw new Error("Invalid number of references");
        }
        if (bits.length > 1023) {
          throw new Error(`Bits overflow: ${bits.length} > 1023`);
        }
        let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = CellType_1.CellType.Ordinary;
      }
      this.type = type;
      this.bits = bits;
      this.refs = refs;
      this.mask = mask;
      this._depths = depths;
      this._hashes = hashes;
      Object.freeze(this);
      Object.freeze(this.refs);
      Object.freeze(this.bits);
      Object.freeze(this.mask);
      Object.freeze(this._depths);
      Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */
    get isExotic() {
      return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */
    toBoc(opts) {
      let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
      let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
      return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */
    toString(indent) {
      let id = indent || "";
      let t = "x";
      if (this.isExotic) {
        if (this.type === CellType_1.CellType.MerkleProof) {
          t = "p";
        } else if (this.type === CellType_1.CellType.MerkleUpdate) {
          t = "u";
        } else if (this.type === CellType_1.CellType.PrunedBranch) {
          t = "p";
        }
      }
      let s2 = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
      for (let k2 in this.refs) {
        const i = this.refs[k2];
        s2 += "\n" + i.toString(id + " ");
      }
      return s2;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */
    asSlice() {
      return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */
    asBuilder() {
      return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
    }
  };
  Cell.Cell = Cell$1;
  _a = symbol_inspect_1.default;
  Cell$1.EMPTY = new Cell$1();
  return Cell;
}
var hasRequiredBuilder$1;
function requireBuilder$1() {
  if (hasRequiredBuilder$1) return Builder;
  hasRequiredBuilder$1 = 1;
  Object.defineProperty(Builder, "__esModule", { value: true });
  Builder.Builder = Builder.beginCell = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const Cell_1 = requireCell();
  const strings_1 = requireStrings();
  function beginCell() {
    return new Builder$1();
  }
  Builder.beginCell = beginCell;
  let Builder$1 = class Builder2 {
    constructor() {
      this._bits = new BitBuilder_1.BitBuilder();
      this._refs = [];
    }
    /**
     * Bits written so far
     */
    get bits() {
      return this._bits.length;
    }
    /**
     * References written so far
     */
    get refs() {
      return this._refs.length;
    }
    /**
     * Available bits
     */
    get availableBits() {
      return 1023 - this.bits;
    }
    /**
     * Available references
     */
    get availableRefs() {
      return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */
    storeBit(value) {
      this._bits.writeBit(value);
      return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */
    storeBits(src) {
      this._bits.writeBits(src);
      return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeBuffer(src, bytes) {
      if (bytes !== void 0 && bytes !== null) {
        if (src.length !== bytes) {
          throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
        }
      }
      this._bits.writeBuffer(src);
      return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeMaybeBuffer(src, bytes) {
      if (src !== null) {
        this.storeBit(1);
        this.storeBuffer(src, bytes);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeUint(value, bits) {
      this._bits.writeUint(value, bits);
      return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeInt(value, bits) {
      this._bits.writeInt(value, bits);
      return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarUint(value, bits) {
      this._bits.writeVarUint(value, bits);
      return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarInt(value, bits) {
      this._bits.writeVarInt(value, bits);
      return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */
    storeCoins(amount) {
      this._bits.writeCoins(amount);
      return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */
    storeMaybeCoins(amount) {
      if (amount !== null && amount !== void 0) {
        this.storeBit(1);
        this.storeCoins(amount);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */
    storeAddress(address) {
      this._bits.writeAddress(address);
      return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeRef(cell) {
      if (this._refs.length >= 4) {
        throw new Error("Too many references");
      }
      if (cell instanceof Cell_1.Cell) {
        this._refs.push(cell);
      } else if (cell instanceof Builder2) {
        this._refs.push(cell.endCell());
      } else {
        throw new Error("Invalid argument");
      }
      return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeMaybeRef(cell) {
      if (cell) {
        this.storeBit(1);
        this.storeRef(cell);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */
    storeSlice(src) {
      let c = src.clone();
      if (c.remainingBits > 0) {
        this.storeBits(c.loadBits(c.remainingBits));
      }
      while (c.remainingRefs > 0) {
        this.storeRef(c.loadRef());
      }
      return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */
    storeMaybeSlice(src) {
      if (src) {
        this.storeBit(1);
        this.storeSlice(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */
    storeBuilder(src) {
      return this.storeSlice(src.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */
    storeMaybeBuilder(src) {
      if (src) {
        this.storeBit(1);
        this.storeBuilder(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeWritable(writer) {
      if (typeof writer === "object") {
        writer.writeTo(this);
      } else {
        writer(this);
      }
      return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeMaybeWritable(writer) {
      if (writer) {
        this.storeBit(1);
        this.storeWritable(writer);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */
    store(writer) {
      this.storeWritable(writer);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeStringTail(src) {
      (0, strings_1.writeString)(src, this);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringTail(src) {
      if (src !== null && src !== void 0) {
        this.storeBit(1);
        (0, strings_1.writeString)(src, this);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeStringRefTail(src) {
      this.storeRef(beginCell().storeStringTail(src));
      return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringRefTail(src) {
      if (src !== null && src !== void 0) {
        this.storeBit(1);
        this.storeStringRefTail(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDict(dict, key, value) {
      if (dict) {
        dict.store(this, key, value);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDictDirect(dict, key, value) {
      dict.storeDirect(this, key, value);
      return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */
    endCell(opts) {
      return new Cell_1.Cell({
        bits: this._bits.build(),
        refs: this._refs,
        exotic: opts?.exotic
      });
    }
    /**
     * Convert to cell
     * @returns cell
     */
    asCell() {
      return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */
    asSlice() {
      return this.endCell().beginParse();
    }
  };
  Builder.Builder = Builder$1;
  return Builder;
}
var StateInit = {};
var SimpleLibrary = {};
var hasRequiredSimpleLibrary;
function requireSimpleLibrary() {
  if (hasRequiredSimpleLibrary) return SimpleLibrary;
  hasRequiredSimpleLibrary = 1;
  Object.defineProperty(SimpleLibrary, "__esModule", { value: true });
  SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
  function loadSimpleLibrary(slice) {
    return {
      public: slice.loadBit(),
      root: slice.loadRef()
    };
  }
  SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
  function storeSimpleLibrary(src) {
    return (builder2) => {
      builder2.storeBit(src.public);
      builder2.storeRef(src.root);
    };
  }
  SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
  SimpleLibrary.SimpleLibraryValue = {
    serialize(src, builder2) {
      storeSimpleLibrary(src)(builder2);
    },
    parse(src) {
      return loadSimpleLibrary(src);
    }
  };
  return SimpleLibrary;
}
var TickTock = {};
var hasRequiredTickTock;
function requireTickTock() {
  if (hasRequiredTickTock) return TickTock;
  hasRequiredTickTock = 1;
  Object.defineProperty(TickTock, "__esModule", { value: true });
  TickTock.storeTickTock = TickTock.loadTickTock = void 0;
  function loadTickTock(slice) {
    return {
      tick: slice.loadBit(),
      tock: slice.loadBit()
    };
  }
  TickTock.loadTickTock = loadTickTock;
  function storeTickTock(src) {
    return (builder2) => {
      builder2.storeBit(src.tick);
      builder2.storeBit(src.tock);
    };
  }
  TickTock.storeTickTock = storeTickTock;
  return TickTock;
}
var hasRequiredStateInit;
function requireStateInit() {
  if (hasRequiredStateInit) return StateInit;
  hasRequiredStateInit = 1;
  Object.defineProperty(StateInit, "__esModule", { value: true });
  StateInit.storeStateInit = StateInit.loadStateInit = void 0;
  const Dictionary_1 = requireDictionary();
  const SimpleLibrary_1 = requireSimpleLibrary();
  const TickTock_1 = requireTickTock();
  function loadStateInit(slice) {
    let splitDepth;
    if (slice.loadBit()) {
      splitDepth = slice.loadUint(5);
    }
    let special;
    if (slice.loadBit()) {
      special = (0, TickTock_1.loadTickTock)(slice);
    }
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
      libraries = void 0;
    }
    return {
      splitDepth,
      special,
      code,
      data,
      libraries
    };
  }
  StateInit.loadStateInit = loadStateInit;
  function storeStateInit(src) {
    return (builder2) => {
      if (src.splitDepth !== null && src.splitDepth !== void 0) {
        builder2.storeBit(true);
        builder2.storeUint(src.splitDepth, 5);
      } else {
        builder2.storeBit(false);
      }
      if (src.special !== null && src.special !== void 0) {
        builder2.storeBit(true);
        builder2.store((0, TickTock_1.storeTickTock)(src.special));
      } else {
        builder2.storeBit(false);
      }
      builder2.storeMaybeRef(src.code);
      builder2.storeMaybeRef(src.data);
      builder2.storeDict(src.libraries);
    };
  }
  StateInit.storeStateInit = storeStateInit;
  return StateInit;
}
var hasRequiredContractAddress;
function requireContractAddress() {
  if (hasRequiredContractAddress) return contractAddress;
  hasRequiredContractAddress = 1;
  Object.defineProperty(contractAddress, "__esModule", { value: true });
  contractAddress.contractAddress = void 0;
  const Builder_1 = requireBuilder$1();
  const StateInit_1 = requireStateInit();
  const Address_1 = requireAddress();
  function contractAddress$1(workchain, init2) {
    let hash = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(init2)).endCell().hash();
    return new Address_1.Address(workchain, hash);
  }
  contractAddress.contractAddress = contractAddress$1;
  return contractAddress;
}
var tuple = {};
var hasRequiredTuple;
function requireTuple() {
  if (hasRequiredTuple) return tuple;
  hasRequiredTuple = 1;
  Object.defineProperty(tuple, "__esModule", { value: true });
  tuple.parseTuple = tuple.serializeTuple = tuple.parseTupleItem = tuple.serializeTupleItem = void 0;
  const Builder_1 = requireBuilder$1();
  const INT64_MIN = BigInt("-9223372036854775808");
  const INT64_MAX = BigInt("9223372036854775807");
  function serializeTupleItem(src, builder2) {
    if (src.type === "null") {
      builder2.storeUint(0, 8);
    } else if (src.type === "int") {
      if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
        builder2.storeUint(1, 8);
        builder2.storeInt(src.value, 64);
      } else {
        builder2.storeUint(256, 15);
        builder2.storeInt(src.value, 257);
      }
    } else if (src.type === "nan") {
      builder2.storeInt(767, 16);
    } else if (src.type === "cell") {
      builder2.storeUint(3, 8);
      builder2.storeRef(src.cell);
    } else if (src.type === "slice") {
      builder2.storeUint(4, 8);
      builder2.storeUint(0, 10);
      builder2.storeUint(src.cell.bits.length, 10);
      builder2.storeUint(0, 3);
      builder2.storeUint(src.cell.refs.length, 3);
      builder2.storeRef(src.cell);
    } else if (src.type === "builder") {
      builder2.storeUint(5, 8);
      builder2.storeRef(src.cell);
    } else if (src.type === "tuple") {
      let head = null;
      let tail = null;
      for (let i = 0; i < src.items.length; i++) {
        let s2 = head;
        head = tail;
        tail = s2;
        if (i > 1) {
          head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();
        }
        let bc = (0, Builder_1.beginCell)();
        serializeTupleItem(src.items[i], bc);
        tail = bc.endCell();
      }
      builder2.storeUint(7, 8);
      builder2.storeUint(src.items.length, 16);
      if (head) {
        builder2.storeRef(head);
      }
      if (tail) {
        builder2.storeRef(tail);
      }
    } else {
      throw Error("Invalid value");
    }
  }
  tuple.serializeTupleItem = serializeTupleItem;
  function parseTupleItem(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
      return { type: "null" };
    } else if (kind === 1) {
      return { type: "int", value: cs.loadIntBig(64) };
    } else if (kind === 2) {
      if (cs.loadUint(7) === 0) {
        return { type: "int", value: cs.loadIntBig(257) };
      } else {
        cs.loadBit();
        return { type: "nan" };
      }
    } else if (kind === 3) {
      return { type: "cell", cell: cs.loadRef() };
    } else if (kind === 4) {
      let startBits = cs.loadUint(10);
      let endBits = cs.loadUint(10);
      let startRefs = cs.loadUint(3);
      let endRefs = cs.loadUint(3);
      let rs = cs.loadRef().beginParse();
      rs.skip(startBits);
      let dt = rs.loadBits(endBits - startBits);
      let builder2 = (0, Builder_1.beginCell)().storeBits(dt);
      if (startRefs < endRefs) {
        for (let i = 0; i < startRefs; i++) {
          rs.loadRef();
        }
        for (let i = 0; i < endRefs - startRefs; i++) {
          builder2.storeRef(rs.loadRef());
        }
      }
      return { type: "slice", cell: builder2.endCell() };
    } else if (kind === 5) {
      return { type: "builder", cell: cs.loadRef() };
    } else if (kind === 7) {
      let length = cs.loadUint(16);
      let items = [];
      if (length > 1) {
        let head = cs.loadRef().beginParse();
        let tail = cs.loadRef().beginParse();
        items.unshift(parseTupleItem(tail));
        for (let i = 0; i < length - 2; i++) {
          let ohead = head;
          head = ohead.loadRef().beginParse();
          tail = ohead.loadRef().beginParse();
          items.unshift(parseTupleItem(tail));
        }
        items.unshift(parseTupleItem(head));
      } else if (length === 1) {
        items.push(parseTupleItem(cs.loadRef().beginParse()));
      }
      return { type: "tuple", items };
    } else {
      throw Error("Unsupported stack item");
    }
  }
  tuple.parseTupleItem = parseTupleItem;
  function serializeTupleTail(src, builder2) {
    if (src.length > 0) {
      let tail = (0, Builder_1.beginCell)();
      serializeTupleTail(src.slice(0, src.length - 1), tail);
      builder2.storeRef(tail.endCell());
      serializeTupleItem(src[src.length - 1], builder2);
    }
  }
  function serializeTuple(src) {
    let builder2 = (0, Builder_1.beginCell)();
    builder2.storeUint(src.length, 24);
    let r = [...src];
    serializeTupleTail(r, builder2);
    return builder2.endCell();
  }
  tuple.serializeTuple = serializeTuple;
  function parseTuple(src) {
    let res = [];
    let cs = src.beginParse();
    let size = cs.loadUint(24);
    for (let i = 0; i < size; i++) {
      let next = cs.loadRef();
      res.unshift(parseTupleItem(cs));
      cs = next.beginParse();
    }
    return res;
  }
  tuple.parseTuple = parseTuple;
  return tuple;
}
var reader = {};
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  Object.defineProperty(reader, "__esModule", { value: true });
  reader.TupleReader = void 0;
  class TupleReader {
    constructor(items) {
      this.items = [...items];
    }
    get remaining() {
      return this.items.length;
    }
    peek() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      return this.items[0];
    }
    pop() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      let res = this.items[0];
      this.items.splice(0, 1);
      return res;
    }
    skip(num = 1) {
      for (let i = 0; i < num; i++) {
        this.pop();
      }
      return this;
    }
    readBigNumber() {
      let popped = this.pop();
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readBigNumberOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readNumber() {
      return Number(this.readBigNumber());
    }
    readNumberOpt() {
      let r = this.readBigNumberOpt();
      if (r !== null) {
        return Number(r);
      } else {
        return null;
      }
    }
    readBoolean() {
      let res = this.readNumber();
      return res === 0 ? false : true;
    }
    readBooleanOpt() {
      let res = this.readNumberOpt();
      if (res !== null) {
        return res === 0 ? false : true;
      } else {
        return null;
      }
    }
    readAddress() {
      let r = this.readCell().beginParse().loadAddress();
      if (r !== null) {
        return r;
      } else {
        throw Error("Not an address");
      }
    }
    readAddressOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        return r.beginParse().loadMaybeAddress();
      } else {
        return null;
      }
    }
    readCell() {
      let popped = this.pop();
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell: " + popped.type);
      }
      return popped.cell;
    }
    readCellOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell");
      }
      return popped.cell;
    }
    readTuple() {
      let popped = this.pop();
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    readTupleOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    static readLispList(reader2) {
      const result = [];
      let tail = reader2;
      while (tail !== null) {
        var head = tail.pop();
        if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
          throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
        }
        tail = tail.readTupleOpt();
        result.push(head);
      }
      return result;
    }
    readLispListDirect() {
      if (this.items.length === 1 && this.items[0].type === "null") {
        return [];
      }
      return TupleReader.readLispList(this);
    }
    readLispList() {
      return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
      let s2 = this.readCell().beginParse();
      if (s2.remainingRefs !== 0) {
        throw Error("Not a buffer");
      }
      if (s2.remainingBits % 8 !== 0) {
        throw Error("Not a buffer");
      }
      return s2.loadBuffer(s2.remainingBits / 8);
    }
    readBufferOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        if (s2.remainingRefs !== 0 || s2.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s2.loadBuffer(s2.remainingBits / 8);
      } else {
        return null;
      }
    }
    readString() {
      let s2 = this.readCell().beginParse();
      return s2.loadStringTail();
    }
    readStringOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        return s2.loadStringTail();
      } else {
        return null;
      }
    }
  }
  reader.TupleReader = TupleReader;
  return reader;
}
var builder = {};
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", { value: true });
  builder.TupleBuilder = void 0;
  const Builder_1 = requireBuilder$1();
  const Cell_1 = requireCell();
  const Slice_1 = requireSlice();
  class TupleBuilder {
    constructor() {
      this._tuple = [];
    }
    writeNumber(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: BigInt(v2) });
      }
    }
    writeBoolean(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: v2 ? -1n : 0n });
      }
    }
    writeBuffer(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeBuffer(v2).endCell() });
      }
    }
    writeString(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeStringTail(v2).endCell() });
      }
    }
    writeCell(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "cell", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "cell", cell: v2.asCell() });
        }
      }
    }
    writeSlice(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "slice", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "slice", cell: v2.asCell() });
        }
      }
    }
    writeBuilder(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "builder", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "builder", cell: v2.asCell() });
        }
      }
    }
    writeTuple(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "tuple", items: v2 });
      }
    }
    writeAddress(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeAddress(v2).endCell() });
      }
    }
    build() {
      return [...this._tuple];
    }
  }
  builder.TupleBuilder = TupleBuilder;
  return builder;
}
var _export = {};
var _helpers = {};
var convert = {};
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromNano = convert.toNano = void 0;
  function toNano(src) {
    if (typeof src === "bigint") {
      return src * 1000000000n;
    } else {
      if (typeof src === "number") {
        if (!Number.isFinite(src)) {
          throw Error("Invalid number");
        }
        if (Math.log10(src) <= 6) {
          src = src.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
        } else if (src - Math.trunc(src) === 0) {
          src = src.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
        } else {
          throw Error("Not enough precision for a number value. Use string value instead");
        }
      }
      let neg = false;
      while (src.startsWith("-")) {
        neg = !neg;
        src = src.slice(1);
      }
      if (src === ".") {
        throw Error("Invalid number");
      }
      let parts = src.split(".");
      if (parts.length > 2) {
        throw Error("Invalid number");
      }
      let whole = parts[0];
      let frac = parts[1];
      if (!whole) {
        whole = "0";
      }
      if (!frac) {
        frac = "0";
      }
      if (frac.length > 9) {
        throw Error("Invalid number");
      }
      while (frac.length < 9) {
        frac += "0";
      }
      let r = BigInt(whole) * 1000000000n + BigInt(frac);
      if (neg) {
        r = -r;
      }
      return r;
    }
  }
  convert.toNano = toNano;
  function fromNano(src) {
    let v2 = BigInt(src);
    let neg = false;
    if (v2 < 0) {
      neg = true;
      v2 = -v2;
    }
    let frac = v2 % 1000000000n;
    let facStr = frac.toString();
    while (facStr.length < 9) {
      facStr = "0" + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let whole = v2 / 1000000000n;
    let wholeStr = whole.toString();
    let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
    if (neg) {
      value = "-" + value;
    }
    return value;
  }
  convert.fromNano = fromNano;
  return convert;
}
var ExtraCurrency = {};
var hasRequiredExtraCurrency;
function requireExtraCurrency() {
  if (hasRequiredExtraCurrency) return ExtraCurrency;
  hasRequiredExtraCurrency = 1;
  Object.defineProperty(ExtraCurrency, "__esModule", { value: true });
  ExtraCurrency.packExtraCurrencyCell = ExtraCurrency.packExtraCurrencyDict = ExtraCurrency.storeExtraCurrency = ExtraCurrency.loadMaybeExtraCurrency = ExtraCurrency.loadExtraCurrency = void 0;
  const Builder_1 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k2, v2] of ecDict) {
      ecMap[k2] = v2;
    }
    return ecMap;
  }
  ExtraCurrency.loadExtraCurrency = loadExtraCurrency;
  function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
  }
  ExtraCurrency.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
  function storeExtraCurrency(extracurrency) {
    return (builder2) => {
      builder2.storeDict(packExtraCurrencyDict(extracurrency));
    };
  }
  ExtraCurrency.storeExtraCurrency = storeExtraCurrency;
  function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k2, v2]) => resEc.set(Number(k2), v2));
    return resEc;
  }
  ExtraCurrency.packExtraCurrencyDict = packExtraCurrencyDict;
  function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_1.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
  }
  ExtraCurrency.packExtraCurrencyCell = packExtraCurrencyCell;
  return ExtraCurrency;
}
var hasRequired_helpers;
function require_helpers() {
  if (hasRequired_helpers) return _helpers;
  hasRequired_helpers = 1;
  Object.defineProperty(_helpers, "__esModule", { value: true });
  _helpers.comment = _helpers.external = _helpers.internal = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  const Builder_1 = requireBuilder$1();
  const convert_1 = requireConvert();
  const ExtraCurrency_1 = requireExtraCurrency();
  function internal(src) {
    let bounce = true;
    if (src.bounce !== null && src.bounce !== void 0) {
      bounce = src.bounce;
    }
    let to;
    if (typeof src.to === "string") {
      to = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
      to = src.to;
    } else {
      throw new Error(`Invalid address ${src.to}`);
    }
    let value;
    if (typeof src.value === "string") {
      value = (0, convert_1.toNano)(src.value);
    } else {
      value = src.value;
    }
    let other;
    if (src.extracurrency) {
      other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src.extracurrency);
    }
    let body = Cell_1.Cell.EMPTY;
    if (typeof src.body === "string") {
      body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
    } else if (src.body) {
      body = src.body;
    }
    return {
      info: {
        type: "internal",
        dest: to,
        value: { coins: value, other },
        bounce,
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
      },
      init: src.init ?? void 0,
      body
    };
  }
  _helpers.internal = internal;
  function external(src) {
    let to;
    if (typeof src.to === "string") {
      to = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
      to = src.to;
    } else {
      throw new Error(`Invalid address ${src.to}`);
    }
    return {
      info: {
        type: "external-in",
        dest: to,
        importFee: 0n
      },
      init: src.init ?? void 0,
      body: src.body || Cell_1.Cell.EMPTY
    };
  }
  _helpers.external = external;
  function comment(src) {
    return (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
  }
  _helpers.comment = comment;
  return _helpers;
}
var Account = {};
var AccountStorage = {};
var AccountState = {};
var hasRequiredAccountState;
function requireAccountState() {
  if (hasRequiredAccountState) return AccountState;
  hasRequiredAccountState = 1;
  Object.defineProperty(AccountState, "__esModule", { value: true });
  AccountState.storeAccountState = AccountState.loadAccountState = void 0;
  const StateInit_1 = requireStateInit();
  function loadAccountState(cs) {
    if (cs.loadBit()) {
      return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
    } else if (cs.loadBit()) {
      return { type: "frozen", stateHash: cs.loadUintBig(256) };
    } else {
      return { type: "uninit" };
    }
  }
  AccountState.loadAccountState = loadAccountState;
  function storeAccountState(src) {
    return (builder2) => {
      if (src.type === "active") {
        builder2.storeBit(true);
        builder2.store((0, StateInit_1.storeStateInit)(src.state));
      } else if (src.type === "frozen") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.storeUint(src.stateHash, 256);
      } else if (src.type === "uninit") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      }
    };
  }
  AccountState.storeAccountState = storeAccountState;
  return AccountState;
}
var CurrencyCollection = {};
var hasRequiredCurrencyCollection;
function requireCurrencyCollection() {
  if (hasRequiredCurrencyCollection) return CurrencyCollection;
  hasRequiredCurrencyCollection = 1;
  Object.defineProperty(CurrencyCollection, "__esModule", { value: true });
  CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
  const Dictionary_1 = requireDictionary();
  function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
      5
      /* log2(32) */
    ));
    if (other.size === 0) {
      return { coins };
    } else {
      return { other, coins };
    }
  }
  CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
  function storeCurrencyCollection(collection) {
    return (builder2) => {
      builder2.storeCoins(collection.coins);
      if (collection.other) {
        builder2.storeDict(collection.other);
      } else {
        builder2.storeBit(0);
      }
    };
  }
  CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
  return CurrencyCollection;
}
var hasRequiredAccountStorage;
function requireAccountStorage() {
  if (hasRequiredAccountStorage) return AccountStorage;
  hasRequiredAccountStorage = 1;
  Object.defineProperty(AccountStorage, "__esModule", { value: true });
  AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
  const AccountState_1 = requireAccountState();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadAccountStorage(slice) {
    return {
      lastTransLt: slice.loadUintBig(64),
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
      state: (0, AccountState_1.loadAccountState)(slice)
    };
  }
  AccountStorage.loadAccountStorage = loadAccountStorage;
  function storeAccountStorage(src) {
    return (builder2) => {
      builder2.storeUint(src.lastTransLt, 64);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
      builder2.store((0, AccountState_1.storeAccountState)(src.state));
    };
  }
  AccountStorage.storeAccountStorage = storeAccountStorage;
  return AccountStorage;
}
var StorageInfo = {};
var StorageExtraInfo = {};
var hasRequiredStorageExtraInfo;
function requireStorageExtraInfo() {
  if (hasRequiredStorageExtraInfo) return StorageExtraInfo;
  hasRequiredStorageExtraInfo = 1;
  Object.defineProperty(StorageExtraInfo, "__esModule", { value: true });
  StorageExtraInfo.storeStorageExtraInfo = StorageExtraInfo.loadStorageExtraInfo = void 0;
  function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
      return null;
    }
    if (header === 1) {
      return {
        dictHash: slice.loadUintBig(256)
      };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
  }
  StorageExtraInfo.loadStorageExtraInfo = loadStorageExtraInfo;
  function storeStorageExtraInfo(src) {
    return (builder2) => {
      if (src === null || typeof src === "undefined") {
        builder2.storeUint(0, 3);
      } else {
        builder2.storeUint(1, 3);
        builder2.storeUint(src.dictHash, 256);
      }
    };
  }
  StorageExtraInfo.storeStorageExtraInfo = storeStorageExtraInfo;
  return StorageExtraInfo;
}
var StorageUsed = {};
var hasRequiredStorageUsed;
function requireStorageUsed() {
  if (hasRequiredStorageUsed) return StorageUsed;
  hasRequiredStorageUsed = 1;
  Object.defineProperty(StorageUsed, "__esModule", { value: true });
  StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
  function loadStorageUsed(cs) {
    return {
      cells: cs.loadVarUintBig(3),
      bits: cs.loadVarUintBig(3)
    };
  }
  StorageUsed.loadStorageUsed = loadStorageUsed;
  function storeStorageUsed(src) {
    return (builder2) => {
      builder2.storeVarUint(src.cells, 3);
      builder2.storeVarUint(src.bits, 3);
    };
  }
  StorageUsed.storeStorageUsed = storeStorageUsed;
  return StorageUsed;
}
var hasRequiredStorageInfo;
function requireStorageInfo() {
  if (hasRequiredStorageInfo) return StorageInfo;
  hasRequiredStorageInfo = 1;
  Object.defineProperty(StorageInfo, "__esModule", { value: true });
  StorageInfo.storeStorageInfo = StorageInfo.loadStorageInfo = void 0;
  const StorageExtraInfo_1 = requireStorageExtraInfo();
  const StorageUsed_1 = requireStorageUsed();
  function loadStorageInfo(slice) {
    return {
      used: (0, StorageUsed_1.loadStorageUsed)(slice),
      storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
      lastPaid: slice.loadUint(32),
      duePayment: slice.loadMaybeCoins()
    };
  }
  StorageInfo.loadStorageInfo = loadStorageInfo;
  function storeStorageInfo(src) {
    return (builder2) => {
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src.used));
      builder2.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src.storageExtra));
      builder2.storeUint(src.lastPaid, 32);
      builder2.storeMaybeCoins(src.duePayment);
    };
  }
  StorageInfo.storeStorageInfo = storeStorageInfo;
  return StorageInfo;
}
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return Account;
  hasRequiredAccount = 1;
  Object.defineProperty(Account, "__esModule", { value: true });
  Account.storeAccount = Account.loadAccount = void 0;
  const AccountStorage_1 = requireAccountStorage();
  const StorageInfo_1 = requireStorageInfo();
  function loadAccount(slice) {
    return {
      addr: slice.loadAddress(),
      storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
      storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
  }
  Account.loadAccount = loadAccount;
  function storeAccount(src) {
    return (builder2) => {
      builder2.storeAddress(src.addr);
      builder2.store((0, StorageInfo_1.storeStorageInfo)(src.storageStats));
      builder2.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
    };
  }
  Account.storeAccount = storeAccount;
  return Account;
}
var AccountStatus = {};
var hasRequiredAccountStatus;
function requireAccountStatus() {
  if (hasRequiredAccountStatus) return AccountStatus;
  hasRequiredAccountStatus = 1;
  Object.defineProperty(AccountStatus, "__esModule", { value: true });
  AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
  function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0) {
      return "uninitialized";
    }
    if (status === 1) {
      return "frozen";
    }
    if (status === 2) {
      return "active";
    }
    if (status === 3) {
      return "non-existing";
    }
    throw Error("Invalid data");
  }
  AccountStatus.loadAccountStatus = loadAccountStatus;
  function storeAccountStatus(src) {
    return (builder2) => {
      if (src === "uninitialized") {
        builder2.storeUint(0, 2);
      } else if (src === "frozen") {
        builder2.storeUint(1, 2);
      } else if (src === "active") {
        builder2.storeUint(2, 2);
      } else if (src === "non-existing") {
        builder2.storeUint(3, 2);
      } else {
        throw Error("Invalid data");
      }
      return builder2;
    };
  }
  AccountStatus.storeAccountStatus = storeAccountStatus;
  return AccountStatus;
}
var AccountStatusChange = {};
var hasRequiredAccountStatusChange;
function requireAccountStatusChange() {
  if (hasRequiredAccountStatusChange) return AccountStatusChange;
  hasRequiredAccountStatusChange = 1;
  Object.defineProperty(AccountStatusChange, "__esModule", { value: true });
  AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
  function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
      return "unchanged";
    }
    if (slice.loadBit()) {
      return "deleted";
    } else {
      return "frozen";
    }
  }
  AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
  function storeAccountStatusChange(src) {
    return (builder2) => {
      if (src == "unchanged") {
        builder2.storeBit(0);
      } else if (src === "frozen") {
        builder2.storeBit(1);
        builder2.storeBit(0);
      } else if (src === "deleted") {
        builder2.storeBit(1);
        builder2.storeBit(1);
      } else {
        throw Error("Invalid account status change");
      }
    };
  }
  AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
  return AccountStatusChange;
}
var OutList = {};
var MessageRelaxed = {};
var CommonMessageInfoRelaxed = {};
var hasRequiredCommonMessageInfoRelaxed;
function requireCommonMessageInfoRelaxed() {
  if (hasRequiredCommonMessageInfoRelaxed) return CommonMessageInfoRelaxed;
  hasRequiredCommonMessageInfoRelaxed = 1;
  Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", { value: true });
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfoRelaxed(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src2 = slice.loadMaybeAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src2,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    }
    const src = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
  function storeCommonMessageInfoRelaxed(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  return CommonMessageInfoRelaxed;
}
var hasRequiredMessageRelaxed;
function requireMessageRelaxed() {
  if (hasRequiredMessageRelaxed) return MessageRelaxed;
  hasRequiredMessageRelaxed = 1;
  Object.defineProperty(MessageRelaxed, "__esModule", { value: true });
  MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
  const Builder_1 = requireBuilder$1();
  const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
  const StateInit_1 = requireStateInit();
  function loadMessageRelaxed(slice) {
    const info2 = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init2 = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init2 = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init2 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info: info2,
      init: init2,
      body
    };
  }
  MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
  function storeMessageRelaxed(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          if (builder2.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        if (builder2.availableBits - 1 >= message.body.bits.length && builder2.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
          needRef = false;
        } else {
          needRef = true;
        }
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
  return MessageRelaxed;
}
var LibRef = {};
var hasRequiredLibRef;
function requireLibRef() {
  if (hasRequiredLibRef) return LibRef;
  hasRequiredLibRef = 1;
  Object.defineProperty(LibRef, "__esModule", { value: true });
  LibRef.storeLibRef = LibRef.loadLibRef = void 0;
  function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
      return {
        type: "hash",
        libHash: slice.loadBuffer(32)
      };
    } else {
      return {
        type: "ref",
        library: slice.loadRef()
      };
    }
  }
  LibRef.loadLibRef = loadLibRef;
  function storeLibRef(src) {
    return (builder2) => {
      if (src.type === "hash") {
        builder2.storeUint(0, 1);
        builder2.storeBuffer(src.libHash);
      } else {
        builder2.storeUint(1, 1);
        builder2.storeRef(src.library);
      }
    };
  }
  LibRef.storeLibRef = storeLibRef;
  return LibRef;
}
var hasRequiredOutList;
function requireOutList() {
  if (hasRequiredOutList) return OutList;
  hasRequiredOutList = 1;
  Object.defineProperty(OutList, "__esModule", { value: true });
  OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
  const MessageRelaxed_1 = requireMessageRelaxed();
  const Builder_1 = requireBuilder$1();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const LibRef_1 = requireLibRef();
  function storeOutAction(action) {
    switch (action.type) {
      case "sendMsg":
        return storeOutActionSendMsg(action);
      case "setCode":
        return storeOutActionSetCode(action);
      case "reserve":
        return storeOutActionReserve(action);
      case "changeLibrary":
        return storeOutActionChangeLibrary(action);
      default:
        throw new Error(`Unknown action type ${action.type}`);
    }
  }
  OutList.storeOutAction = storeOutAction;
  const outActionSendMsgTag = 247711853;
  function storeOutActionSendMsg(action) {
    return (builder2) => {
      builder2.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_1.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
  }
  const outActionSetCodeTag = 2907562126;
  function storeOutActionSetCode(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
  }
  const outActionReserveTag = 921090057;
  function storeOutActionReserve(action) {
    return (builder2) => {
      builder2.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
  }
  const outActionChangeLibraryTag = 653925844;
  function storeOutActionChangeLibrary(action) {
    return (builder2) => {
      builder2.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
  }
  function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
      const mode = slice.loadUint(8);
      const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
      return {
        type: "sendMsg",
        mode,
        outMsg
      };
    }
    if (tag === outActionSetCodeTag) {
      const newCode = slice.loadRef();
      return {
        type: "setCode",
        newCode
      };
    }
    if (tag === outActionReserveTag) {
      const mode = slice.loadUint(8);
      const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        type: "reserve",
        mode,
        currency
      };
    }
    if (tag === outActionChangeLibraryTag) {
      const mode = slice.loadUint(7);
      const libRef = (0, LibRef_1.loadLibRef)(slice);
      return {
        type: "changeLibrary",
        mode,
        libRef
      };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
  }
  OutList.loadOutAction = loadOutAction;
  function storeOutList(actions) {
    const cell = actions.reduce((cell2, action) => (0, Builder_1.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_1.beginCell)().endCell());
    return (builder2) => {
      builder2.storeSlice(cell.beginParse());
    };
  }
  OutList.storeOutList = storeOutList;
  function loadOutList(slice) {
    const actions = [];
    while (slice.remainingRefs) {
      const nextCell = slice.loadRef();
      actions.push(loadOutAction(slice));
      slice = nextCell.beginParse();
    }
    return actions.reverse();
  }
  OutList.loadOutList = loadOutList;
  return OutList;
}
var CommonMessageInfo = {};
var hasRequiredCommonMessageInfo;
function requireCommonMessageInfo() {
  if (hasRequiredCommonMessageInfo) return CommonMessageInfo;
  hasRequiredCommonMessageInfo = 1;
  Object.defineProperty(CommonMessageInfo, "__esModule", { value: true });
  CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfo(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src2 = slice.loadAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src2,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      const src2 = slice.loadMaybeExternalAddress();
      const dest2 = slice.loadAddress();
      const importFee = slice.loadCoins();
      return {
        type: "external-in",
        src: src2,
        dest: dest2,
        importFee
      };
    }
    const src = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
  function storeCommonMessageInfo(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-in") {
        builder2.storeBit(1);
        builder2.storeBit(0);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeCoins(source.importFee);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
  return CommonMessageInfo;
}
var ComputeSkipReason = {};
var hasRequiredComputeSkipReason;
function requireComputeSkipReason() {
  if (hasRequiredComputeSkipReason) return ComputeSkipReason;
  hasRequiredComputeSkipReason = 1;
  Object.defineProperty(ComputeSkipReason, "__esModule", { value: true });
  ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
  function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0) {
      return "no-state";
    } else if (reason === 1) {
      return "bad-state";
    } else if (reason === 2) {
      return "no-gas";
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
  }
  ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
  function storeComputeSkipReason(src) {
    return (builder2) => {
      if (src === "no-state") {
        builder2.storeUint(0, 2);
      } else if (src === "bad-state") {
        builder2.storeUint(1, 2);
      } else if (src === "no-gas") {
        builder2.storeUint(2, 2);
      } else {
        throw new Error(`Unknown ComputeSkipReason: ${src}`);
      }
    };
  }
  ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
  return ComputeSkipReason;
}
var DepthBalanceInfo = {};
var hasRequiredDepthBalanceInfo;
function requireDepthBalanceInfo() {
  if (hasRequiredDepthBalanceInfo) return DepthBalanceInfo;
  hasRequiredDepthBalanceInfo = 1;
  Object.defineProperty(DepthBalanceInfo, "__esModule", { value: true });
  DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
      splitDepth,
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
  }
  DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
  function storeDepthBalanceInfo(src) {
    return (builder2) => {
      builder2.storeUint(src.splitDepth, 5);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
    };
  }
  DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
  return DepthBalanceInfo;
}
var HashUpdate = {};
var hasRequiredHashUpdate;
function requireHashUpdate() {
  if (hasRequiredHashUpdate) return HashUpdate;
  hasRequiredHashUpdate = 1;
  Object.defineProperty(HashUpdate, "__esModule", { value: true });
  HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
  function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 114) {
      throw Error("Invalid data");
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return { oldHash, newHash };
  }
  HashUpdate.loadHashUpdate = loadHashUpdate;
  function storeHashUpdate(src) {
    return (builder2) => {
      builder2.storeUint(114, 8);
      builder2.storeBuffer(src.oldHash);
      builder2.storeBuffer(src.newHash);
    };
  }
  HashUpdate.storeHashUpdate = storeHashUpdate;
  return HashUpdate;
}
var MasterchainStateExtra = {};
var hasRequiredMasterchainStateExtra;
function requireMasterchainStateExtra() {
  if (hasRequiredMasterchainStateExtra) return MasterchainStateExtra;
  hasRequiredMasterchainStateExtra = 1;
  Object.defineProperty(MasterchainStateExtra, "__esModule", { value: true });
  MasterchainStateExtra.loadMasterchainStateExtra = void 0;
  const Dictionary_1 = requireDictionary();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadMasterchainStateExtra(cs) {
    if (cs.loadUint(16) !== 52262) {
      throw Error("Invalid data");
    }
    if (cs.loadBit()) {
      cs.loadRef();
    }
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
      config,
      configAddress,
      globalBalance
    };
  }
  MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
  return MasterchainStateExtra;
}
var Message = {};
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return Message;
  hasRequiredMessage = 1;
  Object.defineProperty(Message, "__esModule", { value: true });
  Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
  const Builder_1 = requireBuilder$1();
  const CommonMessageInfo_1 = requireCommonMessageInfo();
  const StateInit_1 = requireStateInit();
  function loadMessage(slice) {
    const info2 = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init2 = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init2 = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init2 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info: info2,
      init: init2,
      body
    };
  }
  Message.loadMessage = loadMessage;
  function storeMessage(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          needRef2 = builder2.availableBits - 2 < initCell.bits + message.body.bits.length;
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        needRef = builder2.availableBits - 1 < message.body.bits.length || builder2.refs + message.body.refs.length > 4;
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  Message.storeMessage = storeMessage;
  Message.MessageValue = {
    serialize(src, builder2) {
      builder2.storeRef((0, Builder_1.beginCell)().store(storeMessage(src)));
    },
    parse(slice) {
      return loadMessage(slice.loadRef().beginParse());
    }
  };
  return Message;
}
var SendMode = {};
var hasRequiredSendMode;
function requireSendMode() {
  if (hasRequiredSendMode) return SendMode;
  hasRequiredSendMode = 1;
  Object.defineProperty(SendMode, "__esModule", { value: true });
  SendMode.SendMode = void 0;
  var SendMode$1;
  (function(SendMode2) {
    SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode2[SendMode2["NONE"] = 0] = "NONE";
  })(SendMode$1 || (SendMode.SendMode = SendMode$1 = {}));
  return SendMode;
}
var ReserveMode = {};
var hasRequiredReserveMode;
function requireReserveMode() {
  if (hasRequiredReserveMode) return ReserveMode;
  hasRequiredReserveMode = 1;
  Object.defineProperty(ReserveMode, "__esModule", { value: true });
  ReserveMode.ReserveMode = void 0;
  var ReserveMode$1;
  (function(ReserveMode2) {
    ReserveMode2[ReserveMode2["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
  })(ReserveMode$1 || (ReserveMode.ReserveMode = ReserveMode$1 = {}));
  return ReserveMode;
}
var ShardAccount = {};
var hasRequiredShardAccount;
function requireShardAccount() {
  if (hasRequiredShardAccount) return ShardAccount;
  hasRequiredShardAccount = 1;
  Object.defineProperty(ShardAccount, "__esModule", { value: true });
  ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
  const Builder_1 = requireBuilder$1();
  const Account_1 = requireAccount();
  function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = void 0;
    if (!accountRef.isExotic) {
      let accountSlice = accountRef.beginParse();
      if (accountSlice.loadBit()) {
        account = (0, Account_1.loadAccount)(accountSlice);
      }
    }
    return {
      account,
      lastTransactionHash: slice.loadUintBig(256),
      lastTransactionLt: slice.loadUintBig(64)
    };
  }
  ShardAccount.loadShardAccount = loadShardAccount;
  function storeShardAccount(src) {
    return (builder2) => {
      if (src.account) {
        builder2.storeRef((0, Builder_1.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
      } else {
        builder2.storeRef((0, Builder_1.beginCell)().storeBit(false));
      }
      builder2.storeUint(src.lastTransactionHash, 256);
      builder2.storeUint(src.lastTransactionLt, 64);
    };
  }
  ShardAccount.storeShardAccount = storeShardAccount;
  return ShardAccount;
}
var ShardAccounts = {};
var hasRequiredShardAccounts;
function requireShardAccounts() {
  if (hasRequiredShardAccounts) return ShardAccounts;
  hasRequiredShardAccounts = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    const Dictionary_1 = requireDictionary();
    const DepthBalanceInfo_1 = requireDepthBalanceInfo();
    const ShardAccount_1 = requireShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src, builder2) {
        builder2.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder2.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src) {
      return (Builder2) => {
        Builder2.storeDict(src);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  })(ShardAccounts);
  return ShardAccounts;
}
var ShardIdent = {};
var hasRequiredShardIdent;
function requireShardIdent() {
  if (hasRequiredShardIdent) return ShardIdent;
  hasRequiredShardIdent = 1;
  Object.defineProperty(ShardIdent, "__esModule", { value: true });
  ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
  function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
      throw Error("Invalid data");
    }
    return {
      shardPrefixBits: slice.loadUint(6),
      workchainId: slice.loadInt(32),
      shardPrefix: slice.loadUintBig(64)
    };
  }
  ShardIdent.loadShardIdent = loadShardIdent;
  function storeShardIdent(src) {
    return (builder2) => {
      builder2.storeUint(0, 2);
      builder2.storeUint(src.shardPrefixBits, 6);
      builder2.storeInt(src.workchainId, 32);
      builder2.storeUint(src.shardPrefix, 64);
    };
  }
  ShardIdent.storeShardIdent = storeShardIdent;
  return ShardIdent;
}
var ShardStateUnsplit = {};
var hasRequiredShardStateUnsplit;
function requireShardStateUnsplit() {
  if (hasRequiredShardStateUnsplit) return ShardStateUnsplit;
  hasRequiredShardStateUnsplit = 1;
  Object.defineProperty(ShardStateUnsplit, "__esModule", { value: true });
  ShardStateUnsplit.loadShardStateUnsplit = void 0;
  const MasterchainStateExtra_1 = requireMasterchainStateExtra();
  const ShardAccounts_1 = requireShardAccounts();
  const ShardIdent_1 = requireShardIdent();
  function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 2418257890) {
      throw Error("Invalid data");
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    let shardAccountsRef = cs.loadRef();
    let accounts = void 0;
    if (!shardAccountsRef.isExotic) {
      accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    cs.loadRef();
    let mcStateExtra = cs.loadBit();
    let extras = null;
    if (mcStateExtra) {
      let cell = cs.loadRef();
      if (!cell.isExotic) {
        extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
      }
    }
    return {
      globalId,
      shardId,
      seqno,
      vertSeqNo,
      genUtime,
      genLt,
      minRefMcSeqno,
      beforeSplit,
      accounts,
      extras
    };
  }
  ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
  return ShardStateUnsplit;
}
var SplitMergeInfo = {};
var hasRequiredSplitMergeInfo;
function requireSplitMergeInfo() {
  if (hasRequiredSplitMergeInfo) return SplitMergeInfo;
  hasRequiredSplitMergeInfo = 1;
  Object.defineProperty(SplitMergeInfo, "__esModule", { value: true });
  SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
  function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
      currentShardPrefixLength,
      accountSplitDepth,
      thisAddress,
      siblingAddress
    };
  }
  SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
  function storeSplitMergeInfo(src) {
    return (builder2) => {
      builder2.storeUint(src.currentShardPrefixLength, 6);
      builder2.storeUint(src.accountSplitDepth, 6);
      builder2.storeUint(src.thisAddress, 256);
      builder2.storeUint(src.siblingAddress, 256);
    };
  }
  SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
  return SplitMergeInfo;
}
var Transaction = {};
var TransactionDescription = {};
var TransactionActionPhase = {};
var hasRequiredTransactionActionPhase;
function requireTransactionActionPhase() {
  if (hasRequiredTransactionActionPhase) return TransactionActionPhase;
  hasRequiredTransactionActionPhase = 1;
  Object.defineProperty(TransactionActionPhase, "__esModule", { value: true });
  TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
      success,
      valid,
      noFunds,
      statusChange,
      totalFwdFees,
      totalActionFees,
      resultCode,
      resultArg,
      totalActions,
      specActions,
      skippedActions,
      messagesCreated,
      actionListHash,
      totalMessageSize
    };
  }
  TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
  function storeTransactionActionPhase(src) {
    return (builder2) => {
      builder2.storeBit(src.success);
      builder2.storeBit(src.valid);
      builder2.storeBit(src.noFunds);
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
      builder2.storeMaybeCoins(src.totalFwdFees);
      builder2.storeMaybeCoins(src.totalActionFees);
      builder2.storeInt(src.resultCode, 32);
      builder2.storeMaybeInt(src.resultArg, 32);
      builder2.storeUint(src.totalActions, 16);
      builder2.storeUint(src.specActions, 16);
      builder2.storeUint(src.skippedActions, 16);
      builder2.storeUint(src.messagesCreated, 16);
      builder2.storeUint(src.actionListHash, 256);
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src.totalMessageSize));
    };
  }
  TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
  return TransactionActionPhase;
}
var TransactionBouncePhase = {};
var hasRequiredTransactionBouncePhase;
function requireTransactionBouncePhase() {
  if (hasRequiredTransactionBouncePhase) return TransactionBouncePhase;
  hasRequiredTransactionBouncePhase = 1;
  Object.defineProperty(TransactionBouncePhase, "__esModule", { value: true });
  TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionBouncePhase(slice) {
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let messageFees = slice.loadCoins();
      let forwardFees = slice.loadCoins();
      return {
        type: "ok",
        messageSize,
        messageFees,
        forwardFees
      };
    }
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let requiredForwardFees = slice.loadCoins();
      return {
        type: "no-funds",
        messageSize,
        requiredForwardFees
      };
    }
    return {
      type: "negative-funds"
    };
  }
  TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
  function storeTransactionBouncePhase(src) {
    return (builder2) => {
      if (src.type === "ok") {
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
        builder2.storeCoins(src.messageFees);
        builder2.storeCoins(src.forwardFees);
      } else if (src.type === "negative-funds") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      } else if (src.type === "no-funds") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
        builder2.storeCoins(src.requiredForwardFees);
      } else {
        throw new Error("Invalid TransactionBouncePhase type");
      }
    };
  }
  TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
  return TransactionBouncePhase;
}
var TransactionComputePhase = {};
var hasRequiredTransactionComputePhase;
function requireTransactionComputePhase() {
  if (hasRequiredTransactionComputePhase) return TransactionComputePhase;
  hasRequiredTransactionComputePhase = 1;
  Object.defineProperty(TransactionComputePhase, "__esModule", { value: true });
  TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
  const Builder_1 = requireBuilder$1();
  const ComputeSkipReason_1 = requireComputeSkipReason();
  function loadTransactionComputePhase(slice) {
    if (!slice.loadBit()) {
      let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
      return {
        type: "skipped",
        reason
      };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
      type: "vm",
      success,
      messageStateUsed,
      accountActivated,
      gasFees,
      gasUsed,
      gasLimit,
      gasCredit,
      mode,
      exitCode,
      exitArg,
      vmSteps,
      vmInitStateHash,
      vmFinalStateHash
    };
  }
  TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
  function storeTransactionComputePhase(src) {
    return (builder2) => {
      if (src.type === "skipped") {
        builder2.storeBit(0);
        builder2.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
        return;
      }
      builder2.storeBit(1);
      builder2.storeBit(src.success);
      builder2.storeBit(src.messageStateUsed);
      builder2.storeBit(src.accountActivated);
      builder2.storeCoins(src.gasFees);
      builder2.storeRef((0, Builder_1.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b2) => src.gasCredit !== void 0 && src.gasCredit !== null ? b2.storeBit(1).storeVarUint(src.gasCredit, 2) : b2.storeBit(0)).storeUint(src.mode, 8).storeInt(src.exitCode, 32).store((b2) => src.exitArg !== void 0 && src.exitArg !== null ? b2.storeBit(1).storeInt(src.exitArg, 32) : b2.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
    };
  }
  TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
  return TransactionComputePhase;
}
var TransactionCreditPhase = {};
var hasRequiredTransactionCreditPhase;
function requireTransactionCreditPhase() {
  if (hasRequiredTransactionCreditPhase) return TransactionCreditPhase;
  hasRequiredTransactionCreditPhase = 1;
  Object.defineProperty(TransactionCreditPhase, "__esModule", { value: true });
  TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
      dueFeesColelcted,
      credit
    };
  }
  TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
  function storeTransactionCreditPhase(src) {
    return (builder2) => {
      if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src.dueFeesColelcted);
      }
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
    };
  }
  TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
  return TransactionCreditPhase;
}
var TransactionStoragePhase = {};
var hasRequiredTransactionStoragePhase;
function requireTransactionStoragePhase() {
  if (hasRequiredTransactionStoragePhase) return TransactionStoragePhase;
  hasRequiredTransactionStoragePhase = 1;
  Object.defineProperty(TransactionStoragePhase, "__esModule", { value: true });
  TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = void 0;
    if (slice.loadBit()) {
      storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
      storageFeesCollected,
      storageFeesDue,
      statusChange
    };
  }
  TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
  function storeTransactionsStoragePhase(src) {
    return (builder2) => {
      builder2.storeCoins(src.storageFeesCollected);
      if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src.storageFeesDue);
      }
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
    };
  }
  TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  return TransactionStoragePhase;
}
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
  if (hasRequiredTransactionDescription) return TransactionDescription;
  hasRequiredTransactionDescription = 1;
  Object.defineProperty(TransactionDescription, "__esModule", { value: true });
  TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
  const Builder_1 = requireBuilder$1();
  const SplitMergeInfo_1 = requireSplitMergeInfo();
  const Transaction_1 = requireTransaction();
  const TransactionActionPhase_1 = requireTransactionActionPhase();
  const TransactionBouncePhase_1 = requireTransactionBouncePhase();
  const TransactionComputePhase_1 = requireTransactionComputePhase();
  const TransactionCreditPhase_1 = requireTransactionCreditPhase();
  const TransactionStoragePhase_1 = requireTransactionStoragePhase();
  function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0) {
      const creditFirst = slice.loadBit();
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let creditPhase = void 0;
      if (slice.loadBit()) {
        creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      let aborted = slice.loadBit();
      let bouncePhase = void 0;
      if (slice.loadBit()) {
        bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
      }
      const destroyed = slice.loadBit();
      return {
        type: "generic",
        creditFirst,
        storagePhase,
        creditPhase,
        computePhase,
        actionPhase,
        bouncePhase,
        aborted,
        destroyed
      };
    }
    if (type === 1) {
      return {
        type: "storage",
        storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
      };
    }
    if (type === 2 || type === 3) {
      const isTock = type === 3;
      let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "tick-tock",
        isTock,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 4) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "split-prepare",
        splitInfo,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 5) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
      const installed = slice.loadBit();
      return {
        type: "split-install",
        splitInfo,
        prepareTransaction,
        installed
      };
    }
    throw Error(`Unsupported transaction description type ${type}`);
  }
  TransactionDescription.loadTransactionDescription = loadTransactionDescription;
  function storeTransactionDescription(src) {
    return (builder2) => {
      if (src.type === "generic") {
        builder2.storeUint(0, 4);
        builder2.storeBit(src.creditFirst);
        if (src.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        if (src.creditPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        if (src.bouncePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.destroyed);
      } else if (src.type === "storage") {
        builder2.storeUint(1, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
      } else if (src.type === "tick-tock") {
        builder2.storeUint(src.isTock ? 3 : 2, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        builder2.storeBit(src.destroyed);
      } else if (src.type === "split-prepare") {
        builder2.storeUint(4, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
        if (src.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        builder2.storeBit(src.destroyed);
      } else if (src.type === "split-install") {
        builder2.storeUint(5, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
        builder2.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
        builder2.storeBit(src.installed);
      } else {
        throw Error(`Unsupported transaction description type ${src.type}`);
      }
    };
  }
  TransactionDescription.storeTransactionDescription = storeTransactionDescription;
  return TransactionDescription;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction) return Transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(Transaction, "__esModule", { value: true });
  Transaction.storeTransaction = Transaction.loadTransaction = void 0;
  const Builder_1 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  const AccountStatus_1 = requireAccountStatus();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const HashUpdate_1 = requireHashUpdate();
  const Message_1 = requireMessage();
  const TransactionDescription_1 = requireTransactionDescription();
  function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 7) {
      throw Error("Invalid data");
    }
    let address = slice.loadUintBig(256);
    let lt = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
      address,
      lt,
      prevTransactionHash,
      prevTransactionLt,
      now,
      outMessagesCount,
      oldStatus,
      endStatus,
      inMessage,
      outMessages,
      totalFees,
      stateUpdate,
      description,
      raw,
      hash: () => raw.hash()
    };
  }
  Transaction.loadTransaction = loadTransaction;
  function storeTransaction(src) {
    return (builder2) => {
      builder2.storeUint(7, 4);
      builder2.storeUint(src.address, 256);
      builder2.storeUint(src.lt, 64);
      builder2.storeUint(src.prevTransactionHash, 256);
      builder2.storeUint(src.prevTransactionLt, 64);
      builder2.storeUint(src.now, 32);
      builder2.storeUint(src.outMessagesCount, 15);
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
      let msgBuilder = (0, Builder_1.beginCell)();
      if (src.inMessage) {
        msgBuilder.storeBit(true);
        msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
      } else {
        msgBuilder.storeBit(false);
      }
      msgBuilder.storeDict(src.outMessages);
      builder2.storeRef(msgBuilder);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
      builder2.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
      builder2.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
    };
  }
  Transaction.storeTransaction = storeTransaction;
  return Transaction;
}
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = requireAccount();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = requireAccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = requireAccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = requireAccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = requireAccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = requireOutList();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = requireCommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = requireComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = requireCurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = requireDepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var ExtraCurrency_1 = requireExtraCurrency();
    Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyCell;
    } });
    Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyDict;
    } });
    Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadExtraCurrency;
    } });
    Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadMaybeExtraCurrency;
    } });
    Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.storeExtraCurrency;
    } });
    var HashUpdate_1 = requireHashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = requireMasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = requireMessage();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = requireMessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = requireSendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ReserveMode_1 = requireReserveMode();
    Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function() {
      return ReserveMode_1.ReserveMode;
    } });
    var ShardAccount_1 = requireShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = requireShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = requireShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = requireShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = requireSimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var LibRef_1 = requireLibRef();
    Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function() {
      return LibRef_1.loadLibRef;
    } });
    Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function() {
      return LibRef_1.storeLibRef;
    } });
    var SplitMergeInfo_1 = requireSplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = requireStateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInfo_1 = requireStorageInfo();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.storeStorageInfo;
    } });
    var StorageUsed_1 = requireStorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var TickTock_1 = requireTickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = requireTransaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = requireTransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = requireTransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = requireTransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = requireTransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = requireTransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = requireTransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  })(_export);
  return _export;
}
var openContract = {};
var hasRequiredOpenContract;
function requireOpenContract() {
  if (hasRequiredOpenContract) return openContract;
  hasRequiredOpenContract = 1;
  Object.defineProperty(openContract, "__esModule", { value: true });
  openContract.openContract = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  function openContract$1(src, factory) {
    let address;
    let init2 = null;
    if (!Address_1.Address.isAddress(src.address)) {
      throw Error("Invalid address");
    }
    address = src.address;
    if (src.init) {
      if (!(src.init.code instanceof Cell_1.Cell)) {
        throw Error("Invalid init.code");
      }
      if (!(src.init.data instanceof Cell_1.Cell)) {
        throw Error("Invalid init.data");
      }
      init2 = src.init;
    }
    let executor = factory({ address, init: init2 });
    return new Proxy(src, {
      get(target, prop) {
        const value = target[prop];
        if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send") || prop.startsWith("is"))) {
          if (typeof value === "function") {
            return (...args) => value.apply(target, [executor, ...args]);
          }
        }
        return value;
      }
    });
  }
  openContract.openContract = openContract$1;
  return openContract;
}
var ComputeError = {};
var hasRequiredComputeError;
function requireComputeError() {
  if (hasRequiredComputeError) return ComputeError;
  hasRequiredComputeError = 1;
  Object.defineProperty(ComputeError, "__esModule", { value: true });
  ComputeError.ComputeError = void 0;
  let ComputeError$1 = class ComputeError2 extends Error {
    constructor(message, exitCode, opts) {
      super(message);
      this.exitCode = exitCode;
      this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
      this.logs = opts && opts.logs ? opts.logs : null;
      Object.setPrototypeOf(this, ComputeError2.prototype);
    }
  };
  ComputeError.ComputeError = ComputeError$1;
  return ComputeError;
}
var getMethodId = {};
var hasRequiredGetMethodId;
function requireGetMethodId() {
  if (hasRequiredGetMethodId) return getMethodId;
  hasRequiredGetMethodId = 1;
  Object.defineProperty(getMethodId, "__esModule", { value: true });
  getMethodId.getMethodId = void 0;
  const TABLE = new Int16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ]);
  function crc162(data) {
    if (!(data instanceof Buffer)) {
      data = Buffer.from(data);
    }
    let crc = 0;
    for (let index2 = 0; index2 < data.length; index2++) {
      const byte = data[index2];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  }
  function getMethodId$1(name) {
    return crc162(name) & 65535 | 65536;
  }
  getMethodId.getMethodId = getMethodId$1;
  return getMethodId;
}
var safeSign = {};
var hasRequiredSafeSign;
function requireSafeSign() {
  if (hasRequiredSafeSign) return safeSign;
  hasRequiredSafeSign = 1;
  Object.defineProperty(safeSign, "__esModule", { value: true });
  safeSign.safeSignVerify = safeSign.safeSign = void 0;
  const crypto_1 = requireDist$1();
  const MIN_SEED_LENGTH = 8;
  const MAX_SEED_LENGTH = 64;
  function createSafeSignHash(cell, seed) {
    let seedData = Buffer.from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
      throw Error("Seed can	 be longer than 64 bytes");
    }
    if (seedData.length < MIN_SEED_LENGTH) {
      throw Error("Seed must be at least 8 bytes");
    }
    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
  }
  function safeSign$1(cell, secretKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
  }
  safeSign.safeSign = safeSign$1;
  function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
  }
  safeSign.safeSignVerify = safeSignVerify;
  return safeSign;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$1;
  hasRequiredDist = 1;
  (function(exports) {
    var __createBinding = dist$1 && dist$1.__createBinding || (Object.create ? (function(o4, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m[k2];
    }));
    var __exportStar = dist$1 && dist$1.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTupleItem = exports.parseTupleItem = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = requireAddress();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = requireExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = requireADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = requireContractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = requireBitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = requireBitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = requireBitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_1 = requireBuilder$1();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_1.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_1.beginCell;
    } });
    var Slice_1 = requireSlice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = requireCellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = requireCell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = requireDictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = requireExoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.convertToMerkleProof;
    } });
    var exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = requireExoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = requireGenerateMerkleProof();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProofDirect;
    } });
    var generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = requireTuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    Object.defineProperty(exports, "parseTupleItem", { enumerable: true, get: function() {
      return tuple_1.parseTupleItem;
    } });
    Object.defineProperty(exports, "serializeTupleItem", { enumerable: true, get: function() {
      return tuple_1.serializeTupleItem;
    } });
    var reader_1 = requireReader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = requireBuilder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = requireOpenContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = requireComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = requireConvert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = requireCrc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = requireCrc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = requireBase32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = requireGetMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = requireSafeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  })(dist$1);
  return dist$1;
}
var distExports$1 = requireDist();
const DEFAULT_DURABLE_EVENTS_CONFIG = {
  recoveryIntervalMs: 10 * 1e3,
  // 10 seconds
  processingTimeoutMs: 60 * 1e3,
  // 1 minute
  cleanupIntervalMs: 60 * 1e3,
  // 1 minute
  retentionMs: 60 * 10 * 1e3,
  // 10 minutes
  retryDelayMs: 500,
  // 500 milliseconds
  maxRetries: 20
  // 20 retry attempts
};
class JettonError extends Error {
  code;
  details;
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "JettonError";
  }
}
var JettonErrorCode;
(function(JettonErrorCode2) {
  JettonErrorCode2["INVALID_ADDRESS"] = "INVALID_ADDRESS";
  JettonErrorCode2["JETTON_NOT_FOUND"] = "JETTON_NOT_FOUND";
  JettonErrorCode2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
  JettonErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  JettonErrorCode2["INVALID_AMOUNT"] = "INVALID_AMOUNT";
  JettonErrorCode2["PREPARATION_FAILED"] = "PREPARATION_FAILED";
})(JettonErrorCode || (JettonErrorCode = {}));
function asMaybeAddressFriendly(data) {
  try {
    return asAddressFriendly(data);
  } catch {
    return null;
  }
}
function asAddressFriendly(data) {
  if (data instanceof distExports$1.Address) {
    return data.toString();
  }
  try {
    if (data)
      return distExports$1.Address.parse(data).toString();
  } catch {
  }
  throw new Error(`Can not convert to AddressFriendly from "${data}"`);
}
function formatWalletAddress(address, isTestnet = false) {
  if (typeof address === "string") {
    return distExports$1.Address.parse(address).toString({ bounceable: false, testOnly: isTestnet });
  }
  return address.toString({ bounceable: false, testOnly: isTestnet });
}
function isValidAddress(address) {
  if (typeof address !== "string") {
    return false;
  }
  try {
    distExports$1.Address.parse(address);
  } catch (_) {
    return false;
  }
  return true;
}
function isFriendlyTonAddress(address) {
  try {
    distExports$1.Address.parseFriendly(address);
  } catch (_) {
    return false;
  }
  return true;
}
function asHex(data) {
  if (!/^0x[0-9a-fA-F]+$/.test(data) || data.length % 2 !== 0) {
    throw new Error("Not a valid hex");
  }
  return data;
}
const ERROR_CODES = {
  // Bridge Manager Errors (7000-7099)
  BRIDGE_NOT_INITIALIZED: 7e3,
  BRIDGE_CONNECTION_FAILED: 7001,
  BRIDGE_EVENT_PROCESSING_FAILED: 7002,
  BRIDGE_RESPONSE_SEND_FAILED: 7003,
  // Session Errors (7100-7199)
  SESSION_NOT_FOUND: 7100,
  SESSION_ID_REQUIRED: 7101,
  SESSION_CREATION_FAILED: 7102,
  SESSION_DOMAIN_REQUIRED: 7103,
  SESSION_RESTORATION_FAILED: 7104,
  // Event Store Errors (7200-7299)
  EVENT_STORE_NOT_INITIALIZED: 7200,
  EVENT_STORE_OPERATION_FAILED: 7201,
  // Storage Errors (7300-7399)
  STORAGE_READ_FAILED: 7300,
  STORAGE_WRITE_FAILED: 7301,
  // Wallet Errors (7400-7499)
  WALLET_NOT_FOUND: 7400,
  WALLET_REQUIRED: 7401,
  WALLET_INVALID: 7402,
  WALLET_CREATION_FAILED: 7403,
  WALLET_INITIALIZATION_FAILED: 7404,
  LEDGER_DEVICE_ERROR: 7405,
  // Request Processing Errors (7500-7599)
  INVALID_REQUEST_EVENT: 7500,
  REQUEST_PROCESSING_FAILED: 7501,
  RESPONSE_CREATION_FAILED: 7502,
  APPROVAL_FAILED: 7503,
  REJECTION_FAILED: 7504,
  // API Client Errors (7600-7699)
  API_CLIENT_ERROR: 7600,
  TON_CLIENT_INITIALIZATION_FAILED: 7601,
  API_REQUEST_FAILED: 7602,
  ACCOUNT_NOT_FOUND: 7603,
  // Jetton/NFT Errors (7700-7799)
  JETTONS_MANAGER_ERROR: 7700,
  NFT_MANAGER_ERROR: 7701,
  // Contract Errors (7800-7899)
  CONTRACT_DEPLOYMENT_FAILED: 7800,
  CONTRACT_EXECUTION_FAILED: 7801,
  CONTRACT_VALIDATION_FAILED: 7802,
  // Network Errors (7850-7899)
  NETWORK_NOT_CONFIGURED: 7850,
  // Generic Errors (7900-7999)
  UNKNOWN_ERROR: 7900,
  VALIDATION_ERROR: 7901,
  INITIALIZATION_ERROR: 7902,
  CONFIGURATION_ERROR: 7903,
  NETWORK_ERROR: 7904,
  UNKNOWN_EMULATION_ERROR: 7905,
  INVALID_CONFIG: 7906
};
function getErrorCodeName(code) {
  const entry = Object.entries(ERROR_CODES).find(([, value]) => value === code);
  return entry ? entry[0] : `UNKNOWN_CODE_${code}`;
}
class WalletKitError extends Error {
  code;
  codeName;
  originalError;
  context;
  constructor(code, message, originalError, context) {
    const fullMessage = originalError ? `${message}: ${originalError.message}` : message;
    super(fullMessage);
    this.name = "WalletKitError";
    this.code = code;
    this.codeName = getErrorCodeName(code);
    this.originalError = originalError;
    this.context = context;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, WalletKitError);
    }
    if (originalError?.stack) {
      this.stack = `${this.stack}
Caused by: ${originalError.stack}`;
    }
  }
  /**
   * Create a WalletKitError from an unknown error
   */
  static fromError(code, message, error2, context) {
    if (error2 instanceof Error) {
      return new WalletKitError(code, message, error2, context);
    }
    const errorMessage = error2 && typeof error2 === "object" && "message" in error2 ? String(error2.message) : String(error2);
    return new WalletKitError(code, `${message}: ${errorMessage}`, void 0, { ...context, originalValue: error2 });
  }
  /**
   * Check if an error is a WalletKitError with a specific code
   */
  static isWalletKitError(error2, code) {
    if (!(error2 instanceof WalletKitError)) {
      return false;
    }
    if (code !== void 0) {
      return error2.code === code;
    }
    return true;
  }
  /**
   * Serialize error to JSON
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      codeName: this.codeName,
      context: this.context,
      stack: this.stack,
      originalError: this.originalError ? {
        name: this.originalError.name,
        message: this.originalError.message,
        stack: this.originalError.stack
      } : void 0
    };
  }
}
class BridgeError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.BRIDGE_NOT_INITIALIZED, message, originalError, context);
    this.name = "BridgeError";
  }
}
class SessionError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.SESSION_NOT_FOUND, message, originalError, context);
    this.name = "SessionError";
  }
}
class EventStoreError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.EVENT_STORE_NOT_INITIALIZED, message, originalError, context);
    this.name = "EventStoreError";
  }
}
class StorageError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.STORAGE_READ_FAILED, message, originalError, context);
    this.name = "StorageError";
  }
}
function Base64Normalize(data) {
  return data.replace(/\s+/g, "").replace(/-/g, "+").replace(/_/g, "/");
}
function Base64NormalizeUrl(data) {
  const normalized = Base64Normalize(data);
  const burl = normalized.replace(/-/g, "+").replace(/\//g, "_").replace(/=/g, "");
  return burl;
}
function ParseBase64(data) {
  if (typeof atob === "undefined" && typeof Buffer === "undefined") {
    throw new WalletKitError(ERROR_CODES.CONFIGURATION_ERROR, "atob function is not available in this environment");
  }
  data = Base64Normalize(data);
  return typeof atob === "function" ? atob(data) : Buffer.from(data, "base64").toString("utf-8");
}
function Base64ToHex(data) {
  if (!data)
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid hash: data is required");
  const binary2 = Base64ToUint8Array(data);
  if (!binary2)
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid hash: binary is required");
  return Uint8ArrayToHex(binary2);
}
function Uint8ArrayToHex(data) {
  return asHex(`0x${[...data].map((b2) => {
    if (b2 < 0 || b2 > 255)
      throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid byte: expected 0-255", void 0, {
        actualByte: b2
      });
    return b2.toString(16).padStart(2, "0");
  }).join("")}`);
}
function Base64ToUint8Array(data) {
  if (!data)
    return null;
  const binary2 = ParseBase64(data);
  const len = binary2.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary2.charCodeAt(i);
  }
  return bytes;
}
function Uint8ArrayToBase64(data) {
  if (typeof btoa === "undefined" && typeof Buffer === "undefined") {
    throw new Error("btoa is not available in this environment");
  }
  let binary2 = "";
  for (let i = 0; i < data.length; i++) {
    binary2 += String.fromCharCode(data[i]);
  }
  return typeof btoa === "function" ? btoa(binary2) : Buffer.from(data).toString("base64");
}
function Base64ToBigInt(data) {
  if (!data || data === "")
    return 0n;
  const binary2 = ParseBase64(data);
  const len = binary2.length;
  let result = 0n;
  for (let i = 0; i < len; i++) {
    result = (result << 8n) + BigInt(binary2.charCodeAt(i));
  }
  return result;
}
function BigIntToBase64(data) {
  if (data === 0n)
    return "";
  const bytes = [];
  let temp = data;
  while (temp > 0n) {
    bytes.push(Number(temp & 0xffn));
    temp >>= 8n;
  }
  const arr = new Uint8Array(bytes.reverse());
  return Uint8ArrayToBase64(arr);
}
function Uint8ArrayToBigInt(data) {
  let result = 0n;
  for (let i = 0; i < data.length; i++) {
    result = (result << 8n) + BigInt(data[i]);
  }
  return result;
}
function HexToBigInt(data) {
  return BigInt(data);
}
function HexToUint8Array(data) {
  const hex = data.slice(2);
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}
function HexToBase64(data) {
  return Uint8ArrayToBase64(HexToUint8Array(data));
}
function parseOutgoingTonTransfers(tx, addressBook, status) {
  const actions = [];
  for (const msg of tx.out_msgs || []) {
    const valueNum = toPositiveNumber(msg.value);
    if (valueNum === null) {
      continue;
    }
    const sender = msg.source ?? tx.account;
    const recipient = msg.destination;
    const amount = BigInt(valueNum);
    const recipientAccount = msg.init_state ? toContractAccount$3(recipient, addressBook) : toAccount(recipient, addressBook);
    const comment = extractComment(msg) ?? void 0;
    actions.push({
      type: "TonTransfer",
      id: Base64ToHex(tx.hash),
      status,
      TonTransfer: {
        sender: toAccount(sender, addressBook),
        recipient: recipientAccount,
        amount,
        ...comment !== void 0 ? { comment } : {}
      },
      simplePreview: {
        name: "Ton Transfer",
        description: `Transferring ${distExports$1.fromNano(String(amount))} TON`,
        value: `${distExports$1.fromNano(String(amount))} TON`,
        accounts: [toAccount(sender, addressBook), recipientAccount]
      },
      baseTransactions: [Base64ToHex(tx.hash)]
    });
  }
  return actions;
}
function parseIncomingTonTransfers(tx, addressBook, status) {
  const actions = [];
  const msg = tx.in_msg;
  if (!msg) {
    return actions;
  }
  const valueNum = toPositiveNumber(msg.value);
  if (valueNum === null) {
    return actions;
  }
  const sender = msg.source ?? tx.account;
  const recipient = msg.destination;
  const amount = BigInt(valueNum);
  const incomingStatus = computeIncomingTonTransferStatus(tx, status);
  const recipientAccount = msg.init_state ? toContractAccount$3(recipient, addressBook) : toAccount(recipient, addressBook);
  const comment = extractComment(msg) ?? void 0;
  actions.push({
    type: "TonTransfer",
    id: Base64ToHex(tx.hash),
    status: incomingStatus,
    TonTransfer: {
      sender: toAccount(sender, addressBook),
      recipient: recipientAccount,
      amount,
      ...comment !== void 0 ? { comment } : {}
    },
    simplePreview: {
      name: "Ton Transfer",
      description: `Transferring ${distExports$1.fromNano(String(amount))} TON`,
      value: `${distExports$1.fromNano(String(amount))} TON`,
      accounts: [toAccount(sender, addressBook), recipientAccount]
    },
    baseTransactions: [Base64ToHex(tx.hash)]
  });
  return actions;
}
function computeStatus$1(tx) {
  const aborted = Boolean(tx.description?.aborted);
  const computeSuccess = Boolean(tx.description?.compute_ph?.success);
  const actionSuccess = Boolean(tx.description?.action?.success);
  return !aborted && computeSuccess && actionSuccess ? "success" : "failure";
}
function computeIncomingTonTransferStatus(tx, defaultStatus) {
  const description = tx.description;
  const creditPh = description?.credit_ph;
  const credit = creditPh?.credit;
  if (credit && Number(credit) > 0) {
    return "success";
  }
  return defaultStatus;
}
function toPositiveNumber(value) {
  if (value === null || value === void 0) {
    return null;
  }
  const n = Number(value);
  if (!Number.isFinite(n) || n <= 0) {
    return null;
  }
  return n;
}
function extractComment(msg) {
  const decoded = msg.message_content && msg.message_content.decoded;
  if (decoded && typeof decoded === "object") {
    if (typeof decoded.comment === "string" && decoded.comment.length > 0) {
      return decoded.comment;
    }
    if (decoded["@type"] === "text_comment" && typeof decoded.text === "string" && decoded.text.length > 0) {
      return decoded.text;
    }
  }
  return null;
}
function toContractAccount$3(address, addressBook) {
  const acc = toAccount(address, addressBook);
  return { ...acc, isWallet: false };
}
function parseContractActions(ownerFriendly, transactions, addressBook) {
  const actions = [];
  for (const hash of Object.keys(transactions)) {
    const tx = transactions[hash];
    if (asAddressFriendly(tx.account) !== ownerFriendly)
      continue;
    const status = computeStatus$1(tx);
    for (const msg of tx.out_msgs || []) {
      if (!msg || !msg.destination)
        continue;
      if (!msg.opcode)
        continue;
      const contractAddress2 = msg.destination;
      const tonAttached = BigInt(Number(msg.value || "0"));
      const operation = msg.opcode;
      const child = findChildTransactionByInMsgHash(transactions, msg.hash);
      const baseTx = child ? Base64ToHex(child.hash) : Base64ToHex(tx.hash);
      const exec = {
        type: "SmartContractExec",
        id: Base64ToHex(tx.hash),
        status,
        SmartContractExec: {
          executor: toAccount(ownerFriendly, addressBook),
          contract: toContractAccount$2(contractAddress2, addressBook),
          tonAttached,
          operation,
          payload: ""
        },
        simplePreview: {
          name: "Smart Contract Execution",
          description: "Execution of smart contract",
          value: `${distExports$1.fromNano(String(tonAttached))} TON`,
          accounts: [toAccount(ownerFriendly, addressBook), toContractAccount$2(contractAddress2, addressBook)]
        },
        baseTransactions: [baseTx]
      };
      actions.push(exec);
      if (child && isDeploy(child, msg)) {
        const deploy = {
          type: "ContractDeploy",
          id: Base64ToHex(child.hash),
          status: computeStatus$1(child),
          ContractDeploy: {
            address: asAddressFriendly(contractAddress2),
            interfaces: []
          },
          simplePreview: {
            name: "Contract Deploy",
            description: "Deploying a contract",
            value: "",
            accounts: [toContractAccount$2(contractAddress2, addressBook)]
          },
          baseTransactions: [baseTx]
        };
        actions.push(deploy);
      }
    }
  }
  return actions;
}
function isDeploy(child, msg) {
  const created = child.orig_status === "nonexist" && child.end_status === "active";
  const hasInit = Boolean(msg.init_state) || Boolean(child.in_msg && child.in_msg.init_state);
  return created || hasInit;
}
function findChildTransactionByInMsgHash(transactions, inMsgHashBase64) {
  for (const key of Object.keys(transactions)) {
    const t = transactions[key];
    if (t.in_msg && t.in_msg.hash === inMsgHashBase64)
      return t;
  }
  return null;
}
function toContractAccount$2(address, addressBook) {
  const acc = toAccount(address, addressBook);
  return { ...acc, isWallet: false };
}
var OpCode;
(function(OpCode2) {
  OpCode2["JettonTransfer"] = "0x0f8a7ea5";
  OpCode2["JettonInternalTransfer"] = "0x178d4519";
  OpCode2["JettonNotify"] = "0x7362d09c";
  OpCode2["JettonBurn"] = "0x595f07bc";
  OpCode2["JettonMint"] = "0x15";
  OpCode2["NftTransfer"] = "0x5fcc3d14";
  OpCode2["NftOwnershipAssigned"] = "0x05138d91";
  OpCode2["NftOwnerChanged"] = "0x7bdd97de";
  OpCode2["NftGetStaticData"] = "0x2fcb26a2";
  OpCode2["NftReportStaticData"] = "0x8b771735";
  OpCode2["Excess"] = "0xd53276db";
  OpCode2["WalletV4Transfer"] = "0x0";
  OpCode2["DnsResolve"] = "0x19f02441";
  OpCode2["DnsChangeRecord"] = "0x4eb1f0f9";
  OpCode2["DexSwap"] = "0x25938561";
  OpCode2["DexProvideLiquidity"] = "0xfcf9e58f";
})(OpCode || (OpCode = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["JettonTransfer"] = "jetton_transfer";
  MessageType2["JettonInternalTransfer"] = "jetton_internal_transfer";
  MessageType2["JettonNotify"] = "jetton_notify";
  MessageType2["JettonBurn"] = "jetton_burn";
  MessageType2["JettonMint"] = "jetton_mint";
  MessageType2["NftTransfer"] = "nft_transfer";
  MessageType2["NftOwnershipAssigned"] = "nft_ownership_assigned";
  MessageType2["NftOwnerChanged"] = "nft_owner_changed";
  MessageType2["Excess"] = "excess";
  MessageType2["TonTransfer"] = "ton_transfer";
  MessageType2["ContractExec"] = "contract_exec";
  MessageType2["ContractDeploy"] = "contract_deploy";
  MessageType2["Unknown"] = "unknown";
})(MessageType || (MessageType = {}));
const OpCodeMapping = {
  [OpCode.JettonTransfer]: MessageType.JettonTransfer,
  [OpCode.JettonInternalTransfer]: MessageType.JettonInternalTransfer,
  [OpCode.JettonNotify]: MessageType.JettonNotify,
  [OpCode.JettonBurn]: MessageType.JettonBurn,
  [OpCode.JettonMint]: MessageType.JettonMint,
  [OpCode.NftTransfer]: MessageType.NftTransfer,
  [OpCode.NftOwnershipAssigned]: MessageType.NftOwnershipAssigned,
  [OpCode.NftOwnerChanged]: MessageType.NftOwnerChanged,
  [OpCode.NftGetStaticData]: MessageType.Unknown,
  [OpCode.NftReportStaticData]: MessageType.Unknown,
  [OpCode.Excess]: MessageType.Excess,
  [OpCode.WalletV4Transfer]: MessageType.TonTransfer,
  [OpCode.DnsResolve]: MessageType.Unknown,
  [OpCode.DnsChangeRecord]: MessageType.Unknown,
  [OpCode.DexSwap]: MessageType.Unknown,
  [OpCode.DexProvideLiquidity]: MessageType.Unknown
};
({
  [MessageType.JettonTransfer]: OpCode.JettonTransfer,
  [MessageType.JettonInternalTransfer]: OpCode.JettonInternalTransfer,
  [MessageType.JettonNotify]: OpCode.JettonNotify,
  [MessageType.JettonBurn]: OpCode.JettonBurn,
  [MessageType.JettonMint]: OpCode.JettonMint,
  [MessageType.NftTransfer]: OpCode.NftTransfer,
  [MessageType.NftOwnershipAssigned]: OpCode.NftOwnershipAssigned,
  [MessageType.NftOwnerChanged]: OpCode.NftOwnerChanged,
  [MessageType.Excess]: OpCode.Excess,
  [MessageType.TonTransfer]: OpCode.WalletV4Transfer,
  [MessageType.ContractExec]: void 0,
  [MessageType.ContractDeploy]: void 0,
  [MessageType.Unknown]: void 0
});
const LegacyOpCodeMap = {
  "0x0f8a7ea5": "jetton_transfer",
  "0x178d4519": "jetton_internal_transfer",
  "0x7362d09c": "jetton_notify",
  "0x595f07bc": "jetton_burn",
  "0xd53276db": "excess",
  "0x5fcc3d14": "nft_transfer",
  "0x05138d91": "nft_ownership_assigned",
  "0x7bdd97de": "nft_owner_changed"
};
function resolveOpCode(opcode) {
  const normalized = opcode.toLowerCase();
  for (const [_key, value] of Object.entries(OpCode)) {
    if (value.toLowerCase() === normalized) {
      return OpCodeMapping[value];
    }
  }
  const legacy = LegacyOpCodeMap[normalized];
  if (legacy) {
    return legacy;
  }
  return MessageType.Unknown;
}
class MessagePatternRegistry {
  patterns = /* @__PURE__ */ new Map();
  /**
   * Register a pattern for a message type
   */
  register(pattern) {
    const existing = this.patterns.get(pattern.messageType) || [];
    existing.push(pattern);
    this.patterns.set(pattern.messageType, existing);
  }
  /**
   * Find matching pattern for a message
   */
  match(msg) {
    for (const patterns of this.patterns.values()) {
      for (const pattern of patterns) {
        if (pattern.match(msg)) {
          return pattern;
        }
      }
    }
    return null;
  }
  /**
   * Get all patterns for a message type
   */
  getPatterns(messageType) {
    return this.patterns.get(messageType) || [];
  }
}
const messagePatternRegistry = new MessagePatternRegistry();
function getDecodedBody(msg) {
  if (!msg)
    return null;
  const mc = msg.message_content;
  if (isRecord$2(mc)) {
    const decoded = mc.decoded;
    return isRecord$2(decoded) ? decoded : null;
  }
  return null;
}
function getDecodedType(msg) {
  const decoded = getDecodedBody(msg);
  if (decoded) {
    const type = decoded["@type"];
    if (typeof type === "string")
      return type;
    const value = decoded["value"];
    if (isRecord$2(value) && typeof value["@type"] === "string") {
      return value["@type"];
    }
  }
  return null;
}
function isRecord$2(v2) {
  return typeof v2 === "object" && v2 !== null;
}
messagePatternRegistry.register({
  messageType: MessageType.JettonTransfer,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x0f8a7ea5" || type === "jetton_transfer" || decoded !== null && decoded["@type"] === "jetton_transfer";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.JettonInternalTransfer,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x178d4519" || type === "jetton_internal_transfer" || decoded !== null && decoded["@type"] === "jetton_internal_transfer";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.JettonNotify,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x7362d09c" || type === "jetton_notify" || decoded !== null && decoded["@type"] === "jetton_notify";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.NftTransfer,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x5fcc3d14" || type === "nft_transfer" || decoded !== null && decoded["@type"] === "nft_transfer";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.NftOwnershipAssigned,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x05138d91" || type === "nft_ownership_assigned" || decoded !== null && decoded["@type"] === "nft_ownership_assigned";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.NftOwnerChanged,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x7bdd97de" || type === "nft_owner_changed" || decoded !== null && decoded["@type"] === "nft_owner_changed";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.Excess,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0xd53276db" || type === "excess" || decoded !== null && decoded["@type"] === "excess";
  },
  decode: (msg) => getDecodedBody(msg)
});
function getDecoded(msg) {
  return getDecodedBody(msg);
}
function extractOpFromBody(msg) {
  return getDecodedType(msg);
}
function matchOpWithMap(op, types, mapping) {
  if (!op)
    return "";
  const messageType = resolveOpCode(op);
  if (messageType !== MessageType.Unknown) {
    const typeString = messageType;
    if (types.includes(typeString)) {
      return typeString;
    }
  }
  const normalized = mapping[op] ?? op;
  return types.includes(normalized) ? normalized : "";
}
function parseJettonActions(ownerFriendly, item, addressBook) {
  const actions = [];
  const txs = item.transactions || {};
  let added = false;
  for (const key of Object.keys(txs)) {
    const tx = txs[key];
    const inMsg = tx.in_msg;
    const decoded = getDecoded(inMsg);
    if (!decoded)
      continue;
    if (decoded["@type"] === "jetton_transfer" && inMsg?.source && asAddressFriendly(inMsg.source) === ownerFriendly) {
      const amount = toBigInt(readAmountValue(getProp$1(decoded, "amount")));
      const dest = toAddr$1(getProp$1(decoded, "destination"));
      const comment = extractCommentFromDecoded(getForwardPayloadValue(decoded)) ?? void 0;
      const senderWallet = asAddressFriendly(tx.account);
      const recipientWallet = findRecipientJettonWalletFromOut(tx);
      const status = computeStatus(tx);
      const id = findFirstOwnerTxId(ownerFriendly, item) ?? Base64ToHex(tx.hash);
      const base = collectBaseTransactionsSent(item, ownerFriendly);
      const jetton = buildJettonInfo(item, senderWallet, addressBook);
      const action = {
        type: "JettonTransfer",
        id,
        status,
        JettonTransfer: {
          sender: toAccount(ownerFriendly, addressBook),
          recipient: toAccount(dest, addressBook),
          sendersWallet: senderWallet,
          recipientsWallet: recipientWallet ?? "",
          amount,
          comment,
          jetton
        },
        simplePreview: jettonPreview(amount, jetton.symbol, jetton.decimals, jetton.image, [
          toAccount(dest, addressBook),
          toAccount(ownerFriendly, addressBook),
          toContractAccount$1(jetton.address || inferMinterFromAddressBook(addressBook)?.address || "", addressBook)
        ]),
        baseTransactions: base
      };
      actions.push(action);
      added = true;
    }
  }
  if (!added)
    for (const key of Object.keys(txs)) {
      const tx = txs[key];
      if (asAddressFriendly(tx.account) === ownerFriendly)
        continue;
      const inMsg = tx.in_msg;
      const decoded = getDecoded(inMsg);
      if (!decoded)
        continue;
      if (decoded["@type"] === "jetton_internal_transfer") {
        const amount = toBigInt(readAmountValue(getProp$1(decoded, "amount")));
        const senderMain = toAddr$1(getProp$1(decoded, "from"));
        const recipientWallet = asAddressFriendly(tx.account);
        const senderWallet = asAddressFriendly(inMsg.source);
        const status = computeStatus(tx);
        const id = getTraceRootId(item) ?? Base64ToHex(tx.hash);
        const base = collectBaseTransactionsReceived(item, ownerFriendly);
        const jetton = buildJettonInfo(item, recipientWallet, addressBook);
        const action = {
          type: "JettonTransfer",
          id,
          status,
          JettonTransfer: {
            sender: toAccount(senderMain, addressBook),
            recipient: toAccount(ownerFriendly, addressBook),
            sendersWallet: senderWallet,
            recipientsWallet: recipientWallet,
            amount,
            jetton
          },
          simplePreview: jettonPreview(amount, jetton.symbol, jetton.decimals, jetton.image, [
            toAccount(ownerFriendly, addressBook),
            toAccount(senderMain, addressBook),
            toContractAccount$1(jetton.address || inferMinterFromAddressBook(addressBook)?.address || "", addressBook)
          ]),
          baseTransactions: base
        };
        actions.push(action);
        added = true;
      }
    }
  return actions;
}
function extractCommentFromDecoded(decoded) {
  if (!isRecord$1(decoded))
    return null;
  const t = decoded["@type"];
  if (t === "text_comment") {
    const txt = decoded["text"];
    if (typeof txt === "string" && txt.length > 0)
      return txt;
  }
  return null;
}
function toBigInt(value) {
  if (value === void 0 || value === null)
    return BigInt(0);
  const n = typeof value === "string" ? Number(value) : value;
  return BigInt(Number.isFinite(n) ? n : 0);
}
function toAddr$1(raw) {
  if (!raw)
    return "";
  if (typeof raw === "string") {
    if (/^[A-Fa-f0-9]{64}$/.test(raw)) {
      return asAddressFriendly(`0:${raw}`);
    }
    return asAddressFriendly(raw);
  }
  if (isRecord$1(raw)) {
    const wc = raw["workchain_id"];
    const addr = raw["address"];
    if ((typeof wc === "string" || typeof wc === "number") && typeof addr === "string") {
      return asAddressFriendly(`${wc}:${addr}`);
    }
  }
  return "";
}
function jettonPreview(amount, symbol, decimals, image, accounts) {
  let denom = BigInt(1);
  for (let i = 0; i < (decimals || 0); i++)
    denom = denom * BigInt(10);
  const value = Number(amount) / Number(denom);
  const human = symbol ? `${trimAmount(value)} ${symbol}` : `${trimAmount(value)}`;
  const preview = {
    name: "Jetton Transfer",
    description: `Transferring ${human}`,
    value: human,
    accounts
  };
  if (image)
    preview.valueImage = image;
  return preview;
}
function computeStatus(tx) {
  const aborted = Boolean(tx.description?.aborted);
  const computePh = tx.description?.["compute_ph"];
  const action = tx.description?.["action"];
  const computeSuccess = Boolean(computePh && Boolean(computePh["success"]));
  const actionSuccess = Boolean(action && Boolean(action["success"]));
  return !aborted && computeSuccess && actionSuccess ? "success" : "failure";
}
function findFirstOwnerTxId(ownerFriendly, item) {
  for (const h2 of item.transactions_order || []) {
    const tx = item.transactions[h2];
    if (tx && asAddressFriendly(tx.account) === ownerFriendly) {
      return Base64ToHex(h2);
    }
  }
  return null;
}
function getTraceRootId(item) {
  const first = (item.transactions_order || [])[0];
  return first ? Base64ToHex(first) : null;
}
function findRecipientJettonWalletFromOut(tx) {
  for (const m of tx.out_msgs || []) {
    const d = getDecoded(m);
    if (m.opcode === OpCode.JettonInternalTransfer || d && d["@type"] === "jetton_internal_transfer") {
      return asAddressFriendly(m.destination);
    }
  }
  return null;
}
function collectBaseTransactionsSent(item, ownerFriendly) {
  const order = item.transactions_order || [];
  const pairs = [];
  for (const h2 of order) {
    const tx = item.transactions[h2];
    if (!tx)
      continue;
    if (asAddressFriendly(tx.account) === ownerFriendly)
      continue;
    const t = getTxType(tx);
    if (t)
      pairs.push({ type: t, hex: Base64ToHex(h2) });
  }
  const priority = {
    jetton_transfer: 1,
    jetton_notify: 2,
    jetton_internal_transfer: 3,
    excess: 4
  };
  pairs.sort((a2, b2) => (priority[a2.type] ?? 99) - (priority[b2.type] ?? 99));
  return pairs.map((p2) => p2.hex);
}
function collectBaseTransactionsReceived(item, ownerFriendly) {
  const order = item.transactions_order || [];
  const findTx = (predicate) => {
    for (const h2 of order) {
      const tx = item.transactions[h2];
      if (!tx)
        continue;
      if (predicate(tx))
        return Base64ToHex(h2);
    }
    return null;
  };
  const root = getTraceRootId(item);
  const isType = (tx, type) => getTxType(tx) === type;
  const jt = findTx((tx) => isType(tx, "jetton_transfer"));
  const internal = findTx((tx) => isType(tx, "jetton_internal_transfer") && asAddressFriendly(tx.account) !== ownerFriendly);
  const excess = findTx((tx) => isType(tx, "excess"));
  const out = [];
  if (root)
    out.push(root);
  if (jt)
    out.push(jt);
  if (internal)
    out.push(internal);
  if (excess)
    out.push(excess);
  return out;
}
function getTxType(tx) {
  const fromBody = extractOpFromBody(tx.in_msg);
  return matchOpWithMap(fromBody || tx.in_msg?.opcode || "", ["jetton_transfer", "jetton_internal_transfer", "jetton_notify", "excess"], {
    [OpCode.JettonTransfer]: "jetton_transfer",
    [OpCode.JettonInternalTransfer]: "jetton_internal_transfer",
    [OpCode.JettonNotify]: "jetton_notify",
    [OpCode.Excess]: "excess"
  });
}
function buildJettonInfo(item, walletFriendly, addressBook) {
  const walletInfo = addressBook[walletFriendly];
  if (walletInfo?.jettonWallet?.jettonMaster) {
    const masterAddress = asMaybeAddressFriendly(walletInfo.jettonWallet.jettonMaster);
    const masterInfo = masterAddress ? addressBook[masterAddress] : void 0;
    if (masterInfo?.jetton) {
      return masterInfo.jetton;
    }
  }
  const metadata = item.metadata;
  let master;
  if (metadata) {
    for (const [raw, infoAny] of Object.entries(metadata)) {
      const info2 = infoAny;
      const tokenInfo = info2["token_info"];
      if (!Array.isArray(tokenInfo))
        continue;
      for (const tAny of tokenInfo) {
        const t = tAny;
        if (t["type"] === "jetton_wallets") {
          const extra = t["extra"];
          const owner = extra?.["owner"];
          if (typeof owner === "string" && asAddressFriendly(owner) && asAddressFriendly(raw) === walletFriendly) {
            const j = extra?.["jetton"];
            if (typeof j === "string")
              master = j;
          }
        }
      }
    }
  }
  let name = "";
  let symbol = "";
  let decimals = 0;
  let image;
  if (master && metadata && metadata[master]) {
    const m = metadata[master];
    name = m["name"] || "";
    symbol = m["symbol"] || "";
    const extra = m["extra"];
    const dec = extra?.["decimals"];
    decimals = typeof dec === "string" ? parseInt(dec, 10) : 0;
    image = m["image"] || extra?.["_image_small"] || extra?.["_image_medium"] || extra?.["_image_big"];
  }
  let outAddress = master ? asAddressFriendly(master) : "";
  if (!outAddress) {
    const inferred = inferMinterFromAddressBook(addressBook);
    if (inferred) {
      outAddress = inferred.address;
      if (!name)
        name = inferred.name;
      if (!symbol)
        symbol = inferred.symbol;
      if (!decimals)
        decimals = inferred.decimals;
      if (!image)
        image = inferred.image;
    }
  }
  return {
    address: outAddress,
    name,
    symbol,
    decimals,
    image: image ?? "",
    verification: "whitelist",
    score: 100
  };
}
function toContractAccount$1(address, addressBook) {
  const acct = toAccount(address, addressBook);
  return { ...acct, isWallet: false };
}
function inferMinterFromAddressBook(addressBook) {
  const knownMinterByDomain = "usdt-minter.ton";
  for (const key of Object.keys(addressBook)) {
    const entry = addressBook[key];
    const domain = entry && entry.domain;
    if (domain === knownMinterByDomain || typeof domain === "string" && domain.includes("minter")) {
      return {
        address: key,
        name: "Tether USD",
        symbol: "USD",
        decimals: 6,
        image: "https://cache.tonapi.io/imgproxy/T3PB4s7oprNVaJkwqbGg54nexKE0zzKhcrPv8jcWYzU/rs:fill:200:200:1/g:no/aHR0cHM6Ly90ZXRoZXIudG8vaW1hZ2VzL2xvZ29DaXJjbGUucG5n.webp"
      };
    }
  }
  return null;
}
function trimAmount(v2) {
  if (v2 >= 1)
    return `${Number(v2.toFixed(3)).toString().replace(/\.0+$/, "")}`;
  const s2 = v2.toFixed(9);
  return s2.replace(/0+$/, "").replace(/\.$/, "");
}
function isRecord$1(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getProp$1(obj, key) {
  return isRecord$1(obj) ? obj[key] : void 0;
}
function readAmountValue(obj) {
  if (!isRecord$1(obj))
    return void 0;
  const v2 = obj["value"];
  if (typeof v2 === "string" || typeof v2 === "number")
    return v2;
  return void 0;
}
function getForwardPayloadValue(decoded) {
  const fp = getProp$1(decoded, "forward_payload");
  return isRecord$1(fp) ? fp["value"] : void 0;
}
function parseNftActions(ownerFriendly, item, addressBook) {
  const actions = [];
  const txs = item.transactions || {};
  for (const key of Object.keys(txs)) {
    const tx = txs[key];
    if (asAddressFriendly(tx.account) !== ownerFriendly)
      continue;
    for (const out of tx.out_msgs || []) {
      const decoded = getDecoded(out);
      if (decoded?.["@type"] === "nft_transfer") {
        const newOwner = toAddr(getProp(decoded, "new_owner"));
        const nftAddr = out.destination ? asAddressFriendly(out.destination) : "";
        const status = computeStatus$1(tx);
        const base = collectBaseTransactionsForSent(item, ownerFriendly, newOwner, nftAddr);
        const action = buildNftAction(status, ownerFriendly, newOwner, nftAddr, addressBook, base);
        actions.push(action);
      }
    }
  }
  for (const key of Object.keys(txs)) {
    const tx = txs[key];
    const acc = asAddressFriendly(tx.account);
    const decoded = getDecoded(tx.in_msg);
    if (!decoded)
      continue;
    const t = decoded["@type"];
    if (acc === ownerFriendly && (t === "nft_ownership_assigned" || t === "nft_owner_changed")) {
      const prevOwner = toAddr(getProp(decoded, "prev_owner")) || toAddr(getProp(decoded, "old_owner"));
      const nftAddr = tx.in_msg?.source ? asAddressFriendly(tx.in_msg.source) : "";
      const nftTx = findTransactionByAccount(item, nftAddr);
      const status = nftTx ? computeStatus$1(nftTx) : computeStatus$1(tx);
      const base = collectBaseTransactionsForReceived(item, ownerFriendly, nftAddr);
      const action = buildNftAction(status, prevOwner, ownerFriendly, nftAddr, addressBook, base);
      actions.push(action);
    }
  }
  return actions;
}
function buildNftAction(status, senderFriendly, recipientFriendly, nftAddress, addressBook, base) {
  const preview = {
    name: "NFT Transfer",
    description: "Transferring 1 NFT",
    value: "1 NFT",
    accounts: [
      toAccount(recipientFriendly, addressBook),
      toAccount(senderFriendly, addressBook),
      toContractAccount(nftAddress, addressBook)
    ]
  };
  return {
    type: "NftItemTransfer",
    id: base[0] || "",
    status,
    NftItemTransfer: {
      sender: toAccount(senderFriendly, addressBook),
      recipient: toAccount(recipientFriendly, addressBook),
      nft: nftAddress
    },
    simplePreview: preview,
    baseTransactions: base
  };
}
function collectBaseTransactionsForSent(item, ownerFriendly, newOwner, nftAddr) {
  const order = item.transactions_order || [];
  let ownerTonFromNft = null;
  let assignToNewOwner = null;
  let nftTransferHash = null;
  for (const h2 of order) {
    const tx = item.transactions[h2];
    if (!tx)
      continue;
    const acc = asAddressFriendly(tx.account);
    const t = getNftType(tx);
    if (!ownerTonFromNft && acc === ownerFriendly && tx.in_msg?.source && asAddressFriendly(tx.in_msg.source) === nftAddr) {
      ownerTonFromNft = Base64ToHex(h2);
    }
    if (!assignToNewOwner && acc === asAddressFriendly(newOwner) && (t === "nft_ownership_assigned" || t === "nft_owner_changed")) {
      assignToNewOwner = Base64ToHex(h2);
    }
    if (!nftTransferHash && acc === nftAddr && t === "nft_transfer") {
      nftTransferHash = Base64ToHex(h2);
    }
  }
  return [ownerTonFromNft, assignToNewOwner, nftTransferHash].filter(Boolean);
}
function getNftType(tx) {
  const t = extractOpFromBody(tx.in_msg) || tx.in_msg?.opcode || "";
  return matchOpWithMap(t, ["nft_transfer", "nft_ownership_assigned", "nft_owner_changed", "excess"], {
    [OpCode.NftTransfer]: "nft_transfer",
    [OpCode.NftOwnershipAssigned]: "nft_ownership_assigned",
    [OpCode.NftOwnerChanged]: "nft_owner_changed",
    [OpCode.Excess]: "excess"
  });
}
function collectBaseTransactionsForReceived(item, ownerFriendly, nftAddr) {
  const order = item.transactions_order || [];
  let ownerFromNft = null;
  const outToOwner = [];
  const others = [];
  for (const h2 of order) {
    const tx = item.transactions[h2];
    if (!tx)
      continue;
    const acc = asAddressFriendly(tx.account);
    if (!ownerFromNft && acc === ownerFriendly && tx.in_msg?.source && asAddressFriendly(tx.in_msg.source) === nftAddr) {
      ownerFromNft = Base64ToHex(h2);
      continue;
    }
    if (acc !== ownerFriendly) {
      const hex = Base64ToHex(h2);
      const targetsOwner = (tx.out_msgs || []).some((m) => asAddressFriendly(m.destination) === ownerFriendly);
      if (targetsOwner)
        outToOwner.push(hex);
      others.push(hex);
    }
  }
  const firstOther = outToOwner[0] || null;
  const base = [];
  if (firstOther)
    base.push(firstOther);
  const second = others.find((h2) => h2 !== firstOther) || null;
  if (second)
    base.push(second);
  if (ownerFromNft)
    base.push(ownerFromNft);
  return base;
}
function toContractAccount(address, addressBook) {
  const acc = toAccount(address, addressBook);
  return { ...acc, isWallet: false };
}
function findTransactionByAccount(item, account) {
  for (const key of Object.keys(item.transactions || {})) {
    const t = item.transactions[key];
    if (t && asAddressFriendly(t.account) === account)
      return t;
  }
  return null;
}
function toAddr(raw) {
  if (!raw)
    return "";
  if (typeof raw === "string") {
    if (/^[A-Fa-f0-9]{64}$/.test(raw))
      return asAddressFriendly(`0:${raw}`);
    return asAddressFriendly(raw);
  }
  if (isRecord(raw)) {
    const wc = raw["workchain_id"];
    const addr = raw["address"];
    if ((typeof wc === "string" || typeof wc === "number") && typeof addr === "string") {
      return asAddressFriendly(`${wc}:${addr}`);
    }
  }
  return "";
}
function isRecord(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getProp(obj, key) {
  return isRecord(obj) ? obj[key] : void 0;
}
function toAddressBook$1(data) {
  const out = {};
  for (const [address, bookRow] of Object.entries(data.address_book)) {
    const friendly = asAddressFriendly(address);
    if (bookRow.domain) {
      out[friendly] = { domain: bookRow.domain };
    }
    if (bookRow.interfaces && Array.isArray(bookRow.interfaces)) {
      const hasWalletInterface = bookRow.interfaces.some((iface) => typeof iface === "string" && iface.toLowerCase().includes("wallet"));
      if (hasWalletInterface) {
        if (!out[friendly]) {
          out[friendly] = {};
        }
        out[friendly].isWallet = true;
      }
    }
  }
  for (const [address, meta] of Object.entries(data.metadata)) {
    const friendly = asAddressFriendly(address);
    if (!out[friendly]) {
      out[friendly] = {};
    }
    if (!meta.token_info)
      continue;
    for (const tokenInfo of meta.token_info) {
      if (tokenInfo.type === "jetton_masters") {
        const masterInfo = tokenInfo;
        const decimals = masterInfo.extra?.decimals ? parseInt(masterInfo.extra.decimals, 10) : 0;
        const image = masterInfo.image || masterInfo.extra?._image_small || masterInfo.extra?._image_medium || masterInfo.extra?._image_big || "";
        out[friendly].jetton = {
          address: friendly,
          name: masterInfo.name || "",
          symbol: masterInfo.symbol || "",
          decimals,
          image,
          verification: "whitelist",
          score: 100
        };
      } else if (tokenInfo.type === "jetton_wallets") {
        const walletInfo = tokenInfo;
        out[friendly].jettonWallet = {
          balance: walletInfo.extra?.balance || "0",
          jettonMaster: asAddressFriendly(walletInfo.extra?.jetton || ""),
          owner: asAddressFriendly(walletInfo.extra?.owner || "")
        };
      }
    }
  }
  return out;
}
function buildEvent(data, account, actions, addressBook) {
  return {
    eventId: Base64ToHex(data.trace_id),
    account: toAccount(account, addressBook),
    timestamp: data.start_utime,
    actions,
    isScam: false,
    lt: Number(data.start_lt),
    inProgress: data.is_incomplete,
    trace: data.trace,
    transactions: data.transactions
  };
}
function filterActionsByPriority(actions) {
  const hasJetton = actions.some((a2) => a2.type === "JettonTransfer");
  const hasNft = actions.some((a2) => a2.type === "NftItemTransfer");
  if (hasJetton || hasNft) {
    const keepTypes = hasJetton ? ["JettonTransfer"] : ["NftItemTransfer"];
    return actions.filter((a2) => keepTypes.includes(a2.type));
  }
  return actions;
}
function toEvent(data, account, addressBook = {}) {
  const accountFriendly = asAddressFriendly(account);
  const transactions = data.transactions || {};
  const actions = [];
  for (const txHash of Object.keys(transactions)) {
    const tx = transactions[txHash];
    if (asAddressFriendly(tx.account) !== accountFriendly) {
      continue;
    }
    const status = computeStatus$1(tx);
    actions.push(...parseOutgoingTonTransfers(tx, addressBook, status), ...parseIncomingTonTransfers(tx, addressBook, status));
  }
  actions.push(...parseContractActions(accountFriendly, transactions, addressBook), ...parseJettonActions(accountFriendly, data, addressBook), ...parseNftActions(accountFriendly, data, addressBook));
  const filteredActions = filterActionsByPriority(actions);
  return buildEvent(data, account, filteredActions, addressBook);
}
function emulationEvent(data, account) {
  const txEntries = Object.entries(data.transactions);
  const byLtAsc = [...txEntries].sort((a2, b2) => BigInt(a2[1].lt) < BigInt(b2[1].lt) ? -1 : 1);
  const transactions_order = byLtAsc.map(([hash]) => hash);
  const start_lt = byLtAsc[0]?.[1].lt ?? "0";
  byLtAsc[byLtAsc.length - 1]?.[1].lt ?? "0";
  const start_utime = byLtAsc.length > 0 ? Math.min(...byLtAsc.map(([, tx]) => tx.now)) : Math.floor(Date.now() / 1e3);
  byLtAsc.length > 0 ? Math.max(...byLtAsc.map(([, tx]) => tx.now)) : start_utime;
  byLtAsc.map(([, tx]) => tx.mc_block_seqno);
  const trace_id = transactions_order[0] ?? "";
  const rootTx = trace_id ? data.transactions[trace_id] : void 0;
  rootTx?.in_msg?.hash_norm || rootTx?.in_msg?.hash || "";
  const traceItem = {
    actions: data.actions,
    is_incomplete: data.is_incomplete,
    start_lt,
    start_utime,
    trace: data.trace,
    trace_id,
    trace_info: {
      messages: byLtAsc.reduce((sum, [, tx]) => sum + (tx.in_msg ? 1 : 0) + (tx.out_msgs?.length ?? 0), 0),
      transactions: transactions_order.length
    },
    transactions: data.transactions,
    transactions_order
  };
  traceItem.metadata = data.metadata;
  let inferredAccount = account && String(account).trim() ? String(account).trim() : void 0;
  if (!inferredAccount) {
    inferredAccount = rootTx?.account;
  }
  if (!inferredAccount) {
    inferredAccount = byLtAsc[0]?.[1]?.account ?? Object.values(data.transactions || {})[0]?.account;
  }
  if (!inferredAccount) {
    inferredAccount = "";
  }
  const addressBook = toAddressBook$1(data);
  return toEvent(traceItem, inferredAccount, addressBook);
}
function toAccount(address, addressBook) {
  const friendly = asMaybeAddressFriendly(address);
  const out = {
    address: friendly ?? address ?? "",
    isScam: false,
    isWallet: Boolean(friendly)
  };
  if (friendly) {
    const record = addressBook[friendly];
    if (record) {
      if (record.isScam) {
        out.isScam = record.isScam;
      }
      if (record.isWallet) {
        out.isWallet = record.isWallet;
      }
      if (record.domain) {
        out.name = record.domain;
      }
    }
  }
  return out;
}
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
  config;
  parent;
  static defaultConfig = {
    level: LogLevel.INFO,
    prefix: "TonWalletKit",
    enableTimestamp: true,
    enableStackTrace: false
  };
  constructor(config) {
    this.parent = config?.parent;
    this.config = { ...Logger.defaultConfig, ...config };
    if (this.parent) {
      this.config = {
        ...this.parent.config,
        ...config,
        // Build hierarchical prefix
        prefix: this.buildHierarchicalPrefix(config?.prefix)
      };
    }
  }
  /**
   * Update logger configuration
   */
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * Create a child logger with a prefix that inherits from this logger
   */
  createChild(prefix, config) {
    return new Logger({
      ...config,
      parent: this,
      prefix
    });
  }
  /**
   * Build hierarchical prefix by combining parent prefix with current prefix
   */
  buildHierarchicalPrefix(currentPrefix) {
    if (!this.parent || !currentPrefix) {
      return currentPrefix || this.parent?.config.prefix || "";
    }
    const parentPrefix = this.parent.config.prefix;
    if (!parentPrefix) {
      return currentPrefix;
    }
    return `${parentPrefix}:${currentPrefix}`;
  }
  /**
   * Get the full hierarchical prefix for this logger
   */
  getPrefix() {
    return this.config.prefix || "";
  }
  /**
   * Get the parent logger if it exists
   */
  getParent() {
    return this.parent;
  }
  /**
   * Log debug messages
   */
  debug(message, context) {
    if (this.config.level <= LogLevel.DEBUG) {
      this.log("DEBUG", message, context);
    }
  }
  /**
   * Log info messages
   */
  info(message, context) {
    if (this.config.level <= LogLevel.INFO) {
      this.log("INFO", message, context);
    }
  }
  /**
   * Log warning messages
   */
  warn(message, context) {
    if (this.config.level <= LogLevel.WARN) {
      this.log("WARN", message, context);
    }
  }
  /**
   * Log error messages
   */
  error(message, context) {
    if (this.config.level <= LogLevel.ERROR) {
      this.log("ERROR", message, context);
    }
  }
  /**
   * Internal logging method
   */
  log(level, message, context) {
    const timestamp = this.config.enableTimestamp ? (/* @__PURE__ */ new Date()).toISOString() : "";
    const prefix = this.config.prefix ? `[${this.config.prefix}]` : "";
    let logMessage = "";
    if (timestamp) {
      logMessage += `${timestamp} `;
    }
    if (prefix) {
      logMessage += `${prefix} `;
    }
    logMessage += `${level}: ${message}`;
    const logArgs = [logMessage];
    if (context && Object.keys(context).length > 0) {
      logArgs.push(context);
    }
    switch (level) {
      case "DEBUG":
        console.debug(...logArgs);
        break;
      case "INFO":
        console.info(...logArgs);
        break;
      case "WARN":
        console.warn(...logArgs);
        break;
      case "ERROR":
        console.error(...logArgs);
        if (this.config.enableStackTrace) {
          console.trace();
        }
        break;
    }
  }
}
const globalLogger = new Logger({
  level: LogLevel.DEBUG,
  enableStackTrace: true
});
function delay(ms) {
  return new Promise((resolve) => setTimeout(() => {
    resolve();
  }, ms));
}
async function CallForSuccess(toCall, attempts = 20, delayMs = 100) {
  if (typeof toCall !== "function") {
    throw new Error("unknown input");
  }
  let i = 0;
  let lastError;
  while (i < attempts) {
    try {
      const res = await toCall();
      return res;
    } catch (err) {
      lastError = err;
      i++;
      await delay(delayMs);
    }
  }
  throw lastError;
}
class LocalStorageAdapter {
  prefix;
  maxRetries;
  retryDelay;
  localStorage;
  constructor(config = {}, _localStorage) {
    this.prefix = config.prefix || "tonwallet:";
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 100;
    if (_localStorage) {
      this.localStorage = _localStorage;
    } else {
      this.localStorage = window.localStorage;
    }
  }
  async get(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      return this.localStorage.getItem(fullKey);
    });
  }
  async set(key, value) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      this.localStorage.setItem(fullKey, value);
    });
  }
  async remove(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      this.localStorage.removeItem(fullKey);
    });
  }
  async clear() {
    return this.withRetry(async () => {
      const keysToRemove = this.getPrefixedKeys();
      keysToRemove.forEach((key) => this.localStorage.removeItem(key));
    });
  }
  getPrefixedKeys() {
    const keys = [];
    for (let i = 0; i < this.localStorage.length; i++) {
      const key = this.localStorage.key(i);
      if (key && key.startsWith(this.prefix)) {
        keys.push(key);
      }
    }
    return keys;
  }
  async withRetry(operation) {
    return CallForSuccess(operation, this.maxRetries, this.retryDelay);
  }
}
class MemoryStorageAdapter {
  store = /* @__PURE__ */ new Map();
  prefix;
  constructor(config = {}) {
    this.prefix = config.prefix || "";
  }
  async get(key) {
    const fullKey = this.prefix + key;
    return this.store.has(fullKey) ? this.store.get(fullKey) : null;
  }
  async set(key, value) {
    const fullKey = this.prefix + key;
    this.store.set(fullKey, value);
  }
  async remove(key) {
    const fullKey = this.prefix + key;
    this.store.delete(fullKey);
  }
  async clear() {
    if (this.prefix) {
      const keysToDelete = Array.from(this.store.keys()).filter((key) => key.startsWith(this.prefix));
      keysToDelete.forEach((key) => this.store.delete(key));
    } else {
      this.store.clear();
    }
  }
  /**
   * Get current store size (for testing/debugging)
   */
  getSize() {
    return this.store.size;
  }
  /**
   * Get all keys (for testing/debugging)
   */
  getKeys() {
    return Array.from(this.store.keys());
  }
}
const log$k = globalLogger.createChild("StorageAdapter");
function createStorageAdapter(config = {}) {
  if (typeof localStorage !== "undefined") {
    try {
      return new LocalStorageAdapter(config);
    } catch (error2) {
      log$k.warn("Failed to create LocalStorageAdapter, falling back to memory", { error: error2 });
    }
  }
  if (config.allowMemory) {
    return new MemoryStorageAdapter(config);
  } else {
    throw new Error("No storage adapter available");
  }
}
class ExtensionStorageAdapter {
  prefix;
  maxRetries;
  retryDelay;
  localStorage;
  constructor(config = {}, localStorage2) {
    this.prefix = config.prefix || "tonwallet:";
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 100;
    this.localStorage = localStorage2;
  }
  async get(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      const itemObj = await this.localStorage.get(fullKey);
      if (!itemObj) {
        return null;
      }
      const item = itemObj[fullKey];
      if (!item) {
        return null;
      }
      return item.toString();
    });
  }
  async set(key, value) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      await this.localStorage.set({
        [fullKey]: value
      });
    });
  }
  async remove(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      await this.localStorage.remove(fullKey);
    });
  }
  async clear() {
    return this.withRetry(async () => {
      return this.localStorage.clear();
    });
  }
  async withRetry(operation) {
    return CallForSuccess(operation, this.maxRetries, this.retryDelay);
  }
}
const log$j = globalLogger.createChild("Storage");
class Storage {
  adapter;
  constructor(adapter) {
    this.adapter = adapter;
  }
  /**
   * Get a value from storage by key
   * @param key The storage key
   * @returns The stored value, or null if not found
   */
  async get(key) {
    try {
      const value = await this.adapter.get(key);
      if (value === null) {
        return null;
      }
      return JSON.parse(value);
    } catch (error2) {
      log$j.warn("Failed to parse stored value", { key, error: error2 });
      return null;
    }
  }
  /**
   * Set a value in storage
   * @param key The storage key
   * @param value The value to store (will be JSON serialized)
   */
  async set(key, value) {
    try {
      const serialized = JSON.stringify(value);
      await this.adapter.set(key, serialized);
    } catch (error2) {
      log$j.error("Failed to serialize value for storage", { key, error: error2 });
      throw error2;
    }
  }
  /**
   * Remove a value from storage
   * @param key The storage key to remove
   */
  async remove(key) {
    await this.adapter.remove(key);
  }
  /**
   * Clear all storage data
   */
  async clear() {
    await this.adapter.clear();
  }
  /**
   * Get the underlying storage adapter
   * @returns The StorageAdapter instance
   */
  getAdapter() {
    return this.adapter;
  }
}
function validateWallet(_wallet, _context = {}) {
  const errors = [];
  const warnings = [];
  return {
    isValid: errors.length === 0,
    errors,
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
function validateBridgeEvent(event, context = {}) {
  const errors = [];
  if (!event || typeof event !== "object") {
    errors.push("event must be an object");
    return { isValid: false, errors };
  }
  if (!event.id || typeof event.id !== "string") {
    errors.push("event.id must be a non-empty string");
  }
  if (!event.method || typeof event.method !== "string") {
    errors.push("event.method must be a non-empty string");
  } else if (!isValidEventMethod(event.method)) {
    if (context.strict) {
      errors.push(`unsupported event method: ${event.method}`);
    }
  }
  if (event.params && typeof event.params !== "object") {
    errors.push("event.params must be an object if provided");
  }
  if (event.sessionId && typeof event.sessionId !== "string") {
    errors.push("event.sessionId must be a string if provided");
  }
  if (event.timestamp && typeof event.timestamp !== "number") {
    errors.push("event.timestamp must be a number if provided");
  }
  return {
    isValid: errors.length === 0,
    errors
  };
}
function isValidEventMethod(method) {
  const supportedMethods = [
    "connect",
    "sendTransaction",
    "signData",
    "disconnect",
    "tonconnect_connect",
    "tonconnect_sendTransaction",
    "tonconnect_signData",
    "tonconnect_disconnect",
    "wallet_connect",
    "wallet_disconnect",
    "personal_sign"
  ];
  return supportedMethods.includes(method);
}
function validateTransactionMessages(messages, isTonConnect = true) {
  const errors = [];
  if (!Array.isArray(messages)) {
    errors.push("messages must be an array");
    return { isValid: false, errors };
  }
  if (messages.length === 0) {
    errors.push("messages array cannot be empty");
    return { isValid: false, errors };
  }
  messages.forEach((msg, index2) => {
    const msgErrors = validateTransactionMessage(msg, isTonConnect).errors;
    msgErrors.forEach((error2) => {
      errors.push(`message[${index2}]: ${error2}`);
    });
  });
  return {
    isValid: errors.length === 0,
    errors
  };
}
function validateTransactionMessage(message, isTonConnect = true) {
  const errors = [];
  if (typeof message !== "object") {
    return { isValid: false, errors: ["Invalid message"] };
  }
  if (message === null || message === void 0) {
    return { isValid: false, errors: ["Invalid message"] };
  }
  if (isTonConnect && typeof message.mode !== "undefined") {
    errors.push("mode must be undefined for tonconnect!");
  }
  const objErrors = validateMessageObject(message).errors;
  errors.push(...objErrors);
  return {
    isValid: errors.length === 0,
    errors
  };
}
function validateMessageObject(message) {
  const errors = [];
  if (!message.address || typeof message.address !== "string") {
    errors.push("to address is required and must be a string");
  } else {
    if (!isFriendlyTonAddress(message.address)) {
      errors.push("to address must be a valid friendly TON address");
    }
  }
  if (message.amount !== void 0) {
    if (!isValidNanotonAmount(message.amount)) {
      errors.push("value must be a valid nanonton amount (string of digits)");
    }
  } else {
    errors.push("value must be a valid nanonton amount (string of digits)");
  }
  if (message.payload) {
    if (typeof message.payload !== "string") {
      errors.push("payload must be a string if provided");
    } else {
      if (!isValidBOC(message.payload)) {
        errors.push("payload must be a valid base64 string if provided");
      }
    }
  }
  if (message.stateInit) {
    if (typeof message.stateInit !== "string") {
      errors.push("stateInit must be a string if provided");
    } else {
      if (!isValidBOC(message.stateInit)) {
        errors.push("stateInit must be a valid base64 string if provided");
      }
    }
  }
  return {
    isValid: errors.length === 0,
    errors
  };
}
function isValidNanotonAmount(amount) {
  if (typeof amount !== "string") {
    return false;
  }
  const amountStr = String(amount);
  const parsed = BigInt(amountStr);
  return parsed >= 0 && parsed.toString() === amountStr;
}
function isValidBOC(bocString) {
  try {
    distExports$1.Cell.fromBase64(bocString);
    return true;
  } catch {
    return false;
  }
}
globalLogger.createChild("WalletManager");
class WalletManager {
  wallets = /* @__PURE__ */ new Map();
  storage;
  // private storageKey = 'wallets';
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Initialize manager and load persisted wallets
   */
  async initialize() {
  }
  /**
   * Get all wallets as array
   */
  getWallets() {
    return Array.from(this.wallets.values());
  }
  /**
   * Get wallet by wallet ID (network:address format)
   */
  getWallet(walletId) {
    return this.wallets.get(walletId) || void 0;
  }
  /**
   * Add a wallet with validation
   */
  async addWallet(wallet2) {
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    const walletId = wallet2.getWalletId();
    if (this.wallets.has(walletId)) {
      return walletId;
    }
    this.wallets.set(walletId, wallet2);
    return walletId;
  }
  /**
   * Remove wallet by wallet ID or wallet adapter
   */
  async removeWallet(walletIdOrAdapter) {
    let walletId;
    if (typeof walletIdOrAdapter === "string") {
      walletId = walletIdOrAdapter;
    } else {
      walletId = walletIdOrAdapter.getWalletId();
    }
    const removed = this.wallets.delete(walletId);
    return removed;
  }
  /**
   * Update existing wallet
   */
  async updateWallet(wallet2) {
    const walletId = wallet2.getWalletId();
    if (!this.wallets.has(walletId)) {
      throw new Error(`Wallet with ID ${walletId} not found`);
    }
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    this.wallets.set(walletId, wallet2);
  }
  /**
   * Clear all wallets
   */
  async clearWallets() {
    this.wallets.clear();
  }
  /**
   * Get wallet count
   */
  getWalletCount() {
    return this.wallets.size;
  }
  /**
   * Check if wallet exists by wallet ID
   */
  hasWallet(walletId) {
    return this.wallets.has(walletId);
  }
  /**
   * Get wallet ID for a wallet adapter
   */
  getWalletId(wallet2) {
    return wallet2.getWalletId();
  }
}
const log$i = globalLogger.createChild("TONConnectStoredSessionManager");
class TONConnectStoredSessionManager {
  sessions = /* @__PURE__ */ new Map();
  storage;
  walletManager;
  storageKey = "sessions";
  schemaVersion = 1;
  constructor(storage, walletManager) {
    this.storage = storage;
    this.walletManager = walletManager;
  }
  /**
   * Initialize manager and load persisted sessions
   */
  async initialize() {
    await this.loadSessions();
    await this.migrateSessions();
  }
  /**
   * Create new session
   * @param sessionId - Unique session identifier
   * @param dAppInfo - Information about the dApp
   * @param wallet - The wallet to associate with this session (optional for connect requests before wallet selection)
   * @param options - Additional options for session creation
   */
  async createSession(sessionId, dAppInfo, wallet2, isJsBridge) {
    const now = /* @__PURE__ */ new Date();
    const randomKeyPair = new SessionCrypto().stringifyKeypair();
    const walletId = wallet2.getWalletId();
    let domain;
    try {
      const url = new URL(dAppInfo.url || "");
      domain = url.host;
    } catch {
      throw new Error("Unable to resolve domain from dApp URL for new sessions");
    }
    const session = {
      sessionId,
      walletId,
      walletAddress: wallet2?.getAddress() ?? "",
      createdAt: now.toISOString(),
      lastActivityAt: now.toISOString(),
      privateKey: randomKeyPair.secretKey,
      publicKey: randomKeyPair.publicKey,
      domain,
      dAppName: dAppInfo.name,
      dAppDescription: dAppInfo.description,
      dAppUrl: dAppInfo.url,
      dAppIconUrl: dAppInfo.iconUrl,
      isJsBridge,
      schemaVersion: this.schemaVersion
    };
    this.sessions.set(sessionId, session);
    await this.persistSessions();
    return await this.getSession(sessionId);
  }
  /**
   * Get session by ID
   */
  async getSession(sessionId) {
    return this.sessions.get(sessionId);
  }
  async getSessions(filter) {
    let sessions = Array.from(this.sessions.values());
    if (!filter) {
      return sessions;
    }
    let domain;
    if (filter.domain) {
      try {
        domain = new URL(filter.domain).host;
      } catch {
        domain = filter.domain;
      }
    }
    return sessions.filter((session) => {
      let isIncluded = true;
      if (filter.walletId) {
        isIncluded = isIncluded && session.walletId === filter.walletId;
      }
      if (filter.domain) {
        isIncluded = isIncluded && session.domain === domain;
      }
      if (filter.isJsBridge !== void 0) {
        isIncluded = isIncluded && session.isJsBridge === filter.isJsBridge;
      }
      return isIncluded;
    });
  }
  /**
   * Remove session by ID
   */
  async removeSession(sessionId) {
    const session = await this.getSession(sessionId);
    if (!session) {
      return session;
    }
    const removed = this.sessions.delete(sessionId);
    if (removed) {
      await this.persistSessions();
    }
    return session;
  }
  async removeSessions(filter) {
    const sessionsToRemove = await this.getSessions(filter);
    let removedCount = 0;
    for (const session of sessionsToRemove) {
      if (this.sessions.delete(session.sessionId)) {
        removedCount++;
      }
    }
    if (removedCount > 0) {
      await this.persistSessions();
    }
    return sessionsToRemove;
  }
  /**
   * Clear all sessions
   */
  async clearSessions() {
    this.sessions.clear();
    await this.persistSessions();
  }
  /**
   * Get session count
   */
  getSessionCount() {
    return this.sessions.size;
  }
  /**
   * Check if session exists
   */
  hasSession(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * Clean up expired sessions (optional cleanup based on inactivity)
   */
  async cleanupInactiveSessions(maxInactiveHours = 24) {
    const cutoffTime = /* @__PURE__ */ new Date();
    cutoffTime.setHours(cutoffTime.getHours() - maxInactiveHours);
    const sessionsToRemove = [];
    for (const [sessionId, session] of this.sessions.entries()) {
      if (new Date(session.lastActivityAt) < cutoffTime) {
        sessionsToRemove.push(sessionId);
      }
    }
    for (const sessionId of sessionsToRemove) {
      this.sessions.delete(sessionId);
    }
    if (sessionsToRemove.length > 0) {
      await this.persistSessions();
    }
    return sessionsToRemove.length;
  }
  /**
   * Load sessions from storage
   */
  async loadSessions() {
    try {
      const storedSessions = await this.storage.get(this.storageKey);
      if (storedSessions && Array.isArray(storedSessions)) {
        for (const session of storedSessions) {
          if (session.walletId && !session.walletAddress) {
            const wallet2 = this.walletManager.getWallet(session.walletId);
            if (wallet2) {
              session.walletAddress = wallet2.getAddress();
            } else {
              log$i.warn("Session Wallet not found for session", { sessionId: session.sessionId });
              continue;
            }
          }
          this.sessions.set(session.sessionId, session);
        }
        log$i.debug("Loaded session metadata", { count: storedSessions.length });
      }
    } catch (error2) {
      log$i.warn("Failed to load sessions from storage", { error: error2 });
    }
  }
  /**
   * Persist session metadata to storage
   */
  async persistSessions() {
    try {
      const sessionsToStore = Array.from(this.sessions.values());
      await this.storage.set(this.storageKey, sessionsToStore);
    } catch (error2) {
      log$i.warn("Failed to persist sessions to storage", { error: error2 });
    }
  }
  async migrateSessions() {
    for (const [sessionId, session] of this.sessions.entries()) {
      const migratedSession = this.migrate(session);
      if (migratedSession) {
        this.sessions.set(sessionId, migratedSession);
      } else {
        this.sessions.delete(sessionId);
      }
    }
    await this.persistSessions();
  }
  migrate(session) {
    if (session.schemaVersion === this.schemaVersion) {
      return session;
    }
    return void 0;
  }
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
  function normalizeInput(input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (typeof input === "string") {
      const encoder = new TextEncoder();
      ret = encoder.encode(input);
    } else {
      throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
  }
  function toHex(bytes) {
    return Array.prototype.map.call(bytes, function(n) {
      return (n < 16 ? "0" : "") + n.toString(16);
    }).join("");
  }
  function uint32ToHex(val) {
    return (4294967296 + val).toString(16).substring(1);
  }
  function debugPrint(label, arr, size) {
    let msg = "\n" + label + " = ";
    for (let i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += " ";
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else throw new Error("Invalid size " + size);
      if (i % 6 === 4) {
        msg += "\n" + new Array(label.length + 4).join(" ");
      } else if (i < arr.length - 2) {
        msg += " ";
      }
    }
    console.log(msg);
  }
  function testSpeed(hashFn, N, M2) {
    let startMs = (/* @__PURE__ */ new Date()).getTime();
    const input = new Uint8Array(N);
    for (let i = 0; i < N; i++) {
      input[i] = i % 256;
    }
    const genMs = (/* @__PURE__ */ new Date()).getTime();
    console.log("Generated random input in " + (genMs - startMs) + "ms");
    startMs = genMs;
    for (let i = 0; i < M2; i++) {
      const hashHex = hashFn(input);
      const hashMs = (/* @__PURE__ */ new Date()).getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
      console.log(
        Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
      );
    }
  }
  util = {
    normalizeInput,
    toHex,
    debugPrint,
    testSpeed
  };
  return util;
}
var blake2b_1;
var hasRequiredBlake2b;
function requireBlake2b() {
  if (hasRequiredBlake2b) return blake2b_1;
  hasRequiredBlake2b = 1;
  const util2 = requireUtil();
  function ADD64AA(v3, a2, b2) {
    const o0 = v3[a2] + v3[b2];
    let o1 = v3[a2 + 1] + v3[b2 + 1];
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function ADD64AC(v3, a2, b0, b1) {
    let o0 = v3[a2] + b0;
    if (b0 < 0) {
      o0 += 4294967296;
    }
    let o1 = v3[a2 + 1] + b1;
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
  }
  function B2B_G(a2, b2, c, d, ix, iy) {
    const x0 = m[ix];
    const x1 = m[ix + 1];
    const y0 = m[iy];
    const y1 = m[iy + 1];
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, x0, x1);
    let xor0 = v2[d] ^ v2[a2];
    let xor1 = v2[d + 1] ^ v2[a2 + 1];
    v2[d] = xor1;
    v2[d + 1] = xor0;
    ADD64AA(v2, c, d);
    xor0 = v2[b2] ^ v2[c];
    xor1 = v2[b2 + 1] ^ v2[c + 1];
    v2[b2] = xor0 >>> 24 ^ xor1 << 8;
    v2[b2 + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, y0, y1);
    xor0 = v2[d] ^ v2[a2];
    xor1 = v2[d + 1] ^ v2[a2 + 1];
    v2[d] = xor0 >>> 16 ^ xor1 << 16;
    v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v2, c, d);
    xor0 = v2[b2] ^ v2[c];
    xor1 = v2[b2 + 1] ^ v2[c + 1];
    v2[b2] = xor1 >>> 31 ^ xor0 << 1;
    v2[b2 + 1] = xor0 >>> 31 ^ xor1 << 1;
  }
  const BLAKE2B_IV32 = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function(x2) {
      return x2 * 2;
    })
  );
  const v2 = new Uint32Array(32);
  const m = new Uint32Array(32);
  function blake2bCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 16; i++) {
      v2[i] = ctx.h[i];
      v2[i + 16] = BLAKE2B_IV32[i];
    }
    v2[24] = v2[24] ^ ctx.t;
    v2[25] = v2[25] ^ ctx.t / 4294967296;
    if (last) {
      v2[28] = ~v2[28];
      v2[29] = ~v2[29];
    }
    for (i = 0; i < 32; i++) {
      m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 12; i++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v2[i] ^ v2[i + 16];
    }
  }
  const parameterBlock = new Uint8Array([
    0,
    0,
    0,
    0,
    //  0: outlen, keylen, fanout, depth
    0,
    0,
    0,
    0,
    //  4: leaf length, sequential mode
    0,
    0,
    0,
    0,
    //  8: node offset
    0,
    0,
    0,
    0,
    // 12: node offset
    0,
    0,
    0,
    0,
    // 16: node depth, inner length, rfu
    0,
    0,
    0,
    0,
    // 20: rfu
    0,
    0,
    0,
    0,
    // 24: rfu
    0,
    0,
    0,
    0,
    // 28: rfu
    0,
    0,
    0,
    0,
    // 32: salt
    0,
    0,
    0,
    0,
    // 36: salt
    0,
    0,
    0,
    0,
    // 40: salt
    0,
    0,
    0,
    0,
    // 44: salt
    0,
    0,
    0,
    0,
    // 48: personal
    0,
    0,
    0,
    0,
    // 52: personal
    0,
    0,
    0,
    0,
    // 56: personal
    0,
    0,
    0,
    0
    // 60: personal
  ]);
  function blake2bInit(outlen, key, salt, personal) {
    if (outlen === 0 || outlen > 64) {
      throw new Error("Illegal output length, expected 0 < length <= 64");
    }
    if (key && key.length > 64) {
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    }
    if (salt && salt.length !== 16) {
      throw new Error("Illegal salt, expected Uint8Array with length is 16");
    }
    if (personal && personal.length !== 16) {
      throw new Error("Illegal personal, expected Uint8Array with length is 16");
    }
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      // input count
      c: 0,
      // pointer within buffer
      outlen
      // output length in bytes
    };
    parameterBlock.fill(0);
    parameterBlock[0] = outlen;
    if (key) parameterBlock[1] = key.length;
    parameterBlock[2] = 1;
    parameterBlock[3] = 1;
    if (salt) parameterBlock.set(salt, 32);
    if (personal) parameterBlock.set(personal, 48);
    for (let i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    if (key) {
      blake2bUpdate(ctx, key);
      ctx.c = 128;
    }
    return ctx;
  }
  function blake2bUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2bFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
  }
  function blake2b(input, key, outlen, salt, personal) {
    outlen = outlen || 64;
    input = util2.normalizeInput(input);
    if (salt) {
      salt = util2.normalizeInput(salt);
    }
    if (personal) {
      personal = util2.normalizeInput(personal);
    }
    const ctx = blake2bInit(outlen, key, salt, personal);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
  }
  function blake2bHex(input, key, outlen, salt, personal) {
    const output = blake2b(input, key, outlen, salt, personal);
    return util2.toHex(output);
  }
  blake2b_1 = {
    blake2b,
    blake2bHex,
    blake2bInit,
    blake2bUpdate,
    blake2bFinal
  };
  return blake2b_1;
}
var blake2s_1;
var hasRequiredBlake2s;
function requireBlake2s() {
  if (hasRequiredBlake2s) return blake2s_1;
  hasRequiredBlake2s = 1;
  const util2 = requireUtil();
  function B2S_GET32(v3, i) {
    return v3[i] ^ v3[i + 1] << 8 ^ v3[i + 2] << 16 ^ v3[i + 3] << 24;
  }
  function B2S_G(a2, b2, c, d, x2, y2) {
    v2[a2] = v2[a2] + v2[b2] + x2;
    v2[d] = ROTR32(v2[d] ^ v2[a2], 16);
    v2[c] = v2[c] + v2[d];
    v2[b2] = ROTR32(v2[b2] ^ v2[c], 12);
    v2[a2] = v2[a2] + v2[b2] + y2;
    v2[d] = ROTR32(v2[d] ^ v2[a2], 8);
    v2[c] = v2[c] + v2[d];
    v2[b2] = ROTR32(v2[b2] ^ v2[c], 7);
  }
  function ROTR32(x2, y2) {
    return x2 >>> y2 ^ x2 << 32 - y2;
  }
  const BLAKE2S_IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  const v2 = new Uint32Array(16);
  const m = new Uint32Array(16);
  function blake2sCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 8; i++) {
      v2[i] = ctx.h[i];
      v2[i + 8] = BLAKE2S_IV[i];
    }
    v2[12] ^= ctx.t;
    v2[13] ^= ctx.t / 4294967296;
    if (last) {
      v2[14] = ~v2[14];
    }
    for (i = 0; i < 16; i++) {
      m[i] = B2S_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 10; i++) {
      B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
    }
    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v2[i] ^ v2[i + 8];
    }
  }
  function blake2sInit(outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error("Incorrect output length, should be in [1, 32]");
    }
    const keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
      throw new Error("Incorrect key length, should be in [1, 32]");
    }
    const ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      // hash state
      b: new Uint8Array(64),
      // input block
      c: 0,
      // pointer within block
      t: 0,
      // input count
      outlen
      // output length in bytes
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key);
      ctx.c = 64;
    }
    return ctx;
  }
  function blake2sUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2sFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
    }
    return out;
  }
  function blake2s(input, key, outlen) {
    outlen = outlen || 32;
    input = util2.normalizeInput(input);
    const ctx = blake2sInit(outlen, key);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
  }
  function blake2sHex(input, key, outlen) {
    const output = blake2s(input, key, outlen);
    return util2.toHex(output);
  }
  blake2s_1 = {
    blake2s,
    blake2sHex,
    blake2sInit,
    blake2sUpdate,
    blake2sFinal
  };
  return blake2s_1;
}
var blakejs;
var hasRequiredBlakejs;
function requireBlakejs() {
  if (hasRequiredBlakejs) return blakejs;
  hasRequiredBlakejs = 1;
  const b2b = requireBlake2b();
  const b2s = requireBlake2s();
  blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
  return blakejs;
}
var blakejsExports = requireBlakejs();
const h = /* @__PURE__ */ getDefaultExportFromCjs(blakejsExports);
function P() {
  return typeof process < "u" && !!process.env;
}
function B(o4) {
  return process?.env?.[o4];
}
var O = P() && !B("TONBRIDGE_DEBUG"), s = (...o4) => {
  O || console.debug("[TON_CONNECT_BRIDGE_SDK]", ...o4);
}, b = (...o4) => {
  console.error("[TON_CONNECT_BRIDGE_SDK]", ...o4);
};
var a = class o extends Error {
  static prefix = "[BRIDGE_SDK_ERROR]";
  constructor(e, t) {
    super(e, t), this.message = `${o.prefix} ${e ? `
` + e : ""}`, s(this.message), Object.setPrototypeOf(this, o.prototype);
  }
};
function k(o4) {
  return o4.slice(-1) === "/" ? o4.slice(0, -1) : o4;
}
function E(o4, e) {
  return k(o4) + "/" + e;
}
function p(o4) {
  let e = new AbortController();
  return o4?.aborted ? e.abort() : o4?.addEventListener("abort", () => e.abort(), { once: true }), e;
}
function D(o4, e) {
  let t = null, r = null, n = null;
  return { create: async (d, ...u) => {
    if (n?.abort(), n = p(d), n.signal.aborted) throw new a("Resource creation was aborted");
    let m = o4(n.signal, ...u);
    r = m;
    let g = await m;
    if (r !== m && g !== t) throw await e(g), new a("Resource creation was aborted by a new resource creation");
    return t = g, t;
  }, current: () => t ?? null, dispose: async () => {
    try {
      let d = t;
      t = null;
      let u = r;
      r = null;
      try {
        n?.abort();
      } catch {
      }
      await Promise.allSettled([d ? e(d) : Promise.resolve(), u ? e(await u) : Promise.resolve()]);
    } catch {
    }
  } };
}
function M(o4, e) {
  let t = e?.timeout, r = e?.signal, n = p(r);
  return new Promise(async (i, c) => {
    if (r?.aborted) {
      c(new a("Timeout aborted before setTimeout"));
      return;
    }
    let l;
    typeof t < "u" && (l = setTimeout(() => {
      n.abort(), c(new a(`Timeout after ${t}ms`));
    }, t)), n.signal.addEventListener("abort", () => {
      l && (clearTimeout(l), l = void 0, c(new a("Timeout aborted after setTimeout")));
    }, { once: true }), await o4((...d) => {
      clearTimeout(l), l = void 0, i(...d);
    }, (d) => {
      clearTimeout(l), l = void 0, c(d);
    }, { timeout: t, signal: n.signal });
  });
}
var v = class o2 {
  constructor(e, t, r, n, i, c, l) {
    this.bridgeUrl = e;
    this.sessionIds = t;
    this.listener = r;
    this.errorsListener = n;
    this.lastEventId = i;
    this.heartbeatFormat = c;
    this.enableQueueDoneEvent = l;
  }
  static ssePath = "events";
  static postPath = "message";
  static defaultTtl = 300;
  eventSource = D(async (e, t) => await U({ bridgeUrl: this.bridgeUrl, ssePath: o2.ssePath, sessionIds: this.sessionIds, errorHandler: this.errorsHandler.bind(this), messageHandler: this.messagesHandler.bind(this), signal: e, connectingDeadlineMS: t, lastEventId: this.lastEventId, heartbeatFormat: this.heartbeatFormat, enableQueueDoneEvent: this.enableQueueDoneEvent }), async (e) => {
    e.close();
  });
  get isReady() {
    return this.eventSource.current()?.readyState === EventSource.OPEN;
  }
  get isClosed() {
    return this.eventSource.current()?.readyState !== EventSource.OPEN;
  }
  get isConnecting() {
    return this.eventSource.current()?.readyState === EventSource.CONNECTING;
  }
  static async open(e) {
    let t = new o2(e.bridgeUrl, e.sessionIds, e.listener, e.errorsListener, e.lastEventId, e.heartbeatFormat, e.enableQueueDoneEvent);
    try {
      return await t.registerSession(e.options), t;
    } catch (r) {
      throw await t.close(), r;
    }
  }
  async registerSession(e) {
    await this.eventSource.create(e?.signal, e?.connectingDeadlineMS);
  }
  static async sendRequest(e, t, r, n, i) {
    let c = new URL(E(e, this.postPath));
    c.searchParams.append("client_id", r), c.searchParams.append("to", n), c.searchParams.append("ttl", (i?.ttl ?? o2.defaultTtl).toString()), i?.topic && c.searchParams.append("topic", i.topic), i?.traceId && c.searchParams.append("trace_id", i.traceId);
    let l = Base64.encode(t), d = await this.post(c, l, i?.signal);
    if (!d.ok) throw new a(`Bridge send failed, status ${d.status}`);
  }
  async send(e, t, r, n) {
    return o2.sendRequest(this.bridgeUrl, e, t, r, n);
  }
  async close() {
    await this.eventSource.dispose().catch((e) => {
      b("[BridgeGateway] Failed to close connection:", e);
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  static async post(e, t, r) {
    let n = await fetch(e, { method: "post", body: t, signal: r });
    if (!n.ok) throw new a(`Bridge send failed, status ${n.status}`);
    return n;
  }
  async errorsHandler(e, t) {
    this.errorsListener(t);
  }
  async messagesHandler(e) {
    this.listener(e);
  }
};
async function U(o4) {
  let { lastEventId: e, heartbeatFormat: t, enableQueueDoneEvent: r } = o4;
  return await M(async (n, i, c) => {
    let { signal: l } = c;
    if (s("[BridgeGateway] Connecting to bridge SSE..."), l?.aborted) {
      i(new a("Bridge connection aborted before connection"));
      return;
    }
    let d = new URL(E(o4.bridgeUrl, o4.ssePath));
    if (d.searchParams.append("client_id", o4.sessionIds.join(",")), e && d.searchParams.append("last_event_id", e), t && d.searchParams.append("heartbeat", t), r && d.searchParams.append("enable_queue_done_event", "true"), l?.aborted) {
      i(new a("Bridge connection aborted after building url"));
      return;
    }
    s("[BridgeGateway] Initializing EventSource instance...");
    let u = new EventSource(d.toString()), m = false;
    u.onerror = async (g) => {
      if (s("[BridgeGateway] EventSource error occurred:", JSON.stringify(g)), l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on error callback"));
        return;
      }
      if (!m) {
        u.close(), i(new a("Bridge error before connecting"));
        return;
      }
      try {
        u.close(), await o4.errorHandler(u, g);
      } catch (A) {
        u.close(), i(A);
      }
    }, u.onopen = () => {
      if (l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on open"));
        return;
      }
      m = true, s("[BridgeGateway] EventSource connection established."), n(u);
    }, u.onmessage = (g) => {
      if (l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on message"));
        return;
      }
      e = g.lastEventId, o4.messageHandler(g);
    }, o4.signal?.addEventListener("abort", () => {
      u.close(), i(new a("Bridge connection aborted"));
    }, { once: true });
  }, { timeout: o4.connectingDeadlineMS, signal: o4.signal });
}
async function y(o4, e) {
  if (e?.signal?.aborted) throw new a("Delay aborted before setTimeout");
  return new Promise((t, r) => {
    let n = setTimeout(t, o4);
    e?.signal?.addEventListener("abort", () => {
      clearTimeout(n), r(new a("Delay aborted after setTimeout"));
    }, { once: true });
  });
}
async function S(o4, e) {
  let { signal: t, attempts: r = 10, delayMs: n = 100 } = e ?? {};
  if (typeof o4 != "function") throw new a(`Expected a function, got ${typeof o4}`);
  let i = 0, c;
  for (; i < r; ) {
    if (s(`[callForSuccess] Attempt: ${i}`), t?.aborted) throw new a(`Aborted after attempts ${i}`);
    try {
      return await o4({ signal: t });
    } catch (l) {
      s(`[callForSuccess], error after attempt ${i}, ${/* @__PURE__ */ new Date()}: ${JSON.stringify(l)}`, l), c = l, i++, i < r && (await y(n, { signal: t }), e?.exponential && (n = Math.min(n * 2, e.maxDelayMs ?? Number.MAX_SAFE_INTEGER)));
    }
  }
  throw c;
}
function T(o4) {
  return [...new Set(o4)];
}
function x(o4, e) {
  let t = new Set(o4), r = new Set(e);
  if (t.size !== r.size) return false;
  for (let n of t) if (!r.has(n)) return false;
  return true;
}
function G(o4, e) {
  let t = h.blake2bInit(f.box.nonceLength);
  return h.blake2bUpdate(t, o4), h.blake2bUpdate(t, e), h.blake2bFinal(t);
}
function I(o4, e, t) {
  let r = o4.subarray(0, f.box.publicKeyLength), n = G(r, e), i = o4.subarray(f.box.publicKeyLength);
  return f.box.open(i, n, r, t);
}
var C = class o3 {
  constructor(e, t = null, r = null, n = void 0) {
    this.bridgeUrl = e;
    this.listener = t;
    this.errorListener = r;
    this.heartbeatReconnectIntervalMs = n;
  }
  clients = [];
  lastEventId;
  abortController;
  gateway = null;
  onConnectingCallback;
  onQueueDoneCallback;
  heartbeatMessage = "heartbeat";
  queueEndMessage = "queue_done";
  defaultConnectingDeadlineMS = 14e3;
  defaultRetryDelayMs = 1e3;
  defaultMaxExponentialDelayMS = 7e3;
  missedHeartbeatDelay = 100;
  lastHeartbeatAt = Date.now();
  heartbeatTimer = null;
  connectionOptions = {};
  static async open(e) {
    let t = new o3(e.bridgeUrl, e.listener, e.errorListener, e.options?.heartbeatReconnectIntervalMs);
    e.onConnecting && (t.onConnecting = e.onConnecting), e.onQueueDone && (t.onQueueDone = e.onQueueDone);
    try {
      return await t.restoreConnection(e.clients, e.options), t;
    } catch (r) {
      throw await t.close(), r;
    }
  }
  get isReady() {
    return this.gateway?.isReady || false;
  }
  get isConnecting() {
    return this.gateway?.isConnecting ?? false;
  }
  get isClosed() {
    return this.gateway?.isClosed ?? false;
  }
  startHeartbeatWatcher(e) {
    if (!this.heartbeatReconnectIntervalMs) return;
    this.stopHeartbeatWatcher();
    let t = p(e), { signal: r } = t;
    this.lastHeartbeatAt = Date.now();
    let n = (c) => {
      this.heartbeatTimer = setTimeout(i, c);
    }, i = async () => {
      if (r.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      if (Date.now() - this.lastHeartbeatAt < this.heartbeatReconnectIntervalMs) {
        n(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      if (await y(this.missedHeartbeatDelay, { signal: r }), r.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      let l = Date.now() - this.lastHeartbeatAt;
      if (l <= this.heartbeatReconnectIntervalMs) {
        n(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      s(`[BridgeProvider] No heartbeat for ${l}ms, reconnecting...`);
      try {
        await this.reconnect(r);
      } catch (d) {
        b("[BridgeProvider] Failed to reconnect after missed heartbeat:", d), this.errorListener?.(d);
      }
    };
    n(this.heartbeatReconnectIntervalMs);
  }
  stopHeartbeatWatcher() {
    this.heartbeatTimer && (clearTimeout(this.heartbeatTimer), this.heartbeatTimer = null);
  }
  async restoreConnection(e, t) {
    if (e.length === 0) {
      s("[BridgeProvider] No clients passed");
      return;
    }
    this.clients = e, this.lastEventId = t?.lastEventId, this.connectionOptions = { connectingDeadlineMs: t?.connectingDeadlineMs, delayMs: t?.delayMs, maxDelayMs: t?.maxDelayMs, exponential: t?.exponential }, s("[BridgeProvider] Restoring connection...");
    let r = p(t?.signal);
    this.abortController?.abort(), this.abortController = r;
    let n = r.signal;
    if (n.aborted) {
      s("[BridgeProvider] Restore aborted before start.");
      return;
    }
    if (await this.reconnect(n), r.signal.aborted) {
      s("[BridgeProvider] Restore aborted after connecting.");
      return;
    }
    this.startHeartbeatWatcher(t?.signal);
  }
  async updateClients(e, t) {
    let r = this.clients.map((i) => i.session.sessionId), n = e.map((i) => i.session.sessionId);
    x(r, n) || (this.clients = e, await this.restoreConnection(e, { ...this.connectionOptions, signal: t?.signal }));
  }
  async reconnect(e) {
    try {
      await this.closeGateway();
    } catch (r) {
      s("[BridgeProvider] Error closing gateway:", JSON.stringify(r)), this.errorListener?.(r);
    }
    if (e.aborted) {
      s("[BridgeProvider] Reconnect aborted after closing gateway.");
      return;
    }
    let t = this.connectionOptions;
    await S(({ signal: r }) => this.openGateway(this.clients.map((n) => n.session), { lastEventId: this.lastEventId, connectingDeadlineMS: t?.connectingDeadlineMs ?? this.defaultConnectingDeadlineMS, signal: r }), { attempts: Number.MAX_SAFE_INTEGER, delayMs: t?.delayMs ?? this.defaultRetryDelayMs, signal: e, exponential: t?.exponential ?? true, maxDelayMs: t?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async send(e, t, r, n) {
    if (n?.signal?.aborted) {
      s("[BridgeProvider] Send aborted before encryption.");
      return;
    }
    let i = t.encrypt(JSON.stringify(e), hexToByteArray(r)), c = n?.topic ?? ("method" in e ? e.method : void 0);
    await S(async ({ signal: l }) => {
      await v.sendRequest(this.bridgeUrl, i, t.sessionId, r, { traceId: n?.traceId, topic: c, signal: l, ttl: n?.ttl });
    }, { attempts: n?.attempts ?? Number.MAX_SAFE_INTEGER, delayMs: n?.delayMs ?? this.defaultRetryDelayMs, signal: n?.signal, exponential: n?.exponential ?? true, maxDelayMs: n?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async close() {
    s("[BridgeProvider] Closing provider and gateway..."), await this.closeGateway(), this.stopHeartbeatWatcher(), this.lastEventId = void 0, this.clients = [], s("[BridgeProvider] Closed.");
  }
  listen(e) {
    this.listener = e;
  }
  set onQueueDone(e) {
    this.onQueueDoneCallback = () => {
      try {
        e();
      } catch (t) {
        b(`[BridgeProvider] Error during onQueueDone callback: ${JSON.stringify(t)}`, t), this.errorListener?.(t);
      }
    };
  }
  set onConnecting(e) {
    this.onConnectingCallback = () => {
      try {
        e();
      } catch (t) {
        b(`[BridgeProvider] Error during onConnecting callback: ${JSON.stringify(t)}`, t), this.errorListener?.(t);
      }
    };
  }
  getCryptoSession(e) {
    let t = this.clients.find(({ clientId: r }) => r === e);
    if (!t) throw new a("Client session does not exist");
    return t.session;
  }
  loadMaybeSource(e, t) {
    if (!t) return;
    let r = I(Base64.decode(t).toUint8Array(), hexToByteArray(e.sessionId), hexToByteArray(e.stringifyKeypair().secretKey));
    if (!r) throw new Error("Decrypt error ");
    let n = JSON.parse(new TextDecoder().decode(r));
    return { origin: n.origin, ip: n.ip, time: n.time, userAgent: n.user_agent };
  }
  async gatewayListener(e) {
    if (e.data === this.heartbeatMessage) {
      this.lastHeartbeatAt = Date.now();
      return;
    }
    if (e.data === this.queueEndMessage) {
      this.onQueueDoneCallback?.();
      return;
    }
    s(`[BridgeProvider] Message received. Event ID: ${e.lastEventId}`);
    let t;
    try {
      t = JSON.parse(e.data);
    } catch {
      this.errorListener?.(new a(`Failed to parse message: ${e.data}`));
      return;
    }
    let r = this.getCryptoSession(t.from), n = JSON.parse(r.decrypt(Base64.decode(t.message).toUint8Array(), hexToByteArray(t.from))), i = this.loadMaybeSource(r, t.request_source);
    s("[BridgeProvider] Incoming message decrypted:", n), this.lastEventId = e.lastEventId, this.listener?.({ lastEventId: e.lastEventId, traceId: t.trace_id, ...n, from: t.from, requestSource: i, connectSource: t.connect_source });
  }
  async gatewayErrorsListener(e) {
    if (this.gateway?.isClosed || this.gateway?.isConnecting) {
      let r = p(this.abortController?.signal);
      try {
        return s("[BridgeProvider] Error in gatewayErrorsListener, trying to reconnect:", e), this.onConnectingCallback?.(), this.reconnect(r.signal);
      } catch (n) {
        r.abort(), s("[BridgeProvider] Error in gatewayErrorsListener after reconnect:", n), this.errorListener?.(n);
      }
    }
    let t = new a(`Bridge error ${JSON.stringify(e)}`);
    b("[BridgeProvider] Gateway error:", t), this.errorListener?.(t);
  }
  async openGateway(e, t) {
    if (t?.signal?.aborted) {
      s("[BridgeProvider] Open gateway aborted before start.");
      return;
    }
    if (this.gateway && (s("[BridgeProvider] Existing gateway detected. Closing it..."), await this.closeGateway()), s("[BridgeProvider] Creating new BridgeGateway instance..."), t?.signal?.aborted) {
      s("[BridgeProvider] Open gateway aborted after close.");
      return;
    }
    this.gateway = new v(this.bridgeUrl, T(e.map(({ sessionId: r }) => r)), this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.lastEventId, "message", true), s("[BridgeProvider] BridgeGateway created. Connecting to bridge..."), this.onConnectingCallback?.(), await this.gateway.registerSession({ connectingDeadlineMS: t?.connectingDeadlineMS, signal: t?.signal }), s("[BridgeProvider] Connected to bridge successfully.");
  }
  async closeGateway() {
    this.gateway && (s("[BridgeProvider] Closing previous gateway..."), await this.gateway.close(), this.gateway = null, s("[BridgeProvider] Gateway closed."));
  }
};
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const _state = {};
function v7(options, buf2, offset) {
  let bytes;
  {
    const now = Date.now();
    const rnds = rng();
    updateV7State(_state, now, rnds);
    bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf2, offset);
  }
  return unsafeStringify(bytes);
}
function updateV7State(state, now, rnds) {
  state.msecs ??= -Infinity;
  state.seq ??= 0;
  if (now > state.msecs) {
    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    state.msecs = now;
  } else {
    state.seq = state.seq + 1 | 0;
    if (state.seq === 0) {
      state.msecs++;
    }
  }
  return state;
}
function v7Bytes(rnds, msecs, seq, buf2, offset = 0) {
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  if (!buf2) {
    buf2 = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf2.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
  }
  msecs ??= Date.now();
  seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
  buf2[offset++] = msecs / 1099511627776 & 255;
  buf2[offset++] = msecs / 4294967296 & 255;
  buf2[offset++] = msecs / 16777216 & 255;
  buf2[offset++] = msecs / 65536 & 255;
  buf2[offset++] = msecs / 256 & 255;
  buf2[offset++] = msecs & 255;
  buf2[offset++] = 112 | seq >>> 28 & 15;
  buf2[offset++] = seq >>> 20 & 255;
  buf2[offset++] = 128 | seq >>> 14 & 63;
  buf2[offset++] = seq >>> 6 & 255;
  buf2[offset++] = seq << 2 & 255 | rnds[10] & 3;
  buf2[offset++] = rnds[11];
  buf2[offset++] = rnds[12];
  buf2[offset++] = rnds[13];
  buf2[offset++] = rnds[14];
  buf2[offset++] = rnds[15];
  return buf2;
}
const DEFAULT_DEVICE_INFO = {
  platform: "browser",
  appName: "Wallet",
  appVersion: "1.0.0",
  maxProtocolVersion: 2,
  features: [
    "SendTransaction",
    {
      name: "SendTransaction",
      maxMessages: 1
    }
  ]
};
const DEFAULT_WALLET_INFO = {
  name: "Wallet",
  appName: "Wallet",
  imageUrl: "https://example.com/image.png",
  bridgeUrl: "https://example.com/bridge.png",
  universalLink: "https://example.com/universal-link",
  aboutUrl: "https://example.com/about",
  platforms: ["chrome", "firefox", "safari", "android", "ios", "windows", "macos", "linux"],
  jsBridgeKey: "wallet"
};
function getDeviceInfoWithDefaults(options) {
  const deviceInfo = {
    ...DEFAULT_DEVICE_INFO,
    ...options
  };
  return addLegacySendTransactionFeature(deviceInfo);
}
function createDeviceInfo(options) {
  const infoWithDefaults = getDeviceInfoWithDefaults(options);
  const features = [];
  if (infoWithDefaults.features.some((feature) => typeof feature === "object" && feature.name === "SendTransaction")) {
    const sendTransactionFeature = infoWithDefaults.features.find((feature) => typeof feature === "object" && feature.name === "SendTransaction");
    if (sendTransactionFeature) {
      features.push({
        name: "SendTransaction",
        maxMessages: sendTransactionFeature.maxMessages ?? 1
      });
      features.push("SendTransaction");
    }
  } else if (infoWithDefaults.features.some((feature) => feature === "SendTransaction")) {
    features.push("SendTransaction");
  }
  if (infoWithDefaults.features.some((feature) => typeof feature === "object" && feature.name === "SignData")) {
    const signDataFeature = infoWithDefaults.features.find((feature) => typeof feature === "object" && feature.name === "SignData");
    if (signDataFeature) {
      features.push({
        name: "SignData",
        types: signDataFeature.types
      });
    }
  }
  return infoWithDefaults;
}
function createWalletManifest(options) {
  const walletInfo = getWalletInfoWithDefaults(options);
  return walletInfo;
}
function getWalletInfoWithDefaults(options) {
  const walletInfo = {
    ...DEFAULT_WALLET_INFO,
    ...options
  };
  return walletInfo;
}
function getDeviceInfoForWallet(walletAdapter, deviceInfoOptions) {
  const baseDeviceInfo = getDeviceInfoWithDefaults(deviceInfoOptions);
  if (walletAdapter?.getSupportedFeatures) {
    const adapterFeatures = walletAdapter.getSupportedFeatures();
    const deviceInfo = {
      ...baseDeviceInfo,
      features: adapterFeatures
    };
    return addLegacySendTransactionFeature(deviceInfo);
  }
  return baseDeviceInfo;
}
function addLegacySendTransactionFeature(options) {
  const features = options.features;
  const hasSendTransactionString = features.some((feature) => feature === "SendTransaction");
  const hasSendTransactionObject = features.some((feature) => typeof feature === "object" && feature.name === "SendTransaction");
  const shouldAddString = !hasSendTransactionString && hasSendTransactionObject;
  return {
    ...options,
    features: shouldAddString ? ["SendTransaction", ...features] : features
  };
}
const DEFAULT_REQUEST_TIMEOUT = 3e5;
const RESTORE_CONNECTION_TIMEOUT = 1e4;
const TONCONNECT_BRIDGE_RESPONSE = "TONCONNECT_BRIDGE_RESPONSE";
const TONCONNECT_BRIDGE_EVENT = "TONCONNECT_BRIDGE_EVENT";
globalLogger.createChild("ExtensionTransport");
const log$h = globalLogger.createChild("BridgeManager");
class BridgeManager {
  config;
  bridgeProvider;
  sessionManager;
  storage;
  isConnected = false;
  reconnectAttempts = 0;
  lastEventId;
  storageKey = "bridge_last_event_id";
  walletKitConfig;
  jsBridgeTransport;
  // Event processing queue and concurrency control
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eventQueue = [];
  isProcessing = false;
  // Durable events support
  eventStore;
  eventRouter;
  eventEmitter;
  analytics;
  requestProcessingTimeoutId;
  constructor(walletManifest, config, sessionManager, storage, eventStore, eventRouter, walletKitConfig, eventEmitter, analyticsManager) {
    const isManifestJsBridge = walletManifest && "jsBridgeKey" in walletManifest ? true : false;
    const manifestJsBridgeKey = walletManifest && "jsBridgeKey" in walletManifest ? walletManifest.jsBridgeKey : void 0;
    const manifestBridgeUrl = walletManifest && "bridgeUrl" in walletManifest ? walletManifest.bridgeUrl : void 0;
    this.config = {
      heartbeatInterval: 5e3,
      reconnectInterval: 15e3,
      maxReconnectAttempts: 5,
      ...{
        enableJsBridge: isManifestJsBridge,
        jsBridgeKey: manifestJsBridgeKey,
        bridgeUrl: manifestBridgeUrl
      },
      ...config
    };
    this.sessionManager = sessionManager;
    this.storage = storage;
    this.eventStore = eventStore;
    this.eventEmitter = eventEmitter;
    this.eventRouter = eventRouter;
    this.analytics = analyticsManager?.scoped({
      bridge_url: this.config.bridgeUrl
    });
    this.walletKitConfig = walletKitConfig;
    this.jsBridgeTransport = config?.jsBridgeTransport;
    if (!this.jsBridgeTransport && config?.enableJsBridge) {
      throw new WalletKitError(ERROR_CODES.INVALID_CONFIG, "JS Bridge transport is not configured");
    }
  }
  /**
   * Initialize bridge connection
   */
  async start() {
    if (this.bridgeProvider) {
      log$h.warn("Bridge already initialized");
      return;
    }
    try {
      await this.loadLastEventId();
      if (!this.config?.disableHttpConnection) {
        await this.connectToSSEBridge();
      } else {
        this.isConnected = true;
        this.reconnectAttempts = 0;
      }
    } catch (error2) {
      log$h.error("Failed to start bridge", { error: error2 });
      throw error2;
    }
    const requestProcessing = () => {
      this.processBridgeEvents();
      this.requestProcessingTimeoutId = setTimeout(requestProcessing, 1e3);
    };
    requestProcessing();
  }
  /**
   * Create new session for a dApp connection
   */
  async createSession(appSessionId) {
    log$h.info("[BRIDGE] Creating session", { appSessionId });
    const session = await this.sessionManager.getSession(appSessionId);
    if (!session) {
      throw new WalletKitError(ERROR_CODES.SESSION_NOT_FOUND, `Session not found`, void 0, {
        appSessionId
      });
    }
    if (this.bridgeProvider && this.isConnected) {
      log$h.info("[BRIDGE] Updating clients");
      await this.updateClients();
    }
  }
  /**
   * Remove session
   */
  async removeSession(appSessionId) {
    if (this.bridgeProvider && this.isConnected) {
      await this.updateClients();
    }
    log$h.debug("Session removed", { appSessionId });
  }
  /**
   * Send response to dApp
   */
  async sendResponse(event, response, providedSessionCrypto) {
    if (event.isLocal) {
      return;
    }
    if (event.isJsBridge) {
      return this.sendJsBridgeResponse(event.tabId?.toString() || "", event.isJsBridge, event.messageId ?? null, response, {
        traceId: event?.traceId
      });
    }
    if (!this.bridgeProvider) {
      throw new WalletKitError(ERROR_CODES.BRIDGE_NOT_INITIALIZED, "Bridge not initialized for sending response");
    }
    const sessionId = event.from || event.sessionId;
    if (!sessionId) {
      throw new WalletKitError(ERROR_CODES.SESSION_ID_REQUIRED, "Session ID is required for sending response", void 0, { event: { id: event.id } });
    }
    let sessionCrypto = providedSessionCrypto;
    if (!sessionCrypto) {
      const session = await this.sessionManager.getSession(sessionId);
      if (session) {
        sessionCrypto = new SessionCrypto({
          publicKey: session.publicKey,
          secretKey: session.privateKey
        });
      } else {
        throw new WalletKitError(ERROR_CODES.SESSION_NOT_FOUND, `Session not found for response`, void 0, {
          sessionId,
          eventId: event.id
        });
      }
    }
    try {
      await this.bridgeProvider.send(response, sessionCrypto, sessionId, {
        traceId: event?.traceId
      });
      log$h.debug("Response sent successfully", { sessionId, requestId: event.id });
    } catch (error2) {
      log$h.error("Failed to send response through bridge", {
        sessionId,
        requestId: event.id,
        error: error2
      });
      throw WalletKitError.fromError(ERROR_CODES.BRIDGE_RESPONSE_SEND_FAILED, "Failed to send response through bridge", error2, { sessionId, requestId: event.id });
    }
  }
  async sendJsBridgeResponse(sessionId, _isJsBridge, requestId, response, options) {
    const source = this.config.jsBridgeKey + "-tonconnect";
    const message = {
      type: TONCONNECT_BRIDGE_RESPONSE,
      source,
      messageId: requestId,
      success: true,
      payload: response,
      traceId: options?.traceId
    };
    if (this.jsBridgeTransport) {
      try {
        await this.jsBridgeTransport(sessionId, message);
      } catch (e) {
        console.error("Failed to send response through JS Bridge", { error: e });
      }
    } else {
      throw new WalletKitError(ERROR_CODES.INVALID_CONFIG, "JS Bridge transport is not configured");
    }
  }
  /**
   * Close bridge connection
   */
  async close() {
    if (this.bridgeProvider) {
      await this.bridgeProvider.close();
      this.bridgeProvider = void 0;
    }
    this.eventQueue = [];
    this.isProcessing = false;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    if (this.requestProcessingTimeoutId) {
      clearTimeout(this.requestProcessingTimeoutId);
      this.requestProcessingTimeoutId = void 0;
    }
  }
  /**
   * Get connection status
   */
  isConnectedToBridge() {
    return this.isConnected;
  }
  /**
   * Get active session count
   */
  // getSessionCount(): number {
  //     return this.sessions.size;
  // }
  async getClients() {
    return (await this.sessionManager.getSessions()).map((session) => ({
      session: new SessionCrypto({
        publicKey: session.publicKey,
        secretKey: session.privateKey.length > 64 ? session.privateKey.slice(0, 64) : session.privateKey
      }),
      clientId: session.sessionId
    }));
  }
  /**
   * Connect to TON Connect bridge
   */
  async connectToSSEBridge() {
    if (!this.config.bridgeUrl) {
      return;
    }
    const connectTraceId = v7();
    try {
      const clients = await this.getClients();
      if (clients.length === 0) {
        clients.push({
          clientId: "0",
          session: new SessionCrypto()
        });
      }
      if (this.analytics) {
        const client = clients[0];
        this.analytics.emitBridgeClientConnectStarted({
          trace_id: connectTraceId,
          client_id: client?.clientId
        });
      }
      this.bridgeProvider = await C.open({
        bridgeUrl: this.config.bridgeUrl,
        clients,
        listener: this.queueBridgeEvent.bind(this),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        errorListener: (error2) => {
          log$h.error("Bridge listener error", { error: error2.toString() });
          this.analytics?.emitBridgeClientConnectError({
            error_message: `${error2?.toString() || "Unknown error"}${error2?.errorCode ? ` (Code: ${error2?.errorCode})` : ""}`,
            trace_id: error2?.traceId ?? connectTraceId,
            client_id: error2?.clientId
          });
        },
        options: {
          lastEventId: this.lastEventId
          // heartbeatReconnectIntervalMs: this.config.reconnectInterval,
        }
      });
      this.isConnected = true;
      this.reconnectAttempts = 0;
      log$h.info("Bridge connected successfully");
      if (this.analytics) {
        const client = clients[0];
        this.analytics.emitBridgeClientConnectEstablished({
          trace_id: connectTraceId,
          client_id: client?.clientId
        });
      }
    } catch (error2) {
      log$h.error("Bridge connection failed", { error: error2?.toString() });
      this.analytics?.emitBridgeClientConnectError({
        error_message: `${error2?.toString() || "Unknown error"}${error2?.errorCode ? ` (Code: ${error2?.errorCode})` : ""}`,
        trace_id: error2?.traceId ?? connectTraceId,
        client_id: error2?.clientId
      });
      if (!this.config.disableHttpConnection) {
        if (this.reconnectAttempts < (this.config.maxReconnectAttempts || 5)) {
          this.reconnectAttempts++;
          log$h.info("Bridge reconnection attempt", { attempt: this.reconnectAttempts });
          setTimeout(() => {
            this.connectToSSEBridge().catch((error3) => log$h.error("Bridge reconnection failed", { error: error3 }));
          }, this.config.reconnectInterval);
        }
      }
      throw WalletKitError.fromError(ERROR_CODES.BRIDGE_CONNECTION_FAILED, "Failed to connect to bridge", error2, {
        reconnectAttempts: this.reconnectAttempts,
        bridgeUrl: this.config.bridgeUrl
      });
    }
  }
  /**
   * Restart bridge connection in case of error, so we can receive events again
   */
  async restartConnection() {
    await this.close();
    await this.start();
  }
  /**
   * Add client to existing bridge connection
   */
  async updateClients() {
    log$h.debug("Updating clients");
    if (this.bridgeProvider) {
      const clients = await this.getClients();
      log$h.info("[BRIDGE] Restoring connection", { clients: clients.length });
      await this.bridgeProvider.restoreConnection(clients, {
        lastEventId: this.lastEventId
      });
    }
  }
  /**
   * Queue incoming bridge events for processing
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  queueBridgeEvent(event) {
    log$h.debug("Bridge event queued", { eventId: event?.id, event });
    this.eventQueue.push(event);
    this.processBridgeEvents().catch((error2) => {
      log$h.error("Error in background event processing", { error: error2 });
    });
  }
  queueJsBridgeEvent(messageInfo, event) {
    log$h.debug("JS Bridge event queued", { eventId: messageInfo?.messageId });
    if (!event) {
      return;
    }
    if (!event.traceId) {
      event.traceId = v7();
    }
    if (event.method == "connect") {
      this.eventQueue.push({
        ...event,
        isJsBridge: true,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId,
        walletId: messageInfo.walletId
      });
    } else if (event.method == "restoreConnection") {
      this.eventEmitter?.emit("restoreConnection", {
        ...event,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId,
        walletId: messageInfo.walletId
      });
    } else if (event.method == "send" && event?.params?.length === 1) {
      this.eventQueue.push({
        ...event,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ...event.params[0],
        isJsBridge: true,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId,
        walletId: messageInfo.walletId
      });
    }
    this.processBridgeEvents().catch((error2) => {
      log$h.error("Error in background event processing", { error: error2 });
    });
  }
  /**
   * Process events from the queue with concurrency control
   * New events from the bridge added to eventQueue to avoid concurrency
   * processBridgeEvents takes events from queue one by one and tries to store them durably
   * if event stored successfully, we will update lastEventId and proceed to the next event
   * if we've encountered error, bridge connection we be restarted from last success id, so we should try to process same event again
   */
  async processBridgeEvents() {
    if (this.isProcessing) {
      log$h.debug("Event processing already in progress, skipping");
      return;
    }
    this.isProcessing = true;
    try {
      while (this.eventQueue.length > 0) {
        const event = this.eventQueue.shift();
        if (event) {
          event.isLocal = false;
          await this.handleBridgeEvent(event);
        }
      }
    } catch (error2) {
      log$h.error("Error during event processing", { error: error2 });
      this.isProcessing = false;
      this.restartConnection();
      return;
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Handle individual bridge event (original processing logic)
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleBridgeEvent(event) {
    try {
      log$h.info("Bridge event received", { event });
      const rawEvent = {
        id: event.id || crypto.randomUUID(),
        method: event.method || "unknown",
        params: event.params || event,
        // sessionId: event.from,
        timestamp: Date.now(),
        from: event?.from,
        domain: event?.domain,
        isJsBridge: event?.isJsBridge,
        tabId: event?.tabId,
        messageId: event?.messageId,
        traceId: event?.traceId,
        walletId: event?.walletId
      };
      if (!rawEvent.traceId) {
        rawEvent.traceId = v7();
      }
      await this.sessionManager.initialize();
      if (rawEvent.from) {
        const session = await this.sessionManager.getSession(rawEvent.from);
        rawEvent.domain = session?.domain || "";
        if (session) {
          if (session?.walletId) {
            rawEvent.walletId = session.walletId;
          }
          if (session?.walletAddress) {
            rawEvent.walletAddress = session.walletAddress;
          }
          rawEvent.dAppInfo = {
            name: session.dAppName,
            description: session.dAppDescription,
            url: session.dAppUrl,
            iconUrl: session.dAppIconUrl
          };
        }
      } else if (rawEvent.domain) {
        const sessions = await this.sessionManager.getSessions({
          walletId: event.walletId,
          domain: rawEvent.domain,
          isJsBridge: rawEvent.isJsBridge
        });
        const session = sessions.length > 0 ? sessions[0] : void 0;
        if (session?.walletId) {
          rawEvent.walletId = session.walletId;
        }
        if (session?.walletAddress) {
          rawEvent.walletAddress = session.walletAddress;
        }
        if (session?.sessionId) {
          rawEvent.from = session.sessionId;
        }
        if (session) {
          rawEvent.dAppInfo = {
            name: session.dAppName,
            description: session.dAppDescription,
            url: session.dAppUrl,
            iconUrl: session.dAppIconUrl
          };
          if (!rawEvent.from) {
            rawEvent.from = session.sessionId;
          }
        }
      }
      if (!this.eventStore) {
        throw new WalletKitError(ERROR_CODES.EVENT_STORE_NOT_INITIALIZED, "Event store is not initialized");
      }
      try {
        await this.eventStore.storeEvent(rawEvent);
        if (this.eventEmitter) {
          this.eventEmitter.emit("bridge-storage-updated");
        }
        log$h.info("Event stored durably", { eventId: rawEvent.id, method: rawEvent.method });
      } catch (error2) {
        log$h.error("Failed to store event durably", {
          eventId: rawEvent.id,
          error: error2.message
        });
        throw WalletKitError.fromError(ERROR_CODES.EVENT_STORE_OPERATION_FAILED, "Failed to store event durably", error2, { eventId: rawEvent.id, method: rawEvent.method });
      }
      log$h.info("Bridge event processed", { rawEvent });
      if (event?.lastEventId && event.lastEventId !== this.lastEventId) {
        this.lastEventId = event.lastEventId;
        await this.saveLastEventId();
      }
    } catch (error2) {
      log$h.error("Error handling bridge event", { error: error2 });
    }
  }
  /**
   * Load last event ID from storage
   */
  async loadLastEventId() {
    try {
      const savedEventId = await this.storage.get(this.storageKey);
      if (savedEventId) {
        this.lastEventId = savedEventId;
        log$h.debug("Loaded last event ID from storage", { lastEventId: this.lastEventId });
      }
    } catch (error2) {
      const storageError = WalletKitError.fromError(ERROR_CODES.STORAGE_READ_FAILED, "Failed to load last event ID from storage", error2);
      log$h.warn("Failed to load last event ID from storage", { error: storageError });
    }
  }
  /**
   * Save last event ID to storage
   */
  async saveLastEventId() {
    try {
      if (this.lastEventId) {
        await this.storage.set(this.storageKey, this.lastEventId);
        log$h.debug("Saved last event ID to storage", { lastEventId: this.lastEventId });
      }
    } catch (error2) {
      const storageError = WalletKitError.fromError(ERROR_CODES.STORAGE_WRITE_FAILED, "Failed to save last event ID to storage", error2);
      log$h.warn("Failed to save last event ID to storage", { error: storageError });
    }
  }
}
class BasicHandler {
  _notifyHandler;
  constructor(notify) {
    this._notifyHandler = notify;
  }
  async notify(event) {
    if (this._notifyHandler) {
      return await this._notifyHandler(event);
    }
    return Promise.resolve();
  }
}
function isValidHost(host) {
  if (host.indexOf(".") === -1)
    return false;
  if (host.startsWith(".") || host.endsWith("."))
    return false;
  const parts = host.split(".");
  return parts.every((part) => part.length > 0);
}
const log$g = globalLogger.createChild("ConnectHandler");
class ConnectHandler extends BasicHandler {
  analytics;
  constructor(notify, analyticsManager) {
    super(notify);
    this.analytics = analyticsManager?.scoped();
  }
  canHandle(event) {
    return event.method === "connect";
  }
  async handle(event) {
    const manifestUrl = this.extractManifestUrl(event);
    let manifest = null;
    let manifestFetchErrorCode = void 0;
    if (manifestUrl) {
      try {
        const result = await this.fetchManifest(manifestUrl);
        manifest = result.manifest;
        manifestFetchErrorCode = result.manifestFetchErrorCode;
      } catch (error2) {
        log$g.warn("Failed to fetch manifest", { error: error2 });
      }
    }
    const preview = this.createPreview(event, manifestUrl, manifest, manifestFetchErrorCode);
    const connectEvent = {
      ...event,
      id: event.id,
      requestedItems: event.params.items ? this.toConnectionRequestEventRequestedItems(event.params.items) : [],
      preview,
      dAppInfo: preview.dAppInfo,
      isJsBridge: event.isJsBridge,
      tabId: event.tabId,
      returnStrategy: event.params.returnStrategy
    };
    this.analytics?.emitWalletConnectRequestReceived({
      trace_id: event.traceId,
      client_id: event.from,
      manifest_json_url: manifestUrl || preview?.dAppInfo?.manifestUrl,
      is_ton_addr: event.params?.items?.some((item) => item.name === "ton_addr") || false,
      is_ton_proof: event.params?.items?.some((item) => item.name === "ton_proof") || false,
      proof_payload_size: event.params?.items?.some((item) => item.name === "ton_proof") ? event.params?.items?.find((item) => item.name === "ton_proof")?.payload?.length : 0
    });
    return connectEvent;
  }
  toConnectionRequestEventRequestedItems(items) {
    return items.map((item) => {
      if (item.name === "ton_addr") {
        return { type: "ton_addr" };
      } else if (item.name === "ton_proof") {
        return {
          type: "ton_proof",
          value: {
            payload: item.payload
          }
        };
      } else {
        return { type: "unknown", value: item };
      }
    });
  }
  /**
   * Extract dApp name from bridge event or manifest
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractDAppName(event, manifest) {
    const name = manifest?.name || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    event.params?.manifest?.name || "Unknown dApp";
    return name?.toString()?.trim();
  }
  /**
   * Extract manifest URL from bridge event
   */
  extractManifestUrl(event) {
    const url = event.params?.manifest?.url ?? event.params?.manifestUrl ?? "";
    return url.trim();
  }
  /**
   * Create preview object for connect request
   */
  createPreview(event, manifestUrl, fetchedManifest, manifestFetchErrorCode) {
    const eventManifest = event.params?.manifest;
    const manifest = fetchedManifest || eventManifest;
    const dAppUrl = (event?.domain || manifest?.url?.toString() || "").trim();
    let finalManifestFetchErrorCode = manifestFetchErrorCode;
    if (!finalManifestFetchErrorCode && dAppUrl) {
      try {
        const parsedDAppUrl = new URL(dAppUrl);
        if (!isValidHost(parsedDAppUrl.host)) {
          log$g.warn("Invalid dApp URL in manifest - invalid host format", {
            dAppUrl,
            host: parsedDAppUrl.host
          });
          finalManifestFetchErrorCode = CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR;
        }
      } catch (_) {
        log$g.warn("Invalid dApp URL in manifest - failed to parse", { dAppUrl });
        finalManifestFetchErrorCode = CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR;
      }
    }
    const sanitizedManifest = manifest && {
      name: manifest.name?.toString()?.trim() || "",
      description: manifest.description?.toString()?.trim() || "",
      iconUrl: manifest.iconUrl?.toString()?.trim() || ""
    };
    const requestedItems = event.params?.items || [];
    const permissions = [];
    const addrItem = requestedItems.find((item) => item.name === "ton_addr");
    if (addrItem) {
      permissions.push({
        name: "ton_addr",
        title: "TON Address",
        description: "Gives dApp information about your TON address"
      });
    }
    const proofItem = requestedItems.find((item) => item.name === "ton_proof");
    if (proofItem) {
      permissions.push({
        name: "ton_proof",
        title: "TON Proof",
        description: "Gives dApp signature, that can be used to verify your access to private key"
      });
    }
    return {
      permissions,
      dAppInfo: {
        url: dAppUrl,
        name: sanitizedManifest?.name,
        description: sanitizedManifest?.description,
        iconUrl: sanitizedManifest?.iconUrl,
        manifestUrl
      },
      manifestFetchErrorCode: finalManifestFetchErrorCode ?? void 0
    };
  }
  static MANIFEST_PROXY_URL = "https://walletbot.me/tonconnect-proxy/";
  /**
   * Fetch manifest from URL
   */
  async fetchManifest(manifestUrl) {
    try {
      const parsedUrl = new URL(manifestUrl);
      if (!isValidHost(parsedUrl.host)) {
        return {
          manifest: null,
          manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR
        };
      }
    } catch (_) {
      return {
        manifest: null,
        manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR
      };
    }
    const directResult = await this.tryFetchManifest(manifestUrl);
    if (directResult.manifest) {
      return directResult;
    }
    log$g.info("Direct manifest fetch failed, trying proxy", { manifestUrl });
    const proxyUrl = `${ConnectHandler.MANIFEST_PROXY_URL}${manifestUrl}`;
    return this.tryFetchManifest(proxyUrl);
  }
  async tryFetchManifest(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        return {
          manifest: null,
          manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR
        };
      }
      const result = await response.json();
      return {
        manifest: result,
        manifestFetchErrorCode: void 0
      };
    } catch (_) {
      return {
        manifest: null,
        manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR
      };
    }
  }
}
var SendModeBase;
(function(SendModeBase2) {
  SendModeBase2[SendModeBase2["ORDINARY"] = 0] = "ORDINARY";
  SendModeBase2[SendModeBase2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
  SendModeBase2[SendModeBase2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
})(SendModeBase || (SendModeBase = {}));
var SendModeFlag;
(function(SendModeFlag2) {
  SendModeFlag2[SendModeFlag2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
  SendModeFlag2[SendModeFlag2["BOUNCE_IF_FAILURE"] = 16] = "BOUNCE_IF_FAILURE";
  SendModeFlag2[SendModeFlag2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
  SendModeFlag2[SendModeFlag2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
})(SendModeFlag || (SendModeFlag = {}));
function SendModeFromValue(value) {
  let base;
  if (value & SendModeBase.CARRY_ALL_REMAINING_BALANCE) {
    base = SendModeBase.CARRY_ALL_REMAINING_BALANCE;
  } else if (value & SendModeBase.CARRY_ALL_REMAINING_INCOMING_VALUE) {
    base = SendModeBase.CARRY_ALL_REMAINING_INCOMING_VALUE;
  } else {
    base = SendModeBase.ORDINARY;
  }
  const flags = [];
  if (value & SendModeFlag.DESTROY_ACCOUNT_IF_ZERO) {
    flags.push(SendModeFlag.DESTROY_ACCOUNT_IF_ZERO);
  }
  if (value & SendModeFlag.BOUNCE_IF_FAILURE) {
    flags.push(SendModeFlag.BOUNCE_IF_FAILURE);
  }
  if (value & SendModeFlag.IGNORE_ERRORS) {
    flags.push(SendModeFlag.IGNORE_ERRORS);
  }
  if (value & SendModeFlag.PAY_GAS_SEPARATELY) {
    flags.push(SendModeFlag.PAY_GAS_SEPARATELY);
  }
  return { base, flags };
}
function SendModeToValue(sendMode) {
  let value = sendMode.base ?? SendModeBase.ORDINARY;
  for (const flag of sendMode.flags) {
    value |= flag;
  }
  return value;
}
function toExtraCurrencies(extraCurrency) {
  if (!extraCurrency) {
    return void 0;
  }
  return extraCurrency;
}
function toTransactionRequestMessage(msg) {
  asAddressFriendly(msg.address);
  return {
    address: msg.address,
    amount: msg.amount,
    payload: msg.payload ? msg.payload : void 0,
    stateInit: msg.stateInit ? msg.stateInit : void 0,
    extraCurrency: toExtraCurrencies(msg.extraCurrency),
    mode: msg.mode ? SendModeFromValue(msg.mode) : void 0
  };
}
function toConnectTransactionParamMessage(message) {
  return {
    address: message.address,
    amount: message.amount,
    payload: message.payload,
    stateInit: message.stateInit,
    extraCurrency: message.extraCurrency,
    mode: message.mode ? SendModeToValue(message.mode) : void 0
  };
}
function toTransactionRequest(params) {
  return {
    messages: params.messages.map(toTransactionRequestMessage),
    network: params.network ? { chainId: params.network } : void 0,
    validUntil: params.valid_until,
    fromAddress: params.from
  };
}
function toConnectTransactionParamContent(request) {
  return {
    messages: request.messages.map(toConnectTransactionParamMessage),
    network: request.network?.chainId,
    valid_until: request.validUntil,
    from: request.fromAddress
  };
}
function toAddressBookEntry(row) {
  return {
    domain: row.domain ?? void 0,
    address: asAddressFriendly(row.user_friendly),
    interfaces: row.interfaces
  };
}
function toAddressBook(addressBookV3) {
  const addressBook = {};
  for (const [_, row] of Object.entries(addressBookV3)) {
    const userFriendlyAddress = asAddressFriendly(row.user_friendly);
    addressBook[userFriendlyAddress] = toAddressBookEntry(row);
  }
  return addressBook;
}
function toTransactionEmulatedTrace(response) {
  return {
    mcBlockSeqno: response.mc_block_seqno,
    trace: toTransactionTraceNode(response.trace),
    transactions: Object.fromEntries(Object.entries(response.transactions ?? {}).map(([hash, tx]) => [Base64ToHex(hash), toTransaction(tx)])),
    actions: response.actions.map(toTransactionTraceAction),
    randSeed: Base64ToHex(response.rand_seed),
    isIncomplete: response.is_incomplete,
    codeCells: Object.fromEntries(Object.entries(response.code_cells ?? {}).map(([hash, cell]) => [Base64ToHex(hash), cell])),
    dataCells: Object.fromEntries(Object.entries(response.data_cells ?? {}).map(([hash, cell]) => [Base64ToHex(hash), cell])),
    metadata: {},
    // to be filled later
    addressBook: {}
    // to be filled later
  };
}
function toTransactionTraceNode(node) {
  return {
    txHash: node.tx_hash ? Base64ToHex(node.tx_hash) : void 0,
    inMsgHash: node.in_msg_hash ? Base64ToHex(node.in_msg_hash) : void 0,
    children: node.children?.map(toTransactionTraceNode) ?? []
  };
}
function toTransactionsResponse(response) {
  return {
    transactions: response.transactions?.map(toTransaction) ?? [],
    addressBook: toAddressBook(response.address_book)
  };
}
function toTransaction(tx) {
  return {
    account: asAddressFriendly(tx.account),
    accountStateBefore: toAccountState(tx.account_state_before),
    accountStateAfter: toAccountState(tx.account_state_after),
    description: toTransactionDescription(tx.description),
    hash: Base64ToHex(tx.hash),
    logicalTime: tx.lt,
    now: tx.now,
    mcBlockSeqno: tx.mc_block_seqno,
    traceExternalHash: Base64ToHex(tx.trace_external_hash),
    traceId: tx.trace_id ?? void 0,
    previousTransactionHash: tx.prev_trans_hash ? Base64ToHex(tx.prev_trans_hash) : void 0,
    previousTransactionLogicalTime: tx.prev_trans_lt ?? void 0,
    origStatus: toAccountStatus(tx.orig_status),
    endStatus: toAccountStatus(tx.end_status),
    totalFees: tx.total_fees,
    totalFeesExtraCurrencies: tx.total_fees_extra_currencies,
    blockRef: toTransactionBlockRef(tx.block_ref),
    inMessage: tx.in_msg ? toTransactionMessage(tx.in_msg) : void 0,
    outMessages: tx.out_msgs?.map(toTransactionMessage) ?? [],
    isEmulated: tx.emulated
  };
}
function toAccountStatus(status) {
  if (status === "active") {
    return { type: "active" };
  } else if (status === "frozen") {
    return { type: "frozen" };
  } else if (status === "uninit") {
    return { type: "uninit" };
  } else {
    return { type: "unknown", value: status };
  }
}
function toTransactionBlockRef(ref) {
  return {
    workchain: ref.workchain,
    shard: ref.shard,
    seqno: ref.seqno
  };
}
function toTransactionDescription(desc) {
  return {
    type: desc.type,
    isAborted: desc.aborted,
    isDestroyed: desc.destroyed,
    isCreditFirst: desc.credit_first,
    isTock: desc.is_tock,
    isInstalled: desc.installed,
    storagePhase: {
      storageFeesCollected: desc.storage_ph?.storage_fees_collected,
      statusChange: desc.storage_ph?.status_change
    },
    creditPhase: desc.credit_ph ? {
      credit: desc.credit_ph?.credit
    } : void 0,
    computePhase: {
      isSkipped: desc.compute_ph?.skipped,
      isSuccess: desc.compute_ph?.success,
      isMessageStateUsed: desc.compute_ph?.msg_state_used,
      isAccountActivated: desc.compute_ph?.account_activated,
      gasFees: desc.compute_ph?.gas_fees,
      gasUsed: desc.compute_ph?.gas_used,
      gasLimit: desc.compute_ph?.gas_limit,
      gasCredit: desc.compute_ph?.gas_credit,
      mode: desc.compute_ph?.mode,
      exitCode: desc.compute_ph?.exit_code,
      vmStepsNumber: desc.compute_ph?.vm_steps,
      vmInitStateHash: desc.compute_ph?.vm_init_state_hash ? Base64ToHex(desc.compute_ph.vm_init_state_hash) : void 0,
      vmFinalStateHash: desc.compute_ph?.vm_final_state_hash ? Base64ToHex(desc.compute_ph.vm_final_state_hash) : void 0
    },
    action: {
      isSuccess: desc.action?.success,
      isValid: desc.action?.valid,
      hasNoFunds: desc.action?.no_funds,
      statusChange: desc.action?.status_change,
      totalForwardingFees: desc.action?.total_fwd_fees,
      totalActionFees: desc.action?.total_action_fees,
      resultCode: desc.action?.result_code,
      totalActionsNumber: desc.action?.tot_actions,
      specActionsNumber: desc.action?.spec_actions,
      skippedActionsNumber: desc.action?.skipped_actions,
      messagesCreatedNumber: desc.action?.msgs_created,
      actionListHash: desc.action?.action_list_hash ? Base64ToHex(desc.action.action_list_hash) : void 0,
      totalMessagesSize: {
        cells: desc.action?.tot_msg_size.cells,
        bits: desc.action?.tot_msg_size.bits
      }
    }
  };
}
function toTransactionMessage(msg) {
  return {
    hash: Base64ToHex(msg.hash),
    normalizedHash: msg.hash_norm ? Base64ToHex(msg.hash_norm) : void 0,
    source: asMaybeAddressFriendly(msg.source) ?? void 0,
    destination: asMaybeAddressFriendly(msg.destination) ?? void 0,
    value: msg.value ?? void 0,
    valueExtraCurrencies: msg.value_extra_currencies,
    fwdFee: msg.fwd_fee ?? void 0,
    ihrFee: msg.ihr_fee ?? void 0,
    creationLogicalTime: msg.created_lt ?? void 0,
    createdAt: msg.created_at ? Number(msg.created_at) : void 0,
    ihrDisabled: msg.ihr_disabled ?? void 0,
    isBounce: msg.bounce ?? void 0,
    isBounced: msg.bounced ?? void 0,
    importFee: msg.import_fee ?? void 0,
    opcode: msg.opcode ?? void 0,
    messageContent: {
      hash: msg.message_content?.hash ? Base64ToHex(msg.message_content.hash) : void 0,
      body: msg.message_content?.body ? msg.message_content.body : void 0,
      decoded: msg.message_content?.decoded ?? void 0
    }
  };
}
function toAccountState(state) {
  return {
    hash: Base64ToHex(state.hash),
    balance: state.balance,
    extraCurrencies: state.extra_currencies ?? void 0,
    accountStatus: state.account_status ? toAccountStatus(state.account_status) : void 0,
    frozenHash: state.frozen_hash ? Base64ToHex(state.frozen_hash) : void 0,
    dataHash: state.data_hash ? Base64ToHex(state.data_hash) : void 0,
    codeHash: state.code_hash ? Base64ToHex(state.code_hash) : void 0
  };
}
function toTransactionTraceAction(action) {
  return {
    traceId: action.trace_id ?? void 0,
    actionId: action.action_id,
    startLt: action.start_lt,
    endLt: action.end_lt,
    startUtime: action.start_utime,
    endUtime: action.end_utime,
    traceEndLt: action.trace_end_lt,
    traceEndUtime: action.trace_end_utime,
    traceMcSeqnoEnd: action.trace_mc_seqno_end,
    transactions: action.transactions.map(Base64ToHex),
    isSuccess: action.success,
    traceExternalHash: Base64ToHex(action.trace_external_hash),
    // Filter out invalid addresses
    accounts: (action.accounts ?? []).map(asMaybeAddressFriendly).filter((addr) => addr !== null),
    details: toTransactionTraceActionDetails(action)
  };
}
function toTransactionTraceActionDetails(action) {
  if (action.type === "jetton_swap") {
    return {
      type: "jetton_swap",
      value: toTransactionTraceActionJettonSwapDetails(action.details)
    };
  } else if (action.type === "call_contract") {
    return {
      type: "call_contract",
      value: toTransactionTraceActionCallContractDetails(action.details)
    };
  } else if (action.type === "ton_transfer") {
    return {
      type: "ton_transfer",
      value: toTransactionTraceActionTONTransferDetails(action.details)
    };
  } else {
    return {
      type: "unknown",
      value: action.details
    };
  }
}
function toTransactionTraceActionJettonSwapDetails(details) {
  return {
    dex: details.dex,
    sender: asMaybeAddressFriendly(details.sender) ?? void 0,
    dexIncomingTransfer: {
      asset: asMaybeAddressFriendly(details.dex_incoming_transfer?.asset) ?? void 0,
      source: asMaybeAddressFriendly(details.dex_incoming_transfer?.source) ?? void 0,
      destination: asMaybeAddressFriendly(details.dex_incoming_transfer?.destination) ?? void 0,
      sourceJettonWallet: asMaybeAddressFriendly(details.dex_incoming_transfer?.source_jetton_wallet) ?? void 0,
      destinationJettonWallet: asMaybeAddressFriendly(details.dex_incoming_transfer?.destination_jetton_wallet) ?? void 0,
      amount: details.dex_incoming_transfer?.amount
    },
    dexOutgoingTransfer: {
      asset: asMaybeAddressFriendly(details.dex_outgoing_transfer?.asset) ?? void 0,
      source: asMaybeAddressFriendly(details.dex_outgoing_transfer?.source) ?? void 0,
      destination: asMaybeAddressFriendly(details.dex_outgoing_transfer?.destination) ?? void 0,
      sourceJettonWallet: asMaybeAddressFriendly(details.dex_outgoing_transfer?.source_jetton_wallet) ?? void 0,
      destinationJettonWallet: asMaybeAddressFriendly(details.dex_outgoing_transfer?.destination_jetton_wallet) ?? void 0,
      amount: details.dex_outgoing_transfer?.amount
    },
    peerSwaps: details.peer_swaps
  };
}
function toTransactionTraceActionCallContractDetails(details) {
  return {
    opcode: details.opcode,
    source: asMaybeAddressFriendly(details.source) ?? void 0,
    destination: asMaybeAddressFriendly(details.destination) ?? void 0,
    value: details.value,
    valueExtraCurrencies: details.extra_currencies ?? void 0
  };
}
function toTransactionTraceActionTONTransferDetails(details) {
  return {
    source: asMaybeAddressFriendly(details.source) ?? void 0,
    destination: asMaybeAddressFriendly(details.destination) ?? void 0,
    value: details.value,
    valueExtraCurrencies: details.value_extra_currencies,
    comment: details.comment ?? void 0,
    isEncrypted: details.encrypted
  };
}
var AssetType;
(function(AssetType2) {
  AssetType2["ton"] = "ton";
  AssetType2["jetton"] = "jetton";
  AssetType2["nft"] = "nft";
})(AssetType || (AssetType = {}));
const Network = {
  /**
   * TON Mainnet (chain ID: -239)
   */
  mainnet: () => ({ chainId: "-239" }),
  /**
   * TON Testnet (chain ID: -3)
   */
  testnet: () => ({ chainId: "-3" }),
  /**
   * Custom network with specified chain ID
   */
  custom: (chainId) => ({ chainId })
};
var Result;
(function(Result2) {
  Result2["success"] = "success";
  Result2["failure"] = "failure";
})(Result || (Result = {}));
const TON_PROXY_ADDRESSES = [
  "EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez",
  "EQBnGWMCf3-FZZq1W4IWcWiGAc3PHuZ0_H-7sad2oY00o83S"
];
const JETTON_TRANSFER_OPCODE = 260734629;
function parseJettonTransfer(slice) {
  if (slice.remainingBits < 32 || slice.preloadUint(32) !== JETTON_TRANSFER_OPCODE) {
    throw new Error("Expected JettonTransfer opcode 0x0f8a7ea5");
  }
  slice.loadUint(32);
  const queryId = slice.loadUintBig(64);
  const amount = slice.loadCoins();
  const destination = slice.loadMaybeAddress();
  const responseDestination = slice.loadMaybeAddress();
  const customPayloadFlag = slice.loadUint(1);
  const customPayload = customPayloadFlag === 0 ? null : slice.loadRef();
  const forwardTonAmount = slice.loadCoins();
  return {
    kind: "JettonTransfer",
    query_id: queryId,
    amount,
    destination,
    response_destination: responseDestination,
    custom_payload: customPayload,
    forward_ton_amount: forwardTonAmount
  };
}
function processToncenterMoneyFlow(emulation) {
  if (!emulation || !emulation.transactions) {
    return {
      outputs: "0",
      inputs: "0",
      allJettonTransfers: [],
      ourTransfers: [],
      ourAddress: void 0
    };
  }
  const firstTx = emulation.transactions[emulation.trace.tx_hash];
  const ourTxes = Object.values(emulation.transactions).filter((t) => t.account === firstTx.account);
  const messagesFrom = ourTxes.flatMap((t) => t.out_msgs);
  const messagesTo = ourTxes.flatMap((t) => t.in_msg).filter((m) => m !== null);
  const outputs = messagesFrom.reduce((acc, m) => {
    if (m.value) {
      return acc + BigInt(m.value);
    }
    return acc + 0n;
  }, 0n).toString();
  const inputs = messagesTo.reduce((acc, m) => {
    if (m.value) {
      return acc + BigInt(m.value);
    }
    return acc + 0n;
  }, 0n).toString();
  const jettonTransfers = [];
  for (const t of Object.values(emulation.transactions)) {
    if (!t.in_msg?.source) {
      continue;
    }
    let parsed = null;
    try {
      parsed = parseJettonTransfer(distExports$1.Cell.fromBase64(t.in_msg.message_content.body).beginParse());
    } catch (_) {
      continue;
    }
    if (!parsed) {
      continue;
    }
    const from = asMaybeAddressFriendly(t.in_msg.source);
    const to = parsed.destination instanceof distExports$1.Address ? parsed.destination : null;
    if (!to) {
      continue;
    }
    const jettonAmount = parsed.amount;
    const metadata = emulation.metadata[t.account];
    if (!metadata || !metadata?.token_info) {
      continue;
    }
    const tokenInfo = metadata.token_info.find((t2) => t2.valid && t2.type === "jetton_wallets");
    if (!tokenInfo) {
      continue;
    }
    const jettonAddress = asMaybeAddressFriendly(tokenInfo.extra.jetton);
    jettonTransfers.push({
      fromAddress: from ?? void 0,
      toAddress: asMaybeAddressFriendly(to.toString()) ?? void 0,
      tokenAddress: jettonAddress ?? void 0,
      amount: jettonAmount.toString(),
      assetType: AssetType.jetton
    });
  }
  const ourAddress = distExports$1.Address.parse(firstTx.account);
  const selfTransfers = [];
  const ourJettonTransfersByAddress = jettonTransfers.reduce((acc, transfer) => {
    if (transfer.assetType !== AssetType.jetton) {
      return acc;
    }
    const jettonKey = transfer.tokenAddress?.toString() || "unknown";
    if (TON_PROXY_ADDRESSES.includes(jettonKey)) {
      return acc;
    }
    const rawKey = distExports$1.Address.parse(jettonKey).toRawString().toUpperCase();
    if (!acc[rawKey]) {
      acc[rawKey] = 0n;
    }
    if (ourAddress && transfer.toAddress === ourAddress.toString()) {
      acc[rawKey] += BigInt(transfer.amount);
    }
    if (ourAddress && transfer.fromAddress === ourAddress.toString()) {
      acc[rawKey] -= BigInt(transfer.amount);
    }
    return acc;
  }, {});
  const ourJettonTransfers = Object.entries(ourJettonTransfersByAddress).map(([jettonKey, amount]) => ({
    assetType: AssetType.jetton,
    tokenAddress: asMaybeAddressFriendly(jettonKey) ?? void 0,
    amount: amount.toString()
  }));
  selfTransfers.push({
    assetType: AssetType.ton,
    amount: (BigInt(inputs) - BigInt(outputs)).toString()
  });
  selfTransfers.push(...ourJettonTransfers);
  return {
    outputs,
    inputs,
    allJettonTransfers: jettonTransfers,
    ourTransfers: selfTransfers,
    ourAddress: asAddressFriendly(ourAddress)
  };
}
async function createTransactionPreview(client, request, wallet2) {
  const txData = await wallet2?.getSignedSendTransaction(request, { fakeSignature: true });
  if (!txData) {
    return {
      result: Result.failure,
      error: {
        code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
        message: "Unknown emulation error"
      }
    };
  }
  let emulationResult;
  try {
    const emulatedResult = await CallForSuccess(() => client.fetchEmulation(txData, true));
    if (emulatedResult.result === "success") {
      emulationResult = emulatedResult.emulationResult;
    } else {
      return {
        result: Result.failure,
        error: {
          code: emulatedResult.emulationError.code,
          message: emulatedResult.emulationError.message
        }
      };
    }
  } catch (_error) {
    return {
      result: Result.failure,
      error: {
        code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
        message: "Unknown emulation error"
      }
    };
  }
  const moneyFlow = processToncenterMoneyFlow(emulationResult);
  return {
    result: Result.success,
    trace: toTransactionEmulatedTrace(emulationResult),
    moneyFlow
  };
}
const log$f = globalLogger.createChild("TransactionHandler");
class TransactionHandler extends BasicHandler {
  config;
  walletManager;
  sessionManager;
  eventEmitter;
  analytics;
  constructor(notify, config, eventEmitter, walletManager, sessionManager, analyticsManager) {
    super(notify);
    this.config = config;
    this.walletManager = walletManager;
    this.sessionManager = sessionManager;
    this.eventEmitter = eventEmitter;
    this.sessionManager = sessionManager;
    this.analytics = analyticsManager?.scoped();
  }
  canHandle(event) {
    return event.method === "sendTransaction";
  }
  async handle(event) {
    const walletId = event.walletId;
    const walletAddress = event.walletAddress;
    if (!walletId && !walletAddress) {
      log$f.error("Wallet ID not found", { event });
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
          message: "Wallet ID not found"
        },
        id: event.id
      };
    }
    const wallet2 = walletId ? this.walletManager.getWallet(walletId) : void 0;
    if (!wallet2) {
      log$f.error("Wallet not found", { event, walletId, walletAddress });
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
          message: "Wallet not found"
        },
        id: event.id
      };
    }
    const requestValidation = this.parseTonConnectTransactionRequest(event, wallet2);
    if (!requestValidation.result || !requestValidation?.validation?.isValid) {
      log$f.error("Failed to parse transaction request", { event, requestValidation });
      this.eventEmitter.emit("event:error", event);
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR,
          message: "Failed to parse transaction request"
        },
        id: event.id
      };
    }
    const request = requestValidation.result;
    let preview;
    if (!this.config.eventProcessor?.disableTransactionEmulation) {
      try {
        preview = await CallForSuccess(() => createTransactionPreview(wallet2.client, request, wallet2));
        if (preview.result === Result.success && preview.trace) {
          try {
            this.eventEmitter.emit("emulation:result", preview.trace);
          } catch (error2) {
            log$f.warn("Error emitting emulation result event", { error: error2 });
          }
        }
      } catch (error2) {
        log$f.error("Failed to create transaction preview", { error: error2 });
        preview = {
          error: {
            code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
            message: "Unknown emulation error"
          },
          result: Result.failure
        };
      }
    }
    const txEvent = {
      ...event,
      request,
      preview: {
        data: preview
      },
      dAppInfo: event.dAppInfo ?? {},
      walletId: walletId ?? this.walletManager.getWalletId(wallet2),
      walletAddress: walletAddress ?? wallet2.getAddress()
    };
    if (this.analytics) {
      const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
      this.analytics?.emitWalletTransactionRequestReceived({
        trace_id: event.traceId,
        client_id: event.from,
        wallet_id: sessionData?.publicKey,
        dapp_name: event.dAppInfo?.name,
        network_id: wallet2.getNetwork().chainId,
        // manifest_json_url: event.dAppInfo?.url, // todo
        origin_url: event.dAppInfo?.url
      });
    }
    return txEvent;
  }
  /**
   * Parse raw transaction request from bridge event
   */
  parseTonConnectTransactionRequest(event, wallet2) {
    let errors = [];
    try {
      if (event.params.length !== 1) {
        throw new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "Invalid transaction request - expected exactly 1 parameter", void 0, { paramCount: event.params.length, eventId: event.id });
      }
      const params = JSON.parse(event.params[0]);
      const validUntilValidation = this.validateValidUntil(params.valid_until);
      if (!validUntilValidation.isValid) {
        errors = errors.concat(validUntilValidation.errors);
      } else {
        params.valid_until = validUntilValidation.result;
      }
      const networkValidation = this.validateNetwork(params.network, wallet2);
      if (!networkValidation.isValid) {
        errors = errors.concat(networkValidation.errors);
      } else {
        params.network = networkValidation.result;
      }
      const fromValidation = this.validateFrom(params.from, wallet2);
      if (!fromValidation.isValid) {
        errors = errors.concat(fromValidation.errors);
      } else {
        params.from = fromValidation.result;
      }
      const isTonConnect = !event.isLocal;
      const messagesValidation = validateTransactionMessages(params.messages, isTonConnect);
      if (!messagesValidation.isValid) {
        errors = errors.concat(messagesValidation.errors);
      }
      return {
        result: toTransactionRequest(params),
        validation: { isValid: errors.length === 0, errors }
      };
    } catch (error2) {
      log$f.error("Failed to parse transaction request", { error: error2 });
      errors.push("Failed to parse transaction request");
      return {
        result: void 0,
        validation: { isValid: errors.length === 0, errors }
      };
    }
  }
  /**
   * Parse network from various possible formats
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateNetwork(network, wallet2) {
    let errors = [];
    if (typeof network === "string") {
      if (network === "-3" || network === "-239") {
        const chain = network === "-3" ? CHAIN.TESTNET : CHAIN.MAINNET;
        const walletNetwork = wallet2.getNetwork();
        if (chain !== walletNetwork.chainId) {
          errors.push("Invalid network not equal to wallet network");
        } else {
          return { result: chain, isValid: errors.length === 0, errors };
        }
      } else {
        errors.push("Invalid network not a valid network");
      }
    } else {
      errors.push("Invalid network not a string");
    }
    return { result: void 0, isValid: errors.length === 0, errors };
  }
  validateFrom(from, wallet2) {
    let errors = [];
    if (typeof from !== "string") {
      errors.push("Invalid from address not a string");
      return { result: "", isValid: errors.length === 0, errors };
    }
    if (!isValidAddress(from)) {
      errors.push("Invalid from address");
      return { result: "", isValid: errors.length === 0, errors };
    }
    const fromAddress = distExports$1.Address.parse(from);
    const walletAddress = distExports$1.Address.parse(wallet2.getAddress());
    if (!fromAddress.equals(walletAddress)) {
      errors.push("Invalid from address not equal to wallet address");
      return { result: "", isValid: errors.length === 0, errors };
    }
    return { result: from, isValid: errors.length === 0, errors };
  }
  /**
   * Parse validUntil timestamp
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateValidUntil(validUntil) {
    let errors = [];
    if (typeof validUntil === "undefined") {
      return { result: 0, isValid: errors.length === 0, errors };
    }
    if (typeof validUntil !== "number" || isNaN(validUntil)) {
      errors.push("Invalid validUntil timestamp not a number");
      return { result: 0, isValid: errors.length === 0, errors };
    }
    const now = Math.floor(Date.now() / 1e3);
    if (validUntil < now) {
      errors.push("Invalid validUntil timestamp");
      return { result: 0, isValid: errors.length === 0, errors };
    }
    return { result: validUntil, isValid: errors.length === 0, errors };
  }
}
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BOC_PREFIX = "te6cc";
function isValidObject(data) {
  return typeof data === "object" && data !== null;
}
function isValidString(data) {
  return typeof data === "string";
}
function hasExtraProperties(data, allowedKeys) {
  return typeof data === "object" && data !== null && Object.keys(data).some((key) => !allowedKeys.includes(key));
}
function isValidBoc(value) {
  return typeof value === "string" && BASE64_REGEX.test(value) && value.startsWith(BOC_PREFIX);
}
function validateSignDataPayload(data) {
  if (!isValidObject(data)) {
    return "Payload must be an object";
  }
  if (!isValidString(data.type)) {
    return "'type' is required";
  }
  switch (data.type) {
    case "text":
      return validateSignDataPayloadText(data);
    case "binary":
      return validateSignDataPayloadBinary(data);
    case "cell":
      return validateSignDataPayloadCell(data);
    default:
      return "Invalid 'type' value";
  }
}
function validateSignDataPayloadText(data) {
  const allowedKeys = ["type", "text", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Text payload contains extra properties";
  }
  if (!isValidString(data.text)) {
    return "'text' is required";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadBinary(data) {
  const allowedKeys = ["type", "bytes", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Binary payload contains extra properties";
  }
  if (!isValidString(data.bytes)) {
    return "'bytes' is required";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadCell(data) {
  const allowedKeys = ["type", "schema", "cell", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Cell payload contains extra properties";
  }
  if (!isValidString(data.schema)) {
    return "'schema' is required";
  }
  if (!isValidString(data.cell)) {
    return "'cell' is required";
  }
  if (!isValidBoc(data.cell)) {
    return "Invalid 'cell' format (must be valid base64)";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
const log$e = globalLogger.createChild("SignDataHandler");
class SignDataHandler extends BasicHandler {
  analytics;
  walletManager;
  sessionManager;
  constructor(notify, walletManager, sessionManager, analyticsManager) {
    super(notify);
    this.walletManager = walletManager;
    this.sessionManager = sessionManager;
    this.analytics = analyticsManager?.scoped();
  }
  canHandle(event) {
    return event.method === "signData";
  }
  async handle(event) {
    const walletId = event.walletId;
    const walletAddress = event.walletAddress;
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "No wallet ID found in sign data event", void 0, {
        eventId: event.id
      });
    }
    const wallet2 = walletId ? this.walletManager.getWallet(walletId) : void 0;
    const payload = this.parseDataToSign(event);
    if (!payload) {
      log$e.error("No data to sign found in request", { event });
      throw new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "No data to sign found in request", void 0, {
        eventId: event.id
      });
    }
    const preview = this.createDataPreview(payload.data, event);
    if (!preview) {
      log$e.error("No preview found for data", { data: payload });
      throw new WalletKitError(ERROR_CODES.RESPONSE_CREATION_FAILED, "Failed to create preview for sign data request", void 0, { eventId: event.id, data: payload });
    }
    const signEvent = {
      ...event,
      payload,
      preview: {
        dAppInfo: event.dAppInfo ?? {},
        data: preview
      },
      dAppInfo: event.dAppInfo ?? {},
      walletId: walletId ?? (wallet2 ? this.walletManager.getWalletId(wallet2) : ""),
      walletAddress: walletAddress ?? wallet2?.getAddress() ?? void 0
    };
    if (this.analytics) {
      const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
      this.analytics?.emitWalletSignDataRequestReceived({
        trace_id: event.traceId,
        client_id: event.from,
        wallet_id: sessionData?.publicKey,
        dapp_name: event.dAppInfo?.name,
        network_id: wallet2?.getNetwork().chainId,
        // manifest_json_url: event.dAppInfo?.url, // todo
        origin_url: event.dAppInfo?.url
      });
    }
    return signEvent;
  }
  /**
   * Parse data to sign from bridge event
   */
  parseDataToSign(event) {
    try {
      const parsed = JSON.parse(event.params[0]);
      const validationResult = validateSignDataPayload(parsed);
      if (validationResult) {
        log$e.error("Invalid data to sign found in request", { validationResult });
        return void 0;
      }
      if (parsed === void 0) {
        return void 0;
      }
      let signData;
      if (parsed.type === "text") {
        signData = {
          type: "text",
          value: {
            content: parsed.text
          }
        };
      } else if (parsed.type === "binary") {
        signData = {
          type: "binary",
          value: {
            content: parsed.bytes
          }
        };
      } else if (parsed.type === "cell") {
        signData = {
          type: "cell",
          value: {
            schema: parsed.schema,
            content: parsed.cell
          }
        };
      } else {
        return void 0;
      }
      return {
        network: parsed.network ? Network.custom(parsed.network) : void 0,
        fromAddress: parsed.from,
        data: signData
      };
    } catch (error2) {
      log$e.error("Invalid data to sign found in request", { error: error2 });
      return void 0;
    }
  }
  /**
   * Create human-readable preview of data to sign
   */
  createDataPreview(data, _event) {
    if (data.type === "text") {
      return {
        type: "text",
        value: {
          content: data.value.content
        }
      };
    }
    if (data.type === "binary") {
      return {
        type: "binary",
        value: {
          content: data.value.content
        }
      };
    }
    if (data.type === "cell") {
      try {
        return {
          type: "cell",
          value: {
            schema: data.value.schema,
            content: data.value.content
            // parsed,
          }
        };
      } catch (error2) {
        log$e.error("Error deserializing cell", { error: error2 });
        return {
          type: "cell",
          value: {
            schema: data.value.schema,
            content: data.value.content
          }
        };
      }
    }
    return void 0;
  }
}
class DisconnectHandler extends BasicHandler {
  sessionManager;
  constructor(notify, sessionManager) {
    super(notify);
    this.sessionManager = sessionManager;
  }
  canHandle(event) {
    return event.method === "disconnect";
  }
  async handle(event) {
    const walletId = event.walletId;
    const walletAddress = event.walletAddress;
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "No wallet ID found in disconnect event", void 0, {
        eventId: event.id
      });
    }
    const reason = this.extractDisconnectReason(event);
    const disconnectEvent = {
      id: event.id,
      preview: {
        reason,
        dAppInfo: event.dAppInfo ?? {}
      },
      walletId: walletId ?? "",
      walletAddress,
      dAppInfo: event.dAppInfo ?? {}
    };
    await this.sessionManager.removeSession(event.from || "");
    return disconnectEvent;
  }
  /**
   * Extract disconnect reason from bridge event
   */
  extractDisconnectReason(event) {
    const params = event.params || {};
    const reason = params.reason;
    if (typeof reason === "string" && reason.length > 0) {
      return reason.slice(0, 200);
    }
    return void 0;
  }
}
const log$d = globalLogger.createChild("EventRouter");
class EventRouter {
  config;
  eventEmitter;
  sessionManager;
  walletManager;
  analyticsManager;
  handlers = [];
  bridgeManager;
  // Event callbacks
  connectRequestCallback = void 0;
  transactionRequestCallback = void 0;
  signDataRequestCallback = void 0;
  disconnectCallback = void 0;
  errorCallback = void 0;
  constructor(config, eventEmitter, sessionManager, walletManager, analyticsManager) {
    this.config = config;
    this.eventEmitter = eventEmitter;
    this.sessionManager = sessionManager;
    this.walletManager = walletManager;
    this.analyticsManager = analyticsManager;
    this.setupHandlers();
  }
  setBridgeManager(bridgeManager) {
    this.bridgeManager = bridgeManager;
  }
  /**
   * Route incoming bridge event to appropriate handler
   */
  async routeEvent(event) {
    const validation = validateBridgeEvent(event);
    if (!validation.isValid) {
      log$d.error("Invalid bridge event", { errors: validation.errors });
      return;
    }
    try {
      for (const handler of this.handlers) {
        if (handler.canHandle(event)) {
          const result = await handler.handle(event);
          if ("error" in result) {
            this.notifyErrorCallback({ id: result.id, data: { ...event }, error: result.error });
            try {
              await this.bridgeManager.sendResponse(event, result);
            } catch (error2) {
              log$d.error("Error sending response for error event", { error: error2, event, result });
            }
            return;
          }
          await handler.notify(result);
          break;
        }
      }
    } catch (error2) {
      log$d.error("Error routing event", { error: error2 });
      throw error2;
    }
  }
  /**
   * Register event callbacks
   */
  onConnectRequest(callback) {
    this.connectRequestCallback = callback;
  }
  onTransactionRequest(callback) {
    this.transactionRequestCallback = callback;
  }
  onSignDataRequest(callback) {
    this.signDataRequestCallback = callback;
  }
  onDisconnect(callback) {
    this.disconnectCallback = callback;
  }
  onRequestError(callback) {
    this.errorCallback = callback;
  }
  /**
   * Remove specific callback
   */
  removeConnectRequestCallback() {
    this.connectRequestCallback = void 0;
  }
  removeTransactionRequestCallback() {
    this.transactionRequestCallback = void 0;
  }
  removeSignDataRequestCallback() {
    this.signDataRequestCallback = void 0;
  }
  removeDisconnectCallback() {
    this.disconnectCallback = void 0;
  }
  removeErrorCallback() {
    this.errorCallback = void 0;
  }
  /**
   * Clear all callbacks
   */
  clearCallbacks() {
    this.connectRequestCallback = void 0;
    this.transactionRequestCallback = void 0;
    this.signDataRequestCallback = void 0;
    this.disconnectCallback = void 0;
    this.errorCallback = void 0;
  }
  /**
   * Setup event handlers
   */
  setupHandlers() {
    this.handlers = [
      new ConnectHandler(this.notifyConnectRequestCallbacks.bind(this), this.analyticsManager),
      new TransactionHandler(this.notifyTransactionRequestCallbacks.bind(this), this.config, this.eventEmitter, this.walletManager, this.sessionManager, this.analyticsManager),
      new SignDataHandler(this.notifySignDataRequestCallbacks.bind(this), this.walletManager, this.sessionManager, this.analyticsManager),
      new DisconnectHandler(this.notifyDisconnectCallbacks.bind(this), this.sessionManager)
    ];
  }
  /**
   * Notify connect request callbacks
   */
  async notifyConnectRequestCallbacks(event) {
    return await this.connectRequestCallback?.(event);
  }
  /**
   * Notify transaction request callbacks
   */
  async notifyTransactionRequestCallbacks(event) {
    return await this.transactionRequestCallback?.(event);
  }
  /**
   * Notify sign data request callbacks
   */
  async notifySignDataRequestCallbacks(event) {
    return await this.signDataRequestCallback?.(event);
  }
  /**
   * Notify disconnect callbacks
   */
  async notifyDisconnectCallbacks(event) {
    return await this.disconnectCallback?.(event);
  }
  /**
   * Notify error callbacks
   */
  async notifyErrorCallback(event) {
    return await this.errorCallback?.(event);
  }
  /**
   * Get enabled event types based on registered callbacks
   */
  getEnabledEventTypes() {
    const enabledTypes = [];
    if (this.connectRequestCallback) {
      enabledTypes.push("connect");
    }
    if (this.transactionRequestCallback) {
      enabledTypes.push("sendTransaction");
    }
    if (this.signDataRequestCallback) {
      enabledTypes.push("signData");
    }
    if (this.disconnectCallback) {
      enabledTypes.push("disconnect");
    }
    return enabledTypes;
  }
}
var distExports = requireDist$1();
const tonProofPrefix = "ton-proof-item-v2/";
const tonConnectPrefix = "ton-connect";
async function CreateTonProofMessageBytes(message) {
  const wc = Buffer.alloc(4);
  wc.writeUInt32BE(message.workchain);
  const ts = Buffer.alloc(8);
  ts.writeBigUInt64LE(BigInt(message.timestamp));
  const dl = Buffer.alloc(4);
  dl.writeUInt32LE(message.domain.lengthBytes);
  const m = Buffer.concat([
    Buffer.from(tonProofPrefix),
    wc,
    HexToUint8Array(message.addressHash),
    dl,
    Buffer.from(message.domain.value),
    ts,
    Buffer.from(message.payload)
  ]);
  const messageHash = distExports.sha256_sync(m);
  const fullMes = Buffer.concat([Buffer.from([255, 255]), Buffer.from(tonConnectPrefix), Buffer.from(messageHash)]);
  const res = distExports.sha256_sync(fullMes);
  return Buffer.from(res);
}
function CreateTonProofMessage({ address, domain, payload, stateInit, timestamp }) {
  const res = {
    workchain: address.workChain,
    addressHash: Uint8ArrayToHex(address.hash),
    domain: {
      lengthBytes: domain.lengthBytes,
      value: domain.value
    },
    payload,
    stateInit,
    timestamp
  };
  return res;
}
function signed_crc_table() {
  var c = 0, table = new Array(256);
  for (var n = 0; n != 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }
  return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
}
var T0 = signed_crc_table();
function slice_by_16_tables(T10) {
  var c = 0, v2 = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
  for (n = 0; n != 256; ++n)
    table[n] = T10[n];
  for (n = 0; n != 256; ++n) {
    v2 = T10[n];
    for (c = 256 + n; c < 4096; c += 256)
      v2 = table[c] = v2 >>> 8 ^ T10[v2 & 255];
  }
  var out = [];
  for (n = 1; n != 16; ++n)
    out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
  return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_buf(B2, seed) {
  var C2 = seed ^ -1, L = B2.length - 15, i = 0;
  for (; i < L; )
    C2 = Tf[B2[i++] ^ C2 & 255] ^ Te[B2[i++] ^ C2 >> 8 & 255] ^ Td[B2[i++] ^ C2 >> 16 & 255] ^ Tc[B2[i++] ^ C2 >>> 24] ^ Tb[B2[i++]] ^ Ta[B2[i++]] ^ T9[B2[i++]] ^ T8[B2[i++]] ^ T7[B2[i++]] ^ T6[B2[i++]] ^ T5[B2[i++]] ^ T4[B2[i++]] ^ T3[B2[i++]] ^ T2[B2[i++]] ^ T1[B2[i++]] ^ T0[B2[i++]];
  L += 15;
  while (i < L)
    C2 = C2 >>> 8 ^ T0[(C2 ^ B2[i++]) & 255];
  return ~C2;
}
const buf = crc32_buf;
function createTextBinaryHash(data, parsedAddr, domain, timestamp) {
  const wcBuffer = Buffer.alloc(4);
  wcBuffer.writeInt32BE(parsedAddr.workChain);
  const domainBuffer = Buffer.from(domain, "utf8");
  const domainLenBuffer = Buffer.alloc(4);
  domainLenBuffer.writeUInt32BE(domainBuffer.length);
  const tsBuffer = Buffer.alloc(8);
  tsBuffer.writeBigUInt64BE(BigInt(timestamp));
  const typePrefix = data.type === "text" ? "txt" : "bin";
  const content = data.value.content;
  const encoding = data.type === "text" ? "utf8" : "base64";
  const payloadPrefix = Buffer.from(typePrefix);
  const payloadBuffer = Buffer.from(content, encoding);
  const payloadLenBuffer = Buffer.alloc(4);
  payloadLenBuffer.writeUInt32BE(payloadBuffer.length);
  const message = Buffer.concat([
    Buffer.from([255, 255]),
    Buffer.from("ton-connect/sign-data/"),
    wcBuffer,
    parsedAddr.hash,
    domainLenBuffer,
    domainBuffer,
    tsBuffer,
    payloadPrefix,
    payloadLenBuffer,
    payloadBuffer
  ]);
  return distExports.sha256_sync(message);
}
function createCellHash(payload, parsedAddr, domain, timestamp) {
  const cell = distExports$1.Cell.fromBase64(payload.content);
  const schemaHash = buf(Buffer.from(payload.schema, "utf8"), void 0) >>> 0;
  const tep81Domain = domain.split(".").reverse().join("\0") + "\0";
  const message = distExports$1.beginCell().storeUint(1968607266, 32).storeUint(schemaHash, 32).storeUint(timestamp, 64).storeAddress(parsedAddr).storeStringRefTail(tep81Domain).storeRef(cell).endCell();
  return Buffer.from(message.hash());
}
function PrepareSignData(data) {
  const { payload, domain, address } = data;
  const timestamp = Math.floor(Date.now() / 1e3);
  const parsedAddr = distExports$1.Address.parse(address);
  const finalHash = payload.data?.type === "cell" ? createCellHash(payload.data.value, parsedAddr, domain, timestamp) : createTextBinaryHash(payload.data, parsedAddr, domain, timestamp);
  return {
    address,
    timestamp,
    domain,
    payload,
    hash: Uint8ArrayToHex(finalHash)
  };
}
const log$c = globalLogger.createChild("RequestProcessor");
class RequestProcessor {
  walletKitOptions;
  sessionManager;
  bridgeManager;
  walletManager;
  analytics;
  constructor(walletKitOptions, sessionManager, bridgeManager, walletManager, analyticsManager) {
    this.walletKitOptions = walletKitOptions;
    this.sessionManager = sessionManager;
    this.bridgeManager = bridgeManager;
    this.walletManager = walletManager;
    this.analytics = analyticsManager?.scoped();
  }
  /**
   * Helper to get wallet from event, supporting both walletId and walletAddress
   */
  getWalletFromEvent(event) {
    if (event.walletId) {
      return this.walletManager.getWallet(event.walletId);
    }
    return void 0;
  }
  /**
   * Helper to get wallet address from event
   */
  getWalletAddressFromEvent(event) {
    if (event.walletAddress) {
      return event.walletAddress;
    }
    if (event.walletId) {
      return this.walletManager.getWallet(event.walletId)?.getAddress();
    }
    return void 0;
  }
  /**
   * Process connect request approval
   */
  async approveConnectRequest(event, response) {
    try {
      const walletId = event.walletId;
      if (!walletId) {
        const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet is required for connect request approval", void 0, { eventId: event.id });
        throw error2;
      }
      const wallet2 = this.getWalletFromEvent(event);
      if (!wallet2) {
        const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect request", void 0, { walletId, eventId: event.id });
        throw error2;
      }
      const newSession = await this.sessionManager.createSession(event.from || (await distExports.getSecureRandomBytes(32)).toString("hex"), {
        name: event.preview.dAppInfo?.name || "",
        url: event.preview.dAppInfo?.url || "",
        iconUrl: event.preview.dAppInfo?.iconUrl || "",
        description: event.preview.dAppInfo?.description || ""
      }, wallet2, event.isJsBridge ?? false);
      await this.bridgeManager.createSession(newSession.sessionId);
      const tonConnectResponse = await this.createConnectApprovalResponse(event, response?.proof);
      await this.bridgeManager.sendResponse(event, tonConnectResponse.result);
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(newSession.sessionId) : void 0;
        this.analytics.emitWalletConnectAccepted({
          client_id: event.from,
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          network_id: wallet2.getNetwork().chainId,
          origin_url: event.dAppInfo?.url,
          dapp_name: event.dAppInfo?.name,
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          manifest_json_url: event.dAppInfo?.manifestUrl,
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value?.payload?.length
        });
        this.analytics.emitWalletConnectResponseSent({
          client_id: event.from,
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          manifest_json_url: event.preview.dAppInfo?.manifestUrl,
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value.payload?.length,
          network_id: wallet2.getNetwork().chainId
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to approve connect request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process connect request rejection
   */
  async rejectConnectRequest(event, reason, errorCode) {
    try {
      log$c.info("Connect request rejected", {
        id: event.id,
        dAppName: event.preview.dAppInfo?.name || "",
        reason: reason || "User rejected connection"
      });
      const response = {
        event: "connect_error",
        id: 1,
        // parseInt(event.id || '') ?? 1,
        payload: {
          code: errorCode ?? CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected connection"
        }
      };
      const sessionId = event.from || "";
      try {
        await this.bridgeManager.sendResponse(event, response, new SessionCrypto());
      } catch (error2) {
        log$c.error("Failed to send connect request rejection response", { error: error2 });
      }
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(sessionId) : void 0;
        this.analytics.emitWalletConnectRejected({
          client_id: event.from,
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.preview.dAppInfo?.name || "",
          origin_url: event.preview.dAppInfo?.url || "",
          manifest_json_url: event.preview.dAppInfo?.manifestUrl || "",
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value.payload?.length
        });
        this.analytics.emitWalletConnectResponseSent({
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.preview.dAppInfo?.name || "",
          origin_url: event.preview.dAppInfo?.url || "",
          manifest_json_url: event.preview.dAppInfo?.manifestUrl || "",
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value.payload?.length,
          client_id: event.from
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to reject connect request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process transaction request approval
   */
  async approveTransactionRequest(event, response) {
    try {
      if (response) {
        const tonConnectResponse = {
          result: response.signedBoc,
          id: event.id || ""
        };
        await this.bridgeManager.sendResponse(event, tonConnectResponse);
        this.sendTransactionAnalytics(event, response.signedBoc);
        return response;
      } else {
        const signedBoc = await this.signTransaction(event);
        if (!this.walletKitOptions.dev?.disableNetworkSend) {
          const client = this.getClientForWallet(event.walletId);
          await CallForSuccess(() => client.sendBoc(signedBoc));
        }
        const response2 = {
          result: signedBoc,
          id: event.id || ""
        };
        await this.bridgeManager.sendResponse(event, response2);
        this.sendTransactionAnalytics(event, signedBoc);
        return { signedBoc };
      }
    } catch (error2) {
      log$c.error("Failed to approve transaction request", { error: error2 });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      if (error2?.message?.includes("Ledger device")) {
        throw new WalletKitError(ERROR_CODES.LEDGER_DEVICE_ERROR, "Ledger device error", error2);
      }
      throw error2;
    }
  }
  /**
   * Send transaction analytics events
   */
  sendTransactionAnalytics(event, signedBoc) {
    if (!this.analytics)
      return;
    const wallet2 = this.getWalletFromEvent(event);
    this.analytics.emitWalletTransactionSent({
      trace_id: event.traceId,
      network_id: wallet2?.getNetwork().chainId,
      client_id: event.from,
      signed_boc: signedBoc
    });
  }
  /**
   * Process transaction request rejection
   */
  async rejectTransactionRequest(event, reason) {
    try {
      const response = typeof reason === "string" || typeof reason === "undefined" ? {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected transaction"
        },
        id: event.id
      } : {
        error: reason,
        id: event.id
      };
      await this.bridgeManager.sendResponse(event, response);
      const wallet2 = this.getWalletFromEvent(event);
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
        this.analytics.emitWalletTransactionDeclined({
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          network_id: wallet2?.getNetwork().chainId,
          client_id: event.from,
          decline_reason: typeof reason === "string" ? reason : reason?.message
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to reject transaction request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process sign data request approval
   */
  async approveSignDataRequest(event, response) {
    try {
      if (response) {
        const wallet2 = this.getWalletFromEvent(event);
        if (!wallet2) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet approving for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const tonConnectResponse = {
          id: event.id || "",
          result: {
            signature: HexToBase64(response.signature),
            address: distExports$1.Address.parse(wallet2.getAddress()).toRawString(),
            timestamp: response.timestamp,
            domain: response.domain,
            payload: toTonConnectSignDataPayload(event.payload)
          }
        };
        await this.bridgeManager.sendResponse(event, tonConnectResponse);
        if (this.analytics) {
          const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
          this.analytics.emitWalletSignDataAccepted({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            network_id: wallet2?.getNetwork().chainId,
            client_id: event.from
          });
          this.analytics.emitWalletSignDataSent({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            network_id: wallet2?.getNetwork().chainId,
            client_id: event.from
          });
        }
        return response;
      } else {
        if (!event.domain) {
          const error2 = new WalletKitError(ERROR_CODES.SESSION_DOMAIN_REQUIRED, "Domain is required for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const walletId = event.walletId;
        const walletAddress = this.getWalletAddressFromEvent(event);
        if (!walletId && !walletAddress) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet ID is required for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const wallet2 = this.getWalletFromEvent(event);
        if (!wallet2) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for sign data request", void 0, { walletId, walletAddress, eventId: event.id });
          throw error2;
        }
        let domainUrl = event.domain;
        try {
          domainUrl = new URL(event.domain).host;
        } catch {
        }
        const signData = PrepareSignData({
          payload: event.payload,
          domain: domainUrl,
          address: wallet2.getAddress()
        });
        const signature = await wallet2.getSignedSignData(signData);
        const signatureBase64 = HexToBase64(signature);
        const response2 = {
          id: event.id,
          result: {
            signature: signatureBase64,
            address: distExports$1.Address.parse(signData.address).toRawString(),
            timestamp: signData.timestamp,
            domain: signData.domain,
            payload: toTonConnectSignDataPayload(signData.payload)
          }
        };
        await this.bridgeManager.sendResponse(event, response2);
        if (this.analytics) {
          const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
          this.analytics.emitWalletSignDataAccepted({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            network_id: wallet2.getNetwork().chainId,
            client_id: event.from
          });
          this.analytics.emitWalletSignDataSent({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            network_id: wallet2.getNetwork().chainId,
            client_id: event.from
          });
        }
        return {
          timestamp: signData.timestamp,
          domain: signData.domain,
          signature
        };
      }
    } catch (error2) {
      log$c.error("Failed to approve sign data request", {
        error: error2?.message?.toString() ?? error2?.toString()
      });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      throw error2;
    }
  }
  /**
   * Process sign data request rejection
   */
  async rejectSignDataRequest(event, reason) {
    try {
      const response = typeof reason === "string" || typeof reason === "undefined" ? {
        error: {
          code: SIGN_DATA_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected transaction"
        },
        id: event.id
      } : {
        error: reason,
        id: event.id
      };
      await this.bridgeManager.sendResponse(event, response);
      const wallet2 = this.getWalletFromEvent(event);
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
        this.analytics.emitWalletSignDataDeclined({
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          network_id: wallet2?.getNetwork().chainId,
          client_id: event.from
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to reject sign data request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Create connect approval response
   */
  async createConnectApprovalResponse(event, proof) {
    const walletId = event.walletId;
    const walletAddress = this.getWalletAddressFromEvent(event);
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet ID is required for connect approval response", void 0, { eventId: event.id });
    }
    const wallet2 = this.getWalletFromEvent(event);
    if (!wallet2) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect approval response", void 0, { walletId, walletAddress, eventId: event.id });
    }
    const walletStateInit = await wallet2.getStateInit();
    const publicKey = wallet2.getPublicKey().replace("0x", "");
    const address = wallet2.getAddress();
    const walletNetwork = wallet2.getNetwork();
    const deviceInfo = getDeviceInfoForWallet(wallet2, this.walletKitOptions.deviceInfo);
    const connectResponse = {
      event: "connect",
      id: Date.now(),
      payload: {
        device: deviceInfo,
        items: [
          {
            name: "ton_addr",
            address: distExports$1.Address.parse(address).toRawString(),
            network: walletNetwork.chainId,
            walletStateInit,
            publicKey
          }
        ]
      }
    };
    const proofRequest = event.requestedItems.find((item) => item.type === "ton_proof");
    if (proofRequest) {
      const tonProofItem = await createTonProofItem({
        wallet: wallet2,
        address,
        walletStateInit,
        dAppUrl: event.preview.dAppInfo?.url,
        proofPayload: proofRequest.value.payload,
        providedProof: proof
      });
      connectResponse.payload.items.push(tonProofItem);
    }
    return { result: connectResponse };
  }
  /**
   * Sign transaction and return BOC
   */
  async signTransaction(event) {
    const walletId = event.walletId;
    const walletAddress = this.getWalletAddressFromEvent(event);
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet ID is required for transaction signing", void 0, { eventId: event.id });
    }
    const wallet2 = this.getWalletFromEvent(event);
    if (!wallet2) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for transaction signing", void 0, { walletId, walletAddress, eventId: event.id });
    }
    const validUntil = event.request.validUntil;
    if (validUntil) {
      const now = Math.floor(Date.now() / 1e3);
      if (validUntil < now) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Transaction valid_until timestamp is in the past", void 0, { validUntil, currentTime: now });
      }
    }
    return await signTransactionInternal(wallet2, event.request);
  }
  /**
   * Get API client for a wallet's network
   * Uses the wallet's network to get the appropriate client from NetworkManager
   */
  getClientForWallet(walletId) {
    if (!walletId) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet address is required to get API client");
    }
    const wallet2 = this.walletManager.getWallet(walletId);
    if (!wallet2) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, `Wallet not found: ${walletId}`);
    }
    return wallet2.getClient();
  }
}
async function signTransactionInternal(wallet2, request) {
  const signedBoc = await wallet2.getSignedSendTransaction(request, {
    fakeSignature: false
  });
  log$c.debug("Signing transaction", {
    messagesNumber: request.messages.length,
    fromAddress: request.fromAddress,
    validUntil: request.validUntil
  });
  return signedBoc;
}
async function createTonProofItem(params) {
  const { wallet: wallet2, address, walletStateInit, dAppUrl, proofPayload, providedProof } = params;
  if (providedProof) {
    return {
      name: "ton_proof",
      proof: {
        timestamp: providedProof.timestamp,
        domain: {
          lengthBytes: providedProof.domain.lengthBytes,
          value: providedProof.domain.value
        },
        payload: providedProof.payload,
        signature: providedProof.signature
      }
    };
  }
  const domain = parseDomain(dAppUrl);
  const timestamp = Math.floor(Date.now() / 1e3);
  const signMessage = CreateTonProofMessage({
    address: distExports$1.Address.parse(address),
    domain,
    payload: proofPayload,
    stateInit: walletStateInit,
    timestamp
  });
  const signature = await wallet2.getSignedTonProof(signMessage);
  const signatureBase64 = HexToBase64(signature);
  return {
    name: "ton_proof",
    proof: {
      timestamp,
      domain: { lengthBytes: domain.lengthBytes, value: domain.value },
      payload: proofPayload,
      signature: signatureBase64
    }
  };
}
function parseDomain(url) {
  if (!url) {
    return { lengthBytes: 0, value: "" };
  }
  try {
    const parsedUrl = new URL(url);
    return {
      lengthBytes: Buffer.from(parsedUrl.host).length,
      value: parsedUrl.host
    };
  } catch (error2) {
    log$c.error("Failed to parse domain", { error: error2 });
    return { lengthBytes: 0, value: "" };
  }
}
function toTonConnectSignDataPayload(payload) {
  let network;
  if (payload.network?.chainId === CHAIN.MAINNET) {
    network = CHAIN.MAINNET;
  } else if (payload.network?.chainId === CHAIN.TESTNET) {
    network = CHAIN.TESTNET;
  } else {
    network = void 0;
  }
  if (payload.data.type === "text") {
    return {
      network,
      from: payload.fromAddress,
      type: "text",
      text: payload.data.value.content
    };
  } else if (payload.data.type === "cell") {
    return {
      network,
      from: payload.fromAddress,
      type: "cell",
      schema: payload.data.value.schema,
      cell: payload.data.value.content
    };
  } else {
    return {
      network,
      from: payload.fromAddress,
      type: "binary",
      bytes: payload.data.value.content
    };
  }
}
const getEventUUID = () => {
  return crypto.randomUUID();
};
const log$b = globalLogger.createChild("EventStore");
const MAX_EVENT_SIZE_BYTES = 100 * 1024;
class StorageEventStore {
  storage;
  storageKey = "durable_events";
  operationLock = /* @__PURE__ */ new Map();
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Store a new event from the bridge
   */
  async storeEvent(_rawEvent) {
    const rawEvent = { ..._rawEvent, wallet: void 0 };
    const validation = validateBridgeEvent(rawEvent);
    if (!validation.isValid) {
      throw new Error(`Invalid bridge event: ${validation.errors.join(", ")}`);
    }
    const eventStr = JSON.stringify(rawEvent);
    const sizeBytes = new TextEncoder().encode(eventStr).length;
    if (sizeBytes > MAX_EVENT_SIZE_BYTES) {
      throw new Error(`Event too large: ${sizeBytes} bytes (max: ${MAX_EVENT_SIZE_BYTES})`);
    }
    const eventType = this.extractEventType(rawEvent.method);
    const storedEvent = {
      id: getEventUUID(),
      sessionId: rawEvent.from,
      eventType,
      rawEvent,
      status: "new",
      createdAt: Date.now(),
      sizeBytes
    };
    await this.saveEvent(storedEvent);
    log$b.info("Event stored", {
      eventId: storedEvent.id,
      eventType,
      sizeBytes,
      sessionId: rawEvent.from
    });
    return storedEvent;
  }
  /**
   * Get events for a wallet that are ready for processing
   */
  async getEventsForWallet(sessionIds, eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must match one of the session IDs
      event.sessionId && sessionIds.includes(event.sessionId) && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a2, b2) => a2.createdAt - b2.createdAt);
  }
  /**
   * Get events that don't require a wallet or session (e.g., connect events)
   */
  async getNoWalletEvents(eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a2, b2) => a2.createdAt - b2.createdAt);
  }
  /**
   * Attempt to acquire exclusive lock on an event for processing
   */
  async acquireLock(eventId, walletId) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        log$b.warn("Cannot lock non-existent event", { eventId });
        return void 0;
      }
      if (event.status !== "new") {
        log$b.debug("Cannot lock event - not in new status", {
          eventId,
          status: event.status,
          lockedBy: event.lockedBy
        });
        return void 0;
      }
      const updatedEvent = {
        ...event,
        status: "processing",
        processingStartedAt: Date.now(),
        lockedBy: walletId
      };
      allEvents[eventId] = updatedEvent;
      await this.storage.set(this.storageKey, allEvents);
      log$b.debug("Event lock acquired", { eventId, walletAddress: walletId });
      return updatedEvent;
    });
  }
  /**
   * Increment retry count and update error message for an event
   */
  async releaseLock(eventId, error2) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        throw new Error(`Event not found: ${eventId}`);
      }
      if (event.status !== "processing") {
        throw new Error(`Event not in processing status: ${eventId}, current status: ${event.status}`);
      }
      const addRetryCount = error2 ? 1 : 0;
      const updatedEvent = {
        ...event,
        retryCount: (event.retryCount || 0) + addRetryCount,
        lastError: error2,
        status: "new",
        lockedBy: void 0,
        processingStartedAt: void 0
      };
      allEvents[eventId] = updatedEvent;
      await this.storage.set(this.storageKey, allEvents);
      log$b.debug("Event retry count incremented", {
        eventId,
        retryCount: updatedEvent.retryCount,
        error: error2
      });
      return updatedEvent;
    });
  }
  /**
   * Update event status and timestamps with optimistic locking
   */
  async updateEventStatus(eventId, status, oldStatus) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        throw new Error(`Event not found: ${eventId}`);
      }
      if (event.status !== oldStatus) {
        throw new Error(`Event status mismatch: expected '${oldStatus}', but current status is '${event.status}'`);
      }
      const updatedEvent = {
        ...event,
        status
      };
      if (status === "completed") {
        updatedEvent.completedAt = Date.now();
      }
      allEvents[eventId] = updatedEvent;
      await this.storage.set(this.storageKey, allEvents);
      log$b.debug("Event status updated", { eventId, oldStatus, newStatus: status });
      return updatedEvent;
    });
  }
  /**
   * Get event by ID
   */
  async getEvent(eventId) {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return allEvents[eventId] || null;
    } catch (error2) {
      log$b.warn("Failed to get event", { eventId, error: error2 });
      return null;
    }
  }
  /**
   * Recover stale events that have been processing too long
   */
  async recoverStaleEvents(processingTimeoutMs) {
    const events = await this.getAllEvents();
    const now = Date.now();
    let recoveredCount = 0;
    for (const event of events) {
      if (event.status === "processing" && event.processingStartedAt && now - event.processingStartedAt > processingTimeoutMs) {
        const recoveredEvent = {
          ...event,
          processingStartedAt: void 0,
          lockedBy: void 0
        };
        await this.saveEvent(recoveredEvent);
        recoveredCount++;
        log$b.info("Recovered stale event", {
          eventId: event.id,
          lockedBy: event.lockedBy,
          staleMinutes: Math.round((now - event.processingStartedAt) / 6e4),
          retryCount: event.retryCount || 0
        });
      }
    }
    if (recoveredCount > 0) {
      log$b.info("Event recovery completed", { recoveredCount });
    }
    return recoveredCount;
  }
  /**
   * Clean up old completed events
   */
  async cleanupOldEvents(retentionMs) {
    const events = await this.getAllEvents();
    const cutoffTime = Date.now() - retentionMs;
    let cleanedUpCount = 0;
    const eventsToRemove = [];
    for (const event of events) {
      if (event.status === "completed" && event.completedAt && event.completedAt < cutoffTime || event.status === "errored" && event.createdAt < cutoffTime) {
        eventsToRemove.push(event.id);
        log$b.debug("Marked event for cleanup", { eventId: event.id, status: event.status });
      }
    }
    if (eventsToRemove.length > 0) {
      await this.withLock("storage", async () => {
        const allEvents = await this.getAllEventsFromStorage();
        for (const eventId of eventsToRemove) {
          delete allEvents[eventId];
          cleanedUpCount++;
        }
        await this.storage.set(this.storageKey, allEvents);
      });
      log$b.info("Event cleanup completed", { cleanedUpCount });
    }
    return cleanedUpCount;
  }
  /**
   * Get all events (for debugging and internal operations)
   */
  async getAllEvents() {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return Object.values(allEvents);
    } catch (error2) {
      log$b.warn("Failed to get all events", { error: error2 });
      return [];
    }
  }
  // Private helper methods
  async withLock(lockKey, operation) {
    const existingLock = this.operationLock.get(lockKey);
    if (existingLock) {
      await existingLock;
    }
    const operationPromise = operation();
    this.operationLock.set(lockKey, operationPromise.then(() => {
    }, () => {
    }));
    try {
      const result = await operationPromise;
      this.operationLock.delete(lockKey);
      return result;
    } catch (error2) {
      this.operationLock.delete(lockKey);
      throw error2;
    }
  }
  async getAllEventsFromStorage() {
    try {
      const eventsData = await this.storage.get(this.storageKey);
      return eventsData || {};
    } catch (error2) {
      log$b.warn("Failed to get events from storage", { error: error2 });
      return {};
    }
  }
  async saveEvent(event) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      allEvents[event.id] = event;
      await this.storage.set(this.storageKey, allEvents);
    });
  }
  async removeEvent(eventId) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      delete allEvents[eventId];
      await this.storage.set(this.storageKey, allEvents);
    });
  }
  extractEventType(method) {
    switch (method) {
      case "connect":
        return "connect";
      case "sendTransaction":
        return "sendTransaction";
      case "signData":
        return "signData";
      case "disconnect":
        return "disconnect";
      case "restoreConnection":
        return "restoreConnection";
      default:
        throw new Error(`Unknown event method: ${method}`);
    }
  }
}
const log$a = globalLogger.createChild("EventProcessor");
class StorageEventProcessor {
  eventStore;
  config;
  sessionManager;
  eventRouter;
  eventEmitter;
  walletManager;
  // Single global processing loop state
  isProcessing = false;
  wakeUpResolver;
  // Track which wallets are registered for processing
  registeredWallets = /* @__PURE__ */ new Set();
  // Recovery and cleanup timeouts
  recoveryTimeoutId;
  cleanupTimeoutId;
  processorConfig;
  constructor(processorConfig = {}, eventStore, config, walletManager, sessionManager, eventRouter, eventEmitter) {
    this.processorConfig = processorConfig;
    this.eventStore = eventStore;
    this.config = config;
    this.sessionManager = sessionManager;
    this.eventRouter = eventRouter;
    this.eventEmitter = eventEmitter;
    this.walletManager = walletManager;
    if (this.processorConfig.disableEvents) {
      return;
    }
    this.eventEmitter.on("bridge-storage-updated", () => {
      this.triggerProcessing();
    });
  }
  /**
   * Start processing events for a wallet
   */
  async startProcessing(walletId) {
    if (this.processorConfig.disableEvents) {
      return;
    }
    if (walletId) {
      if (this.registeredWallets.has(walletId)) {
        log$a.debug("Processing already registered for wallet", { walletId });
      } else {
        this.registeredWallets.add(walletId);
        log$a.info("Registered wallet for event processing", { walletId });
      }
    }
    if (!this.isProcessing) {
      this.isProcessing = true;
      log$a.info("Started global event processing loop");
      this.processEventsLoop();
    } else {
      this.triggerProcessing();
    }
  }
  /**
   * Stop processing events for a wallet
   */
  async stopProcessing(walletId) {
    if (this.processorConfig.disableEvents) {
      return;
    }
    if (walletId) {
      this.registeredWallets.delete(walletId);
      log$a.info("Unregistered wallet from event processing", { walletId });
    }
    if (this.registeredWallets.size === 0 && this.isProcessing && !walletId) {
      this.isProcessing = false;
      if (this.wakeUpResolver) {
        this.wakeUpResolver();
        this.wakeUpResolver = void 0;
      }
      log$a.info("Stopped global event processing loop (no more wallets)");
    }
  }
  async clearRegisteredWallets() {
    this.registeredWallets.clear();
    log$a.info("Cleared registered wallets from event processing");
  }
  /**
   * Process next available event from any source (wallet or no-wallet)
   * This is the main method used by the global processing loop
   */
  async processNextAvailableEvent() {
    try {
      const allLocalSessions = await this.sessionManager.getSessions();
      const allSessions = allLocalSessions.filter((session) => session.walletId && this.registeredWallets.has(session.walletId));
      const enabledEventTypes = this.getEnabledEventTypes();
      const allEvents = [];
      if (allSessions.length > 0) {
        const walletIds = Array.from(new Set(allSessions.map((s2) => s2.walletId).filter(Boolean)));
        for (const walletId2 of walletIds) {
          const walletSessionIds = allSessions.filter((s2) => s2.walletId === walletId2).map((s2) => s2.sessionId);
          const events = await this.eventStore.getEventsForWallet(walletSessionIds, enabledEventTypes);
          allEvents.push(...events);
        }
      }
      const noWalletEventTypes = this.getNoWalletEnabledEventTypes();
      if (noWalletEventTypes.length > 0) {
        const noWalletEvents = await this.eventStore.getNoWalletEvents(noWalletEventTypes);
        allEvents.push(...noWalletEvents);
      }
      allEvents.sort((a2, b2) => a2.createdAt - b2.createdAt);
      if (allEvents.length === 0) {
        return false;
      }
      const eventToUse = allEvents[0];
      const walletId = allSessions.find((s2) => s2.sessionId === eventToUse.sessionId)?.walletId || eventToUse.rawEvent.walletId || "no-wallet";
      const processed = await this.processEvent(eventToUse, walletId);
      return processed;
    } catch (error2) {
      log$a.error("Error in processNextAvailableEvent", {
        error: error2.message
      });
      return false;
    }
  }
  /**
   * Mark an event as completed after successful processing
   */
  async completeEvent(eventId) {
    try {
      await this.eventStore.updateEventStatus(eventId, "completed", "processing");
      log$a.debug("Event marked as completed", { eventId });
    } catch (error2) {
      log$a.error("Failed to mark event as completed", {
        eventId,
        error: error2.message
      });
    }
  }
  /**
   * Start the recovery process for stale events
   */
  startRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      log$a.debug("Recovery loop already running");
      return;
    }
    const recoveryLoop = async () => {
      try {
        const recoveredCount = await this.eventStore.recoverStaleEvents(this.config.processingTimeoutMs);
        if (recoveredCount > 0) {
          this.triggerProcessing();
        }
      } catch (error2) {
        log$a.error("Error in recovery loop", { error: error2.message });
      }
      if (this.recoveryTimeoutId !== void 0) {
        this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
      }
    };
    const cleanupLoop = async () => {
      try {
        await this.eventStore.cleanupOldEvents(this.config.retentionMs);
      } catch (error2) {
        log$a.error("Error in cleanup loop", { error: error2.message });
      }
      if (this.cleanupTimeoutId !== void 0) {
        this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
      }
    };
    this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
    this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
    log$a.info("Recovery and cleanup loops started");
  }
  /**
   * Stop the recovery process
   */
  stopRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      clearTimeout(this.recoveryTimeoutId);
      this.recoveryTimeoutId = void 0;
    }
    if (this.cleanupTimeoutId) {
      clearTimeout(this.cleanupTimeoutId);
      this.cleanupTimeoutId = void 0;
    }
    log$a.info("Recovery and cleanup loops stopped");
  }
  // Private helper methods
  /**
   * Process a single event with retry logic
   * Returns true if event was processed successfully, false otherwise
   */
  async processEvent(event, walletId) {
    const acquiredEvent = await this.eventStore.acquireLock(event.id, walletId);
    if (!acquiredEvent) {
      log$a.debug("Failed to acquire lock on event", { eventId: event.id, walletId });
      return false;
    }
    const retryCount = event.retryCount || 0;
    if (retryCount >= this.config.maxRetries) {
      log$a.error("Event exceeded max retries, marking as errored", {
        eventId: event.id,
        retryCount,
        maxRetries: this.config.maxRetries
      });
      try {
        await this.eventStore.updateEventStatus(event.id, "errored", "processing");
      } catch (error2) {
        log$a.error("Failed to mark event as errored", {
          eventId: event.id,
          error: error2.message
        });
      }
      return false;
    }
    log$a.info("Processing event", {
      eventId: event.id,
      eventType: event.eventType,
      walletId,
      sessionId: event.sessionId,
      retryCount
    });
    try {
      let wallet2;
      let walletAddress;
      if (walletId) {
        wallet2 = this.walletManager.getWallet(walletId);
        walletAddress = wallet2?.getAddress();
      }
      await this.eventRouter.routeEvent({
        ...event.rawEvent,
        ...walletId ? { walletId } : {},
        ...walletAddress ? { walletAddress } : {}
      });
      await this.eventStore.updateEventStatus(event.id, "completed", "processing");
      log$a.info("Event processing completed", { eventId: event.id });
      return true;
    } catch (error2) {
      const errorMessage = error2.message ?? "Unknown error";
      log$a.error("Error processing event", {
        eventId: event.id,
        error: errorMessage,
        retryCount
      });
      try {
        await this.eventStore.releaseLock(event.id, errorMessage);
      } catch (updateError) {
        log$a.error("Failed to increment retry count", {
          eventId: event.id,
          error: updateError.message
        });
      }
      return false;
    }
  }
  /**
   * Main global processing loop for all events
   */
  async processEventsLoop() {
    while (this.isProcessing) {
      try {
        const processed = await this.processNextAvailableEvent();
        if (!processed) {
          await this.waitForWakeUpOrTimeout(500);
        }
      } catch (error2) {
        log$a.error("Error in global processing loop", {
          error: error2.message
        });
        await this.waitForWakeUpOrTimeout(500);
      }
    }
    this.wakeUpResolver = void 0;
    log$a.debug("Global processing loop ended");
  }
  /**
   * Trigger the global processing loop
   */
  triggerProcessing() {
    if (this.isProcessing && this.wakeUpResolver) {
      log$a.debug("Waking up global processing loop");
      this.wakeUpResolver();
    }
  }
  /**
   * Wait for either a wake-up signal or timeout
   */
  async waitForWakeUpOrTimeout(timeoutMs) {
    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        this.wakeUpResolver = void 0;
        resolve();
      }, timeoutMs);
      const wakeUpResolver = () => {
        clearTimeout(timeoutId);
        this.wakeUpResolver = void 0;
        resolve();
      };
      this.wakeUpResolver = wakeUpResolver;
    });
  }
  /**
   * Get enabled event types based on registered handlers in EventRouter
   */
  getEnabledEventTypes() {
    return this.eventRouter.getEnabledEventTypes();
  }
  /**
   * Get enabled event types for no-wallet processing (currently only connect)
   */
  getNoWalletEnabledEventTypes() {
    const enabledTypes = this.eventRouter.getEnabledEventTypes();
    return enabledTypes.filter((type) => type === "connect" || type === "restoreConnection");
  }
}
const log$9 = globalLogger.createChild("WalletTonClass");
class WalletTonClass {
  async createTransferTonTransaction(param) {
    if (!isValidAddress(param.recipientAddress)) {
      throw new Error(`Invalid to address: ${param.recipientAddress}`);
    }
    if (!isValidNanotonAmount(param.transferAmount)) {
      throw new Error(`Invalid amount: ${param.transferAmount}`);
    }
    let body;
    if (param.payload) {
      body = param.payload;
    } else if (param.comment) {
      body = distExports$1.beginCell().storeUint(0, 32).storeStringTail(param.comment).endCell().toBoc().toString("base64");
    }
    const message = {
      address: param.recipientAddress,
      amount: param.transferAmount,
      payload: body,
      stateInit: param.stateInit,
      extraCurrency: param.extraCurrency,
      mode: param.mode
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
  async createTransferMultiTonTransaction(params) {
    let messages = [];
    for (const param of params) {
      if (!isValidAddress(param.recipientAddress)) {
        throw new Error(`Invalid to address: ${param.recipientAddress}`);
      }
      if (!isValidNanotonAmount(param.transferAmount)) {
        throw new Error(`Invalid amount: ${param.transferAmount}`);
      }
      let body;
      if (param.payload) {
        body = param.payload;
      } else if (param.comment) {
        body = distExports$1.beginCell().storeUint(0, 32).storeStringTail(param.comment).endCell().toBoc().toString("base64");
      }
      const message = {
        address: param.recipientAddress,
        amount: param.transferAmount,
        payload: body,
        stateInit: param.stateInit,
        extraCurrency: param.extraCurrency,
        mode: param.mode
      };
      if (!validateTransactionMessage(message, false).isValid) {
        throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
      }
      messages.push(message);
    }
    return {
      messages,
      fromAddress: this.getAddress()
    };
  }
  async getTransactionPreview(param) {
    const transaction = await param;
    const preview = await CallForSuccess(() => createTransactionPreview(this.client, transaction, this));
    return preview;
  }
  async sendTransaction(request) {
    try {
      const boc = await this.getSignedSendTransaction(request);
      await CallForSuccess(() => this.getClient().sendBoc(boc));
      return { boc };
    } catch (error2) {
      log$9.error("Failed to send transaction", { error: error2 });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      if (error2?.message?.includes("Ledger device")) {
        throw new WalletKitError(ERROR_CODES.LEDGER_DEVICE_ERROR, "Ledger device error", error2);
      }
      throw error2;
    }
  }
  async getBalance() {
    return await CallForSuccess(async () => this.getClient().getBalance(this.getAddress()));
  }
}
function ParseStackItem(item) {
  switch (item.type) {
    case "num":
      if (item.value.startsWith("-")) {
        return { type: "int", value: -BigInt(item.value.slice(1)) };
      } else {
        return { type: "int", value: BigInt(item.value) };
      }
    case "null":
      return { type: "null" };
    case "cell":
      return { type: "cell", cell: distExports$1.Cell.fromBoc(Buffer.from(item.value, "base64"))[0] };
    case "tuple":
    case "list":
      if (item.value.length === 0) {
        return { type: "null" };
      }
      return { type: "tuple", items: item.value.map((value) => ParseStackItem(value)) };
    default:
      throw Error(`Unsupported parse stack item type: ${JSON.stringify(item)}`);
  }
}
function ParseStack(list) {
  let stack = [];
  for (let item of list) {
    stack.push(ParseStackItem(item));
  }
  return stack;
}
function SerializeStackItem(item) {
  switch (item.type) {
    case "int":
      return { type: "num", value: `${item.value < 0 ? "-" : ""}0x${item.value.toString(16)}` };
    case "slice":
      return { type: "slice", value: item.cell.toBoc().toString("base64") };
    case "cell":
      return { type: "cell", value: item.cell.toBoc().toString("base64") };
    default:
      throw Error(`Unsupported serialize stack item type: ${item.type}`);
  }
}
function SerializeStack(list) {
  let stack = [];
  for (let item of list) {
    stack.push(SerializeStackItem(item));
  }
  return stack;
}
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber(n, title = "") {
  if (!Number.isSafeInteger(n) || n < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n}`);
  }
}
function abytes(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function kdfInputToBytes(data, errorTitle = "") {
  if (typeof data === "string")
    return utf8ToBytes(data);
  return abytes(data, void 0, errorTitle);
}
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function createHasher(hashCons, info2 = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info2);
  return Object.freeze(hashC);
}
const oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
class _HMAC {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = false;
  destroyed = false;
  constructor(hash, key) {
    ahash(hash);
    abytes(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf2) {
    aexists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new _HMAC(hash, key);
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c, "c");
  anumber(dkLen, "dkLen");
  anumber(asyncTick, "asyncTick");
  if (c < 1)
    throw new Error("iterations (c) must be >= 1");
  const password = kdfInputToBytes(_password, "password");
  const salt = kdfInputToBytes(_salt, "salt");
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
async function pbkdf2Async(hash, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
class HashMD {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(blockLen, outputLen, padOffset, isLE) {
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to ||= new this.constructor();
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h: h2, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
const shrSH = (h2, _l, s2) => h2 >>> s2;
const shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
const rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
const rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
const rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
const rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA2_64B extends HashMD {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class _SHA512 extends SHA2_64B {
  Ah = SHA512_IV[0] | 0;
  Al = SHA512_IV[1] | 0;
  Bh = SHA512_IV[2] | 0;
  Bl = SHA512_IV[3] | 0;
  Ch = SHA512_IV[4] | 0;
  Cl = SHA512_IV[5] | 0;
  Dh = SHA512_IV[6] | 0;
  Dl = SHA512_IV[7] | 0;
  Eh = SHA512_IV[8] | 0;
  El = SHA512_IV[9] | 0;
  Fh = SHA512_IV[10] | 0;
  Fl = SHA512_IV[11] | 0;
  Gh = SHA512_IV[12] | 0;
  Gl = SHA512_IV[13] | 0;
  Hh = SHA512_IV[14] | 0;
  Hl = SHA512_IV[15] | 0;
  constructor() {
    super(64);
  }
}
const sha512 = /* @__PURE__ */ createHasher(
  () => new _SHA512(),
  /* @__PURE__ */ oidNist(3)
);
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
const psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeed(mnemonic2, passphrase = "") {
  return pbkdf2Async(sha512, normalize(mnemonic2).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}
async function bip39ToPrivateKey(mnemonic2) {
  const seed = await mnemonicToSeed(mnemonic2.join(" "));
  const TON_DERIVATION_PATH = [44, 607, 0];
  const seedContainer = await distExports.deriveEd25519Path(Buffer.from(seed), TON_DERIVATION_PATH);
  return distExports.keyPairFromSeed(seedContainer.subarray(0, 32));
}
async function MnemonicToKeyPair(mnemonic2, mnemonicType = "ton") {
  const mnemonicArray = Array.isArray(mnemonic2) ? mnemonic2 : mnemonic2.split(" ");
  if (mnemonicArray.length !== 12 && mnemonicArray.length !== 24) {
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, `Invalid mnemonic length: expected 12 or 24 words, got ${mnemonicArray.length}`);
  }
  if (mnemonicType === "ton") {
    const key = await distExports.mnemonicToWalletKey(mnemonicArray);
    return {
      publicKey: new Uint8Array(key.publicKey),
      secretKey: new Uint8Array(key.secretKey)
    };
  }
  if (mnemonicType === "bip39") {
    const key = await bip39ToPrivateKey(mnemonicArray);
    return {
      publicKey: new Uint8Array(key.publicKey),
      secretKey: new Uint8Array(key.secretKey)
    };
  }
  throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, `Invalid mnemonic type: expected "ton" or "bip39", got "${mnemonicType}"`, void 0, { receivedType: mnemonicType, supportedTypes: ["ton", "bip39"] });
}
async function CreateTonMnemonic() {
  return distExports.mnemonicNew(24);
}
function DefaultSignature(data, privateKey) {
  let fullKey = privateKey;
  if (fullKey.length === 32) {
    const keyPair = distExports.keyPairFromSeed(Buffer.from(fullKey));
    fullKey = keyPair.secretKey;
  }
  return Uint8ArrayToHex(distExports.sign(Buffer.from(Uint8Array.from(data)), Buffer.from(fullKey)));
}
function createWalletSigner(privateKey) {
  return async (data) => {
    return DefaultSignature(Uint8Array.from(data), privateKey);
  };
}
const fakeKeyPair = distExports.keyPairFromSeed(Buffer.alloc(32, 0));
function FakeSignature(data) {
  return Uint8ArrayToHex([...distExports.sign(Buffer.from(Uint8Array.from(data)), Buffer.from(fakeKeyPair.secretKey))]);
}
class Signer {
  /**
   * Create a signer from a mnemonic phrase
   * @param mnemonic - Mnemonic phrase as string or array of words
   * @param options - Optional configuration for mnemonic type
   * @returns Signer function with publicKey property
   */
  static async fromMnemonic(mnemonic2, options) {
    const keyPair = await MnemonicToKeyPair(mnemonic2, options?.type ?? "ton");
    const signer = createWalletSigner(keyPair.secretKey);
    return {
      sign: signer,
      publicKey: Uint8ArrayToHex(keyPair.publicKey)
    };
  }
  /**
   * Create a signer from a private key
   * @param privateKey - Private key as hex string or Uint8Array
   * @returns Signer function with publicKey property
   */
  static async fromPrivateKey(privateKey) {
    const privateKeyBytes = typeof privateKey === "string" ? Uint8Array.from(Buffer.from(privateKey.replace("0x", ""), "hex")) : privateKey;
    const keyPair = distExports.keyPairFromSeed(Buffer.from(privateKeyBytes));
    const signer = createWalletSigner(keyPair.secretKey);
    return {
      sign: signer,
      publicKey: Uint8ArrayToHex(keyPair.publicKey)
    };
  }
}
function limitString(data, limit) {
  return data.length > limit ? data.substring(0, limit) : data;
}
function toStringTail(data) {
  return distExports$1.beginCell().storeStringTail(limitString(data, 127)).endCell();
}
function getUnixtime() {
  return Math.floor(Date.now() / 1e3);
}
const VERSION = "0.0.3";
function getVersion() {
  return VERSION;
}
function getEventsSubsystem() {
  return "wallet";
}
function createWalletId(network, address) {
  return distExports.sha256_sync(`${network.chainId}:${address}`).toString("base64");
}
function storeJettonTransferMessage(src) {
  return (builder2) => {
    builder2.storeUint(Number(OpCode.JettonTransfer), 32);
    builder2.storeUint(src.queryId, 64);
    builder2.storeCoins(src.amount);
    builder2.storeAddress(src.destination);
    builder2.storeAddress(src.responseDestination);
    builder2.storeMaybeRef(src.customPayload);
    builder2.storeCoins(src.forwardAmount ?? 0);
    builder2.storeMaybeRef(src.forwardPayload);
  };
}
class WalletJettonClass {
  async createTransferJettonTransaction(jettonTransferParams) {
    if (!isValidAddress(jettonTransferParams.recipientAddress)) {
      throw new Error(`Invalid to address: ${jettonTransferParams.recipientAddress}`);
    }
    if (!isValidAddress(jettonTransferParams.jettonAddress)) {
      throw new Error(`Invalid jetton address: ${jettonTransferParams.jettonAddress}`);
    }
    if (!jettonTransferParams.transferAmount || BigInt(jettonTransferParams.transferAmount) <= 0n) {
      throw new Error(`Invalid amount: ${jettonTransferParams.transferAmount}`);
    }
    const jettonWalletAddress = await CallForSuccess(() => this.getJettonWalletAddress(jettonTransferParams.jettonAddress));
    const forwardPayload = jettonTransferParams.comment ? distExports$1.beginCell().storeUint(0, 32).storeStringTail(jettonTransferParams.comment).endCell() : null;
    const jettonPayload = distExports$1.beginCell().store(storeJettonTransferMessage({
      queryId: 0n,
      amount: BigInt(jettonTransferParams.transferAmount),
      destination: distExports$1.Address.parse(jettonTransferParams.recipientAddress),
      responseDestination: distExports$1.Address.parse(this.getAddress()),
      customPayload: null,
      forwardAmount: 1n,
      //1 nanoton default
      forwardPayload
    })).endCell();
    const message = {
      address: jettonWalletAddress,
      amount: "50000000",
      // 0.05 TON for gas fees
      payload: jettonPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: {
        flags: [SendModeFlag.IGNORE_ERRORS, SendModeFlag.PAY_GAS_SEPARATELY]
      }
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
  async getJettonBalance(jettonAddress) {
    const jettonWalletAddress = await this.getJettonWalletAddress(jettonAddress);
    try {
      const result = await this.getClient().runGetMethod(jettonWalletAddress, "get_wallet_data");
      const parsedStack = ParseStack(result.stack);
      const balance = parsedStack[0].type === "int" ? parsedStack[0].value : 0n;
      return balance.toString();
    } catch (_error) {
      return "0";
    }
  }
  async getJettonWalletAddress(jettonAddress) {
    if (!isValidAddress(jettonAddress)) {
      throw new Error(`Invalid jetton address: ${jettonAddress}`);
    }
    try {
      const result = await this.getClient().runGetMethod(jettonAddress, "get_wallet_address", SerializeStack([
        { type: "slice", cell: distExports$1.beginCell().storeAddress(distExports$1.Address.parse(this.getAddress())).endCell() }
      ]));
      const parsedStack = ParseStack(result.stack);
      const jettonWalletAddress = parsedStack[0].type === "slice" || parsedStack[0].type === "cell" ? parsedStack[0].cell.asSlice().loadAddress() : null;
      if (!jettonWalletAddress) {
        throw new Error("Failed to get jetton wallet address");
      }
      return asAddressFriendly(jettonWalletAddress.toString());
    } catch (error2) {
      throw new Error(`Failed to get jetton wallet address for ${jettonAddress}: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async getJettons(params) {
    return this.getClient().jettonsByOwnerAddress({
      ownerAddress: this.getAddress(),
      offset: params?.pagination.offset,
      limit: params?.pagination.limit
    });
  }
}
function storeNftTransferMessage(message) {
  return (builder2) => {
    builder2.storeUint(Number(OpCode.NftTransfer), 32);
    builder2.storeUint(message.queryId, 64);
    builder2.storeAddress(message.newOwner);
    builder2.storeAddress(message.responseDestination);
    builder2.storeMaybeRef(message.customPayload);
    builder2.storeCoins(message.forwardAmount);
    builder2.storeMaybeRef(message.forwardPayload);
  };
}
class WalletNftClass {
  async getNfts(params) {
    const out = await this.getClient().nftItemsByOwner({
      ownerAddress: this.getAddress(),
      pagination: params.pagination
    });
    return out;
  }
  async getNft(address) {
    const result = await this.getClient().nftItemsByAddress({
      address
    });
    if (result.nfts.length > 0) {
      return result.nfts[0];
    }
    return null;
  }
  async createTransferNftTransaction(nftTransferMessage) {
    const forwardPayload = nftTransferMessage.comment ? distExports$1.beginCell().storeUint(0, 32).storeStringTail(nftTransferMessage.comment).endCell() : null;
    const nftPayload = distExports$1.beginCell().store(storeNftTransferMessage({
      customPayload: null,
      forwardAmount: 1n,
      forwardPayload,
      newOwner: distExports$1.Address.parse(nftTransferMessage.recipientAddress),
      queryId: 0n,
      responseDestination: distExports$1.Address.parse(this.getAddress())
    })).endCell();
    const message = {
      address: nftTransferMessage.nftAddress,
      amount: nftTransferMessage.transferAmount?.toString() ?? "100000000",
      // Default 0.1 TON
      payload: nftPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: {
        flags: [SendModeFlag.IGNORE_ERRORS, SendModeFlag.PAY_GAS_SEPARATELY]
      }
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
  async createTransferNftRawTransaction(params) {
    const transferMessage = {
      queryId: BigInt(params.message.queryId),
      newOwner: typeof params.message.newOwner === "string" ? distExports$1.Address.parse(params.message.newOwner) : params.message.newOwner,
      responseDestination: params.message.responseDestination ? typeof params.message.responseDestination === "string" ? distExports$1.Address.parse(params.message.responseDestination) : params.message.responseDestination : null,
      customPayload: params.message.customPayload ? typeof params.message.customPayload === "string" ? distExports$1.Cell.fromBase64(params.message.customPayload) : params.message.customPayload : null,
      forwardAmount: BigInt(params.message.forwardAmount),
      forwardPayload: params.message.forwardPayload ? typeof params.message.forwardPayload === "string" ? distExports$1.Cell.fromBase64(params.message.forwardPayload) : params.message.forwardPayload : null
    };
    const nftPayload = distExports$1.beginCell().store(storeNftTransferMessage(transferMessage)).endCell();
    const message = {
      address: params.nftAddress,
      amount: params.transferAmount.toString(),
      payload: nftPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: {
        flags: [SendModeFlag.IGNORE_ERRORS, SendModeFlag.PAY_GAS_SEPARATELY]
      }
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
}
const log$8 = globalLogger.createChild("Initializer");
class Initializer {
  config;
  networkManager;
  eventEmitter;
  analyticsManager;
  constructor(config, eventEmitter, analyticsManager) {
    this.config = config;
    this.eventEmitter = eventEmitter;
    this.analyticsManager = analyticsManager;
  }
  /**
   * Initialize all components
   */
  async initialize(options, networkManager) {
    try {
      log$8.info("Initializing TonWalletKit...");
      this.networkManager = networkManager;
      const storage = this.initializeStorage(options);
      const { walletManager, sessionManager, bridgeManager, eventRouter, eventProcessor } = await this.initializeManagers(options, storage);
      const { requestProcessor } = this.initializeProcessors(sessionManager, bridgeManager, walletManager);
      log$8.info("TonWalletKit initialized successfully");
      return {
        walletManager,
        sessionManager,
        bridgeManager,
        eventRouter,
        requestProcessor,
        storage,
        eventProcessor
      };
    } catch (error2) {
      log$8.error("Failed to initialize TonWalletKit", { error: error2 });
      throw error2;
    }
  }
  /**
   * Initialize storage adapter and wrap it in Storage
   */
  initializeStorage(options) {
    let adapter;
    if (options.storage && "get" in options.storage && typeof options.storage.get === "function" && "set" in options.storage && typeof options.storage.set === "function" && "remove" in options.storage && typeof options.storage.remove === "function" && "clear" in options.storage && typeof options.storage.clear === "function") {
      adapter = options.storage;
    } else {
      const createStorageOptions = {
        prefix: options?.storage?.prefix ?? "tonwalletkit:",
        maxRetries: options?.storage?.maxRetries,
        retryDelay: options?.storage?.retryDelay,
        allowMemory: options?.storage?.allowMemory
      };
      adapter = createStorageAdapter(createStorageOptions);
    }
    return new Storage(adapter);
  }
  /**
   * Initialize core managers
   */
  async initializeManagers(options, storage) {
    const walletManager = new WalletManager(storage);
    await walletManager.initialize();
    let sessionManager;
    if (options.sessionManager) {
      sessionManager = options.sessionManager;
    } else {
      const storedSessionManager = new TONConnectStoredSessionManager(storage, walletManager);
      await storedSessionManager.initialize();
      sessionManager = storedSessionManager;
    }
    const eventStore = new StorageEventStore(storage);
    const eventRouter = new EventRouter(options, this.eventEmitter, sessionManager, walletManager, this.analyticsManager);
    const bridgeManager = new BridgeManager(options?.walletManifest, options?.bridge, sessionManager, storage, eventStore, eventRouter, options, this.eventEmitter, this.analyticsManager);
    eventRouter.setBridgeManager(bridgeManager);
    bridgeManager.start().then(() => {
      log$8.info("Bridge manager started successfully");
    }).catch((e) => {
      log$8.error("Could not start bridge manager", { error: e?.toString?.() });
    });
    const eventProcessor = new StorageEventProcessor(options?.eventProcessor, eventStore, DEFAULT_DURABLE_EVENTS_CONFIG, walletManager, sessionManager, eventRouter, this.eventEmitter);
    return {
      walletManager,
      sessionManager,
      bridgeManager,
      eventRouter,
      eventProcessor
    };
  }
  /**
   * Initialize processors
   */
  initializeProcessors(sessionManager, bridgeManager, walletManager) {
    const requestProcessor = new RequestProcessor(this.config, sessionManager, bridgeManager, walletManager, this.analyticsManager);
    return {
      requestProcessor
    };
  }
  /**
   * Cleanup resources during shutdown
   */
  async cleanup(components) {
    try {
      log$8.info("Cleaning up TonWalletKit components...");
      if (components.eventProcessor) {
        components.eventProcessor.stopRecoveryLoop();
        await components.eventProcessor.clearRegisteredWallets();
        await components.eventProcessor.stopProcessing();
      }
      if (components.bridgeManager) {
        await components.bridgeManager.close();
      }
      if (components.eventRouter) {
        components.eventRouter.clearCallbacks();
      }
      log$8.info("TonWalletKit cleanup completed");
    } catch (error2) {
      log$8.error("Error during cleanup", { error: error2 });
    }
  }
}
async function wrapWalletInterface(wallet2) {
  const ourClassesToExtend = [WalletTonClass, WalletJettonClass, WalletNftClass];
  const newProxy = new Proxy(wallet2, {
    get: (target, prop) => {
      if (typeof prop === "symbol") {
        return target[prop];
      }
      const ourMethonImplementation = ourClassesToExtend.find((cls) => !!cls.prototype[prop]);
      if (ourMethonImplementation) {
        const value2 = ourMethonImplementation.prototype[prop];
        return (...args) => value2.apply(newProxy, [...args]);
      }
      const value = target[prop];
      return value;
    }
  });
  return newProxy;
}
const defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const warned = /* @__PURE__ */ new Set();
const PROCESS = typeof process === "object" && !!process ? process : {};
const emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}
class Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s2 = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s2;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  #perf;
  /**
   * {@link LRUCache.OptionsBase.perf}
   */
  get perf() {
    return this.#perf;
  }
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #autopurgeTimers;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      autopurgeTimers: c.#autopurgeTimers,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p2) => c.#isBackgroundFetch(p2),
      backgroundFetch: (k2, index2, options, context) => c.#backgroundFetch(k2, index2, options, context),
      moveToTail: (index2) => c.#moveToTail(index2),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index2) => c.#isStale(index2)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
    if (perf !== void 0) {
      if (typeof perf?.now !== "function") {
        throw new TypeError("perf option must have a now() method if specified");
      }
    }
    this.#perf = perf ?? defaultPerf;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    const purgeTimers = this.ttlAutopurge ? new Array(this.#max) : void 0;
    this.#autopurgeTimers = purgeTimers;
    this.#setItemTTL = (index2, ttl, start = this.#perf.now()) => {
      starts[index2] = ttl !== 0 ? start : 0;
      ttls[index2] = ttl;
      if (purgeTimers?.[index2]) {
        clearTimeout(purgeTimers[index2]);
        purgeTimers[index2] = void 0;
      }
      if (ttl !== 0 && purgeTimers) {
        const t = setTimeout(() => {
          if (this.#isStale(index2)) {
            this.#delete(this.#keyList[index2], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
        purgeTimers[index2] = t;
      }
    };
    this.#updateItemAge = (index2) => {
      starts[index2] = ttls[index2] !== 0 ? this.#perf.now() : 0;
    };
    this.#statusTTL = (status, index2) => {
      if (ttls[index2]) {
        const ttl = ttls[index2];
        const start = starts[index2];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = this.#perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index2 = this.#keyMap.get(key);
      if (index2 === void 0) {
        return 0;
      }
      const ttl = ttls[index2];
      const start = starts[index2];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index2) => {
      const s2 = starts[index2];
      const t = ttls[index2];
      return !!t && !!s2 && (cachedNow || getNow()) - s2 > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index2) => {
      this.#calculatedSize -= sizes[index2];
      sizes[index2] = 0;
    };
    this.#requireSize = (k2, v2, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v2)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v2, k2);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index2, size, status) => {
      sizes[index2] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index2];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index2];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index2) {
    return index2 !== void 0 && this.#keyMap.get(this.#keyList[index2]) === index2;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v2 = this.#valList[i];
    const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (this.#perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = this.#perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = this.#perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k2, v2, setOptions = {}) {
    if (v2 === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k2, v2, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k2, "set");
      return this;
    }
    let index2 = this.#size === 0 ? void 0 : this.#keyMap.get(k2);
    if (index2 === void 0) {
      index2 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index2] = k2;
      this.#valList[index2] = v2;
      this.#keyMap.set(k2, index2);
      this.#next[this.#tail] = index2;
      this.#prev[index2] = this.#tail;
      this.#tail = index2;
      this.#size++;
      this.#addItemSize(index2, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v2, k2, "add");
      }
    } else {
      this.#moveToTail(index2);
      const oldVal = this.#valList[index2];
      if (v2 !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s2 } = oldVal;
          if (s2 !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s2, k2, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s2, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k2, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k2, "set"]);
          }
        }
        this.#removeItemSize(index2);
        this.#addItemSize(index2, size, status);
        this.#valList[index2] = v2;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v2, k2, v2 === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index2, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index2);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k2 = this.#keyList[head];
    const v2 = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v2)) {
      v2.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v2, k2, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v2, k2, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (this.#autopurgeTimers?.[head]) {
      clearTimeout(this.#autopurgeTimers[head]);
      this.#autopurgeTimers[head] = void 0;
    }
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k2);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index2 = this.#keyMap.get(k2);
    if (index2 !== void 0) {
      const v2 = this.#valList[index2];
      if (this.#isBackgroundFetch(v2) && v2.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index2)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index2);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index2);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index2 = this.#keyMap.get(k2);
    if (index2 === void 0 || !allowStale && this.#isStale(index2)) {
      return;
    }
    const v2 = this.#valList[index2];
    return this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
  }
  #backgroundFetch(k2, index2, options, context) {
    const v2 = index2 === void 0 ? void 0 : this.#valList[index2];
    if (this.#isBackgroundFetch(v2)) {
      return v2;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v3, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p2;
      const vl = this.#valList[index2];
      if (vl === p2 || ignoreAbort && updateCache && vl === void 0) {
        if (v3 === void 0) {
          if (bf2.__staleWhileFetching !== void 0) {
            this.#valList[index2] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k2, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v3, fetchOpts.options);
        }
      }
      return v3;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p2;
      if (this.#valList[index2] === p2) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k2, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index2] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k2, v2, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v3) => res(v3 === void 0 ? void 0 : v3), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v3) => cb(v3, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p2 = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p2, {
      __abortController: ac,
      __staleWhileFetching: v2,
      __returned: void 0
    });
    if (index2 === void 0) {
      this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
      index2 = this.#keyMap.get(k2);
    } else {
      this.#valList[index2] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p2) {
    if (!this.#hasFetchMethod)
      return false;
    const b2 = p2;
    return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = this.#keyMap.get(k2);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p2 = this.#backgroundFetch(k2, index2, options, context);
      return p2.__returned = p2;
    } else {
      const v2 = this.#valList[index2];
      if (this.#isBackgroundFetch(v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale = this.#isStale(index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index2);
        if (updateAgeOnGet) {
          this.#updateItemAge(index2);
        }
        if (status)
          this.#statusTTL(status, index2);
        return v2;
      }
      const p2 = this.#backgroundFetch(k2, index2, options, context);
      const hasStale = p2.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  async forceFetch(k2, fetchOptions = {}) {
    const v2 = await this.fetch(k2, fetchOptions);
    if (v2 === void 0)
      throw new Error("fetch() returned undefined");
    return v2;
  }
  memo(k2, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v2 = this.get(k2, options);
    if (!forceRefresh && v2 !== void 0)
      return v2;
    const vv = memoMethod(k2, v2, {
      options,
      context
    });
    this.set(k2, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index2 = this.#keyMap.get(k2);
    if (index2 !== void 0) {
      const value = this.#valList[index2];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index2);
      if (this.#isStale(index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k2, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index2);
        if (updateAgeOnGet) {
          this.#updateItemAge(index2);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p2, n) {
    this.#prev[n] = p2;
    this.#next[p2] = n;
  }
  #moveToTail(index2) {
    if (index2 !== this.#tail) {
      if (index2 === this.#head) {
        this.#head = this.#next[index2];
      } else {
        this.#connect(this.#prev[index2], this.#next[index2]);
      }
      this.#connect(this.#tail, index2);
      this.#tail = index2;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    return this.#delete(k2, "delete");
  }
  #delete(k2, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index2 = this.#keyMap.get(k2);
      if (index2 !== void 0) {
        if (this.#autopurgeTimers?.[index2]) {
          clearTimeout(this.#autopurgeTimers?.[index2]);
          this.#autopurgeTimers[index2] = void 0;
        }
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index2);
          const v2 = this.#valList[index2];
          if (this.#isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v2, k2, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v2, k2, reason]);
            }
          }
          this.#keyMap.delete(k2);
          this.#keyList[index2] = void 0;
          this.#valList[index2] = void 0;
          if (index2 === this.#tail) {
            this.#tail = this.#prev[index2];
          } else if (index2 === this.#head) {
            this.#head = this.#next[index2];
          } else {
            const pi = this.#prev[index2];
            this.#next[pi] = this.#next[index2];
            const ni = this.#next[index2];
            this.#prev[ni] = this.#prev[index2];
          }
          this.#size--;
          this.#free.push(index2);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index2 of this.#rindexes({ allowStale: true })) {
      const v2 = this.#valList[index2];
      if (this.#isBackgroundFetch(v2)) {
        v2.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.#keyList[index2];
        if (this.#hasDispose) {
          this.#dispose?.(v2, k2, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v2, k2, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
      for (const t of this.#autopurgeTimers ?? []) {
        if (t !== void 0)
          clearTimeout(t);
      }
      this.#autopurgeTimers?.fill(void 0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}
const log$7 = globalLogger.createChild("JettonsManager");
function createCacheKey(network, address) {
  return `${network.chainId}:${address}`;
}
class JettonsManager {
  eventEmitter;
  networkManager;
  cache;
  DEFAULT_TIMEOUT = 1e4;
  // 10 seconds
  constructor(cacheSize = 1e4, eventEmitter, networkManager) {
    this.eventEmitter = eventEmitter;
    this.networkManager = networkManager;
    this.cache = new LRUCache({
      max: cacheSize,
      ttl: 1e3 * 60 * 10
      // 10 minutes TTL
    });
    for (const network of this.networkManager.getConfiguredNetworks()) {
      this.addTonToCache(network);
    }
    log$7.info("JettonsManager initialized", { cacheSize });
    this.eventEmitter.on("emulation:result", (emulationResult) => {
      if (emulationResult && typeof emulationResult === "object" && "metadata" in emulationResult && "network" in emulationResult) {
        const network = emulationResult.network;
        this.addJettonsFromEmulationMetadata(Network.custom(network), emulationResult.metadata);
      }
    });
  }
  /**
   * Add TON native token to cache for a specific network
   */
  addTonToCache(network) {
    const cacheKey = createCacheKey(network, "TON");
    this.cache.set(cacheKey, {
      address: "TON",
      name: "TON",
      symbol: "TON",
      description: "The Open Network native token",
      decimals: 9,
      totalSupply: "5000000000000000000",
      image: "https://asset.ston.fi/img/EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c/ee9fb21d17bc8d75c2a5f7b5f5f62d2bacec6b128f58b63cb841e98f7b74c4fc",
      verification: {
        verified: true,
        source: "manual"
      }
    });
  }
  /**
   * Get jetton information by address for a specific network
   * @param jettonAddress - The jetton master address
   * @param network - The network to query (required)
   */
  async getJettonInfo(jettonAddress, network) {
    const targetNetwork = network;
    try {
      const cacheKey = this.normalizedCacheKey(targetNetwork, jettonAddress);
      const cachedInfo = this.cache.get(cacheKey);
      if (cachedInfo) {
        log$7.debug("Jetton info found in cache", { jettonAddress, network: targetNetwork });
        return cachedInfo;
      }
      log$7.debug("Jetton info not found in cache", { jettonAddress, network: targetNetwork });
      const address = asMaybeAddressFriendly(jettonAddress);
      if (!address) {
        log$7.error("Invalid jetton address format", { jettonAddress, network: targetNetwork });
        return null;
      }
      const apiClient = this.networkManager.getClient(targetNetwork);
      const jettonFromApi = await apiClient.jettonsByAddress({
        address,
        offset: 0,
        limit: 1
      });
      if (jettonFromApi && jettonFromApi?.jetton_masters?.length > 0 && jettonFromApi?.jetton_masters?.[0]) {
        const jetton = jettonFromApi?.jetton_masters?.[0];
        const metadata = jettonFromApi?.metadata?.[jetton.address];
        const tokenInfo = metadata?.token_info?.find((t) => t.valid && t.type === "jetton_masters");
        let decimals;
        try {
          decimals = parseInt(tokenInfo?.extra.decimals, 10);
        } catch {
          decimals = 9;
        }
        const result = {
          address: jetton.jetton,
          name: tokenInfo?.name ?? "",
          symbol: tokenInfo?.symbol ?? "",
          description: tokenInfo?.description ?? "",
          decimals,
          image: tokenInfo?.image,
          uri: tokenInfo?.extra?.uri,
          totalSupply: "0"
        };
        this.cache.set(cacheKey, result);
        return result;
      }
      return null;
    } catch (error2) {
      log$7.error("Error getting jetton info", { error: error2, jettonAddress, network: targetNetwork });
      return null;
    }
  }
  /**
   * Get jettons for a specific address on a specific network
   * @param userAddress - The user's wallet address
   * @param network - The network to query (required)
   * @param offset - Pagination offset
   * @param limit - Pagination limit
   */
  async getAddressJettons(userAddress, network, offset = 0, limit = 50) {
    const targetNetwork = network;
    try {
      const apiClient = this.networkManager.getClient(targetNetwork);
      log$7.debug("Getting address jettons", {
        userAddress,
        network: targetNetwork,
        offset,
        limit
      });
      const response = await apiClient.jettonsByOwnerAddress({
        ownerAddress: userAddress,
        offset,
        limit
      });
      if (!response.jettons) {
        return [];
      }
      const addressJettons = [];
      for (const item of response.jettons) {
        addressJettons.push(item);
      }
      log$7.debug("Retrieved address jettons", { count: addressJettons.length, network: targetNetwork });
      return addressJettons;
    } catch (error2) {
      log$7.error("Failed to get address jettons", { error: error2, userAddress, network: targetNetwork });
      throw new JettonError(`Failed to get jettons for address: ${error2 instanceof Error ? error2.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error2);
    }
  }
  /**
   * Add jetton info to cache from emulation data for a specific network
   */
  addJettonFromEmulation(network, jettonAddress, emulationInfo) {
    try {
      const cacheKey = this.normalizedCacheKey(network, jettonAddress);
      const jettonInfo = {
        address: jettonAddress,
        name: emulationInfo.name,
        symbol: emulationInfo.symbol,
        description: emulationInfo.description,
        image: emulationInfo.image,
        decimals: typeof emulationInfo.extra.decimals === "string" ? parseInt(emulationInfo.extra.decimals, 10) : emulationInfo.extra.decimals,
        uri: emulationInfo.extra.uri
      };
      this.cache.set(cacheKey, jettonInfo);
      log$7.debug("Added jetton info from emulation to cache", {
        jettonAddress,
        network,
        name: jettonInfo.name,
        symbol: jettonInfo.symbol
      });
    } catch (error2) {
      log$7.error("Error adding jetton from emulation", { error: error2, jettonAddress, network });
    }
  }
  /**
   * Add multiple jettons from emulation metadata for a specific network
   */
  addJettonsFromEmulationMetadata(network, metadata) {
    try {
      let addedCount = 0;
      for (const [jettonAddress, addressMetadata] of Object.entries(metadata)) {
        if (!addressMetadata.is_indexed || !addressMetadata.token_info) {
          continue;
        }
        const jettonMasterInfo = addressMetadata.token_info.find((info2) => typeof info2 === "object" && info2 !== null && "type" in info2 && info2.type === "jetton_masters");
        if (jettonMasterInfo) {
          log$7.debug("Adding jetton from emulation metadata", { jettonAddress, network });
          this.addJettonFromEmulation(network, jettonAddress, jettonMasterInfo);
          addedCount++;
        }
      }
      if (addedCount > 0) {
        log$7.info("Added jettons from emulation metadata", { addedCount, network });
      }
    } catch (error2) {
      log$7.error("Error adding jettons from emulation metadata", { error: error2, network });
    }
  }
  /**
   * Normalize jetton address for consistent caching
   */
  normalizedCacheKey(network, address) {
    if (address === "TON") {
      return createCacheKey(network, address);
    }
    return createCacheKey(network, distExports$1.Address.parse(address).toString());
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.cache.size,
      capacity: this.cache.max
    };
  }
  /**
   * Validate jetton address format
   */
  validateJettonAddress(address) {
    try {
      if (address === "TON") {
        return true;
      }
      distExports$1.Address.parse(address);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Clear the jetton cache for all networks or a specific network
   */
  clearCache(network) {
    if (network) {
      for (const key of this.cache.keys()) {
        if (key.startsWith(`${network.chainId}:`)) {
          this.cache.delete(key);
        }
      }
      this.addTonToCache(network);
      log$7.info("Jetton cache cleared for network", { network });
    } else {
      this.cache.clear();
      for (const net of this.networkManager.getConfiguredNetworks()) {
        this.addTonToCache(net);
      }
      log$7.info("Jetton cache cleared for all networks");
    }
  }
}
const log$6 = globalLogger.createChild("EventEmitter");
class EventEmitter {
  listeners = /* @__PURE__ */ new Map();
  /**
   * Subscribe to an event
   */
  on(eventName, listener) {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.listeners.get(eventName).add(listener);
    log$6.debug("Event listener added", { eventName, totalListeners: this.listeners.get(eventName).size });
  }
  /**
   * Subscribe to an event once (automatically removes after first emission)
   */
  once(eventName, listener) {
    const onceListener = (data) => {
      this.off(eventName, onceListener);
      listener(data);
    };
    this.on(eventName, onceListener);
  }
  /**
   * Unsubscribe from an event
   */
  off(eventName, listener) {
    const eventListeners2 = this.listeners.get(eventName);
    if (eventListeners2) {
      eventListeners2.delete(listener);
      log$6.debug("Event listener removed", { eventName, totalListeners: eventListeners2.size });
      if (eventListeners2.size === 0) {
        this.listeners.delete(eventName);
      }
    }
  }
  /**
   * Emit an event to all subscribers
   */
  emit(eventName, data) {
    const eventListeners2 = this.listeners.get(eventName);
    if (eventListeners2) {
      log$6.debug("Emitting event", { eventName, listenerCount: eventListeners2.size });
      eventListeners2.forEach((listener) => {
        try {
          listener(data);
        } catch (error2) {
          log$6.error("Error in event listener", { eventName, error: error2 });
        }
      });
    }
  }
  /**
   * Remove all listeners for a specific event
   */
  removeAllListeners(eventName) {
    if (eventName) {
      this.listeners.delete(eventName);
      log$6.debug("All listeners removed for event", { eventName });
    } else {
      this.listeners.clear();
      log$6.debug("All event listeners cleared");
    }
  }
  /**
   * Get the number of listeners for an event
   */
  listenerCount(eventName) {
    return this.listeners.get(eventName)?.size || 0;
  }
  /**
   * Get all event names that have listeners
   */
  eventNames() {
    return Array.from(this.listeners.keys());
  }
}
var ContentType;
(function(ContentType2) {
  ContentType2["Json"] = "application/json";
  ContentType2["JsonApi"] = "application/vnd.api+json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
  ContentType2["Text"] = "text/plain";
})(ContentType || (ContentType = {}));
class HttpClient {
  baseUrl = "";
  securityData = null;
  securityWorker;
  abortControllers = /* @__PURE__ */ new Map();
  customFetch = (...fetchParams) => fetch(...fetchParams);
  baseApiParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer"
  };
  constructor(apiConfig = {}) {
    Object.assign(this, apiConfig);
  }
  setSecurityData = (data) => {
    this.securityData = data;
  };
  encodeQueryParam(key, value) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }
  addQueryParam(query, key) {
    return this.encodeQueryParam(key, query[key]);
  }
  addArrayQueryParam(query, key) {
    const value = query[key];
    return value.map((v2) => this.encodeQueryParam(key, v2)).join("&");
  }
  toQueryString(rawQuery) {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key) => "undefined" !== typeof query[key]);
    return keys.map((key) => Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join("&");
  }
  addQueryParams(rawQuery) {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  contentFormatters = {
    [ContentType.Json]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.JsonApi]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.Text]: (input) => input !== null && typeof input !== "string" ? JSON.stringify(input) : input,
    [ContentType.FormData]: (input) => {
      if (input instanceof FormData) {
        return input;
      }
      return Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(key, property instanceof Blob ? property : typeof property === "object" && property !== null ? JSON.stringify(property) : `${property}`);
        return formData;
      }, new FormData());
    },
    [ContentType.UrlEncoded]: (input) => this.toQueryString(input)
  };
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
  createAbortSignal = (cancelToken) => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController2 = this.abortControllers.get(cancelToken);
      if (abortController2) {
        return abortController2.signal;
      }
      return void 0;
    }
    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };
  abortRequest = (cancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);
    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };
  request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
    const secureParams = (typeof secure === "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;
    return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
      ...requestParams,
      headers: {
        ...requestParams.headers || {},
        ...type && type !== ContentType.FormData ? { "Content-Type": type } : {}
      },
      signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) || null,
      body: typeof body === "undefined" || body === null ? null : payloadFormatter(body)
    }).then(async (response) => {
      const r = response;
      r.data = null;
      r.error = null;
      const responseToParse = responseFormat ? response.clone() : response;
      const data = !responseFormat ? r : await responseToParse[responseFormat]().then((data2) => {
        if (r.ok) {
          r.data = data2;
        } else {
          r.error = data2;
        }
        return r;
      }).catch((e) => {
        r.error = e;
        return r;
      });
      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }
      if (!response.ok)
        throw data;
      return data;
    });
  };
}
class Api extends HttpClient {
  events = {
    /**
     * No description
     *
     * @name EventsCreate
     * @request POST:/events
     */
    eventsCreate: (events, params = {}) => this.request({
      path: `/events`,
      method: "POST",
      body: events,
      type: ContentType.Json,
      ...params
    })
  };
}
function pascalToKebab(value) {
  return value.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
const log$5 = globalLogger.createChild("AnalyticsManager");
class AnalyticsManager {
  api;
  baseEvent;
  appInfo;
  events = [];
  timeoutId = null;
  isProcessing = false;
  backoff = 1;
  currentBatchTimeoutMs;
  batchTimeoutMs;
  maxBatchSize;
  maxQueueSize;
  static HTTP_STATUS = {
    TOO_MANY_REQUESTS: 429,
    CLIENT_ERROR_START: 400,
    SERVER_ERROR_START: 500
  };
  static MAX_BACKOFF_ATTEMPTS = 5;
  static BACKOFF_MULTIPLIER = 2;
  constructor(options) {
    this.batchTimeoutMs = options.batchTimeoutMs ?? 5e3;
    this.currentBatchTimeoutMs = this.batchTimeoutMs;
    this.maxBatchSize = options.maxBatchSize ?? 100;
    this.maxQueueSize = options.maxQueueSize ?? 1e3;
    this.appInfo = options.appInfo;
    this.api = new Api({
      baseUrl: options.endpoint ?? "https://analytics.ton.org"
    });
    this.baseEvent = {
      version: getVersion(),
      subsystem: getEventsSubsystem(),
      client_environment: options.appInfo?.env ?? "wallet",
      platform: options.appInfo?.platform,
      browser: options.appInfo?.browser,
      wallet_app_name: options.appInfo?.appName,
      wallet_app_version: options.appInfo?.appVersion
    };
  }
  scoped(sharedData) {
    return new Proxy(this, {
      get(target, prop) {
        const propName = prop.toString();
        if (propName.startsWith("emit")) {
          const eventNamePascal = propName.replace("emit", "");
          const eventNameKebab = pascalToKebab(eventNamePascal);
          return function(event) {
            const executedData = Object.fromEntries(Object.entries(sharedData ?? {}).map(([key, value]) => [
              key,
              typeof value === "function" ? value() : value
            ]));
            return target.emit({
              event_name: eventNameKebab,
              ...executedData,
              ...event
            });
          };
        }
        return Reflect.get(target, prop);
      }
    });
  }
  emit(event) {
    const enhancedEvent = {
      ...this.baseEvent,
      ...event,
      event_id: v7(),
      trace_id: event.trace_id ?? v7(),
      client_timestamp: getUnixtime()
    };
    if (this.appInfo?.getLocale) {
      enhancedEvent.locale = this.appInfo.getLocale();
    }
    if (this.appInfo?.getCurrentUserId) {
      enhancedEvent.user_id = this.appInfo.getCurrentUserId();
    }
    log$5.debug("Analytics event emitted", { event: enhancedEvent });
    this.events.push(enhancedEvent);
    if (this.events.length > this.maxQueueSize) {
      const removed = this.events.length - this.maxQueueSize;
      this.events = this.events.slice(removed);
      log$5.warn("Analytics queue overflow, dropped oldest events", { count: removed });
    }
    if (this.events.length >= this.maxBatchSize) {
      void this.flush();
      return;
    }
    this.startTimeout();
  }
  startTimeout() {
    if (this.timeoutId || this.isProcessing) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      void this.flush();
    }, this.currentBatchTimeoutMs);
  }
  async flush() {
    if (this.isProcessing || this.events.length === 0) {
      return;
    }
    this.clearTimeout();
    this.isProcessing = true;
    const eventsToSend = this.extractEventsToSend();
    try {
      await this.processEventsBatch(eventsToSend);
      log$5.debug("Analytics events sent successfully");
    } catch (error2) {
      this.restoreEvents(eventsToSend);
      log$5.error("Failed to send analytics events", { error: error2 });
    } finally {
      this.isProcessing = false;
      this.scheduleNextFlushIfNeeded();
    }
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  extractEventsToSend() {
    const eventsToSend = this.events.slice(0, this.maxBatchSize);
    this.events = this.events.slice(this.maxBatchSize);
    return eventsToSend;
  }
  async processEventsBatch(eventsToSend) {
    log$5.debug("Sending analytics events", { count: eventsToSend.length });
    try {
      const response = await this.sendEvents(eventsToSend);
      this.handleResponse(response);
    } catch (err) {
      this.handleUnknownError(err);
    }
  }
  handleResponse(response) {
    const { status, statusText } = response;
    if (this.isTooManyRequests(status)) {
      this.handleTooManyRequests(status, statusText);
    } else if (this.isClientError(status)) {
      this.handleClientError(status, statusText);
    } else if (this.isServerError(status)) {
      this.handleUnknownError({ status, statusText });
    }
  }
  restoreEvents(eventsToSend) {
    this.events.unshift(...eventsToSend);
    if (this.events.length > this.maxQueueSize) {
      const removed = this.events.length - this.maxQueueSize;
      this.events = this.events.slice(0, this.maxQueueSize);
      log$5.warn("Analytics queue overflow after restore, dropped oldest events", { count: removed });
    }
  }
  scheduleNextFlushIfNeeded() {
    if (this.events.length > 0) {
      this.startTimeout();
    }
  }
  async sendEvents(events) {
    return await this.api.events.eventsCreate(events);
  }
  isClientError(status) {
    return status >= AnalyticsManager.HTTP_STATUS.CLIENT_ERROR_START && status < AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START;
  }
  isServerError(status) {
    return status >= AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START;
  }
  isTooManyRequests(status) {
    return status === AnalyticsManager.HTTP_STATUS.TOO_MANY_REQUESTS;
  }
  handleClientError(status, statusText) {
    log$5.error("Analytics API client error", { status, statusText });
  }
  handleUnknownError(error2) {
    if (this.backoff < AnalyticsManager.MAX_BACKOFF_ATTEMPTS) {
      this.backoff++;
      this.currentBatchTimeoutMs *= AnalyticsManager.BACKOFF_MULTIPLIER;
      throw new Error(`Unknown analytics API error: ${error2}`);
    } else {
      this.currentBatchTimeoutMs = this.batchTimeoutMs;
      this.backoff = 1;
      return;
    }
  }
  handleTooManyRequests(status, statusText) {
    throw new Error(`Analytics API error: ${status} ${statusText}`);
  }
}
function toNftCollection(address, data) {
  if (!data) {
    if (address) {
      return { address: asAddressFriendly(address) };
    } else {
      return null;
    }
  }
  const out = {
    address: asAddressFriendly(data.address),
    codeHash: data.code_hash ? Base64ToHex(data.code_hash) : void 0,
    dataHash: data.data_hash ? Base64ToHex(data.data_hash) : void 0,
    nextItemIndex: data.next_item_index.toString(),
    ownerAddress: asMaybeAddressFriendly(data.owner_address) ?? void 0
  };
  if (data.collection_content)
    out.extra = data.collection_content;
  return out;
}
function tokenMetaToNftCollection(address, data) {
  if (!data) {
    return { address: asAddressFriendly(address) };
  }
  const image = data?.extra?.cover_image ?? data?.image;
  const out = {
    address: asAddressFriendly(address),
    name: data.name,
    description: data.description,
    image: {
      url: image,
      smallUrl: data?.extra?._image_small,
      mediumUrl: data?.extra?._image_medium,
      largeUrl: data?.extra?._image_big
    },
    extra: data.extra
  };
  return out;
}
function toNftItem(data) {
  const out = {
    address: asAddressFriendly(data.address),
    index: data.index.toString(),
    collection: toNftCollection(data.collection_address, data.collection) ?? void 0,
    auctionContractAddress: asMaybeAddressFriendly(data.auction_contract_address) ?? void 0,
    ownerAddress: asMaybeAddressFriendly(data.owner_address) ?? void 0,
    realOwnerAddress: asMaybeAddressFriendly(data.real_owner) ?? void 0,
    saleContractAddress: asMaybeAddressFriendly(data.sale_contract_address) ?? void 0,
    codeHash: data.code_hash ? Base64ToHex(data.code_hash) : void 0,
    dataHash: data.data_hash ? Base64ToHex(data.data_hash) : void 0,
    isInited: data.init,
    isSoulbound: data.is_sbt,
    isOnSale: data.on_sale
  };
  if (data.content)
    out.extra = data.content;
  return out;
}
function toTokenInfo(data) {
  const result = {
    valid: data.valid,
    type: data.type,
    name: data.name,
    description: data.description,
    image: data.image,
    extra: data.extra,
    animation: data?.extra?.animation_url
  };
  if (data.lottie) {
    result.lottie = data.lottie;
  } else if (data.extra && typeof data.extra === "object" && "lottie" in data.extra) {
    const lottieValue = data.extra.lottie;
    if (typeof lottieValue === "string") {
      result.lottie = lottieValue;
    }
  }
  if (data?.extra?.animation_url) {
    result.animation = data.extra.animation_url;
  } else if (data?.extra?.content_url && data.extra.content_url.includes("mp4")) {
    result.animation = data.extra.content_url;
  }
  return result;
}
function toApiTokenInfo(data) {
  var lottie;
  var animationUrl;
  if (data?.extra?.animation_url) {
    animationUrl = data.extra.animation_url;
  } else if (data?.extra?.content_url && data.extra.content_url.includes("mp4")) {
    animationUrl = data.extra.content_url;
  }
  if (data.lottie) {
    lottie = data.lottie;
  } else if (data.extra && typeof data.extra === "object" && "lottie" in data.extra) {
    const lottieValue = data.extra.lottie;
    if (typeof lottieValue === "string") {
      lottie = lottieValue;
    }
  }
  const result = {
    name: data.name,
    description: data.description,
    image: {
      url: data.image ?? data.extra?._image_medium,
      smallUrl: data.extra?._image_small,
      mediumUrl: data.extra?._image_medium,
      largeUrl: data.extra?._image_big
    },
    animation: {
      url: animationUrl,
      lottie
    },
    symbol: data.symbol
  };
  return result;
}
function toNftItemsResponse(data) {
  const metadata = {};
  const collections = {};
  if (data.metadata) {
    for (const address of Object.keys(data.metadata)) {
      if (!data.metadata[address].token_info || data.metadata[address].token_info.length === 0) {
        continue;
      }
      const tokenInfo = data.metadata[address].token_info[0];
      if (tokenInfo.type === "nft_items") {
        metadata[asAddressFriendly(address)] = {
          isIndexed: data.metadata[address].is_indexed,
          tokenInfo: [toTokenInfo(tokenInfo)]
        };
      } else if (tokenInfo.type === "nft_collections") {
        const collection = tokenMetaToNftCollection(address, tokenInfo);
        if (collection) {
          collections[asAddressFriendly(address)] = collection;
        }
      }
    }
  }
  const out = {
    addressBook: {},
    // metadata,
    nfts: (data.nft_items ?? []).map((data2) => {
      const item = toNftItem(data2);
      const meta = metadata[item.address];
      if (meta) {
        const tokenInfo = meta.tokenInfo.filter((it) => it.valid);
        if (tokenInfo.length > 0) {
          item.info = toApiTokenInfo(tokenInfo[0]);
        }
      }
      const itemCollection = item.collection;
      const itemCollectionMeta = item.collection?.address ? collections[asAddressFriendly(item.collection?.address)] : void 0;
      if (itemCollection || itemCollectionMeta) {
        item.collection = {
          ...itemCollection,
          ...itemCollectionMeta
        };
      }
      return item;
    })
  };
  if (data.address_book) {
    for (const address of Object.keys(data.address_book)) {
      if (out.addressBook) {
        out.addressBook[asAddressFriendly(address)] = {
          address: asAddressFriendly(address),
          domain: data.address_book[address].domain ?? void 0,
          interfaces: data.address_book[address].interfaces ?? []
        };
      }
    }
  }
  return out;
}
function toDnsRecord(data) {
  return {
    dnsNextResolver: data.dns_next_resolver,
    dnsSiteAdnl: data.dns_site_adnl,
    dnsStorageBagId: data.dns_storage_bag_id,
    dnsWallet: asMaybeAddressFriendly(data.dns_wallet),
    domain: data.domain,
    nftItemAddress: asAddressFriendly(data.nft_item_address),
    nftItemOwner: asAddressFriendly(data.nft_item_owner)
  };
}
function toDnsRecords(data) {
  const out = {
    addressBook: {},
    records: data.records ? data.records.map(toDnsRecord) : []
  };
  for (const key of Object.keys(data.address_book)) {
    out.addressBook[asAddressFriendly(key)] = {
      domain: data.address_book[key].domain
    };
  }
  return out;
}
const ROOT_DNS_RESOLVER_MAINNET = "Ef_lZ1T4NCb2mwkme9h2rJfESCE0W34ma9lWp7-_uY3zXDvq";
const ROOT_DNS_RESOLVER_TESTNET = "kf_v5x0Thgr6pq6ur2NvkWhIf4DxAxsL-Nk5rknT6n99oEkd";
var DnsCategory;
(function(DnsCategory2) {
  DnsCategory2["DnsNextResolver"] = "dns_next_resolver";
  DnsCategory2["Wallet"] = "wallet";
  DnsCategory2["Site"] = "site";
  DnsCategory2["BagId"] = "storage";
  DnsCategory2[DnsCategory2["All"] = 0] = "All";
})(DnsCategory || (DnsCategory = {}));
var DnsRecord;
(function(DnsRecord2) {
  DnsRecord2[DnsRecord2["SmcAddress"] = 40915] = "SmcAddress";
  DnsRecord2[DnsRecord2["NextResolver"] = 47763] = "NextResolver";
  DnsRecord2[DnsRecord2["AdnlAddress"] = 44289] = "AdnlAddress";
  DnsRecord2[DnsRecord2["StorageAddress"] = 29811] = "StorageAddress";
})(DnsRecord || (DnsRecord = {}));
function toDnsInternal(domain) {
  domain = domain.toLowerCase().normalize("NFC");
  return domain.split(".").filter(Boolean).reverse().join("\0") + "\0";
}
function toTonDnsCategory(category) {
  category = category ?? DnsCategory.All;
  if (typeof category === "number") {
    return BigInt(category);
  }
  return BigInt("0x" + distExports.sha256_sync(category).toString("hex"));
}
async function dnsResolve(client, domain, category, resolver) {
  let currentResolver = resolver ?? ROOT_DNS_RESOLVER_MAINNET;
  let unresolved = domain;
  let maxResolveDepth = 100;
  while (maxResolveDepth > 0) {
    maxResolveDepth--;
    const step = await dnsLookup(client, unresolved, DnsCategory.DnsNextResolver, currentResolver);
    if (step == null) {
      return null;
    }
    if (step.unresolved) {
      if (!step.value) {
        return null;
      }
      currentResolver = step.value;
      unresolved = step.unresolved;
      continue;
    }
    if (step.record === "NextResolver" && step.value) {
      if (category !== void 0) {
        return dnsLookup(client, ".", category, step.value);
      }
      currentResolver = step.value;
      unresolved = ".";
      continue;
    }
    if (category !== void 0) {
      return dnsLookup(client, ".", category, currentResolver);
    }
    return step;
  }
  return null;
}
async function dnsLookup(client, domain, category, resolver) {
  category = category ?? DnsCategory.DnsNextResolver;
  resolver = resolver ?? ROOT_DNS_RESOLVER_MAINNET;
  const result = {
    resolved: "",
    unresolved: ""
  };
  const isSelf = domain === "." || domain === "";
  const internal = toDnsInternal(domain);
  const param = [
    { type: "slice", cell: toStringTail(internal) },
    { type: "int", value: toTonDnsCategory(category) }
  ];
  const { stack, exitCode } = await client.runGetMethod(asAddressFriendly(resolver), "dnsresolve", SerializeStack(param));
  if (stack?.length !== 2) {
    return null;
  }
  const parsedStack = ParseStack(stack);
  if (exitCode !== 0) {
    return null;
  }
  const resolvedBit = parsedStack[0].type === "int" ? Number(parsedStack[0].value) : 0;
  if (resolvedBit === 0 || resolvedBit % 8 !== 0) {
    return null;
  }
  const resolvedByte = resolvedBit / 8;
  const part = isSelf ? [] : domain.split(".").filter(Boolean);
  const level = internal.slice(0, Number(resolvedByte)).split(".").filter(Boolean).length;
  result.unresolved = part.slice(0, part.length - level).join(".");
  result.resolved = part.slice(part.length - level).join(".");
  if (category === DnsCategory.All) {
    throw new Error("not implemented all categories are requested");
  }
  const cell = parsedStack[1].type === "cell" ? parsedStack[1].cell : null;
  if (!cell) {
    return result;
  }
  const slice = cell.asSlice();
  const tag = slice.loadUint(16);
  if (tag == DnsRecord.NextResolver || tag == DnsRecord.SmcAddress) {
    result.value = slice.loadAddress().toString();
  } else if (tag == DnsRecord.AdnlAddress || tag == DnsRecord.StorageAddress) {
    result.value = toHexString(slice.loadBuffer(32));
  } else {
    result.value = cell.toBoc().toString("base64");
  }
  if (result.value) {
    result.record = DnsRecord[tag];
  }
  return result;
}
const log$4 = globalLogger.createChild("ApiClientToncenter");
class TonClientError extends Error {
  status;
  details;
  constructor(message, status, details) {
    super(message);
    this.name = "TonClientError";
    this.status = status;
    this.details = details;
  }
}
class ApiClientToncenter {
  dnsResolver;
  endpoint;
  apiKey;
  timeout;
  fetchApi;
  network;
  disableNetworkSend;
  constructor(config = {}) {
    this.network = config.network;
    const dnsResolver = this.network?.chainId === CHAIN.MAINNET ? ROOT_DNS_RESOLVER_MAINNET : ROOT_DNS_RESOLVER_TESTNET;
    const defaultEndpoint = this.network?.chainId === CHAIN.MAINNET ? "https://toncenter.com" : "https://testnet.toncenter.com";
    this.dnsResolver = config.dnsResolver ?? dnsResolver;
    this.endpoint = config.endpoint ?? defaultEndpoint;
    this.apiKey = config.apiKey;
    this.timeout = config.timeout ?? 3e4;
    this.fetchApi = config.fetchApi ?? fetch;
    this.disableNetworkSend = config.disableNetworkSend ?? false;
  }
  async nftItemsByAddress(request) {
    const props = {
      address: request.address
    };
    const response = await this.getJson("/api/v3/nft/items", props);
    return toNftItemsResponse(response);
  }
  async nftItemsByOwner(request) {
    const props = {
      owner_address: request.ownerAddress,
      limit: request.pagination?.limit ?? 10,
      offset: request.pagination?.offset ?? 0
    };
    const response = await this.getJson("/api/v3/nft/items", props);
    const formattedResponse = toNftItemsResponse(response);
    return formattedResponse;
  }
  async fetchEmulation(messageBoc, ignoreSignature) {
    const props = {
      boc: messageBoc,
      ignore_chksig: ignoreSignature === true,
      include_code_data: true,
      include_address_book: true,
      include_metadata: true,
      with_actions: true
    };
    const response = await this.postJson("/api/emulate/v1/emulateTrace", props);
    return {
      result: "success",
      emulationResult: response
    };
  }
  async sendBoc(boc) {
    if (this.disableNetworkSend) {
      return "";
    }
    const response = await this.postJson("/api/v3/message", { boc });
    return Base64ToBigInt(response.message_hash_norm).toString(16);
  }
  async runGetMethod(address, method, stack = [], seqno) {
    const props = {
      address,
      method,
      stack
      //serializeStack(stack),
    };
    if (typeof seqno === "number")
      props.seqno = seqno;
    const raw = await this.postJson("/api/v3/runGetMethod", props);
    return {
      gasUsed: raw.gas_used,
      stack: raw.stack,
      exitCode: raw.exit_code
    };
  }
  async getAccountState(address, seqno) {
    const query = { include_boc: true, address: [address] };
    if (typeof seqno === "number")
      query.seqno = seqno.toString();
    const raw = await this.getJson("/api/v3/addressInformation", query);
    const balance = BigInt(raw.balance);
    const extraCurrencies = {};
    for (const currency of raw.extra_currencies || []) {
      extraCurrencies[currency.id] = BigInt(currency.amount);
    }
    const out = {
      status: raw.status,
      balance: balance.toString(),
      extraCurrencies,
      code: raw.code,
      data: raw.data,
      lastTransaction: parseInternalTransactionId({
        hash: raw.last_transaction_hash,
        lt: raw.last_transaction_lt
      })
    };
    if (raw.frozen_hash) {
      out.frozenHash = Base64ToHex(raw.frozen_hash) ?? void 0;
    }
    return out;
  }
  async getBalance(address, seqno) {
    return (await this.getAccountState(address, seqno)).balance;
  }
  async doRequest(url, init2 = {}) {
    const fetchFn = this.fetchApi;
    if (!this.timeout || this.timeout <= 0) {
      return fetchFn(url, init2);
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      return await fetchFn(url, { ...init2, signal: controller.signal });
    } finally {
      clearTimeout(timeoutId);
    }
  }
  async fetch(url, props = {}) {
    const headers = new Headers(props.headers);
    headers.set("accept", "application/json");
    if (this.apiKey)
      headers.set("x-api-key", this.apiKey);
    props = { ...props, headers };
    const response = await this.doRequest(url, props);
    if (!response.ok) {
      throw await this.buildError(response);
    }
    const contentType = response.headers.get("content-type") || "";
    if (!contentType.includes("application/json")) {
      const text = await response.text();
      throw new TonClientError("Unexpected non-JSON response", response.status, text.slice(0, 200));
    }
    const json = await response.json();
    return json;
  }
  async getJson(path, query) {
    return this.fetch(this.buildUrl(path, query), { method: "GET" });
  }
  async postJson(path, props) {
    return this.fetch(this.buildUrl(path), {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(props)
    });
  }
  buildUrl(path, query = {}) {
    const url = new URL(path.replace(/^\/*/, "/"), this.endpoint);
    for (const [key, value] of Object.entries(query)) {
      if (typeof value === "string")
        url.searchParams.set(key, value);
      else if (Array.isArray(value)) {
        for (const item of value) {
          if (typeof item === "string")
            url.searchParams.set(key, item);
          else if (item != null && typeof item.toString === "function") {
            url.searchParams.set(key, item.toString());
          }
        }
      } else if (value != null && typeof value.toString === "function") {
        url.searchParams.set(key, value.toString());
      }
    }
    return url;
  }
  async buildError(response) {
    const message = response.statusText || "HTTP Error";
    const code = response.status ?? 500;
    let detail;
    try {
      detail = await response.json();
    } catch {
    }
    return new TonClientError(`HTTP ${response.status}: ${message}`, code, detail);
  }
  async getAccountTransactions(request) {
    const accounts = request.address?.map(prepareAddress);
    let offset = request.offset ?? 0;
    let limit = request.limit ?? 10;
    if (limit > 100) {
      limit = 100;
    } else if (limit < 0) {
      limit = 0;
    }
    if (offset < 0) {
      offset = 0;
    }
    const response = await this.getJson("/api/v3/transactions", {
      account: accounts,
      limit,
      offset
    });
    return toTransactionsResponse(response);
  }
  async getTransactionsByHash(request) {
    const msgHash = "msgHash" in request ? padBase64(request.msgHash) : void 0;
    const bodyHash = "bodyHash" in request ? padBase64(request.bodyHash) : void 0;
    const response = await this.getJson("/api/v3/transactionsByMessage", {
      msg_hash: msgHash ? [msgHash] : void 0,
      body_hash: bodyHash ? [bodyHash] : void 0
    });
    return toTransactionsResponse(response);
  }
  async getPendingTransactions(request) {
    const accounts = "accounts" in request ? request.accounts?.map(prepareAddress) : void 0;
    const traceId = "traceId" in request ? request.traceId : void 0;
    const response = await this.getJson("/api/v3/pendingTransactions", {
      account: accounts,
      trace_id: traceId
    });
    return toTransactionsResponse(response);
  }
  async getTrace(request) {
    const inTraceId = request.traceId ? request.traceId[0] : void 0;
    const traceId = padBase64(Base64Normalize(inTraceId || "").replace(/=/g, ""));
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        tx_hash: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching trace", { error: error2 });
    }
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        trace_id: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching trace", { error: error2 });
    }
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        msg_hash: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching pending trace", { error: error2 });
    }
    throw new Error("Failed to fetch trace");
  }
  async getPendingTrace(request) {
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/pendingTraces", {
        ext_msg_hash: request.externalMessageHash
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching pending trace", { error: error2 });
    }
    throw new Error("Failed to fetch pending trace");
  }
  async resolveDnsWallet(domain) {
    const result = await dnsResolve(this, domain, DnsCategory.Wallet, this.dnsResolver);
    if (result && result.value) {
      return result.value;
    }
    return null;
  }
  async backResolveDnsWallet(wallet2) {
    if (wallet2 instanceof distExports$1.Address) {
      wallet2 = wallet2.toString();
    }
    const response = toDnsRecords(await this.getJson("/api/v3/dns/records", {
      wallet: wallet2,
      limit: 1,
      offset: 0
    }));
    if (response.records.length > 0) {
      return response.records[0].domain;
    }
    return null;
  }
  async jettonsByAddress(request) {
    return this.getJson("/api/v3/jetton/masters", {
      address: request.address,
      offset: request.offset,
      limit: request.limit
    });
  }
  async jettonsByOwnerAddress(request) {
    const offset = request.offset ?? 0;
    const limit = request.limit ?? 50;
    const rawResponse = await this.getJson("/api/v3/jetton/wallets", {
      owner_address: request.ownerAddress,
      offset,
      limit
    });
    return this.mapToResponseUserJettons(rawResponse);
  }
  mapToResponseUserJettons(rawResponse) {
    const verifiedJettonsMasters = /* @__PURE__ */ new Set([
      "0:B113A994B5024A16719F69139328EB759596C38A25F59028B146FECDC3621DFE"
    ]);
    const userJettons = rawResponse.jetton_wallets.map((wallet2) => {
      const jettonInfo = this.extractJettonInfoFromMetadata(wallet2.jetton, rawResponse.metadata);
      const jetton = {
        address: asAddressFriendly(wallet2.jetton),
        walletAddress: asAddressFriendly(wallet2.address),
        balance: wallet2.balance,
        info: {
          name: jettonInfo.name,
          description: jettonInfo.description,
          image: {
            url: jettonInfo.image,
            data: jettonInfo.image_data
          },
          symbol: jettonInfo.symbol
        },
        decimalsNumber: jettonInfo.decimals,
        // For future use, currently prices are not provided by toncenter
        prices: [
          {
            value: "0",
            currency: "USD"
          }
        ],
        isVerified: verifiedJettonsMasters.has(wallet2.jetton)
        // ????
        // extra: rawResponse.metadata[wallet.jetton]?.token_info,
      };
      return jetton;
    });
    return {
      jettons: userJettons,
      addressBook: {}
    };
  }
  extractJettonInfoFromMetadata(jettonAddress, metadata) {
    const jettonMetadata = metadata[jettonAddress];
    const metadataJettonInfo = jettonMetadata?.token_info?.find((info2) => typeof info2 === "object" && info2 !== null && "type" in info2 && info2.type === "jetton_masters");
    if (metadataJettonInfo) {
      const decimals = typeof metadataJettonInfo.extra.decimals === "string" ? parseInt(metadataJettonInfo.extra.decimals, 10) : metadataJettonInfo.extra.decimals;
      return {
        address: jettonAddress,
        name: metadataJettonInfo.name ?? "",
        symbol: metadataJettonInfo.symbol ?? "",
        description: metadataJettonInfo.description ?? "",
        decimals,
        image: metadataJettonInfo.image,
        image_data: metadataJettonInfo.extra.image_data,
        uri: metadataJettonInfo.extra.uri
      };
    }
    return {
      address: jettonAddress,
      name: "",
      symbol: "",
      description: "",
      decimals: 9
    };
  }
  async getEvents(request) {
    const account = request.account instanceof distExports$1.Address ? request.account.toString() : request.account;
    const limit = request.limit ?? 20;
    const offset = request.offset ?? 0;
    const query = {
      account,
      limit,
      offset
    };
    const list = await this.getJson("/api/v3/traces", query);
    const out = { events: [], limit, offset, hasNext: list.traces.length >= limit };
    const addressBook = toAddressBook$1(list);
    for (const trace of list.traces) {
      out.events.push(toEvent(trace, account, addressBook));
    }
    return out;
  }
}
const padBase64 = (data) => {
  return data.padEnd(data.length + (4 - data.length % 4), "=");
};
function prepareAddress(address) {
  if (address instanceof distExports$1.Address) {
    address = address.toString();
  }
  return address;
}
function parseInternalTransactionId(data) {
  if (data.hash !== "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") {
    return {
      lt: data.lt,
      hash: Base64ToHex(data.hash)
    };
  }
  return null;
}
const log$3 = globalLogger.createChild("NetworkManager");
class NetworkManager {
  clients = /* @__PURE__ */ new Map();
  constructor(options) {
    this.initializeClients(options);
    const configuredNetworks = this.getConfiguredNetworks();
    if (configuredNetworks.length === 0) {
      throw new WalletKitError(ERROR_CODES.CONFIGURATION_ERROR, "At least one network must be configured in TonWalletKitOptions.networks");
    }
  }
  /**
   * Initialize API clients from configuration
   */
  initializeClients(options) {
    const networks = options.networks;
    if (!networks) {
      log$3.warn("No networks configured in TonWalletKitOptions");
      return;
    }
    for (const [chainId, networkConfig] of Object.entries(networks)) {
      const network = Network.custom(chainId);
      if (!networkConfig)
        continue;
      const client = this.createClient(network, networkConfig.apiClient, options);
      this.clients.set(network.chainId, client);
      log$3.info("Initialized network client", { chainId });
    }
  }
  /**
   * Create an API client for a specific network
   */
  createClient(network, apiClientConfig, options) {
    if (this.isApiClient(apiClientConfig)) {
      return apiClientConfig;
    }
    const defaultEndpoint = network.chainId === CHAIN.MAINNET ? "https://toncenter.com" : "https://testnet.toncenter.com";
    const endpoint = apiClientConfig?.url || defaultEndpoint;
    return new ApiClientToncenter({
      endpoint,
      apiKey: apiClientConfig?.key,
      network,
      disableNetworkSend: options.dev?.disableNetworkSend
    });
  }
  /**
   * Type guard to check if value is a full ApiClient instance
   */
  isApiClient(value) {
    return !!value && "nftItemsByAddress" in value && "nftItemsByOwner" in value && "fetchEmulation" in value && "sendBoc" in value && "runGetMethod" in value && "getAccountState" in value && "getBalance" in value;
  }
  /**
   * Get API client for a specific network
   * @param chainId - The chain ID (CHAIN.MAINNET or CHAIN.TESTNET)
   * @returns The API client for the specified network
   * @throws WalletKitError if no client is configured for the network
   */
  getClient(network) {
    const client = this.clients.get(network.chainId);
    if (!client) {
      throw new WalletKitError(ERROR_CODES.NETWORK_NOT_CONFIGURED, `No API client configured for network ${network.chainId}`, void 0, {
        network,
        configuredNetworks: Array.from(this.clients.keys())
      });
    }
    return client;
  }
  /**
   * Check if a network is configured
   */
  hasNetwork(network) {
    return this.clients.has(network.chainId);
  }
  /**
   * Get all configured networks
   */
  getConfiguredNetworks() {
    return Array.from(this.clients.keys()).map((chainId) => Network.custom(chainId));
  }
  /**
   * Add or update a network client dynamically
   */
  setClient(network, client) {
    this.clients.set(network.chainId, client);
    log$3.info("Added/updated network client", { network });
  }
}
const log$2 = globalLogger.createChild("TonWalletKit");
class TonWalletKit {
  // Component references
  walletManager;
  sessionManager;
  eventRouter;
  requestProcessor;
  // private responseHandler!: ResponseHandler;
  networkManager;
  jettonsManager;
  initializer;
  eventProcessor;
  bridgeManager;
  config;
  // Event emitter for this kit instance
  eventEmitter;
  // State
  isInitialized = false;
  initializationPromise;
  analyticsManager;
  constructor(options) {
    this.config = options;
    if (options?.analytics?.enabled) {
      this.analyticsManager = new AnalyticsManager({
        ...options?.analytics,
        appInfo: {
          appName: options?.deviceInfo?.appName,
          appVersion: options?.deviceInfo?.appVersion,
          ...options?.analytics?.appInfo
        }
      });
    }
    this.networkManager = new NetworkManager(options);
    this.eventEmitter = new EventEmitter();
    this.initializer = new Initializer(options, this.eventEmitter, this.analyticsManager);
    this.initializationPromise = this.initialize();
    this.jettonsManager = new JettonsManager(1e4, this.eventEmitter, this.networkManager);
    this.eventEmitter.on("restoreConnection", async (event) => {
      if (!event.domain) {
        log$2.error("Domain is required for restore connection");
        return this.sendErrorConnectResponse(event);
      }
      const sessions = await this.sessionManager.getSessions({
        walletId: event.walletId,
        domain: event.domain,
        isJsBridge: true
      });
      const session = sessions.length > 0 ? sessions[0] : void 0;
      if (!session) {
        log$2.error("Session not found for domain", { domain: event.domain });
        return this.sendErrorConnectResponse(event);
      }
      const wallet2 = session.walletId ? this.walletManager?.getWallet(session.walletId) : void 0;
      if (!wallet2) {
        log$2.error("Wallet not found for session", { walletId: session.walletId });
        return this.sendErrorConnectResponse(event);
      }
      const walletAddress = wallet2.getAddress();
      const walletStateInit = await wallet2.getStateInit();
      const publicKey = wallet2.getPublicKey().replace("0x", "");
      const deviceInfo = getDeviceInfoForWallet(wallet2, this.config.deviceInfo);
      const tonConnectEvent = {
        event: "connect",
        id: Date.now(),
        payload: {
          device: deviceInfo,
          items: [
            {
              name: "ton_addr",
              address: distExports$1.Address.parse(walletAddress).toRawString(),
              // TODO: Support multiple networks
              network: wallet2.getNetwork().chainId === CHAIN.MAINNET ? CHAIN.MAINNET : CHAIN.TESTNET,
              walletStateInit,
              publicKey
            }
          ]
        }
      };
      this.bridgeManager.sendJsBridgeResponse(event?.tabId?.toString() || "", true, event?.id ?? event?.messageId, tonConnectEvent);
    });
  }
  async sendErrorConnectResponse(event) {
    const tonConnectEvent = {
      event: "connect_error",
      id: Date.now(),
      payload: {
        code: CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR,
        message: ""
      }
    };
    await this.bridgeManager.sendJsBridgeResponse(event?.tabId?.toString() || "", true, event?.id ?? event?.messageId, tonConnectEvent);
  }
  // === Initialization ===
  /**
   * Initialize all components
   */
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      const components = await this.initializer.initialize(this.config, this.networkManager);
      this.assignComponents(components);
      await this.setupEventRouting();
      this.eventProcessor.startRecoveryLoop();
      await this.eventProcessor.startProcessing();
      this.isInitialized = true;
    } catch (error2) {
      log$2.error("TonWalletKit initialization failed", { error: error2?.toString() });
      throw error2;
    }
  }
  /**
   * Assign initialized components
   */
  assignComponents(components) {
    this.walletManager = components.walletManager;
    this.sessionManager = components.sessionManager;
    this.eventRouter = components.eventRouter;
    this.requestProcessor = components.requestProcessor;
    this.eventProcessor = components.eventProcessor;
    this.bridgeManager = components.bridgeManager;
  }
  /**
   * Setup event routing from bridge to handlers
   */
  async setupEventRouting() {
    await this.startProcessingForExistingWallets();
  }
  /**
   * Start event processing for all existing wallets
   */
  async startProcessingForExistingWallets() {
    const wallets = this.walletManager.getWallets();
    for (const wallet2 of wallets) {
      try {
        const walletId = wallet2.getWalletId();
        await this.eventProcessor.startProcessing(walletId);
      } catch (error2) {
        log$2.error("Failed to start event processing for wallet", {
          walletAddress: wallet2.getAddress(),
          error: error2
        });
      }
    }
  }
  /**
   * Ensure initialization is complete
   */
  async ensureInitialized() {
    if (this.initializationPromise) {
      await this.initializationPromise;
    }
  }
  /**
   * Get all configured networks
   */
  getConfiguredNetworks() {
    return this.networkManager.getConfiguredNetworks();
  }
  // === Wallet Management API (Delegated) ===
  getWallets() {
    if (!this.isInitialized) {
      log$2.warn("TonWalletKit not yet initialized, returning empty array");
      return [];
    }
    return this.walletManager.getWallets();
  }
  /**
   * Get wallet by wallet ID (network:address format)
   */
  getWallet(walletId) {
    if (!this.isInitialized) {
      log$2.warn("TonWalletKit not yet initialized, returning undefined");
      return void 0;
    }
    return this.walletManager.getWallet(walletId);
  }
  async addWallet(adapter) {
    await this.ensureInitialized();
    const walletNetwork = adapter.getNetwork();
    if (!this.networkManager.hasNetwork(walletNetwork)) {
      throw new WalletKitError(ERROR_CODES.NETWORK_NOT_CONFIGURED, `No API client configured for wallet network ${walletNetwork}`, void 0, { walletNetwork, configuredNetworks: this.networkManager.getConfiguredNetworks() });
    }
    const wallet2 = await wrapWalletInterface(adapter);
    const walletId = await this.walletManager.addWallet(wallet2);
    await this.eventProcessor.startProcessing(walletId);
    return wallet2;
  }
  async removeWallet(walletIdOrAdapter) {
    await this.ensureInitialized();
    let wallet2;
    let walletId;
    if (typeof walletIdOrAdapter === "string") {
      walletId = walletIdOrAdapter;
      wallet2 = this.walletManager.getWallet(walletIdOrAdapter);
    } else {
      walletId = this.walletManager.getWalletId(walletIdOrAdapter);
      wallet2 = this.walletManager.getWallet(walletId);
    }
    if (!wallet2) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for removal", void 0, {
        walletId
      });
    }
    await this.eventProcessor.stopProcessing(wallet2.getAddress());
    await this.walletManager.removeWallet(walletId);
    await this.sessionManager.removeSessions({ walletId });
  }
  async clearWallets() {
    await this.ensureInitialized();
    const wallets = this.walletManager.getWallets();
    for (const wallet2 of wallets) {
      await this.eventProcessor.stopProcessing(wallet2.getAddress());
    }
    await this.walletManager.clearWallets();
    await this.sessionManager.clearSessions();
  }
  // === Session Management API (Delegated) ===
  async disconnect(sessionId) {
    await this.ensureInitialized();
    const removeSession = async (sessionId2) => {
      const session = await this.sessionManager.getSession(sessionId2);
      if (session) {
        try {
          const sessionCrypto = new SessionCrypto({
            publicKey: session.publicKey,
            secretKey: session.privateKey
          });
          await CallForSuccess(() => this.bridgeManager.sendResponse({
            sessionId: sessionId2,
            isJsBridge: session?.isJsBridge,
            id: Date.now(),
            from: sessionId2
          }, {
            event: "disconnect",
            id: Date.now(),
            payload: {}
          }, sessionCrypto), 10, 100);
        } catch (error2) {
          log$2.error("Failed to send disconnect to bridge", { sessionId: sessionId2, error: error2 });
        }
      }
      await this.sessionManager.removeSession(sessionId2);
    };
    if (sessionId) {
      try {
        await removeSession(sessionId);
      } catch (error2) {
        log$2.error("Failed to remove session", { sessionId, error: error2 });
      }
    } else {
      const sessions = await this.sessionManager.getSessions();
      if (sessions.length > 0) {
        for (const session of sessions) {
          try {
            await removeSession(session.sessionId);
          } catch (error2) {
            log$2.error("Failed to remove session", { sessionId: session.sessionId, error: error2 });
          }
        }
      }
    }
  }
  async listSessions() {
    await this.ensureInitialized();
    return await this.sessionManager.getSessions();
  }
  // === Event Handler Registration (Delegated) ===
  onConnectRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onConnectRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onConnectRequest(cb);
      });
    }
  }
  onTransactionRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onTransactionRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onTransactionRequest(cb);
      });
    }
  }
  onSignDataRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onSignDataRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onSignDataRequest(cb);
      });
    }
  }
  onDisconnect(cb) {
    if (this.eventRouter) {
      this.eventRouter.onDisconnect(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onDisconnect(cb);
      });
    }
  }
  removeConnectRequestCallback() {
    this.eventRouter.removeConnectRequestCallback();
  }
  removeTransactionRequestCallback() {
    this.eventRouter.removeTransactionRequestCallback();
  }
  removeSignDataRequestCallback() {
    this.eventRouter.removeSignDataRequestCallback();
  }
  removeDisconnectCallback() {
    this.eventRouter.removeDisconnectCallback();
  }
  onRequestError(cb) {
    if (this.eventRouter) {
      this.eventRouter.onRequestError(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onRequestError(cb);
      });
    }
  }
  removeErrorCallback() {
    this.eventRouter.removeErrorCallback();
  }
  // === URL Processing API ===
  /**
   * Handle pasted TON Connect URL/link
   * Parses the URL and creates a connect request event
   */
  async handleTonConnectUrl(url) {
    await this.ensureInitialized();
    try {
      const parsedUrl = this.parseTonConnectUrl(url);
      if (!parsedUrl) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid TON Connect URL format", void 0, {
          url
        });
      }
      const bridgeEvent = this.createConnectEventFromUrl(parsedUrl);
      if (!bridgeEvent) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid TON Connect URL - unable to create bridge event", void 0, { parsedUrl });
      }
      await this.eventRouter.routeEvent(bridgeEvent);
    } catch (error2) {
      log$2.error("Failed to handle TON Connect URL", { error: error2, url });
      throw error2;
    }
  }
  async handleNewTransaction(wallet2, data) {
    await this.ensureInitialized();
    data.validUntil ??= Math.floor(Date.now() / 1e3) + 300;
    data.network ??= wallet2.getNetwork();
    const walletId = wallet2.getWalletId();
    const bridgeEvent = {
      id: Date.now().toString(),
      method: "sendTransaction",
      params: [JSON.stringify(toConnectTransactionParamContent(data))],
      from: "",
      domain: "",
      isLocal: true,
      walletId,
      walletAddress: asAddressFriendly(wallet2.getAddress())
    };
    await this.eventRouter.routeEvent(bridgeEvent);
  }
  /**
   * Parse TON Connect URL to extract connection parameters
   */
  parseTonConnectUrl(url) {
    try {
      let parsedUrl;
      parsedUrl = new URL(url);
      const params = {};
      for (const [key, value] of parsedUrl.searchParams.entries()) {
        params[key] = value;
      }
      if (!params.v || !params.id || !params.r) {
        log$2.warn("Missing required TON Connect URL parameters");
        return null;
      }
      return {
        version: params.v,
        clientId: params.id,
        requestId: params.id,
        returnStrategy: params.ret || "back",
        r: params.r,
        ...params
      };
    } catch (error2) {
      log$2.error("Failed to parse TON Connect URL", { error: error2, url });
      return null;
    }
  }
  /**
   * Create bridge event from parsed URL parameters
   */
  createConnectEventFromUrl(params) {
    const rString = params.r;
    const r = rString ? JSON.parse(rString) : void 0;
    if (!r?.manifestUrl || !params.clientId) {
      return void 0;
    }
    return {
      from: params.clientId,
      id: params.requestId,
      method: "connect",
      params: {
        manifest: {
          url: r.manifestUrl
        },
        items: r.items,
        returnStrategy: params.returnStrategy
      },
      timestamp: Date.now(),
      domain: ""
    };
  }
  // === Request Processing API (Delegated) ===
  async approveConnectRequest(event, response) {
    await this.ensureInitialized();
    return this.requestProcessor.approveConnectRequest(event, response);
  }
  async rejectConnectRequest(event, reason, errorCode) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectConnectRequest(event, reason, errorCode);
  }
  async approveTransactionRequest(event, response) {
    await this.ensureInitialized();
    return this.requestProcessor.approveTransactionRequest(event, response);
  }
  async rejectTransactionRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectTransactionRequest(event, reason);
  }
  async approveSignDataRequest(event, response) {
    await this.ensureInitialized();
    return this.requestProcessor.approveSignDataRequest(event, response);
  }
  async rejectSignDataRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectSignDataRequest(event, reason);
  }
  // === TON Client Access ===
  /**
   * Get API client for a specific network
   * @param network - The network object
   * @returns The API client for the specified network
   * @throws WalletKitError if no client is configured for the network
   */
  getApiClient(network) {
    if (!this.isInitialized) {
      throw new WalletKitError(ERROR_CODES.INITIALIZATION_ERROR, "TonWalletKit not yet initialized - call initialize() first");
    }
    return this.networkManager.getClient(network);
  }
  /**
   * Get the NetworkManager instance
   * Provides access to all configured network clients
   */
  getNetworkManager() {
    return this.networkManager;
  }
  // === Lifecycle Management ===
  /**
   * Check if kit is ready for use
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * Wait for initialization to complete
   */
  async waitForReady() {
    await this.ensureInitialized();
  }
  /**
   * Get initialization status
   */
  getStatus() {
    return {
      initialized: this.isInitialized,
      ready: this.isInitialized
    };
  }
  /**
   * Clean shutdown
   */
  async close() {
    if (this.initializer) {
      await this.initializer.cleanup({
        walletManager: this.walletManager,
        bridgeManager: this.bridgeManager,
        sessionManager: this.sessionManager,
        eventRouter: this.eventRouter,
        requestProcessor: this.requestProcessor,
        eventProcessor: this.eventProcessor
      });
    }
    this.isInitialized = false;
  }
  // === Jettons API ===
  /**
   * Jettons API access
   */
  get jettons() {
    return this.jettonsManager;
  }
  /**
   * Get jettons manager for internal use
   */
  getJettonsManager() {
    return this.jettonsManager;
  }
  /**
   * Get the event emitter for this kit instance
   * Allows external components to listen to and emit events
   */
  getEventEmitter() {
    return this.eventEmitter;
  }
  /**
   * Process a bridge request from injected JS Bridge
   * This method is called by extension content scripts
   * @param request - The bridge request to process
   * @returns Promise resolving to the response data
   */
  async processInjectedBridgeRequest(messageInfo, request) {
    await this.ensureInitialized();
    return this.bridgeManager.queueJsBridgeEvent(messageInfo, request);
  }
}
const WalletV5R1CodeBoc = "b5ee9c7201021401000281000114ff00f4a413f4bcf2c80b01020120020302014804050102f20e02dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120060702012008090019be5f0f6a2684080a0eb90fa02c02016e0a0b0201480c0d0019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00017b325fb51341c75c875c2c7e00011b262fb513435c28020011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0";
const WalletV5R1CodeCell = distExports$1.Cell.fromBoc(Buffer.from(WalletV5R1CodeBoc, "hex"))[0];
class ActionSendMsg {
  mode;
  outMsg;
  static tag = 247711853;
  tag = ActionSendMsg.tag;
  constructor(mode, outMsg) {
    this.mode = mode;
    this.outMsg = outMsg;
  }
  serialize() {
    return distExports$1.beginCell().storeUint(this.tag, 32).storeUint(this.mode | distExports$1.SendMode.IGNORE_ERRORS, 8).storeRef(distExports$1.beginCell().store(distExports$1.storeMessageRelaxed(this.outMsg)).endCell()).endCell();
  }
}
class ActionAddExtension {
  address;
  static tag = 2;
  tag = ActionAddExtension.tag;
  constructor(address) {
    this.address = address;
  }
  serialize() {
    return distExports$1.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
  }
}
class ActionRemoveExtension {
  address;
  static tag = 3;
  tag = ActionRemoveExtension.tag;
  constructor(address) {
    this.address = address;
  }
  serialize() {
    return distExports$1.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
  }
}
class ActionSetSignatureAuthAllowed {
  allowed;
  static tag = 4;
  tag = ActionSetSignatureAuthAllowed.tag;
  constructor(allowed) {
    this.allowed = allowed;
  }
  serialize() {
    return distExports$1.beginCell().storeUint(this.tag, 8).storeUint(this.allowed ? 1 : 0, 1).endCell();
  }
}
function isExtendedAction(action) {
  return action.tag === ActionAddExtension.tag || action.tag === ActionRemoveExtension.tag || action.tag === ActionSetSignatureAuthAllowed.tag;
}
function packActionsListOut(actions) {
  if (actions.length === 0) {
    return distExports$1.beginCell().endCell();
  }
  const [action, ...rest] = actions;
  if (isExtendedAction(action)) {
    throw new Error("Actions bust be in an order: all extended actions, all out actions");
  }
  return distExports$1.beginCell().storeRef(packActionsListOut(rest)).storeSlice(action.serialize().beginParse()).endCell();
}
function packExtendedActions(extendedActions) {
  const first = extendedActions[0];
  const rest = extendedActions.slice(1);
  let builder2 = distExports$1.beginCell().storeSlice(first.serialize().beginParse());
  if (rest.length > 0) {
    builder2 = builder2.storeRef(packExtendedActions(extendedActions.slice(1)));
  }
  return builder2.endCell();
}
function packActionsListExtended(actions) {
  const extendedActions = [];
  const outActions = [];
  actions.forEach((action) => {
    if (isExtendedAction(action)) {
      extendedActions.push(action);
    } else {
      outActions.push(action);
    }
  });
  let builder2 = distExports$1.beginCell();
  if (outActions.length === 0) {
    builder2 = builder2.storeUint(0, 1);
  } else {
    builder2 = builder2.storeMaybeRef(packActionsListOut(outActions.slice().reverse()));
  }
  if (extendedActions.length === 0) {
    builder2 = builder2.storeUint(0, 1);
  } else {
    const first = extendedActions[0];
    const rest = extendedActions.slice(1);
    builder2 = builder2.storeUint(1, 1).storeSlice(first.serialize().beginParse());
    if (rest.length > 0) {
      builder2 = builder2.storeRef(packExtendedActions(rest));
    }
  }
  return builder2.endCell();
}
function packActionsList(actions) {
  return packActionsListExtended(actions);
}
const log$1 = globalLogger.createChild("WalletV5R1Adapter");
const defaultWalletIdV5R1 = 2147483409;
class WalletV5R1Adapter {
  // private keyPair: { publicKey: Uint8Array; secretKey: Uint8Array };
  signer;
  config;
  walletContract;
  client;
  publicKey;
  version = "v5r1";
  /**
   * Static factory method to create a WalletV5R1Adapter
   * @param signer - Signer function with publicKey property (from Signer utility)
   * @param options - Configuration options for the wallet
   */
  static async create(signer, options) {
    return new WalletV5R1Adapter({
      signer,
      publicKey: signer.publicKey,
      tonClient: options.client,
      network: options.network,
      walletId: options.walletId,
      workchain: options.workchain
    });
  }
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    this.signer = config.signer;
    this.publicKey = this.config.publicKey;
    this.walletContract = WalletV5.createFromConfig({
      publicKey: HexToBigInt(this.publicKey),
      seqno: 0,
      signatureAllowed: true,
      walletId: typeof config.walletId === "bigint" ? Number(config.walletId) : config.walletId ?? defaultWalletIdV5R1,
      extensions: distExports$1.Dictionary.empty()
    }, {
      code: WalletV5R1CodeCell,
      workchain: config.workchain ?? 0,
      client: this.client
    });
  }
  getPublicKey() {
    return this.publicKey;
  }
  getClient() {
    return this.client;
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return this.signer.sign(bytes);
  }
  getNetwork() {
    return this.config.network;
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  getWalletId() {
    return createWalletId(this.getNetwork(), this.getAddress());
  }
  async getSignedSendTransaction(input, options) {
    const actions = packActionsList(input.messages.map((m) => {
      let bounce = true;
      const parsedAddress = distExports$1.Address.parseFriendly(m.address);
      if (parsedAddress.isBounceable === false) {
        bounce = false;
      }
      const msg = distExports$1.internal({
        to: m.address,
        value: BigInt(m.amount),
        bounce,
        extracurrency: m.extraCurrency ? Object.fromEntries(Object.entries(m.extraCurrency).map(([k2, v2]) => [Number(k2), BigInt(v2)])) : void 0
      });
      if (m.payload) {
        try {
          msg.body = distExports$1.Cell.fromBase64(m.payload);
        } catch (error2) {
          log$1.warn("Failed to load payload", { error: error2 });
          throw WalletKitError.fromError(ERROR_CODES.CONTRACT_VALIDATION_FAILED, "Failed to parse transaction payload", error2);
        }
      }
      if (m.stateInit) {
        try {
          msg.init = distExports$1.loadStateInit(distExports$1.Cell.fromBase64(m.stateInit).asSlice());
        } catch (error2) {
          log$1.warn("Failed to load state init", { error: error2 });
          throw WalletKitError.fromError(ERROR_CODES.CONTRACT_VALIDATION_FAILED, "Failed to parse state init", error2);
        }
      }
      return new ActionSendMsg(distExports$1.SendMode.PAY_GAS_SEPARATELY + distExports$1.SendMode.IGNORE_ERRORS, msg);
    }));
    const createBodyOptions = {
      ...options,
      validUntil: void 0
    };
    if (input.validUntil) {
      const now = Math.floor(Date.now() / 1e3);
      const maxValidUntil = now + 600;
      if (input.validUntil < now) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Transaction valid_until timestamp is in the past", void 0, { validUntil: input.validUntil, currentTime: now });
      } else if (input.validUntil > maxValidUntil) {
        createBodyOptions.validUntil = maxValidUntil;
      } else {
        createBodyOptions.validUntil = input.validUntil;
      }
    }
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const walletId = (await this.walletContract.walletId).serialized;
    if (!walletId) {
      throw new Error("Failed to get seqno or walletId");
    }
    const transfer = await this.createBodyV5(seqno, walletId, actions, createBodyOptions);
    const ext = distExports$1.external({
      to: this.walletContract.address,
      init: this.walletContract.init,
      body: transfer
    });
    return distExports$1.beginCell().store(distExports$1.storeMessage(ext)).endCell().toBoc().toString("base64");
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$1.beginCell().store(distExports$1.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV5 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      return await this.walletContract.seqno;
    } catch (error2) {
      log$1.warn("Failed to get seqno", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet ID
   */
  async getWalletV5R1Id() {
    try {
      return this.walletContract.walletId;
    } catch (error2) {
      log$1.warn("Failed to get wallet ID", { error: error2 });
      const walletId = this.config.walletId;
      const subwalletNumber = typeof walletId === "bigint" ? Number(walletId) : walletId || 0;
      return new WalletV5R1Id({ subwalletNumber });
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getAccountState(asAddressFriendly(this.walletContract.address));
      return state.status === "active";
    } catch (error2) {
      log$1.warn("Failed to check deployment status", { error: error2 });
      return false;
    }
  }
  async createBodyV5(seqno, walletId, actionsList, options) {
    const Opcodes2 = {
      auth_signed: 1936287598
    };
    const expireAt = options.validUntil ?? Math.floor(Date.now() / 1e3) + 300;
    const payload = distExports$1.beginCell().storeUint(Opcodes2.auth_signed, 32).storeUint(walletId, 32).storeUint(expireAt, 32).storeUint(seqno, 32).storeSlice(actionsList.beginParse()).endCell();
    const signingData = payload.hash();
    const signature = options.fakeSignature ? FakeSignature(signingData) : await this.sign(signingData);
    return distExports$1.beginCell().storeSlice(payload.beginParse()).storeBuffer(Buffer.from(HexToUint8Array(signature))).endCell();
  }
  async getSignedSignData(input) {
    const signature = await this.sign(HexToUint8Array(input.hash));
    return signature;
  }
  async getSignedTonProof(input) {
    const message = await CreateTonProofMessageBytes(input);
    const signature = await this.sign(message);
    return signature;
  }
  getSupportedFeatures() {
    return [
      {
        name: "SendTransaction",
        maxMessages: 255
      },
      {
        name: "SignData",
        types: ["binary", "cell", "text"]
      }
    ];
  }
}
function walletV5ConfigToCell(config) {
  return distExports$1.beginCell().storeBit(config.signatureAllowed).storeUint(config.seqno, 32).storeUint(config.walletId, 32).storeUint(config.publicKey, 256).storeDict(config.extensions, distExports$1.Dictionary.Keys.BigUint(256), distExports$1.Dictionary.Values.BigInt(1)).endCell();
}
const Opcodes = {
  action_send_msg: 247711853,
  action_set_code: 2907562126,
  action_extended_set_data: 536406539,
  action_extended_add_extension: 2,
  action_extended_remove_extension: 3,
  action_extended_set_signature_auth_allowed: 4,
  auth_extension: 1702392942,
  auth_signed: 1936287598,
  auth_signed_internal: 1936289396
};
class WalletV5R1Id {
  static deserialize(walletId) {
    return new WalletV5R1Id({
      subwalletNumber: walletId
    });
  }
  subwalletNumber;
  serialized;
  constructor(args) {
    this.subwalletNumber = args?.subwalletNumber ?? 0;
    this.serialized = BigInt(this.subwalletNumber);
  }
}
class WalletV5 {
  client;
  address;
  init;
  subwalletId;
  constructor(client, address, init2) {
    this.client = client;
    this.address = address;
    this.init = init2;
  }
  static createFromAddress(client, address) {
    return new WalletV5(client, address);
  }
  static createFromConfig(config, options) {
    const data = walletV5ConfigToCell(config);
    const init2 = { code: options.code, data };
    const wallet2 = new WalletV5(options.client, distExports$1.contractAddress(options.workchain, init2), init2);
    wallet2.subwalletId = config.walletId;
    return wallet2;
  }
  async sendDeploy(provider, via, value) {
    await provider.internal(via, {
      value,
      sendMode: distExports$1.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$1.beginCell().endCell()
    });
  }
  async sendInternalSignedMessage(provider, via, opts) {
    await provider.internal(via, {
      value: opts.value,
      sendMode: distExports$1.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$1.beginCell().storeSlice(opts.body.beginParse()).endCell()
    });
  }
  async sendInternalMessageFromExtension(provider, via, opts) {
    await provider.internal(via, {
      value: opts.value,
      sendMode: distExports$1.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$1.beginCell().storeUint(Opcodes.auth_extension, 32).storeUint(0, 64).storeSlice(opts.body.beginParse()).endCell()
    });
  }
  async sendInternal(provider, via, opts) {
    await provider.internal(via, opts);
  }
  async sendExternalSignedMessage(provider, body) {
    await provider.external(body);
  }
  async sendExternal(provider, body) {
    await provider.external(body);
  }
  get publicKey() {
    return this.client.runGetMethod(asAddressFriendly(this.address), "get_public_key").then((data) => {
      if (data.exitCode === 0) {
        const parsedStack = ParseStack(data.stack);
        if (parsedStack[0]?.type === "int") {
          return parsedStack[0].value;
        } else {
          throw new Error("Stack is not an int");
        }
      } else if (this.init) {
        return this.init.data.asSlice().skip(1 + 32 + 32).loadUintBig(256);
      } else {
        return 0n;
      }
    });
  }
  get status() {
    return this.client.getAccountState(asAddressFriendly(this.address)).then((state) => state.status);
  }
  get seqno() {
    return this.client.runGetMethod(asAddressFriendly(this.address), "seqno").then((data) => {
      if (data.exitCode === 0) {
        const parsedStack = ParseStack(data.stack);
        if (parsedStack[0]?.type === "int") {
          return Number(parsedStack[0].value);
        } else {
          throw new Error("Stack is not an int");
        }
      } else {
        return 0;
      }
    });
  }
  get isSignatureAuthAllowed() {
    return this.client.runGetMethod(asAddressFriendly(this.address), "is_signature_allowed").then((data) => {
      if (data.exitCode === 0) {
        const parsedStack = ParseStack(data.stack);
        if (parsedStack[0]?.type === "int") {
          return Boolean(parsedStack[0].value);
        } else {
          throw new Error("Stack is not an int");
        }
      } else {
        return false;
      }
    });
  }
  get walletId() {
    if (this.subwalletId !== void 0) {
      return new Promise((resolve) => {
        resolve(WalletV5R1Id.deserialize(this.subwalletId));
      });
    } else {
      return this.client.runGetMethod(asAddressFriendly(this.address), "get_subwallet_id").then((data) => {
        if (data.exitCode === 0) {
          const parsedStack = ParseStack(data.stack);
          if (parsedStack[0]?.type === "int") {
            this.subwalletId = Number(parsedStack[0].value);
          } else {
            throw new Error("Stack is not an int");
          }
          return WalletV5R1Id.deserialize(this.subwalletId);
        } else {
          return WalletV5R1Id.deserialize(defaultWalletIdV5R1);
        }
      });
    }
  }
}
class WalletV4R2 {
  address;
  init;
  workchain;
  publicKey;
  subwalletId;
  client;
  constructor(address, init2, options) {
    this.address = address;
    this.init = init2 ?? void 0;
    this.workchain = options.workchain;
    this.client = options.client;
    if (init2) {
      const dataSlice = init2.data.beginParse();
      dataSlice.loadUint(32);
      this.subwalletId = dataSlice.loadUint(32);
      this.publicKey = dataSlice.loadUintBig(256);
    } else {
      this.subwalletId = 0;
      this.publicKey = 0n;
    }
  }
  static createFromConfig(config, options) {
    const data = distExports$1.beginCell().storeUint(config.seqno, 32).storeUint(config.subwalletId, 32).storeUint(config.publicKey, 256).storeBit(0).endCell();
    const init2 = { code: options.code, data };
    const address = distExports$1.contractAddress(options.workchain, init2);
    return new WalletV4R2(address, init2, options);
  }
  static createFromAddress(address, options) {
    return new WalletV4R2(address, null, options);
  }
  async sendDeploy(provider, via, value) {
    await provider.internal(via, {
      value,
      sendMode: distExports$1.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$1.beginCell().endCell()
    });
  }
  /**
   * Get wallet's current sequence number
   */
  async getSeqno() {
    try {
      const state = await this.client.runGetMethod(asAddressFriendly(this.address), "seqno");
      if (state.exitCode !== 0) {
        return 0;
      }
      const parsedStack = ParseStack(state.stack);
      if (parsedStack[0]?.type === "int") {
        return Number(parsedStack[0].value);
      } else {
        throw new Error("Stack is not an int");
      }
    } catch (error2) {
      return 0;
    }
  }
  /**
   * Get wallet's current sequence number (async getter)
   */
  get seqno() {
    return this.getSeqno();
  }
  /**
   * Get wallet's subwallet ID
   */
  async getSubwalletId() {
    try {
      const state = await this.client.runGetMethod(asAddressFriendly(this.address), "get_subwallet_id");
      if (state.exitCode !== 0) {
        return this.subwalletId;
      }
      const parsedStack = ParseStack(state.stack);
      if (parsedStack[0]?.type === "int") {
        return Number(parsedStack[0].value);
      } else {
        throw new Error("Stack is not an int");
      }
    } catch (error2) {
      return this.subwalletId;
    }
  }
  /**
   * Create transfer message body
   */
  createTransfer(args) {
    const timeout = args.timeout ?? Math.floor(Date.now() / 1e3) + 60;
    let body = distExports$1.beginCell().storeUint(this.subwalletId, 32).storeUint(timeout, 32).storeUint(args.seqno, 32).storeUint(0, 8).storeUint(args.sendMode, 8);
    for (const message of args.messages) {
      body = body.storeRef(distExports$1.beginCell().store(distExports$1.storeMessageRelaxed(message)));
    }
    return body.endCell();
  }
  /**
   * Send internal transfer
   */
  async sendTransfer(provider, via, args) {
    const transfer = this.createTransfer(args);
    await provider.internal(via, {
      sendMode: distExports$1.SendMode.PAY_GAS_SEPARATELY,
      body: transfer,
      value: 0n
    });
  }
}
const WalletV4R2CodeCell = distExports$1.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
const defaultWalletIdV4R2 = 698983191;
const log = globalLogger.createChild("WalletV4R2Adapter");
class WalletV4R2Adapter {
  signer;
  config;
  walletContract;
  client;
  publicKey;
  version = "v4r2";
  /**
   * Static factory method to create a WalletV4R2Adapter
   * @param signer - Signer function with publicKey property (from Signer utility)
   * @param options - Configuration options for the wallet
   */
  static async create(signer, options) {
    return new WalletV4R2Adapter({
      signer,
      publicKey: signer.publicKey,
      tonClient: options.client,
      network: options.network,
      walletId: typeof options.walletId === "bigint" ? Number(options.walletId) : options.walletId,
      workchain: options.workchain
    });
  }
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    this.signer = config.signer;
    this.publicKey = this.config.publicKey;
    const walletConfig = {
      publicKey: HexToBigInt(this.publicKey),
      workchain: config.workchain ?? 0,
      seqno: 0,
      subwalletId: config.walletId ?? defaultWalletIdV4R2
    };
    this.walletContract = WalletV4R2.createFromConfig(walletConfig, {
      code: WalletV4R2CodeCell,
      workchain: config.workchain ?? 0,
      client: this.client
    });
  }
  getPublicKey() {
    return this.publicKey;
  }
  getClient() {
    return this.client;
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return this.signer.sign(bytes);
  }
  getNetwork() {
    return this.config.network;
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  getWalletId() {
    return createWalletId(this.getNetwork(), this.getAddress());
  }
  async getSignedSendTransaction(input, _options) {
    if (input.messages.length === 0) {
      throw new Error("Ledger does not support empty messages");
    }
    if (input.messages.length > 4) {
      throw new Error("WalletV4R2 does not support more than 4 messages");
    }
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const timeout = input.validUntil ? Math.min(input.validUntil, Math.floor(Date.now() / 1e3) + 600) : Math.floor(Date.now() / 1e3) + 60;
    try {
      const messages = input.messages.map((m) => {
        let bounce = true;
        const parsedAddress = distExports$1.Address.parseFriendly(m.address);
        if (parsedAddress.isBounceable === false) {
          bounce = false;
        }
        return distExports$1.internal({
          to: distExports$1.Address.parse(m.address),
          value: BigInt(m.amount),
          bounce,
          extracurrency: m.extraCurrency ? Object.fromEntries(Object.entries(m.extraCurrency).map(([k2, v2]) => [Number(k2), BigInt(v2)])) : void 0,
          body: m.payload ? distExports$1.Cell.fromBase64(m.payload) : void 0,
          init: m.stateInit ? distExports$1.loadStateInit(distExports$1.Cell.fromBase64(m.stateInit).asSlice()) : void 0
        });
      });
      const data = this.walletContract.createTransfer({
        seqno,
        sendMode: distExports$1.SendMode.PAY_GAS_SEPARATELY + distExports$1.SendMode.IGNORE_ERRORS,
        messages,
        timeout
      });
      const signature = await this.sign(Uint8Array.from(data.hash()));
      const signedCell = distExports$1.beginCell().storeBuffer(Buffer.from(HexToUint8Array(signature))).storeSlice(data.asSlice()).endCell();
      const ext = distExports$1.external({
        to: this.walletContract.address,
        init: this.walletContract.init,
        body: signedCell
      });
      return distExports$1.beginCell().store(distExports$1.storeMessage(ext)).endCell().toBoc().toString("base64");
    } catch (error2) {
      log.warn("Failed to get signed send transaction", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$1.beginCell().store(distExports$1.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV4R2 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      return await this.walletContract.getSeqno();
    } catch (error2) {
      log.warn("Failed to get seqno", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet's subwallet ID
   */
  async getSubwalletId() {
    try {
      return await this.walletContract.getSubwalletId();
    } catch (error2) {
      log.warn("Failed to get subwallet ID", { error: error2 });
      return this.config.walletId ?? defaultWalletIdV4R2;
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getAccountState(asAddressFriendly(this.walletContract.address));
      return state.status === "active";
    } catch (error2) {
      log.warn("Failed to check deployment status", { error: error2 });
      return false;
    }
  }
  async getSignedSignData(input) {
    const signature = await this.sign(HexToUint8Array(input.hash));
    return signature;
  }
  async getSignedTonProof(input) {
    const message = await CreateTonProofMessageBytes(input);
    const signature = await this.sign(message);
    return signature;
  }
  getSupportedFeatures() {
    return [
      {
        name: "SendTransaction",
        maxMessages: 4
      },
      {
        name: "SignData",
        types: ["binary", "cell", "text"]
      }
    ];
  }
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApiClientToncenter,
  get AssetType() {
    return AssetType;
  },
  Base64Normalize,
  Base64NormalizeUrl,
  Base64ToBigInt,
  Base64ToHex,
  Base64ToUint8Array,
  BigIntToBase64,
  BridgeError,
  BridgeManager,
  CallForSuccess,
  ConnectHandler,
  CreateTonMnemonic,
  CreateTonProofMessageBytes,
  DEFAULT_DURABLE_EVENTS_CONFIG,
  DEFAULT_REQUEST_TIMEOUT,
  DefaultSignature,
  DisconnectHandler,
  ERROR_CODES,
  EventEmitter,
  EventRouter,
  EventStoreError,
  ExtensionStorageAdapter,
  FakeSignature,
  HexToBase64,
  HexToBigInt,
  HexToUint8Array,
  Initializer,
  JettonError,
  get JettonErrorCode() {
    return JettonErrorCode;
  },
  JettonsManager,
  LocalStorageAdapter,
  MemoryStorageAdapter,
  MnemonicToKeyPair,
  Network,
  NetworkManager,
  Opcodes,
  ParseBase64,
  ParseStack,
  RESTORE_CONNECTION_TIMEOUT,
  RequestProcessor,
  get Result() {
    return Result;
  },
  get SEND_TRANSACTION_ERROR_CODES() {
    return SEND_TRANSACTION_ERROR_CODES;
  },
  get SendModeBase() {
    return SendModeBase;
  },
  get SendModeFlag() {
    return SendModeFlag;
  },
  SerializeStack,
  SessionError,
  SignDataHandler,
  Signer,
  Storage,
  StorageError,
  StorageEventProcessor,
  StorageEventStore,
  TONCONNECT_BRIDGE_EVENT,
  TONConnectStoredSessionManager,
  TonWalletKit,
  TransactionHandler,
  Uint8ArrayToBase64,
  Uint8ArrayToBigInt,
  Uint8ArrayToHex,
  WalletKitError,
  WalletManager,
  WalletV4R2,
  WalletV4R2Adapter,
  WalletV4R2CodeCell,
  WalletV5,
  WalletV5R1Adapter,
  WalletV5R1CodeBoc,
  WalletV5R1CodeCell,
  WalletV5R1Id,
  createDeviceInfo,
  createWalletId,
  createWalletManifest,
  defaultWalletIdV4R2,
  defaultWalletIdV5R1,
  emulationEvent,
  formatWalletAddress,
  getErrorCodeName,
  isValidAddress,
  wrapWalletInterface
}, Symbol.toStringTag, { value: "Module" }));
let walletKit = null;
function setWalletKit(instance) {
  walletKit = instance;
}
const internalBrowserGlobal = globalThis;
function getInternalBrowserResolverMap() {
  return internalBrowserGlobal.__internalBrowserResponseResolvers;
}
function ensureInternalBrowserResolverMap() {
  if (!internalBrowserGlobal.__internalBrowserResponseResolvers) {
    internalBrowserGlobal.__internalBrowserResponseResolvers = /* @__PURE__ */ new Map();
  }
  return internalBrowserGlobal.__internalBrowserResponseResolvers;
}
var __async$b = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function hasAndroidSessionManager() {
  var _a, _b;
  const win = window;
  return ((_b = (_a = win.WalletKitNative) == null ? void 0 : _a.hasSessionManager) == null ? void 0 : _b.call(_a)) === true;
}
class AndroidTONConnectSessionsManager {
  constructor() {
    var _a;
    const win = window;
    if (!((_a = win.WalletKitNative) == null ? void 0 : _a.sessionCreate)) {
      throw new Error("Android native session manager bridge not available");
    }
    this.bridge = win.WalletKitNative;
  }
  initialize() {
    return __async$b(this, null, function* () {
    });
  }
  createSession(sessionId, dAppInfo, wallet2, isJsBridge) {
    return __async$b(this, null, function* () {
      var _a, _b, _c, _d;
      try {
        const walletId = (_b = (_a = wallet2.getWalletId) == null ? void 0 : _a.call(wallet2)) != null ? _b : "";
        const walletAddress = (_d = (_c = wallet2.getAddress) == null ? void 0 : _c.call(wallet2)) != null ? _d : "";
        const dAppInfoJson = JSON.stringify({
          name: dAppInfo.name,
          url: dAppInfo.url,
          iconUrl: dAppInfo.iconUrl,
          description: dAppInfo.description
        });
        const resultJson = this.bridge.sessionCreate(sessionId, dAppInfoJson, walletId, walletAddress, isJsBridge);
        const session = JSON.parse(resultJson);
        return session;
      } catch (err) {
        error("[AndroidSessionManager] Failed to create session:", err);
        throw err;
      }
    });
  }
  getSession(sessionId) {
    return __async$b(this, null, function* () {
      try {
        const resultJson = this.bridge.sessionGet(sessionId);
        if (!resultJson) {
          return void 0;
        }
        return JSON.parse(resultJson);
      } catch (err) {
        warn("[AndroidSessionManager] Failed to get session:", err);
        return void 0;
      }
    });
  }
  getSessions(parameters) {
    return __async$b(this, null, function* () {
      try {
        const filterJson = JSON.stringify(parameters != null ? parameters : {});
        const resultJson = this.bridge.sessionGetFiltered(filterJson);
        return JSON.parse(resultJson);
      } catch (err) {
        warn("[AndroidSessionManager] Failed to get sessions:", err);
        return [];
      }
    });
  }
  removeSession(sessionId) {
    return __async$b(this, null, function* () {
      try {
        const resultJson = this.bridge.sessionRemove(sessionId);
        if (!resultJson) {
          return void 0;
        }
        return JSON.parse(resultJson);
      } catch (err) {
        error("[AndroidSessionManager] Failed to remove session:", err);
        throw err;
      }
    });
  }
  removeSessions(parameters) {
    return __async$b(this, null, function* () {
      try {
        const filterJson = JSON.stringify(parameters != null ? parameters : {});
        const resultJson = this.bridge.sessionRemoveFiltered(filterJson);
        return JSON.parse(resultJson);
      } catch (err) {
        error("[AndroidSessionManager] Failed to remove sessions:", err);
        throw err;
      }
    });
  }
  clearSessions() {
    return __async$b(this, null, function* () {
      try {
        this.bridge.sessionClear();
      } catch (err) {
        error("[AndroidSessionManager] Failed to clear sessions:", err);
        throw err;
      }
    });
  }
}
var __async$a = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class AndroidAPIClientAdapter {
  constructor(network) {
    const androidWindow = window;
    if (!androidWindow.WalletKitNative) {
      throw new Error("WalletKitNative bridge not available");
    }
    this.androidBridge = androidWindow.WalletKitNative;
    this.network = network;
  }
  /**
   * Check if native API clients are available.
   */
  static isAvailable() {
    var _a;
    const androidWindow = window;
    return typeof ((_a = androidWindow.WalletKitNative) == null ? void 0 : _a.apiGetNetworks) === "function";
  }
  /**
   * Get all networks that have native API clients configured.
   */
  static getAvailableNetworks() {
    var _a;
    const androidWindow = window;
    if (!((_a = androidWindow.WalletKitNative) == null ? void 0 : _a.apiGetNetworks)) {
      return [];
    }
    try {
      const networksJson = androidWindow.WalletKitNative.apiGetNetworks();
      return JSON.parse(networksJson);
    } catch (err) {
      error("[AndroidAPIClientAdapter] Failed to get available networks:", err);
      return [];
    }
  }
  sendBoc(boc) {
    return __async$a(this, null, function* () {
      try {
        const networkJson = JSON.stringify(this.network);
        const result = this.androidBridge.apiSendBoc(networkJson, boc);
        return result;
      } catch (err) {
        error("[AndroidAPIClientAdapter] sendBoc failed:", err);
        throw err;
      }
    });
  }
  runGetMethod(address, method, stack, seqno) {
    return __async$a(this, null, function* () {
      try {
        const networkJson = JSON.stringify(this.network);
        const stackJson = stack ? JSON.stringify(stack) : null;
        const seqnoArg = seqno != null ? seqno : -1;
        const resultJson = this.androidBridge.apiRunGetMethod(networkJson, address, method, stackJson, seqnoArg);
        const result = JSON.parse(resultJson);
        return result;
      } catch (err) {
        error("[AndroidAPIClientAdapter] runGetMethod failed:", err);
        throw err;
      }
    });
  }
  // Methods not implemented - will throw if called
  // These are optional for mobile usage
  nftItemsByAddress(_request) {
    return __async$a(this, null, function* () {
      throw new Error("nftItemsByAddress is not implemented yet");
    });
  }
  nftItemsByOwner(_request) {
    return __async$a(this, null, function* () {
      throw new Error("nftItemsByOwner is not implemented yet");
    });
  }
  fetchEmulation(_messageBoc, _ignoreSignature) {
    return __async$a(this, null, function* () {
      throw new Error("fetchEmulation is not implemented yet");
    });
  }
  getAccountState(_address, _seqno) {
    return __async$a(this, null, function* () {
      throw new Error("getAccountState is not implemented yet");
    });
  }
  getBalance(address, seqno) {
    return __async$a(this, null, function* () {
      try {
        const networkJson = JSON.stringify(this.network);
        const seqnoArg = seqno != null ? seqno : -1;
        const result = this.androidBridge.apiGetBalance(networkJson, address, seqnoArg);
        return result;
      } catch (err) {
        error("[AndroidAPIClientAdapter] getBalance failed:", err);
        throw err;
      }
    });
  }
  getAccountTransactions(_request) {
    return __async$a(this, null, function* () {
      throw new Error("getAccountTransactions is not implemented yet");
    });
  }
  getTransactionsByHash(_request) {
    return __async$a(this, null, function* () {
      throw new Error("getTransactionsByHash is not implemented yet");
    });
  }
  getPendingTransactions(_request) {
    return __async$a(this, null, function* () {
      throw new Error("getPendingTransactions is not implemented yet");
    });
  }
  getTrace(_request) {
    return __async$a(this, null, function* () {
      throw new Error("getTrace is not implemented yet");
    });
  }
  getPendingTrace(_request) {
    return __async$a(this, null, function* () {
      throw new Error("getPendingTrace is not implemented yet");
    });
  }
  resolveDnsWallet(_domain) {
    return __async$a(this, null, function* () {
      throw new Error("resolveDnsWallet is not implemented yet");
    });
  }
  backResolveDnsWallet(_address) {
    return __async$a(this, null, function* () {
      throw new Error("backResolveDnsWallet is not implemented yet");
    });
  }
  jettonsByAddress(_request) {
    return __async$a(this, null, function* () {
      throw new Error("jettonsByAddress is not implemented yet");
    });
  }
  jettonsByOwnerAddress(_request) {
    return __async$a(this, null, function* () {
      throw new Error("jettonsByOwnerAddress is not implemented yet");
    });
  }
  getEvents(_request) {
    return __async$a(this, null, function* () {
      throw new Error("getEvents is not implemented yet");
    });
  }
}
var __async$9 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function initTonWalletKit(config, deps) {
  return __async$9(this, null, function* () {
    var _a, _b, _c;
    if (walletKit) {
      return { ok: true };
    }
    yield ensureWalletKitLoaded();
    const networksConfig = {};
    if ((config == null ? void 0 : config.networkConfigurations) && Array.isArray(config.networkConfigurations)) {
      for (const netConfig of config.networkConfigurations) {
        networksConfig[netConfig.network.chainId] = {
          apiClient: netConfig.apiClientConfiguration
        };
      }
    }
    if (AndroidAPIClientAdapter.isAvailable()) {
      const availableNetworks = AndroidAPIClientAdapter.getAvailableNetworks();
      for (const nativeNetwork of availableNetworks) {
        networksConfig[nativeNetwork.chainId] = {
          apiClient: new AndroidAPIClientAdapter(nativeNetwork)
        };
      }
    }
    const kitOptions = {
      networks: networksConfig
    };
    if (config == null ? void 0 : config.disableNetworkSend) {
      kitOptions.dev = { disableNetworkSend: true };
    }
    if (config == null ? void 0 : config.deviceInfo) {
      kitOptions.deviceInfo = config.deviceInfo;
    }
    if (config == null ? void 0 : config.walletManifest) {
      kitOptions.walletManifest = config.walletManifest;
    }
    if (config == null ? void 0 : config.bridgeUrl) {
      kitOptions.bridge = {
        bridgeUrl: config.bridgeUrl,
        jsBridgeTransport: (sessionId, message) => __async$9(null, null, function* () {
          var _a2;
          const typedMessage = message;
          let bridgeMessage = typedMessage;
          const DISCONNECT_EVENT = "disconnect";
          if (bridgeMessage.type === TONCONNECT_BRIDGE_RESPONSE) {
            const responseMsg = bridgeMessage;
            const result = responseMsg.result;
            if ((result == null ? void 0 : result.event) === DISCONNECT_EVENT && !responseMsg.messageId) {
              bridgeMessage = {
                type: TONCONNECT_BRIDGE_EVENT,
                source: responseMsg.source,
                event: {
                  event: "disconnect",
                  id: (_a2 = result.id) != null ? _a2 : 0,
                  payload: {}
                }
              };
            }
          }
          if (bridgeMessage.type === TONCONNECT_BRIDGE_RESPONSE && bridgeMessage.messageId) {
            const resolvers = getInternalBrowserResolverMap();
            const messageIdStr = String(bridgeMessage.messageId);
            const resolver = resolvers == null ? void 0 : resolvers.get(messageIdStr);
            if (resolver) {
              resolvers == null ? void 0 : resolvers.delete(messageIdStr);
              resolver.resolve(bridgeMessage);
            } else {
              warn("[walletkitBridge] No pending promise for messageId:", messageIdStr);
            }
          }
          if (bridgeMessage.type === TONCONNECT_BRIDGE_EVENT) {
            deps.postToNative({
              kind: "jsBridgeEvent",
              sessionId,
              event: bridgeMessage
            });
          }
          return Promise.resolve();
        })
      };
    }
    if (window.WalletKitNative) {
      kitOptions.storage = new deps.AndroidStorageAdapter();
    } else if (config == null ? void 0 : config.allowMemoryStorage) {
      info("[walletkitBridge] Using memory storage (sessions will not persist)");
      kitOptions.storage = {
        allowMemory: true
      };
    }
    if (hasAndroidSessionManager()) {
      kitOptions.sessionManager = new AndroidTONConnectSessionsManager();
    }
    if (!TonWalletKit$1) {
      throw new Error("TonWalletKit module not loaded");
    }
    setWalletKit(new TonWalletKit$1(kitOptions));
    if ((_a = walletKit) == null ? void 0 : _a.ensureInitialized) {
      yield (_c = (_b = walletKit) == null ? void 0 : _b.ensureInitialized) == null ? void 0 : _c.call(_b);
    }
    deps.emit("ready", {});
    deps.postToNative({ kind: "ready" });
    info("[walletkitBridge] WalletKit ready");
    return { ok: true };
  });
}
var __async$8 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function ensureReady() {
  return __async$8(this, null, function* () {
    var _a, _b;
    if (!walletKit) {
      throw new Error("WalletKit not initialized");
    }
    yield (_b = (_a = walletKit).ensureInitialized) == null ? void 0 : _b.call(_a);
    return walletKit;
  });
}
function getWalletOrThrow(kit2, walletId) {
  const wallet2 = kit2.getWallet(walletId);
  if (!wallet2) {
    throw new Error(`Wallet not found: ${walletId}`);
  }
  return wallet2;
}
function kit(method, ...args) {
  return __async$8(this, null, function* () {
    const instance = yield ensureReady();
    const fn = instance[method];
    if (typeof fn !== "function") {
      throw new Error(`Method '${method}' not found on WalletKit`);
    }
    return fn.apply(instance, args);
  });
}
function wallet(walletId, method, ...args) {
  return __async$8(this, null, function* () {
    const instance = yield ensureReady();
    const w = getWalletOrThrow(instance, walletId);
    const fn = w[method];
    if (typeof fn !== "function") {
      throw new Error(`Method '${method}' not found on Wallet`);
    }
    return fn.apply(w, args);
  });
}
function getKit() {
  return __async$8(this, null, function* () {
    return ensureReady();
  });
}
function getWallet(walletId) {
  return __async$8(this, null, function* () {
    const instance = yield ensureReady();
    return getWalletOrThrow(instance, walletId);
  });
}
function walletCall(method, args) {
  return __async$8(this, null, function* () {
    const instance = yield ensureReady();
    const w = getWalletOrThrow(instance, args.walletId);
    const fn = w[method];
    if (typeof fn !== "function") {
      throw new Error(`Method '${method}' not found on Wallet`);
    }
    return fn.call(w, args);
  });
}
function clientCall(method, args) {
  return __async$8(this, null, function* () {
    const instance = yield ensureReady();
    const w = getWalletOrThrow(instance, args.walletId);
    const apiClient = w.getClient();
    const fn = apiClient[method];
    if (typeof fn !== "function") {
      throw new Error(`Method '${method}' not found on ApiClient`);
    }
    return fn.call(apiClient, args);
  });
}
function bigIntReplacer(_key, value) {
  if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}
function resolveNativeBridge(scope) {
  const candidate = scope.WalletKitNative;
  if (candidate && typeof candidate.postMessage === "function") {
    return candidate.postMessage.bind(candidate);
  }
  const windowRef = typeof scope.window === "object" && scope.window ? scope.window : void 0;
  const windowCandidate = windowRef == null ? void 0 : windowRef.WalletKitNative;
  if (windowCandidate && typeof windowCandidate.postMessage === "function") {
    return windowCandidate.postMessage.bind(windowCandidate);
  }
  return null;
}
function resolveAndroidBridge(scope) {
  const candidate = scope.AndroidBridge;
  if (candidate && typeof candidate.postMessage === "function") {
    return candidate.postMessage.bind(candidate);
  }
  const windowRef = typeof scope.window === "object" && scope.window ? scope.window : void 0;
  const windowCandidate = windowRef == null ? void 0 : windowRef.AndroidBridge;
  if (windowCandidate && typeof windowCandidate.postMessage === "function") {
    return windowCandidate.postMessage.bind(windowCandidate);
  }
  return null;
}
function postToNative(payload) {
  if (payload === null || typeof payload !== "object" && typeof payload !== "function") {
    const diagnostic = {
      type: typeof payload,
      value: payload,
      stack: new Error("postToNative non-object payload").stack
    };
    error("[walletkitBridge] postToNative received non-object payload", diagnostic);
    throw new Error("Invalid payload - must be an object");
  }
  const json = JSON.stringify(payload, bigIntReplacer);
  const nativePostMessage = resolveNativeBridge(window);
  if (nativePostMessage) {
    nativePostMessage(json);
    return;
  }
  const androidPostMessage = resolveAndroidBridge(window);
  if (androidPostMessage) {
    androidPostMessage(json);
    return;
  }
  if (payload.kind === "event") {
    throw new Error("Native bridge not available - cannot deliver event");
  }
  warn("[walletkitBridge] postToNative: no native handler", payload);
}
function emitCallDiagnostic(id, method, stage, message) {
  postToNative({
    kind: "diagnostic-call",
    id,
    method,
    stage,
    timestamp: Date.now(),
    message
  });
}
var __async$7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
let apiRef;
function emit(type, data) {
  const event = { type, data };
  postToNative({ kind: "event", event });
}
function respond(id, result, error2) {
  postToNative({ kind: "response", id, result, error: error2 });
}
function setBridgeApi(api2) {
  apiRef = api2;
}
function invokeApiMethod(api2, method, params, context) {
  return __async$7(this, null, function* () {
    const fn = api2[method];
    if (typeof fn !== "function") {
      throw new Error(`Unknown method ${String(method)}`);
    }
    const value = yield fn.call(
      api2,
      params,
      context
    );
    return value;
  });
}
function handleCall(id, method, params) {
  return __async$7(this, null, function* () {
    if (!apiRef) {
      throw new Error("Bridge API not registered");
    }
    emitCallDiagnostic(id, method, "start");
    try {
      const context = { id, method };
      const value = yield invokeApiMethod(apiRef, method, params, context);
      emitCallDiagnostic(id, method, "success");
      respond(id, value);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      error(`[walletkitBridge] handleCall error for ${method}:`, message);
      emitCallDiagnostic(id, method, "error", message);
      respond(id, void 0, { message });
    }
  });
}
function registerNativeCallHandler() {
  window.__walletkitCall = (id, method, paramsJson) => {
    let params = void 0;
    if (paramsJson && paramsJson !== "null") {
      try {
        params = JSON.parse(paramsJson);
      } catch (e) {
        respond(id, void 0, { message: "Invalid params JSON" });
        return;
      }
    }
    void handleCall(id, method, params);
  };
}
const eventListeners = {
  onConnectListener: null,
  onTransactionListener: null,
  onSignDataListener: null,
  onDisconnectListener: null,
  onErrorListener: null
};
var __async$6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class AndroidStorageAdapter {
  constructor() {
    const androidWindow = window;
    if (!androidWindow.WalletKitNative) {
      throw new Error("WalletKitNative bridge not available");
    }
    this.androidBridge = androidWindow.WalletKitNative;
  }
  get(key) {
    return __async$6(this, null, function* () {
      try {
        const value = this.androidBridge.storageGet(key);
        if (!value) {
          return null;
        }
        return JSON.parse(value);
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to get key:", key, err);
        return null;
      }
    });
  }
  set(key, value) {
    return __async$6(this, null, function* () {
      try {
        const serialized = JSON.stringify(value);
        this.androidBridge.storageSet(key, serialized);
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to set key:", key, err);
      }
    });
  }
  remove(key) {
    return __async$6(this, null, function* () {
      try {
        this.androidBridge.storageRemove(key);
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to remove key:", key, err);
      }
    });
  }
  clear() {
    return __async$6(this, null, function* () {
      try {
        this.androidBridge.storageClear();
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to clear storage:", err);
      }
    });
  }
}
var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function init(config) {
  return __async$5(this, null, function* () {
    yield ensureWalletKitLoaded();
    return yield initTonWalletKit(config, {
      emit,
      postToNative,
      AndroidStorageAdapter
    });
  });
}
function setEventsListeners(args) {
  return __async$5(this, null, function* () {
    var _a;
    const kit2 = yield getKit();
    const callback = (_a = args == null ? void 0 : args.callback) != null ? _a : ((type, event) => {
      emit(type, event);
    });
    if (eventListeners.onConnectListener) {
      kit2.removeConnectRequestCallback();
    }
    eventListeners.onConnectListener = (event) => {
      callback("connectRequest", event);
    };
    kit2.onConnectRequest(eventListeners.onConnectListener);
    if (eventListeners.onTransactionListener) {
      kit2.removeTransactionRequestCallback();
    }
    eventListeners.onTransactionListener = (event) => {
      callback("transactionRequest", event);
    };
    kit2.onTransactionRequest(eventListeners.onTransactionListener);
    if (eventListeners.onSignDataListener) {
      kit2.removeSignDataRequestCallback();
    }
    eventListeners.onSignDataListener = (event) => {
      callback("signDataRequest", event);
    };
    kit2.onSignDataRequest(eventListeners.onSignDataListener);
    if (eventListeners.onDisconnectListener) {
      kit2.removeDisconnectCallback();
    }
    eventListeners.onDisconnectListener = (event) => {
      callback("disconnect", event);
    };
    kit2.onDisconnect(eventListeners.onDisconnectListener);
    if (eventListeners.onErrorListener) {
      kit2.removeErrorCallback();
    }
    eventListeners.onErrorListener = (event) => {
      callback("requestError", event);
    };
    kit2.onRequestError(eventListeners.onErrorListener);
    return { ok: true };
  });
}
function removeEventListeners() {
  return __async$5(this, null, function* () {
    const kit2 = yield getKit();
    if (eventListeners.onConnectListener) {
      kit2.removeConnectRequestCallback();
      eventListeners.onConnectListener = null;
    }
    if (eventListeners.onTransactionListener) {
      kit2.removeTransactionRequestCallback();
      eventListeners.onTransactionListener = null;
    }
    if (eventListeners.onSignDataListener) {
      kit2.removeSignDataRequestCallback();
      eventListeners.onSignDataListener = null;
    }
    if (eventListeners.onDisconnectListener) {
      kit2.removeDisconnectCallback();
      eventListeners.onDisconnectListener = null;
    }
    if (eventListeners.onErrorListener) {
      kit2.removeErrorCallback();
      eventListeners.onErrorListener = null;
    }
    return { ok: true };
  });
}
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function signWithCustomSigner(signerId, bytes) {
  return __async$4(this, null, function* () {
    var _a, _b;
    const result = yield (_b = (_a = window.WalletKitNative) == null ? void 0 : _a.signWithCustomSigner) == null ? void 0 : _b.call(_a, signerId, Array.from(bytes));
    return result;
  });
}
function mnemonicToKeyPair(args) {
  return __async$4(this, null, function* () {
    var _a;
    if (!MnemonicToKeyPair$1) {
      throw new Error("MnemonicToKeyPair module not loaded");
    }
    return MnemonicToKeyPair$1(args.mnemonic, (_a = args.mnemonicType) != null ? _a : "ton");
  });
}
function sign(args) {
  return __async$4(this, null, function* () {
    if (!DefaultSignature$1) {
      throw new Error("DefaultSignature module not loaded");
    }
    return DefaultSignature$1(Uint8Array.from(args.data), Uint8Array.from(args.secretKey));
  });
}
function createTonMnemonic() {
  return __async$4(this, null, function* () {
    if (!CreateTonMnemonic$1) {
      throw new Error("CreateTonMnemonic module not loaded");
    }
    return CreateTonMnemonic$1();
  });
}
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function getWallets() {
  return __async$3(this, null, function* () {
    const wallets = yield kit("getWallets");
    return wallets.map((w) => {
      var _a;
      return { walletId: (_a = w.getWalletId) == null ? void 0 : _a.call(w), wallet: w };
    });
  });
}
function getWalletById(args) {
  return __async$3(this, null, function* () {
    var _a;
    const w = yield kit("getWallet", args.walletId);
    if (!w) return null;
    return { walletId: (_a = w.getWalletId) == null ? void 0 : _a.call(w), wallet: w };
  });
}
function getWalletAddress(args) {
  return __async$3(this, null, function* () {
    return wallet(args.walletId, "getAddress");
  });
}
function removeWallet(args) {
  return __async$3(this, null, function* () {
    return kit("removeWallet", args.walletId);
  });
}
function getBalance(args) {
  return __async$3(this, null, function* () {
    return wallet(args.walletId, "getBalance");
  });
}
const signerStore = /* @__PURE__ */ new Map();
const adapterStore = /* @__PURE__ */ new Map();
function getSigner(args) {
  return __async$3(this, null, function* () {
    if (args.isCustom && args.publicKey) {
      return {
        sign: (bytes) => __async$3(null, null, function* () {
          return yield signWithCustomSigner(args.signerId, Uint8Array.from(bytes));
        }),
        publicKey: args.publicKey
      };
    }
    const storedSigner = signerStore.get(args.signerId);
    if (!storedSigner) {
      throw new Error(`Signer not found: ${args.signerId}`);
    }
    return storedSigner;
  });
}
function createSigner(args) {
  return __async$3(this, null, function* () {
    var _a;
    if (!Signer$1) {
      throw new Error("Signer module not loaded");
    }
    if (!((_a = args.mnemonic) == null ? void 0 : _a.length) && !args.secretKey) {
      throw new Error("Either mnemonic or secretKey is required");
    }
    const signer = args.mnemonic && args.mnemonic.length > 0 ? yield Signer$1.fromMnemonic(args.mnemonic, { type: args.mnemonicType || "ton" }) : yield Signer$1.fromPrivateKey(args.secretKey);
    const tempId = `signer_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
    signerStore.set(tempId, signer);
    return { _tempId: tempId, signer };
  });
}
function createAdapter(args) {
  return __async$3(this, null, function* () {
    const instance = yield getKit();
    const signer = yield getSigner(args);
    const AdapterClass = args.walletVersion === "v5r1" ? WalletV5R1Adapter$1 : WalletV4R2Adapter$1;
    if (!AdapterClass) {
      throw new Error(`WalletAdapter module not loaded`);
    }
    const network = args.network;
    const adapter = yield AdapterClass.create(signer, {
      client: instance.getApiClient(network),
      network,
      workchain: args.workchain,
      walletId: args.walletId
    });
    const tempId = `adapter_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
    adapterStore.set(tempId, adapter);
    return { _tempId: tempId, adapter };
  });
}
function getAdapterAddress(args) {
  return __async$3(this, null, function* () {
    const adapter = adapterStore.get(args.adapterId);
    if (!adapter) {
      throw new Error(`Adapter not found: ${args.adapterId}`);
    }
    return adapter.getAddress();
  });
}
function addWallet(args) {
  return __async$3(this, null, function* () {
    var _a;
    const instance = yield getKit();
    const adapter = adapterStore.get(args.adapterId);
    if (!adapter) {
      throw new Error(`Adapter not found: ${args.adapterId}`);
    }
    const w = yield instance.addWallet(adapter);
    adapterStore.delete(args.adapterId);
    if (!w) return null;
    return { walletId: (_a = w.getWalletId) == null ? void 0 : _a.call(w), wallet: w };
  });
}
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const createTransferTonTransaction = (args) => walletCall("createTransferTonTransaction", args);
const createTransferMultiTonTransaction = (args) => walletCall("createTransferMultiTonTransaction", args);
const getTransactionPreview = (args) => walletCall("getTransactionPreview", args);
const sendTransaction = (args) => walletCall("sendTransaction", args);
const getRecentTransactions = (args) => clientCall("getAccountTransactions", args);
function handleNewTransaction(args) {
  return __async$2(this, null, function* () {
    const k2 = yield getKit();
    const w = yield getWallet(args[0]);
    return k2.handleNewTransaction(w, args[1]);
  });
}
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function approveConnectRequest(args) {
  return __async$1(this, null, function* () {
    return kit("approveConnectRequest", ...args);
  });
}
function rejectConnectRequest(args) {
  return __async$1(this, null, function* () {
    return kit("rejectConnectRequest", ...args);
  });
}
function approveTransactionRequest(args) {
  return __async$1(this, null, function* () {
    return kit("approveTransactionRequest", ...args);
  });
}
function rejectTransactionRequest(args) {
  return __async$1(this, null, function* () {
    return kit("rejectTransactionRequest", ...args);
  });
}
function approveSignDataRequest(args) {
  return __async$1(this, null, function* () {
    return kit("approveSignDataRequest", ...args);
  });
}
function rejectSignDataRequest(args) {
  return __async$1(this, null, function* () {
    return kit("rejectSignDataRequest", ...args);
  });
}
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function handleTonConnectUrl(args) {
  return __async(this, null, function* () {
    return kit("handleTonConnectUrl", args);
  });
}
function listSessions() {
  return __async(this, null, function* () {
    return kit("listSessions");
  });
}
function disconnectSession(args) {
  return __async(this, null, function* () {
    return kit("disconnect", args);
  });
}
function processInternalBrowserRequest(args) {
  return __async(this, null, function* () {
    const messageInfo = args[0];
    const messageId = messageInfo == null ? void 0 : messageInfo.messageId;
    if (!messageId) {
      throw new Error("processInternalBrowserRequest: messageId is required in messageInfo");
    }
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        const resolverMap2 = ensureInternalBrowserResolverMap();
        resolverMap2.delete(messageId);
        reject(new Error(`Request timeout: ${messageId}`));
      }, 6e4);
      const resolverMap = ensureInternalBrowserResolverMap();
      resolverMap.set(messageId, {
        resolve: (response) => {
          var _a;
          clearTimeout(timeoutId);
          if (response && typeof response === "object" && "payload" in response) {
            resolve((_a = response.payload) != null ? _a : response);
          } else {
            resolve(response);
          }
        },
        reject: (error2) => {
          clearTimeout(timeoutId);
          reject(error2 instanceof Error ? error2 : new Error(String(error2)));
        }
      });
      kit("processInjectedBridgeRequest", ...args).catch((err) => {
        clearTimeout(timeoutId);
        resolverMap.delete(messageId);
        reject(err);
      });
    });
  });
}
const getNfts = (args) => walletCall("getNfts", args);
const getNft = (args) => walletCall("getNft", args);
const createTransferNftTransaction = (args) => walletCall("createTransferNftTransaction", args);
const createTransferNftRawTransaction = (args) => walletCall("createTransferNftRawTransaction", args);
const getJettons = (args) => walletCall("getJettons", args);
const createTransferJettonTransaction = (args) => walletCall("createTransferJettonTransaction", args);
const getJettonBalance = (args) => walletCall("getJettonBalance", args);
const getJettonWalletAddress = (args) => walletCall("getJettonWalletAddress", args);
function emitBrowserPageStarted(args) {
  emit("browserPageStarted", args);
  return { success: true };
}
function emitBrowserPageFinished(args) {
  emit("browserPageFinished", args);
  return { success: true };
}
function emitBrowserError(args) {
  emit("browserError", args);
  return { success: true };
}
function emitBrowserBridgeRequest(args) {
  emit("browserBridgeRequest", args);
  return { success: true };
}
const api = {
  // Initialization
  init,
  setEventsListeners,
  removeEventListeners,
  // Cryptography
  mnemonicToKeyPair,
  sign,
  createTonMnemonic,
  // Wallets
  createSigner,
  createAdapter,
  getAdapterAddress,
  addWallet,
  getWallets,
  getWallet: getWalletById,
  getWalletAddress,
  removeWallet,
  getBalance,
  // Transactions
  getRecentTransactions,
  createTransferTonTransaction,
  createTransferMultiTonTransaction,
  getTransactionPreview,
  handleNewTransaction,
  sendTransaction,
  // Requests
  approveConnectRequest,
  rejectConnectRequest,
  approveTransactionRequest,
  rejectTransactionRequest,
  approveSignDataRequest,
  rejectSignDataRequest,
  // TonConnect & sessions
  handleTonConnectUrl,
  listSessions,
  disconnectSession,
  processInternalBrowserRequest,
  // NFTs
  getNfts,
  getNft,
  createTransferNftTransaction,
  createTransferNftRawTransaction,
  // Jettons
  getJettons,
  createTransferJettonTransaction,
  getJettonBalance,
  getJettonWalletAddress,
  // Browser events
  emitBrowserPageStarted,
  emitBrowserPageFinished,
  emitBrowserError,
  emitBrowserBridgeRequest
};
setBridgeApi(api);
registerNativeCallHandler();
window.walletkitBridge = api;
//# sourceMappingURL=walletkit-android-bridge.mjs.map

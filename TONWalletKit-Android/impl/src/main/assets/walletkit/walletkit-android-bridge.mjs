function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      var isInstance = false;
      try {
        isInstance = this instanceof a3;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a2, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a2;
}
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end2) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end2; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer2[offset + i];
    i += d;
    e = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m2 = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m2, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt2 / c;
      } else {
        value += rt2 * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m2 = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m2 = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
    }
    e = e << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s2 * 128;
  };
  return ieee754;
}
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base64 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf2 = createBuffer(length);
      const actual = buf2.write(string, encoding);
      if (actual !== length) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf2[i] = array[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer2(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x2 = a2.length;
      let y2 = b2.length;
      for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
        if (a2[i] !== b2[i]) {
          x2 = a2[i];
          y2 = b2[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2)) buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end2) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end2 === void 0 || end2 > this.length) {
        end2 = this.length;
      }
      if (end2 <= 0) {
        return "";
      }
      end2 >>>= 0;
      start >>>= 0;
      if (end2 <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end2);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end2);
          case "ascii":
            return asciiSlice(this, start, end2);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end2);
          case "base64":
            return base64Slice(this, start, end2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m2) {
      const i = b2[n];
      b2[n] = b2[m2];
      b2[m2] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end2, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end2 === void 0) {
        end2 = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end2) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end2) {
        return 1;
      }
      start >>>= 0;
      end2 >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end2 - start;
      const len = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end2);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y2 = targetCopy[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string, offset, length) {
      return blitBuffer(utf8ToBytes2(string, buf2.length - offset), buf2, offset, length);
    }
    function asciiWrite(buf2, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf2, offset, length);
    }
    function base64Write(buf2, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf2, offset, length);
    }
    function ucs2Write(buf2, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf2.length - offset), buf2, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end2) {
      if (start === 0 && end2 === buf2.length) {
        return base64.fromByteArray(buf2);
      } else {
        return base64.fromByteArray(buf2.slice(start, end2));
      }
    }
    function utf8Slice(buf2, start, end2) {
      end2 = Math.min(buf2.length, end2);
      const res = [];
      let i = start;
      while (i < end2) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end2) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end2) {
      let ret = "";
      end2 = Math.min(buf2.length, end2);
      for (let i = start; i < end2; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end2) {
      let ret = "";
      end2 = Math.min(buf2.length, end2);
      for (let i = start; i < end2; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end2) {
      const len = buf2.length;
      if (!start || start < 0) start = 0;
      if (!end2 || end2 < 0 || end2 > len) end2 = len;
      let out = "";
      for (let i = start; i < end2; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end2) {
      const bytes = buf2.slice(start, end2);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end2) {
      const len = this.length;
      start = ~~start;
      end2 = end2 === void 0 ? len : ~~end2;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end2 < 0) {
        end2 += len;
        if (end2 < 0) end2 = 0;
      } else if (end2 > len) {
        end2 = len;
      }
      if (end2 < start) end2 = start;
      const newBuf = this.subarray(start, end2);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo2) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo2);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf2[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset++] = lo2;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset + 6] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset + 5] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset + 4] = lo2;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4);
      }
      ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8);
      }
      ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end2 && end2 !== 0) end2 = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end2 > 0 && end2 < start) end2 = start;
      if (end2 === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
      if (end2 > this.length) end2 = this.length;
      if (target.length - targetStart < end2 - start) {
        end2 = target.length - targetStart + start;
      }
      const len = end2 - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end2);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end2),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end2 = this.length;
        } else if (typeof end2 === "string") {
          encoding = end2;
          end2 = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end2) {
        throw new RangeError("Out of range index");
      }
      if (end2 <= start) {
        return this;
      }
      start = start >>> 0;
      end2 = end2 === void 0 ? this.length : end2 >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end2; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end2 - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    const errors2 = {};
    function E2(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo2;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo2 = c % 256;
        byteArray.push(lo2);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i] + alphabet[j2];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var bufferExports = requireBuffer();
var LogLevel$1 = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["OFF"] = 0] = "OFF";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 3] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 4] = "DEBUG";
  return LogLevel2;
})(LogLevel$1 || {});
const logWindow = window;
const consoleRef = globalThis.console;
function getCurrentLogLevel() {
  var _a2;
  const levelStr = logWindow.__WALLETKIT_LOG_LEVEL__ || "OFF";
  return (_a2 = LogLevel$1[levelStr]) != null ? _a2 : 0;
}
const log$l = (...args) => {
  var _a2;
  if (getCurrentLogLevel() >= 4) {
    (_a2 = consoleRef == null ? void 0 : consoleRef.log) == null ? void 0 : _a2.call(consoleRef, "[WalletKit]", ...args);
  }
};
const warn = (...args) => {
  var _a2;
  if (getCurrentLogLevel() >= 2) {
    (_a2 = consoleRef == null ? void 0 : consoleRef.warn) == null ? void 0 : _a2.call(consoleRef, "[WalletKit]", ...args);
  }
};
const error = (...args) => {
  var _a2;
  if (getCurrentLogLevel() >= 1) {
    (_a2 = consoleRef == null ? void 0 : consoleRef.error) == null ? void 0 : _a2.call(consoleRef, "[WalletKit]", ...args);
  }
};
function ensureBuffer(scope) {
  if (typeof scope.Buffer === "undefined") {
    Object.defineProperty(scope, "Buffer", {
      value: bufferExports.Buffer,
      writable: true,
      configurable: true
    });
    log$l("[walletkitBridge]  Buffer polyfill injected");
  }
}
function setupNativeBridge() {
  const scope = window;
  ensureBuffer(scope);
  const bridge = scope.WalletKitNative;
  if (!bridge) {
    warn("[walletkitBridge] WalletKitNative bridge not found, storage will not be available");
    return;
  }
  if (typeof bridge.storageGet !== "function" || typeof bridge.storageSet !== "function" || typeof bridge.storageRemove !== "function" || typeof bridge.storageClear !== "function") {
    warn("[walletkitBridge] Bridge is missing storage methods, WalletKitNativeStorage will not be available");
    return;
  }
  try {
    const nativeStorage = {
      getItem(key) {
        try {
          const value = bridge.storageGet(key);
          return value === void 0 || value === null ? null : String(value);
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.getItem:", err);
          return null;
        }
      },
      setItem(key, value) {
        try {
          bridge.storageSet(key, String(value));
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.setItem:", err);
        }
      },
      removeItem(key) {
        try {
          bridge.storageRemove(key);
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.removeItem:", err);
        }
      },
      clear() {
        try {
          bridge.storageClear();
        } catch (err) {
          error("[walletkitBridge] Error in WalletKitNativeStorage.clear:", err);
        }
      }
    };
    if (typeof scope.WalletKitNativeStorage === "undefined") {
      Object.defineProperty(scope, "WalletKitNativeStorage", {
        value: nativeStorage,
        writable: false,
        configurable: true
      });
      log$l("[walletkitBridge]  WalletKitNativeStorage exposed for secure native storage");
    } else {
      warn("[walletkitBridge] WalletKitNativeStorage already present, not overriding");
    }
  } catch (err) {
    error("[walletkitBridge] Failed to expose WalletKitNativeStorage:", err);
  }
}
setupNativeBridge();
var __async$e = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
const walletKitModulePromise = Promise.resolve().then(() => index);
let TonWalletKit$1 = null;
let CreateTonMnemonic$1 = null;
let MnemonicToKeyPair$1 = null;
let Signer$1 = null;
let DefaultSignature$1 = null;
let WalletV4R2Adapter$1 = null;
let WalletV5R1Adapter$1 = null;
function ensureWalletKitLoaded() {
  return __async$e(this, null, function* () {
    var _a2, _b, _c, _d, _e2, _f;
    if (TonWalletKit$1 && Signer$1 && MnemonicToKeyPair$1 && DefaultSignature$1 && WalletV4R2Adapter$1 && WalletV5R1Adapter$1) {
      return;
    }
    if (!TonWalletKit$1 || !Signer$1 || !MnemonicToKeyPair$1 || !DefaultSignature$1 || !WalletV4R2Adapter$1 || !WalletV5R1Adapter$1) {
      const module = yield walletKitModulePromise;
      TonWalletKit$1 = module.TonWalletKit;
      CreateTonMnemonic$1 = (_a2 = module.CreateTonMnemonic) != null ? _a2 : CreateTonMnemonic$1;
      MnemonicToKeyPair$1 = (_b = module.MnemonicToKeyPair) != null ? _b : MnemonicToKeyPair$1;
      Signer$1 = (_c = module.Signer) != null ? _c : Signer$1;
      DefaultSignature$1 = (_d = module.DefaultSignature) != null ? _d : DefaultSignature$1;
      WalletV4R2Adapter$1 = (_e2 = module.WalletV4R2Adapter) != null ? _e2 : WalletV4R2Adapter$1;
      WalletV5R1Adapter$1 = (_f = module.WalletV5R1Adapter) != null ? _f : WalletV5R1Adapter$1;
    }
  });
}
var naclUtil$1 = { exports: {} };
var naclUtil = naclUtil$1.exports;
var hasRequiredNaclUtil;
function requireNaclUtil() {
  if (hasRequiredNaclUtil) return naclUtil$1.exports;
  hasRequiredNaclUtil = 1;
  (function(module) {
    (function(root, f2) {
      if (module.exports) module.exports = f2();
      else if (root.nacl) root.nacl.util = f2();
      else {
        root.nacl = {};
        root.nacl.util = f2();
      }
    })(naclUtil, function() {
      var util2 = {};
      function validateBase64(s2) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
          throw new TypeError("invalid encoding");
        }
      }
      util2.decodeUTF8 = function(s2) {
        if (typeof s2 !== "string") throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s2)), b2 = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++) b2[i] = d.charCodeAt(i);
        return b2;
      };
      util2.encodeUTF8 = function(arr) {
        var i, s2 = [];
        for (i = 0; i < arr.length; i++) s2.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s2.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util2.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
          };
        } else {
          util2.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
          };
        }
      } else {
        util2.encodeBase64 = function(arr) {
          var i, s2 = [], len = arr.length;
          for (i = 0; i < len; i++) s2.push(String.fromCharCode(arr[i]));
          return btoa(s2.join(""));
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          var i, d = atob(s2), b2 = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++) b2[i] = d.charCodeAt(i);
          return b2;
        };
      }
      return util2;
    });
  })(naclUtil$1);
  return naclUtil$1.exports;
}
var naclUtilExports = requireNaclUtil();
const nacl$1 = /* @__PURE__ */ getDefaultExportFromCjs(naclUtilExports);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl2) {
      var gf = function(init2) {
        var i, r = new Float64Array(16);
        if (init2) for (i = 0; i < init2.length; i++) r[i] = init2[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i, h2, l) {
        x2[i] = h2 >> 24 & 255;
        x2[i + 1] = h2 >> 16 & 255;
        x2[i + 2] = h2 >> 8 & 255;
        x2[i + 3] = h2 & 255;
        x2[i + 4] = l >> 24 & 255;
        x2[i + 5] = l >> 16 & 255;
        x2[i + 6] = l >> 8 & 255;
        x2[i + 7] = l & 255;
      }
      function vn2(x2, xi, y2, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x2[xi + i] ^ y2[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y2, yi) {
        return vn2(x2, xi, y2, yi, 16);
      }
      function crypto_verify_32(x2, xi, y2, yi) {
        return vn2(x2, xi, y2, yi, 32);
      }
      function core_salsa20(o4, p2, k2, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x1 >>> 0 & 255;
        o4[5] = x1 >>> 8 & 255;
        o4[6] = x1 >>> 16 & 255;
        o4[7] = x1 >>> 24 & 255;
        o4[8] = x2 >>> 0 & 255;
        o4[9] = x2 >>> 8 & 255;
        o4[10] = x2 >>> 16 & 255;
        o4[11] = x2 >>> 24 & 255;
        o4[12] = x3 >>> 0 & 255;
        o4[13] = x3 >>> 8 & 255;
        o4[14] = x3 >>> 16 & 255;
        o4[15] = x3 >>> 24 & 255;
        o4[16] = x4 >>> 0 & 255;
        o4[17] = x4 >>> 8 & 255;
        o4[18] = x4 >>> 16 & 255;
        o4[19] = x4 >>> 24 & 255;
        o4[20] = x5 >>> 0 & 255;
        o4[21] = x5 >>> 8 & 255;
        o4[22] = x5 >>> 16 & 255;
        o4[23] = x5 >>> 24 & 255;
        o4[24] = x6 >>> 0 & 255;
        o4[25] = x6 >>> 8 & 255;
        o4[26] = x6 >>> 16 & 255;
        o4[27] = x6 >>> 24 & 255;
        o4[28] = x7 >>> 0 & 255;
        o4[29] = x7 >>> 8 & 255;
        o4[30] = x7 >>> 16 & 255;
        o4[31] = x7 >>> 24 & 255;
        o4[32] = x8 >>> 0 & 255;
        o4[33] = x8 >>> 8 & 255;
        o4[34] = x8 >>> 16 & 255;
        o4[35] = x8 >>> 24 & 255;
        o4[36] = x9 >>> 0 & 255;
        o4[37] = x9 >>> 8 & 255;
        o4[38] = x9 >>> 16 & 255;
        o4[39] = x9 >>> 24 & 255;
        o4[40] = x10 >>> 0 & 255;
        o4[41] = x10 >>> 8 & 255;
        o4[42] = x10 >>> 16 & 255;
        o4[43] = x10 >>> 24 & 255;
        o4[44] = x11 >>> 0 & 255;
        o4[45] = x11 >>> 8 & 255;
        o4[46] = x11 >>> 16 & 255;
        o4[47] = x11 >>> 24 & 255;
        o4[48] = x12 >>> 0 & 255;
        o4[49] = x12 >>> 8 & 255;
        o4[50] = x12 >>> 16 & 255;
        o4[51] = x12 >>> 24 & 255;
        o4[52] = x13 >>> 0 & 255;
        o4[53] = x13 >>> 8 & 255;
        o4[54] = x13 >>> 16 & 255;
        o4[55] = x13 >>> 24 & 255;
        o4[56] = x14 >>> 0 & 255;
        o4[57] = x14 >>> 8 & 255;
        o4[58] = x14 >>> 16 & 255;
        o4[59] = x14 >>> 24 & 255;
        o4[60] = x15 >>> 0 & 255;
        o4[61] = x15 >>> 8 & 255;
        o4[62] = x15 >>> 16 & 255;
        o4[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o4, p2, k2, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x5 >>> 0 & 255;
        o4[5] = x5 >>> 8 & 255;
        o4[6] = x5 >>> 16 & 255;
        o4[7] = x5 >>> 24 & 255;
        o4[8] = x10 >>> 0 & 255;
        o4[9] = x10 >>> 8 & 255;
        o4[10] = x10 >>> 16 & 255;
        o4[11] = x10 >>> 24 & 255;
        o4[12] = x15 >>> 0 & 255;
        o4[13] = x15 >>> 8 & 255;
        o4[14] = x15 >>> 16 & 255;
        o4[15] = x15 >>> 24 & 255;
        o4[16] = x6 >>> 0 & 255;
        o4[17] = x6 >>> 8 & 255;
        o4[18] = x6 >>> 16 & 255;
        o4[19] = x6 >>> 24 & 255;
        o4[20] = x7 >>> 0 & 255;
        o4[21] = x7 >>> 8 & 255;
        o4[22] = x7 >>> 16 & 255;
        o4[23] = x7 >>> 24 & 255;
        o4[24] = x8 >>> 0 & 255;
        o4[25] = x8 >>> 8 & 255;
        o4[26] = x8 >>> 16 & 255;
        o4[27] = x8 >>> 24 & 255;
        o4[28] = x9 >>> 0 & 255;
        o4[29] = x9 >>> 8 & 255;
        o4[30] = x9 >>> 16 & 255;
        o4[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k2, c) {
        core_salsa20(out, inp, k2, c);
      }
      function crypto_core_hsalsa20(out, inp, k2, c) {
        core_hsalsa20(out, inp, k2, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m2, mpos, b2, n, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z2[i] = 0;
        for (i = 0; i < 8; i++) z2[i] = n[i];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m2[mpos + i] ^ x2[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z2[i] & 255) | 0;
            z2[i] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < b2; i++) c[cpos + i] = m2[mpos + i] ^ x2[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b2, n, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z2[i] = 0;
        for (i = 0; i < 8; i++) z2[i] = n[i];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x2[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z2[i] & 255) | 0;
            z2[i] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < b2; i++) c[cpos + i] = x2[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k2, sigma);
        var sn2 = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn2[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn2, s2);
      }
      function crypto_stream_xor(c, cpos, m2, mpos, d, n, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k2, sigma);
        var sn2 = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn2[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m2, mpos, d, sn2, s2);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c, mask, f2, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g2[0] = this.h[0] + 5;
        c = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g2[i] = this.h[i] + c;
          c = g2[i] >>> 13;
          g2[i] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g2[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g2[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i = 1; i < 8; i++) {
          f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
          this.h[i] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m2[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m2[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n, k2) {
        var s2 = new poly1305(k2);
        s2.update(m2, mpos, n);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n, k2) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m2, mpos, n, k2);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c, m2, d, n, k2) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m2, 0, d, n, k2);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c, d, n, k2) {
        var i;
        var x2 = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x2, 0, 32, n, k2);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x2) !== 0) return -1;
        crypto_stream_xor(m2, 0, c, 0, d, n, k2);
        for (i = 0; i < 32; i++) m2[i] = 0;
        return 0;
      }
      function set25519(r, a2) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a2[i] | 0;
      }
      function car25519(o4) {
        var i, v2, c = 1;
        for (i = 0; i < 16; i++) {
          v2 = o4[i] + c + 65535;
          c = Math.floor(v2 / 65536);
          o4[i] = v2 - c * 65536;
        }
        o4[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p2, q, b2) {
        var t, c = ~(b2 - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p2[i] ^ q[i]);
          p2[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o4, n) {
        var i, j2, b2;
        var m2 = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j2 = 0; j2 < 2; j2++) {
          m2[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m2[i] = t[i] - 65535 - (m2[i - 1] >> 16 & 1);
            m2[i - 1] &= 65535;
          }
          m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
          b2 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t, m2, 1 - b2);
        }
        for (i = 0; i < 16; i++) {
          o4[2 * i] = t[i] & 255;
          o4[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a2, b2) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a2);
        pack25519(d, b2);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a2) {
        var d = new Uint8Array(32);
        pack25519(d, a2);
        return d[0] & 1;
      }
      function unpack25519(o4, n) {
        var i;
        for (i = 0; i < 16; i++) o4[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o4[15] &= 32767;
      }
      function A2(o4, a2, b2) {
        for (var i = 0; i < 16; i++) o4[i] = a2[i] + b2[i];
      }
      function Z2(o4, a2, b2) {
        for (var i = 0; i < 16; i++) o4[i] = a2[i] - b2[i];
      }
      function M2(o4, a2, b2) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v2 = a2[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b22;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a2[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b22;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a2[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b22;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a2[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b22;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a2[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b22;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a2[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b22;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a2[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b22;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a2[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b22;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a2[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b22;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a2[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b22;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a2[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b22;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a2[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b22;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a2[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b22;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a2[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b22;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a2[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b22;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a2[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b22;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o4[0] = t0;
        o4[1] = t1;
        o4[2] = t2;
        o4[3] = t3;
        o4[4] = t4;
        o4[5] = t5;
        o4[6] = t6;
        o4[7] = t7;
        o4[8] = t8;
        o4[9] = t9;
        o4[10] = t10;
        o4[11] = t11;
        o4[12] = t12;
        o4[13] = t13;
        o4[14] = t14;
        o4[15] = t15;
      }
      function S2(o4, a2) {
        M2(o4, a2, a2);
      }
      function inv25519(o4, i) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 2 && a2 !== 4) M2(c, c, i);
        }
        for (a2 = 0; a2 < 16; a2++) o4[a2] = c[a2];
      }
      function pow2523(o4, i) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 1) M2(c, c, i);
        }
        for (a2 = 0; a2 < 16; a2++) o4[a2] = c[a2];
      }
      function crypto_scalarmult(q, n, p2) {
        var z2 = new Uint8Array(32);
        var x2 = new Float64Array(80), r, i;
        var a2 = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f2 = gf();
        for (i = 0; i < 31; i++) z2[i] = n[i];
        z2[31] = n[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x2, p2);
        for (i = 0; i < 16; i++) {
          b2[i] = x2[i];
          d[i] = a2[i] = c[i] = 0;
        }
        a2[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z2[i >>> 3] >>> (i & 7) & 1;
          sel25519(a2, b2, r);
          sel25519(c, d, r);
          A2(e, a2, c);
          Z2(a2, a2, c);
          A2(c, b2, d);
          Z2(b2, b2, d);
          S2(d, e);
          S2(f2, a2);
          M2(a2, c, a2);
          M2(c, b2, e);
          A2(e, a2, c);
          Z2(a2, a2, c);
          S2(b2, a2);
          Z2(c, d, f2);
          M2(a2, c, _121665);
          A2(a2, a2, d);
          M2(c, c, a2);
          M2(a2, d, f2);
          M2(d, b2, x2);
          S2(b2, e);
          sel25519(a2, b2, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x2[i + 16] = a2[i];
          x2[i + 32] = c[i];
          x2[i + 48] = b2[i];
          x2[i + 64] = d[i];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k2, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k2, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m2, d, n, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_afternm(c, m2, d, n, k2);
      }
      function crypto_box_open(m2, c, d, n, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_open_afternm(m2, c, d, n, k2);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m2, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j2, h2, l, a2, b2, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j2 = 8 * i + pos;
            wh[i] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
            wl[i] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = K2[i * 2];
            l = K2[i * 2 + 1];
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i % 16];
            l = wl[i % 16];
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a2 & 65535 | b2 << 16;
            h2 = th;
            l = tl;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a2 & 65535 | b2 << 16;
            h2 = bh3;
            l = bl3;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a2 & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j2 = 0; j2 < 16; j2++) {
                h2 = wh[j2];
                l = wl[j2];
                a2 = l & 65535;
                b2 = l >>> 16;
                c = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j2 + 9) % 16];
                l = wl[(j2 + 9) % 16];
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j2 + 1) % 16];
                tl = wl[(j2 + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j2 + 14) % 16];
                tl = wl[(j2 + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                b2 += a2 >>> 16;
                c += b2 >>> 16;
                d += c >>> 16;
                wh[j2] = c & 65535 | d << 16;
                wl[j2] = a2 & 65535 | b2 << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a2 & 65535 | b2 << 16;
          h2 = ah1;
          l = al1;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a2 & 65535 | b2 << 16;
          h2 = ah2;
          l = al2;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a2 & 65535 | b2 << 16;
          h2 = ah3;
          l = al3;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a2 & 65535 | b2 << 16;
          h2 = ah4;
          l = al4;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a2 & 65535 | b2 << 16;
          h2 = ah5;
          l = al5;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a2 & 65535 | b2 << 16;
          h2 = ah6;
          l = al6;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a2 & 65535 | b2 << 16;
          h2 = ah7;
          l = al7;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a2 & 65535 | b2 << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m2, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m2, n);
        n %= 128;
        for (i = 0; i < n; i++) x2[i] = m2[b2 - n + i];
        x2[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x2[n - 9] = 0;
        ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh, hl, x2, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add2(p2, q) {
        var a2 = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z2(a2, p2[1], p2[0]);
        Z2(t, q[1], q[0]);
        M2(a2, a2, t);
        A2(b2, p2[0], p2[1]);
        A2(t, q[0], q[1]);
        M2(b2, b2, t);
        M2(c, p2[3], q[3]);
        M2(c, c, D22);
        M2(d, p2[2], q[2]);
        A2(d, d, d);
        Z2(e, b2, a2);
        Z2(f2, d, c);
        A2(g2, d, c);
        A2(h2, b2, a2);
        M2(p2[0], e, f2);
        M2(p2[1], h2, g2);
        M2(p2[2], g2, f2);
        M2(p2[3], e, h2);
      }
      function cswap(p2, q, b2) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p2[i], q[i], b2);
        }
      }
      function pack(r, p2) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p2[2]);
        M2(tx, p2[0], zi);
        M2(ty, p2[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q, s2) {
        var b2, i;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i = 255; i >= 0; --i) {
          b2 = s2[i / 8 | 0] >> (i & 7) & 1;
          cswap(p2, q, b2);
          add2(q, p2);
          add2(p2, p2);
          cswap(p2, q, b2);
        }
      }
      function scalarbase(p2, s2) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X2);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X2, Y);
        scalarmult(p2, q, s2);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p2, d);
        pack(pk, p2);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x2) {
        var carry, i, j2, k2;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j2 = i - 32, k2 = i - 12; j2 < k2; ++j2) {
            x2[j2] += carry - 16 * x2[i] * L[j2 - (i - 32)];
            carry = Math.floor((x2[j2] + 128) / 256);
            x2[j2] -= carry * 256;
          }
          x2[j2] += carry;
          x2[i] = 0;
        }
        carry = 0;
        for (j2 = 0; j2 < 32; j2++) {
          x2[j2] += carry - (x2[31] >> 4) * L[j2];
          carry = x2[j2] >> 8;
          x2[j2] &= 255;
        }
        for (j2 = 0; j2 < 32; j2++) x2[j2] -= carry * L[j2];
        for (i = 0; i < 32; i++) {
          x2[i + 1] += x2[i] >> 8;
          r[i] = x2[i] & 255;
        }
      }
      function reduce(r) {
        var x2 = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x2[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x2);
      }
      function crypto_sign(sm, m2, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
        var i, j2, x2 = new Float64Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m2[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p2, r);
        pack(sm, p2);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i = 0; i < 64; i++) x2[i] = 0;
        for (i = 0; i < 32; i++) x2[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j2 = 0; j2 < 32; j2++) {
            x2[i + j2] += h2[i] * d[j2];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r, p2) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p2);
        S2(num, r[1]);
        M2(den, num, D2);
        Z2(num, num, r[2]);
        A2(den, r[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r[0], t, den);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r[0], r[0], I2);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p2[31] >> 7) Z2(r[0], gf0, r[0]);
        M2(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m2[i] = sm[i];
        for (i = 0; i < 32; i++) m2[i + 32] = pk[i];
        crypto_hash(h2, m2, n);
        reduce(h2);
        scalarmult(p2, q, h2);
        scalarbase(q, sm.subarray(32));
        add2(p2, q);
        pack(t, p2);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m2[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m2[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D2,
        L,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z: Z2,
        pow2523,
        add: add2,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k2, n) {
        if (k2.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b2 = new Uint8Array(n);
        randombytes(b2, n);
        return b2;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m2.length);
        for (var i = 0; i < msg.length; i++) m2[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m2, m2.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m2, c, c.length, nonce, key) !== 0) return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p2) {
        checkArrayTypes(n, p2);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p2);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k2);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k2, publicKey, secretKey);
        return k2;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k2);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m2 = new Uint8Array(mlen);
        for (var i = 0; i < m2.length; i++) m2[i] = tmp[i];
        return m2;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0) return false;
        if (x2.length !== y2.length) return false;
        return vn2(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn2) {
        randombytes = fn2;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x2, n) {
            var i, v2 = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x2[i] = v2[i];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$0$2;
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x2, n) {
              var i, v2 = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x2[i] = v2[i];
              cleanup(v2);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
var naclFastExports = requireNaclFast();
const f = /* @__PURE__ */ getDefaultExportFromCjs(naclFastExports);
var CONNECT_EVENT_ERROR_CODES;
(function(CONNECT_EVENT_ERROR_CODES2) {
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES2) {
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(SEND_TRANSACTION_ERROR_CODES2) {
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(SIGN_DATA_ERROR_CODES2) {
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(DISCONNECT_ERROR_CODES2) {
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["MAINNET"] = "-239";
  CHAIN2["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));
function encodeUint8Array(value, urlSafe) {
  const encoded = nacl$1.encodeBase64(value);
  if (!urlSafe) {
    return encoded;
  }
  return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
  if (urlSafe) {
    value = decodeURIComponent(value);
  }
  return nacl$1.decodeBase64(value);
}
function encode(value, urlSafe = false) {
  let uint8Array;
  if (value instanceof Uint8Array) {
    uint8Array = value;
  } else {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    uint8Array = nacl$1.decodeUTF8(value);
  }
  return encodeUint8Array(uint8Array, urlSafe);
}
function decode(value, urlSafe = false) {
  const decodedUint8Array = decodeToUint8Array(value, urlSafe);
  return {
    toString() {
      return nacl$1.encodeUTF8(decodedUint8Array);
    },
    toObject() {
      try {
        return JSON.parse(nacl$1.encodeUTF8(decodedUint8Array));
      } catch (e) {
        return null;
      }
    },
    toUint8Array() {
      return decodedUint8Array;
    }
  };
}
const Base64 = {
  encode,
  decode
};
function concatUint8Arrays(buffer1, buffer2) {
  const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
  mergedArray.set(buffer1);
  mergedArray.set(buffer2, buffer1.length);
  return mergedArray;
}
function splitToUint8Arrays(array, index2) {
  if (index2 >= array.length) {
    throw new Error("Index is out of buffer");
  }
  const subArray1 = array.slice(0, index2);
  const subArray2 = array.slice(index2);
  return [subArray1, subArray2];
}
function toHexString(byteArray) {
  let hexString = "";
  byteArray.forEach((byte) => {
    hexString += ("0" + (byte & 255).toString(16)).slice(-2);
  });
  return hexString;
}
function hexToByteArray(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error(`Cannot convert ${hexString} to bytesArray`);
  }
  const result = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
  }
  return result;
}
class SessionCrypto {
  constructor(keyPair) {
    this.nonceLength = 24;
    this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
    this.sessionId = toHexString(this.keyPair.publicKey);
  }
  createKeypair() {
    return f.box.keyPair();
  }
  createKeypairFromString(keyPair) {
    return {
      publicKey: hexToByteArray(keyPair.publicKey),
      secretKey: hexToByteArray(keyPair.secretKey)
    };
  }
  createNonce() {
    return f.randomBytes(this.nonceLength);
  }
  encrypt(message, receiverPublicKey) {
    const encodedMessage = new TextEncoder().encode(message);
    const nonce = this.createNonce();
    const encrypted = f.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
    return concatUint8Arrays(nonce, encrypted);
  }
  decrypt(message, senderPublicKey) {
    const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
    const decrypted = f.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
    if (!decrypted) {
      throw new Error(`Decryption error: 
 message: ${message.toString()} 
 sender pubkey: ${senderPublicKey.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    }
    return new TextDecoder().decode(decrypted);
  }
  stringifyKeypair() {
    return {
      publicKey: toHexString(this.keyPair.publicKey),
      secretKey: toHexString(this.keyPair.secretKey)
    };
  }
}
var dist$4 = {};
var Address$1 = {};
var symbol_inspect;
var hasRequiredSymbol_inspect;
function requireSymbol_inspect() {
  if (hasRequiredSymbol_inspect) return symbol_inspect;
  hasRequiredSymbol_inspect = 1;
  const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
  symbol_inspect = SymbolInspect;
  return symbol_inspect;
}
var crc16$1 = {};
var hasRequiredCrc16$1;
function requireCrc16$1() {
  if (hasRequiredCrc16$1) return crc16$1;
  hasRequiredCrc16$1 = 1;
  Object.defineProperty(crc16$1, "__esModule", { value: true });
  crc16$1.crc16 = void 0;
  function crc162(data) {
    const poly = 4129;
    let reg = 0;
    const message = Buffer.alloc(data.length + 2);
    message.set(data);
    for (let byte of message) {
      let mask = 128;
      while (mask > 0) {
        reg <<= 1;
        if (byte & mask) {
          reg += 1;
        }
        mask >>= 1;
        if (reg > 65535) {
          reg &= 65535;
          reg ^= poly;
        }
      }
    }
    return Buffer.from([Math.floor(reg / 256), reg % 256]);
  }
  crc16$1.crc16 = crc162;
  return crc16$1;
}
var hasRequiredAddress$1;
function requireAddress$1() {
  if (hasRequiredAddress$1) return Address$1;
  hasRequiredAddress$1 = 1;
  var __importDefault = Address$1 && Address$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Address$1, "__esModule", { value: true });
  Address$1.address = Address$1.Address = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const crc16_1 = requireCrc16$1();
  const bounceable_tag = 17;
  const non_bounceable_tag = 81;
  const test_flag = 128;
  function parseFriendlyAddress(src) {
    if (typeof src === "string" && !Address2.isFriendly(src)) {
      throw new Error("Unknown address type");
    }
    const data = Buffer.isBuffer(src) ? src : Buffer.from(src, "base64");
    if (data.length !== 36) {
      throw new Error("Unknown address type: byte length is not equal to 36");
    }
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
      throw new Error("Invalid checksum: " + src);
    }
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
      isTestOnly = true;
      tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag)
      throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 255) {
      workchain = -1;
    } else {
      workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return { isTestOnly, isBounceable, workchain, hashPart };
  }
  class Address2 {
    static isAddress(src) {
      return src instanceof Address2;
    }
    static isFriendly(source) {
      if (source.length !== 48) {
        return false;
      }
      if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
        return false;
      }
      return true;
    }
    static isRaw(source) {
      if (source.indexOf(":") === -1) {
        return false;
      }
      let [wc, hash] = source.split(":");
      if (!Number.isInteger(parseFloat(wc))) {
        return false;
      }
      if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
        return false;
      }
      if (hash.length !== 64) {
        return false;
      }
      return true;
    }
    static normalize(source) {
      if (typeof source === "string") {
        return Address2.parse(source).toString();
      } else {
        return source.toString();
      }
    }
    static parse(source) {
      if (Address2.isFriendly(source)) {
        return this.parseFriendly(source).address;
      } else if (Address2.isRaw(source)) {
        return this.parseRaw(source);
      } else {
        throw new Error("Unknown address type: " + source);
      }
    }
    static parseRaw(source) {
      let workChain = parseInt(source.split(":")[0]);
      let hash = Buffer.from(source.split(":")[1], "hex");
      return new Address2(workChain, hash);
    }
    static parseFriendly(source) {
      if (Buffer.isBuffer(source)) {
        let r = parseFriendlyAddress(source);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      } else {
        let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
        let r = parseFriendlyAddress(addr);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      }
    }
    constructor(workChain, hash) {
      this.toRawString = () => {
        return this.workChain + ":" + this.hash.toString("hex");
      };
      this.toRaw = () => {
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(this.hash);
        addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
        return addressWithChecksum;
      };
      this.toStringBuffer = (args) => {
        let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
        let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
        let tag = bounceable ? bounceable_tag : non_bounceable_tag;
        if (testOnly) {
          tag |= test_flag;
        }
        const addr = Buffer.alloc(34);
        addr[0] = tag;
        addr[1] = this.workChain;
        addr.set(this.hash, 2);
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(addr);
        addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
        return addressWithChecksum;
      };
      this.toString = (args) => {
        let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
        let buffer2 = this.toStringBuffer(args);
        if (urlSafe) {
          return buffer2.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
        } else {
          return buffer2.toString("base64");
        }
      };
      this[_a2] = () => this.toString();
      if (hash.length !== 32) {
        throw new Error("Invalid address hash length: " + hash.length);
      }
      this.workChain = workChain;
      this.hash = hash;
      Object.freeze(this);
    }
    equals(src) {
      if (src.workChain !== this.workChain) {
        return false;
      }
      return src.hash.equals(this.hash);
    }
  }
  Address$1.Address = Address2;
  _a2 = symbol_inspect_1.default;
  function address(src) {
    return Address2.parse(src);
  }
  Address$1.address = address;
  return Address$1;
}
var ExternalAddress$1 = {};
var hasRequiredExternalAddress$1;
function requireExternalAddress$1() {
  if (hasRequiredExternalAddress$1) return ExternalAddress$1;
  hasRequiredExternalAddress$1 = 1;
  var __importDefault = ExternalAddress$1 && ExternalAddress$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(ExternalAddress$1, "__esModule", { value: true });
  ExternalAddress$1.ExternalAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  class ExternalAddress2 {
    static isAddress(src) {
      return src instanceof ExternalAddress2;
    }
    constructor(value, bits) {
      this[_a2] = () => this.toString();
      this.value = value;
      this.bits = bits;
    }
    toString() {
      return `External<${this.bits}:${this.value}>`;
    }
  }
  ExternalAddress$1.ExternalAddress = ExternalAddress2;
  _a2 = symbol_inspect_1.default;
  return ExternalAddress$1;
}
var ADNLAddress$1 = {};
var base32$1 = {};
var hasRequiredBase32$1;
function requireBase32$1() {
  if (hasRequiredBase32$1) return base32$1;
  hasRequiredBase32$1 = 1;
  Object.defineProperty(base32$1, "__esModule", { value: true });
  base32$1.base32Decode = base32$1.base32Encode = void 0;
  const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  function base32Encode(buffer2) {
    const length = buffer2.byteLength;
    let bits = 0;
    let value = 0;
    let output = "";
    for (let i = 0; i < length; i++) {
      value = value << 8 | buffer2[i];
      bits += 8;
      while (bits >= 5) {
        output += alphabet[value >>> bits - 5 & 31];
        bits -= 5;
      }
    }
    if (bits > 0) {
      output += alphabet[value << 5 - bits & 31];
    }
    return output;
  }
  base32$1.base32Encode = base32Encode;
  function readChar(alphabet2, char) {
    const idx = alphabet2.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index2 = 0;
    const output = Buffer.alloc(length * 5 / 8 | 0);
    for (let i = 0; i < length; i++) {
      value = value << 5 | readChar(alphabet, cleanedInput[i]);
      bits += 5;
      if (bits >= 8) {
        output[index2++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output;
  }
  base32$1.base32Decode = base32Decode;
  return base32$1;
}
var hasRequiredADNLAddress$1;
function requireADNLAddress$1() {
  if (hasRequiredADNLAddress$1) return ADNLAddress$1;
  hasRequiredADNLAddress$1 = 1;
  var __importDefault = ADNLAddress$1 && ADNLAddress$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(ADNLAddress$1, "__esModule", { value: true });
  ADNLAddress$1.ADNLAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const base32_1 = requireBase32$1();
  const crc16_1 = requireCrc16$1();
  class ADNLAddress2 {
    static parseFriendly(src) {
      if (src.length !== 55) {
        throw Error("Invalid address");
      }
      src = "f" + src;
      let decoded = (0, base32_1.base32Decode)(src);
      if (decoded[0] !== 45) {
        throw Error("Invalid address");
      }
      let gotHash = decoded.slice(33);
      let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
      if (!hash.equals(gotHash)) {
        throw Error("Invalid address");
      }
      return new ADNLAddress2(decoded.slice(1, 33));
    }
    static parseRaw(src) {
      const data = Buffer.from(src, "base64");
      return new ADNLAddress2(data);
    }
    constructor(address) {
      this.toRaw = () => {
        return this.address.toString("hex").toUpperCase();
      };
      this.toString = () => {
        let data = Buffer.concat([Buffer.from([45]), this.address]);
        let hash = (0, crc16_1.crc16)(data);
        data = Buffer.concat([data, hash]);
        return (0, base32_1.base32Encode)(data).slice(1);
      };
      this[_a2] = () => this.toString();
      if (address.length !== 32) {
        throw Error("Invalid address");
      }
      this.address = address;
    }
    equals(b2) {
      return this.address.equals(b2.address);
    }
  }
  ADNLAddress$1.ADNLAddress = ADNLAddress2;
  _a2 = symbol_inspect_1.default;
  return ADNLAddress$1;
}
var contractAddress$1 = {};
var Builder$4 = {};
var BitBuilder$1 = {};
var BitString$1 = {};
var paddedBits$1 = {};
var hasRequiredPaddedBits$1;
function requirePaddedBits$1() {
  if (hasRequiredPaddedBits$1) return paddedBits$1;
  hasRequiredPaddedBits$1 = 1;
  Object.defineProperty(paddedBits$1, "__esModule", { value: true });
  paddedBits$1.paddedBufferToBits = paddedBits$1.bitsToPaddedBuffer = void 0;
  const BitBuilder_1 = requireBitBuilder$1();
  const BitString_1 = requireBitString$1();
  function bitsToPaddedBuffer(bits) {
    let builder2 = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder2.writeBits(bits);
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for (let i = 0; i < padding; i++) {
      if (i === 0) {
        builder2.writeBit(1);
      } else {
        builder2.writeBit(0);
      }
    }
    return builder2.buffer();
  }
  paddedBits$1.bitsToPaddedBuffer = bitsToPaddedBuffer;
  function paddedBufferToBits(buff) {
    let bitLen = 0;
    for (let i = buff.length - 1; i >= 0; i--) {
      if (buff[i] !== 0) {
        const testByte = buff[i];
        let bitPos = testByte & -testByte;
        if ((bitPos & 1) == 0) {
          bitPos = Math.log2(bitPos) + 1;
        }
        if (i > 0) {
          bitLen = i << 3;
        }
        bitLen += 8 - bitPos;
        break;
      }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
  }
  paddedBits$1.paddedBufferToBits = paddedBufferToBits;
  return paddedBits$1;
}
var hasRequiredBitString$1;
function requireBitString$1() {
  if (hasRequiredBitString$1) return BitString$1;
  hasRequiredBitString$1 = 1;
  var __importDefault = BitString$1 && BitString$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(BitString$1, "__esModule", { value: true });
  BitString$1.BitString = void 0;
  const paddedBits_1 = requirePaddedBits$1();
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  class BitString2 {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/
    static isBitString(src) {
      return src instanceof BitString2;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */
    constructor(data, offset, length) {
      this[_a2] = () => this.toString();
      if (length < 0) {
        throw new Error(`Length ${length} is out of bounds`);
      }
      this._length = length;
      this._data = data;
      this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */
    at(index2) {
      if (index2 >= this._length) {
        throw new Error(`Index ${index2} > ${this._length} is out of bounds`);
      }
      if (index2 < 0) {
        throw new Error(`Index ${index2} < 0 is out of bounds`);
      }
      let byteIndex = this._offset + index2 >> 3;
      let bitIndex = 7 - (this._offset + index2) % 8;
      return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */
    substring(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset(${offset}) < 0 is out of bounds`);
      }
      if (length === 0) {
        return BitString2.EMPTY;
      }
      if (offset + length > this._length) {
        throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
      }
      return new BitString2(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */
    subbuffer(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset + length > this._length) {
        throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
      }
      if (length % 8 !== 0) {
        return null;
      }
      if ((this._offset + offset) % 8 !== 0) {
        return null;
      }
      let start = this._offset + offset >> 3;
      let end2 = start + (length >> 3);
      return this._data.subarray(start, end2);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */
    equals(b2) {
      if (this._length !== b2._length) {
        return false;
      }
      for (let i = 0; i < this._length; i++) {
        if (this.at(i) !== b2.at(i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */
    toString() {
      const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
      if (this._length % 4 === 0) {
        const s2 = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
        if (this._length % 8 === 0) {
          return s2;
        } else {
          return s2.substring(0, s2.length - 1);
        }
      } else {
        const hex = padded.toString("hex").toUpperCase();
        if (this._length % 8 <= 4) {
          return hex.substring(0, hex.length - 1) + "_";
        } else {
          return hex + "_";
        }
      }
    }
  }
  BitString$1.BitString = BitString2;
  _a2 = symbol_inspect_1.default;
  BitString2.EMPTY = new BitString2(Buffer.alloc(0), 0, 0);
  return BitString$1;
}
var hasRequiredBitBuilder$1;
function requireBitBuilder$1() {
  if (hasRequiredBitBuilder$1) return BitBuilder$1;
  hasRequiredBitBuilder$1 = 1;
  Object.defineProperty(BitBuilder$1, "__esModule", { value: true });
  BitBuilder$1.BitBuilder = void 0;
  const Address_1 = requireAddress$1();
  const ExternalAddress_1 = requireExternalAddress$1();
  const BitString_1 = requireBitString$1();
  class BitBuilder2 {
    constructor(size = 1023) {
      this._buffer = Buffer.alloc(Math.ceil(size / 8));
      this._length = 0;
    }
    /**
     * Current number of bits written
     */
    get length() {
      return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */
    writeBit(value) {
      let n = this._length;
      if (n > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
        this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
      }
      this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */
    writeBits(src) {
      for (let i = 0; i < src.length; i++) {
        this.writeBit(src.at(i));
      }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */
    writeBuffer(src) {
      if (this._length % 8 === 0) {
        if (this._length + src.length * 8 > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        src.copy(this._buffer, this._length / 8);
        this._length += src.length * 8;
      } else {
        for (let i = 0; i < src.length; i++) {
          this.writeUint(src[i], 8);
        }
      }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeUint(value, bits) {
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      const v2 = BigInt(value);
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      const vBits = 1n << BigInt(bits);
      if (v2 < 0 || v2 >= vBits) {
        throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
      }
      if (this._length + bits > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      const tillByte = 8 - this._length % 8;
      if (tillByte > 0) {
        const bidx = Math.floor(this._length / 8);
        if (bits < tillByte) {
          const wb = Number(v2);
          this._buffer[bidx] |= wb << tillByte - bits;
          this._length += bits;
        } else {
          const wb = Number(v2 >> BigInt(bits - tillByte));
          this._buffer[bidx] |= wb;
          this._length += tillByte;
        }
      }
      bits -= tillByte;
      while (bits > 0) {
        if (bits >= 8) {
          this._buffer[this._length / 8] = Number(v2 >> BigInt(bits - 8) & 0xffn);
          this._length += 8;
          bits -= 8;
        } else {
          this._buffer[this._length / 8] = Number(v2 << BigInt(8 - bits) & 0xffn);
          this._length += bits;
          bits = 0;
        }
      }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      if (bits === 1) {
        if (v2 !== -1n && v2 !== 0n) {
          throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
        } else {
          this.writeBit(v2 === -1n);
          return;
        }
      }
      let vBits = 1n << BigInt(bits) - 1n;
      if (v2 < -vBits || v2 >= vBits) {
        throw Error(`value is out of range for ${bits} bits. Got ${value}`);
      }
      if (v2 < 0) {
        this.writeBit(true);
        v2 = vBits + v2;
      } else {
        this.writeBit(false);
      }
      this.writeUint(v2, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarUint(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 < 0) {
        throw Error(`value is negative. Got ${value}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      const sizeBytes = Math.ceil(v2.toString(2).length / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeUint(v2, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      const sizeBytes = Math.ceil((v22.toString(2).length + 1) / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeInt(v2, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */
    writeCoins(amount) {
      this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */
    writeAddress(address) {
      if (address === null || address === void 0) {
        this.writeUint(0, 2);
        return;
      }
      if (Address_1.Address.isAddress(address)) {
        this.writeUint(2, 2);
        this.writeUint(0, 1);
        this.writeInt(address.workChain, 8);
        this.writeBuffer(address.hash);
        return;
      }
      if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
        this.writeUint(1, 2);
        this.writeUint(address.bits, 9);
        this.writeUint(address.value, address.bits);
        return;
      }
      throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */
    build() {
      return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */
    buffer() {
      if (this._length % 8 !== 0) {
        throw new Error("BitBuilder buffer is not byte aligned");
      }
      return this._buffer.subarray(0, this._length / 8);
    }
  }
  BitBuilder$1.BitBuilder = BitBuilder2;
  return BitBuilder$1;
}
var Cell$1 = {};
var CellType$1 = {};
var hasRequiredCellType$1;
function requireCellType$1() {
  if (hasRequiredCellType$1) return CellType$1;
  hasRequiredCellType$1 = 1;
  Object.defineProperty(CellType$1, "__esModule", { value: true });
  CellType$1.CellType = void 0;
  var CellType2;
  (function(CellType3) {
    CellType3[CellType3["Ordinary"] = -1] = "Ordinary";
    CellType3[CellType3["PrunedBranch"] = 1] = "PrunedBranch";
    CellType3[CellType3["Library"] = 2] = "Library";
    CellType3[CellType3["MerkleProof"] = 3] = "MerkleProof";
    CellType3[CellType3["MerkleUpdate"] = 4] = "MerkleUpdate";
  })(CellType2 || (CellType$1.CellType = CellType2 = {}));
  return CellType$1;
}
var Slice$1 = {};
var Dictionary$1 = {};
var generateMerkleProof$1 = {};
var readUnaryLength$1 = {};
var hasRequiredReadUnaryLength$1;
function requireReadUnaryLength$1() {
  if (hasRequiredReadUnaryLength$1) return readUnaryLength$1;
  hasRequiredReadUnaryLength$1 = 1;
  Object.defineProperty(readUnaryLength$1, "__esModule", { value: true });
  readUnaryLength$1.readUnaryLength = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  readUnaryLength$1.readUnaryLength = readUnaryLength2;
  return readUnaryLength$1;
}
var exoticMerkleProof$1 = {};
var BitReader$1 = {};
var hasRequiredBitReader$1;
function requireBitReader$1() {
  if (hasRequiredBitReader$1) return BitReader$1;
  hasRequiredBitReader$1 = 1;
  Object.defineProperty(BitReader$1, "__esModule", { value: true });
  BitReader$1.BitReader = void 0;
  const Address_1 = requireAddress$1();
  const ExternalAddress_1 = requireExternalAddress$1();
  class BitReader2 {
    constructor(bits, offset = 0) {
      this._checkpoints = [];
      this._bits = bits;
      this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
      return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
      return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
      if (bits < 0 || this._offset + bits > this._bits.length) {
        throw new Error(`Index ${this._offset + bits} is out of bounds`);
      }
      this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
      if (this._checkpoints.length > 0) {
        this._offset = this._checkpoints.pop();
      } else {
        this._offset = 0;
      }
    }
    /**
     * Save checkpoint
     */
    save() {
      this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
      let r = this._bits.at(this._offset);
      this._offset++;
      return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
      return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
      let r = this._bits.substring(this._offset, bits);
      this._offset += bits;
      return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
      return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
      let buf2 = this._preloadBuffer(bytes, this._offset);
      this._offset += bytes * 8;
      return buf2;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
      return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
      return this._toSafeInteger(this.loadUintBig(bits), "loadUintBig");
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
      let loaded = this.preloadUintBig(bits);
      this._offset += bits;
      return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
      return this._toSafeInteger(this._preloadUint(bits, this._offset), "preloadUintBig");
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
      return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return this._toSafeInteger(res, "loadUintBig");
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
      return this._toSafeInteger(this._preloadInt(bits, this._offset), "preloadIntBig");
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
      return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadUintBig(size * 8), "loadVarUintBig");
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), "preloadVarUintBig");
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadIntBig(size * 8), "loadVarIntBig");
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), "preloadVarIntBig");
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
      return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
      return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address: " + type);
      }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else if (type === 3) {
        throw Error("Unsupported");
      } else {
        throw Error("Unreachable");
      }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
      if (bits % 8 !== 0) {
        throw new Error("Invalid number of bits");
      }
      let length = bits;
      while (true) {
        if (this._bits.at(this._offset + length - 1)) {
          length--;
          break;
        } else {
          length--;
        }
      }
      let r = this._bits.substring(this._offset, length);
      this._offset += bits;
      return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
      return new BitReader2(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let sign2 = this._bits.at(offset);
      let res = 0n;
      for (let i = 0; i < bits - 1; i++) {
        if (this._bits.at(offset + 1 + i)) {
          res += 1n << BigInt(bits - i - 1 - 1);
        }
      }
      if (sign2) {
        res = res - (1n << BigInt(bits - 1));
      }
      return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let res = 0n;
      for (let i = 0; i < bits; i++) {
        if (this._bits.at(offset + i)) {
          res += 1n << BigInt(bits - i - 1);
        }
      }
      return res;
    }
    _preloadBuffer(bytes, offset) {
      let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
      if (fastBuffer) {
        return fastBuffer;
      }
      let buf2 = Buffer.alloc(bytes);
      for (let i = 0; i < bytes; i++) {
        buf2[i] = Number(this._preloadUint(8, offset + i * 8));
      }
      return buf2;
    }
    _loadInternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 2) {
        throw Error("Invalid address");
      }
      let rewrite_pfx = void 0;
      let rewrite_depth = void 0;
      if (this._preloadUint(1, this._offset + 2) !== 0n) {
        rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
        rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
        this._offset += 5 + rewrite_depth;
      }
      let wc = Number(this._preloadInt(8, this._offset + 3));
      let hash = this._preloadBuffer(32, this._offset + 11);
      if (rewrite_depth !== void 0 && rewrite_pfx !== void 0) {
        let pfx = Number(rewrite_pfx);
        let byteIndex = 0;
        let bitIndex = 0;
        let bitsRemaining = rewrite_depth;
        while (bitsRemaining > 0) {
          let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
          let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
          let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
          hash[byteIndex] = hash[byteIndex] & ~mask | bits;
          bitsRemaining -= bitsInThisByte;
          bitIndex += bitsInThisByte;
          if (bitIndex === 8) {
            byteIndex++;
            bitIndex = 0;
          }
        }
      }
      this._offset += 267;
      return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 1) {
        throw Error("Invalid address");
      }
      let bits = Number(this._preloadUint(9, this._offset + 2));
      let value = this._preloadUint(bits, this._offset + 11);
      this._offset += 11 + bits;
      return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src, alt) {
      if (BigInt(Number.MAX_SAFE_INTEGER) < src || src < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new TypeError(`${src} is out of safe integer range. Use ${alt} instead`);
      }
      return Number(src);
    }
  }
  BitReader$1.BitReader = BitReader2;
  return BitReader$1;
}
var hasRequiredExoticMerkleProof$1;
function requireExoticMerkleProof$1() {
  if (hasRequiredExoticMerkleProof$1) return exoticMerkleProof$1;
  hasRequiredExoticMerkleProof$1 = 1;
  Object.defineProperty(exoticMerkleProof$1, "__esModule", { value: true });
  exoticMerkleProof$1.convertToMerkleProof = exoticMerkleProof$1.exoticMerkleProof = void 0;
  const BitReader_1 = requireBitReader$1();
  const Builder_12 = requireBuilder$3();
  function exoticMerkleProof2(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
      throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
      throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 3) {
      throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    const proofHash = reader2.loadBuffer(32);
    const proofDepth = reader2.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
      throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
      throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
    }
    return {
      proofDepth,
      proofHash
    };
  }
  exoticMerkleProof$1.exoticMerkleProof = exoticMerkleProof2;
  function convertToMerkleProof(c) {
    return (0, Builder_12.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
  }
  exoticMerkleProof$1.convertToMerkleProof = convertToMerkleProof;
  return exoticMerkleProof$1;
}
var hasRequiredGenerateMerkleProof$1;
function requireGenerateMerkleProof$1() {
  if (hasRequiredGenerateMerkleProof$1) return generateMerkleProof$1;
  hasRequiredGenerateMerkleProof$1 = 1;
  Object.defineProperty(generateMerkleProof$1, "__esModule", { value: true });
  generateMerkleProof$1.generateMerkleProof = generateMerkleProof$1.generateMerkleProofDirect = void 0;
  const Builder_12 = requireBuilder$3();
  const readUnaryLength_1 = requireReadUnaryLength$1();
  const exoticMerkleProof_1 = requireExoticMerkleProof$1();
  function convertToPrunedBranch(c) {
    return (0, Builder_12.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
  }
  function doGenerateMerkleProof(prefix, slice, n, keys) {
    const originalCell = slice.asCell();
    if (keys.length == 0) {
      return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      return originalCell;
    } else {
      let sl = originalCell.beginParse();
      let left = sl.loadRef();
      let right = sl.loadRef();
      if (!left.isExotic) {
        const leftKeys = keys.filter((key) => {
          return pp + "0" === key.slice(0, pp.length + 1);
        });
        left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, leftKeys);
      }
      if (!right.isExotic) {
        const rightKeys = keys.filter((key) => {
          return pp + "1" === key.slice(0, pp.length + 1);
        });
        right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, rightKeys);
      }
      return (0, Builder_12.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
  }
  function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key) => {
      if (!dict.has(key)) {
        throw new Error(`Trying to generate merkle proof for a missing key "${key}"`);
      }
    });
    const s2 = (0, Builder_12.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof("", s2, keyObject.bits, keys.map((key) => keyObject.serialize(key).toString(2).padStart(keyObject.bits, "0")));
  }
  generateMerkleProof$1.generateMerkleProofDirect = generateMerkleProofDirect;
  function generateMerkleProof2(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
  }
  generateMerkleProof$1.generateMerkleProof = generateMerkleProof2;
  return generateMerkleProof$1;
}
var generateMerkleUpdate$1 = {};
var hasRequiredGenerateMerkleUpdate$1;
function requireGenerateMerkleUpdate$1() {
  if (hasRequiredGenerateMerkleUpdate$1) return generateMerkleUpdate$1;
  hasRequiredGenerateMerkleUpdate$1 = 1;
  Object.defineProperty(generateMerkleUpdate$1, "__esModule", { value: true });
  generateMerkleUpdate$1.generateMerkleUpdate = void 0;
  const Builder_12 = requireBuilder$3();
  const generateMerkleProof_1 = requireGenerateMerkleProof$1();
  function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_12.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
  }
  function generateMerkleUpdate2(dict, key, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
    dict.set(key, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
  }
  generateMerkleUpdate$1.generateMerkleUpdate = generateMerkleUpdate2;
  return generateMerkleUpdate$1;
}
var parseDict$1 = {};
var hasRequiredParseDict$1;
function requireParseDict$1() {
  if (hasRequiredParseDict$1) return parseDict$1;
  hasRequiredParseDict$1 = 1;
  Object.defineProperty(parseDict$1, "__esModule", { value: true });
  parseDict$1.parseDict = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  function doParse(prefix, slice, n, res, extractor) {
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = readUnaryLength2(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      res.set(BigInt("0b" + pp), extractor(slice));
    } else {
      let left = slice.loadRef();
      let right = slice.loadRef();
      if (!left.isExotic) {
        doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
      }
      if (!right.isExotic) {
        doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
      }
    }
  }
  function parseDict2(sc, keySize, extractor) {
    let res = /* @__PURE__ */ new Map();
    if (sc) {
      doParse("", sc, keySize, res, extractor);
    }
    return res;
  }
  parseDict$1.parseDict = parseDict2;
  return parseDict$1;
}
var serializeDict$1 = {};
var findCommonPrefix$1 = {};
var hasRequiredFindCommonPrefix$1;
function requireFindCommonPrefix$1() {
  if (hasRequiredFindCommonPrefix$1) return findCommonPrefix$1;
  hasRequiredFindCommonPrefix$1 = 1;
  Object.defineProperty(findCommonPrefix$1, "__esModule", { value: true });
  findCommonPrefix$1.findCommonPrefix = void 0;
  function findCommonPrefix2(src, startPos = 0) {
    if (src.length === 0) {
      return "";
    }
    let r = src[0].slice(startPos);
    for (let i = 1; i < src.length; i++) {
      const s2 = src[i];
      while (s2.indexOf(r, startPos) !== startPos) {
        r = r.substring(0, r.length - 1);
        if (r === "") {
          return r;
        }
      }
    }
    return r;
  }
  findCommonPrefix$1.findCommonPrefix = findCommonPrefix2;
  return findCommonPrefix$1;
}
var hasRequiredSerializeDict$1;
function requireSerializeDict$1() {
  if (hasRequiredSerializeDict$1) return serializeDict$1;
  hasRequiredSerializeDict$1 = 1;
  Object.defineProperty(serializeDict$1, "__esModule", { value: true });
  serializeDict$1.serializeDict = serializeDict$1.detectLabelType = serializeDict$1.writeLabelSame = serializeDict$1.writeLabelLong = serializeDict$1.writeLabelShort = serializeDict$1.buildTree = void 0;
  const Builder_12 = requireBuilder$3();
  const findCommonPrefix_1 = requireFindCommonPrefix$1();
  function pad(src, size) {
    while (src.length < size) {
      src = "0" + src;
    }
    return src;
  }
  function forkMap(src, prefixLen) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    let left = /* @__PURE__ */ new Map();
    let right = /* @__PURE__ */ new Map();
    for (let [k2, d] of src.entries()) {
      if (k2[prefixLen] === "0") {
        left.set(k2, d);
      } else {
        right.set(k2, d);
      }
    }
    if (left.size === 0) {
      throw Error("Internal inconsistency. Left emtpy.");
    }
    if (right.size === 0) {
      throw Error("Internal inconsistency. Right emtpy.");
    }
    return { left, right };
  }
  function buildNode(src, prefixLen) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    if (src.size === 1) {
      return { type: "leaf", value: Array.from(src.values())[0] };
    }
    let { left, right } = forkMap(src, prefixLen);
    return {
      type: "fork",
      left: buildEdge(left, prefixLen + 1),
      right: buildEdge(right, prefixLen + 1)
    };
  }
  function buildEdge(src, prefixLen = 0) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);
    return { label, node: buildNode(src, label.length + prefixLen) };
  }
  function buildTree(src, keyLength) {
    let converted = /* @__PURE__ */ new Map();
    for (let k2 of Array.from(src.keys())) {
      const padded = pad(k2.toString(2), keyLength);
      converted.set(padded, src.get(k2));
    }
    return buildEdge(converted);
  }
  serializeDict$1.buildTree = buildTree;
  function writeLabelShort(src, to2) {
    to2.storeBit(0);
    for (let i = 0; i < src.length; i++) {
      to2.storeBit(1);
    }
    to2.storeBit(0);
    if (src.length > 0) {
      to2.storeUint(BigInt("0b" + src), src.length);
    }
    return to2;
  }
  serializeDict$1.writeLabelShort = writeLabelShort;
  function labelShortLength(src) {
    return 1 + src.length + 1 + src.length;
  }
  function writeLabelLong(src, keyLength, to2) {
    to2.storeBit(1);
    to2.storeBit(0);
    let length = Math.ceil(Math.log2(keyLength + 1));
    to2.storeUint(src.length, length);
    if (src.length > 0) {
      to2.storeUint(BigInt("0b" + src), src.length);
    }
    return to2;
  }
  serializeDict$1.writeLabelLong = writeLabelLong;
  function labelLongLength(src, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
  }
  function writeLabelSame(value, length, keyLength, to2) {
    to2.storeBit(1);
    to2.storeBit(1);
    to2.storeBit(value);
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to2.storeUint(length, lenLen);
  }
  serializeDict$1.writeLabelSame = writeLabelSame;
  function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
  }
  function isSame(src) {
    if (src.length === 0 || src.length === 1) {
      return true;
    }
    for (let i = 1; i < src.length; i++) {
      if (src[i] !== src[0]) {
        return false;
      }
    }
    return true;
  }
  function detectLabelType(src, keyLength) {
    let kind = "short";
    let kindLength = labelShortLength(src);
    let longLength = labelLongLength(src, keyLength);
    if (longLength < kindLength) {
      kindLength = longLength;
      kind = "long";
    }
    if (isSame(src)) {
      let sameLength = labelSameLength(keyLength);
      if (sameLength < kindLength) {
        kindLength = sameLength;
        kind = "same";
      }
    }
    return kind;
  }
  serializeDict$1.detectLabelType = detectLabelType;
  function writeLabel(src, keyLength, to2) {
    let type = detectLabelType(src, keyLength);
    if (type === "short") {
      writeLabelShort(src, to2);
    } else if (type === "long") {
      writeLabelLong(src, keyLength, to2);
    } else if (type === "same") {
      writeLabelSame(src[0] === "1", src.length, keyLength, to2);
    }
  }
  function writeNode(src, keyLength, serializer, to2) {
    if (src.type === "leaf") {
      serializer(src.value, to2);
    }
    if (src.type === "fork") {
      const leftCell = (0, Builder_12.beginCell)();
      const rightCell = (0, Builder_12.beginCell)();
      writeEdge(src.left, keyLength - 1, serializer, leftCell);
      writeEdge(src.right, keyLength - 1, serializer, rightCell);
      to2.storeRef(leftCell);
      to2.storeRef(rightCell);
    }
  }
  function writeEdge(src, keyLength, serializer, to2) {
    writeLabel(src.label, keyLength, to2);
    writeNode(src.node, keyLength - src.label.length, serializer, to2);
  }
  function serializeDict2(src, keyLength, serializer, to2) {
    const tree = buildTree(src, keyLength);
    writeEdge(tree, keyLength, serializer, to2);
  }
  serializeDict$1.serializeDict = serializeDict2;
  return serializeDict$1;
}
var internalKeySerializer$1 = {};
var hasRequiredInternalKeySerializer$1;
function requireInternalKeySerializer$1() {
  if (hasRequiredInternalKeySerializer$1) return internalKeySerializer$1;
  hasRequiredInternalKeySerializer$1 = 1;
  Object.defineProperty(internalKeySerializer$1, "__esModule", { value: true });
  internalKeySerializer$1.deserializeInternalKey = internalKeySerializer$1.serializeInternalKey = void 0;
  const Address_1 = requireAddress$1();
  const BitString_1 = requireBitString$1();
  const paddedBits_1 = requirePaddedBits$1();
  function serializeInternalKey(value) {
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw Error("Invalid key type: not a safe integer: " + value);
      }
      return "n:" + value.toString(10);
    } else if (typeof value === "bigint") {
      return "b:" + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
      return "a:" + value.toString();
    } else if (Buffer.isBuffer(value)) {
      return "f:" + value.toString("hex");
    } else if (BitString_1.BitString.isBitString(value)) {
      return "B:" + value.toString();
    } else {
      throw Error("Invalid key type");
    }
  }
  internalKeySerializer$1.serializeInternalKey = serializeInternalKey;
  function deserializeInternalKey(value) {
    let k2 = value.slice(0, 2);
    let v2 = value.slice(2);
    if (k2 === "n:") {
      return parseInt(v2, 10);
    } else if (k2 === "b:") {
      return BigInt(v2);
    } else if (k2 === "a:") {
      return Address_1.Address.parse(v2);
    } else if (k2 === "f:") {
      return Buffer.from(v2, "hex");
    } else if (k2 === "B:") {
      const lastDash = v2.slice(-1) == "_";
      const isPadded = lastDash || v2.length % 2 != 0;
      if (isPadded) {
        let charLen = lastDash ? v2.length - 1 : v2.length;
        const padded = v2.substr(0, charLen) + "0";
        if (!lastDash && (charLen & 1) !== 0) {
          return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
        } else {
          return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
        }
      } else {
        return new BitString_1.BitString(Buffer.from(v2, "hex"), 0, v2.length << 2);
      }
    }
    throw Error("Invalid key type: " + k2);
  }
  internalKeySerializer$1.deserializeInternalKey = deserializeInternalKey;
  return internalKeySerializer$1;
}
var hasRequiredDictionary$1;
function requireDictionary$1() {
  if (hasRequiredDictionary$1) return Dictionary$1;
  hasRequiredDictionary$1 = 1;
  Object.defineProperty(Dictionary$1, "__esModule", { value: true });
  Dictionary$1.Dictionary = void 0;
  const Address_1 = requireAddress$1();
  const Builder_12 = requireBuilder$3();
  const Cell_1 = requireCell$1();
  const BitString_1 = requireBitString$1();
  const generateMerkleProof_1 = requireGenerateMerkleProof$1();
  const generateMerkleUpdate_1 = requireGenerateMerkleUpdate$1();
  const parseDict_1 = requireParseDict$1();
  const serializeDict_1 = requireSerializeDict$1();
  const internalKeySerializer_1 = requireInternalKeySerializer$1();
  class Dictionary2 {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key, value) {
      if (key && value) {
        return new Dictionary2(/* @__PURE__ */ new Map(), key, value);
      } else {
        return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
      }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key, value, sc) {
      let slice;
      if (sc instanceof Cell_1.Cell) {
        if (sc.isExotic) {
          return Dictionary2.empty(key, value);
        }
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let cell = slice.loadMaybeRef();
      if (cell && !cell.isExotic) {
        return Dictionary2.loadDirect(key, value, cell.beginParse());
      } else {
        return Dictionary2.empty(key, value);
      }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key, value, sc) {
      if (!sc) {
        return Dictionary2.empty(key, value);
      }
      let slice;
      if (sc instanceof Cell_1.Cell) {
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
      let prepare = /* @__PURE__ */ new Map();
      for (let [k2, v2] of values) {
        prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k2)), v2);
      }
      return new Dictionary2(prepare, key, value);
    }
    constructor(values, key, value) {
      this._key = key;
      this._value = value;
      this._map = values;
    }
    get size() {
      return this._map.size;
    }
    get(key) {
      return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    has(key) {
      return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    set(key, value) {
      this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
      return this;
    }
    delete(key) {
      const k2 = (0, internalKeySerializer_1.serializeInternalKey)(key);
      return this._map.delete(k2);
    }
    clear() {
      this._map.clear();
    }
    *[Symbol.iterator]() {
      for (const [k2, v2] of this._map) {
        const key = (0, internalKeySerializer_1.deserializeInternalKey)(k2);
        yield [key, v2];
      }
    }
    keys() {
      return Array.from(this._map.keys()).map((v2) => (0, internalKeySerializer_1.deserializeInternalKey)(v2));
    }
    values() {
      return Array.from(this._map.values());
    }
    store(builder2, key, value) {
      if (this._map.size === 0) {
        builder2.storeBit(0);
      } else {
        let resolvedKey = this._key;
        if (key !== null && key !== void 0) {
          resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k2, v2] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
        }
        builder2.storeBit(1);
        let dd = (0, Builder_12.beginCell)();
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
        builder2.storeRef(dd.endCell());
      }
    }
    storeDirect(builder2, key, value) {
      if (this._map.size === 0) {
        throw Error("Cannot store empty dictionary directly");
      }
      let resolvedKey = this._key;
      if (key !== null && key !== void 0) {
        resolvedKey = key;
      }
      let resolvedValue = this._value;
      if (value !== null && value !== void 0) {
        resolvedValue = value;
      }
      if (!resolvedKey) {
        throw Error("Key serializer is not defined");
      }
      if (!resolvedValue) {
        throw Error("Value serializer is not defined");
      }
      let prepared = /* @__PURE__ */ new Map();
      for (const [k2, v2] of this._map) {
        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
      }
      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder2);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */
    generateMerkleProof(keys) {
      return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */
    generateMerkleProofDirect(keys) {
      return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key, newValue) {
      return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
    }
  }
  Dictionary$1.Dictionary = Dictionary2;
  Dictionary2.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
      return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
      return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
      return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
      return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
      return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
      return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
      return createBitStringKey(bits);
    }
  };
  Dictionary2.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
      return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
      return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
      return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
      return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
      return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
      return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
      return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
      return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
      return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
      return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
      return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key, value) => {
      return createDictionaryValue(key, value);
    }
  };
  function createAddressKey() {
    return {
      bits: 267,
      serialize: (src) => {
        if (!Address_1.Address.isAddress(src)) {
          throw Error("Key is not an address");
        }
        return (0, Builder_12.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
      }
    };
  }
  function createBigIntKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "bigint") {
          throw Error("Key is not a bigint");
        }
        return (0, Builder_12.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
      }
    };
  }
  function createIntKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src)) {
          throw Error("Key is not a safe integer: " + src);
        }
        return (0, Builder_12.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
      }
    };
  }
  function createBigUintKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "bigint") {
          throw Error("Key is not a bigint");
        }
        if (src < 0) {
          throw Error("Key is negative: " + src);
        }
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      }
    };
  }
  function createUintKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src)) {
          throw Error("Key is not a safe integer: " + src);
        }
        if (src < 0) {
          throw Error("Key is negative: " + src);
        }
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return Number((0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
      }
    };
  }
  function createBufferKey(bytes) {
    return {
      bits: bytes * 8,
      serialize: (src) => {
        if (!Buffer.isBuffer(src)) {
          throw Error("Key is not a buffer");
        }
        return (0, Builder_12.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
      }
    };
  }
  function createBitStringKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (!BitString_1.BitString.isBitString(src))
          throw Error("Key is not a BitString");
        return (0, Builder_12.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
      }
    };
  }
  function createIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadInt(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadIntBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigVarIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeVarInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadVarIntBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigVarUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeVarUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadVarUintBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadUint(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadUintBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBooleanValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeBit(src);
      },
      parse: (src) => {
        let value = src.loadBit();
        src.endParse();
        return value;
      }
    };
  }
  function createAddressValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeAddress(src);
      },
      parse: (src) => {
        let addr = src.loadAddress();
        src.endParse();
        return addr;
      }
    };
  }
  function createCellValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeRef(src);
      },
      parse: (src) => {
        let value = src.loadRef();
        src.endParse();
        return value;
      }
    };
  }
  function createDictionaryValue(key, value) {
    return {
      serialize: (src, buidler) => {
        src.store(buidler);
      },
      parse: (src) => {
        let dict = Dictionary2.load(key, value, src);
        src.endParse();
        return dict;
      }
    };
  }
  function createBufferValue(size) {
    return {
      serialize: (src, buidler) => {
        if (src.length !== size) {
          throw Error("Invalid buffer size");
        }
        buidler.storeBuffer(src);
      },
      parse: (src) => {
        let value = src.loadBuffer(size);
        src.endParse();
        return value;
      }
    };
  }
  function createBitStringValue(bits) {
    return {
      serialize: (src, builder2) => {
        if (src.length !== bits) {
          throw Error("Invalid BitString size");
        }
        builder2.storeBits(src);
      },
      parse: (src) => {
        let value = src.loadBits(bits);
        src.endParse();
        return value;
      }
    };
  }
  return Dictionary$1;
}
var strings$1 = {};
var hasRequiredStrings$1;
function requireStrings$1() {
  if (hasRequiredStrings$1) return strings$1;
  hasRequiredStrings$1 = 1;
  Object.defineProperty(strings$1, "__esModule", { value: true });
  strings$1.writeString = strings$1.stringToCell = strings$1.readString = void 0;
  const Builder_12 = requireBuilder$3();
  function readBuffer(slice) {
    if (slice.remainingBits % 8 !== 0) {
      throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
      throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    let res;
    if (slice.remainingBits === 0) {
      res = Buffer.alloc(0);
    } else {
      res = slice.loadBuffer(slice.remainingBits / 8);
    }
    if (slice.remainingRefs === 1) {
      res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
    }
    return res;
  }
  function readString(slice) {
    return readBuffer(slice).toString();
  }
  strings$1.readString = readString;
  function writeBuffer(src, builder2) {
    if (src.length > 0) {
      let bytes = Math.floor(builder2.availableBits / 8);
      if (src.length > bytes) {
        let a2 = src.subarray(0, bytes);
        let t = src.subarray(bytes);
        builder2 = builder2.storeBuffer(a2);
        let bb = (0, Builder_12.beginCell)();
        writeBuffer(t, bb);
        builder2 = builder2.storeRef(bb.endCell());
      } else {
        builder2 = builder2.storeBuffer(src);
      }
    }
  }
  function stringToCell(src) {
    let builder2 = (0, Builder_12.beginCell)();
    writeBuffer(Buffer.from(src), builder2);
    return builder2.endCell();
  }
  strings$1.stringToCell = stringToCell;
  function writeString(src, builder2) {
    writeBuffer(Buffer.from(src), builder2);
  }
  strings$1.writeString = writeString;
  return strings$1;
}
var hasRequiredSlice$1;
function requireSlice$1() {
  if (hasRequiredSlice$1) return Slice$1;
  hasRequiredSlice$1 = 1;
  var __importDefault = Slice$1 && Slice$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Slice$1, "__esModule", { value: true });
  Slice$1.Slice = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const Dictionary_1 = requireDictionary$1();
  const Builder_12 = requireBuilder$3();
  const strings_1 = requireStrings$1();
  class Slice2 {
    constructor(reader2, refs) {
      this[_a2] = () => this.toString();
      this._reader = reader2.clone();
      this._refs = [...refs];
      this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */
    get remainingBits() {
      return this._reader.remaining;
    }
    /**
     * Get offset bits
     */
    get offsetBits() {
      return this._reader.offset;
    }
    /**
     * Get remaining refs
     */
    get remainingRefs() {
      return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */
    get offsetRefs() {
      return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */
    skip(bits) {
      this._reader.skip(bits);
      return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */
    loadBit() {
      return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */
    preloadBit() {
      return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */
    loadBoolean() {
      return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */
    loadMaybeBoolean() {
      if (this.loadBit()) {
        return this.loadBoolean();
      } else {
        return null;
      }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    loadBits(bits) {
      return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    preloadBits(bits) {
      return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUint(bits) {
      return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUintBig(bits) {
      return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUint(bits) {
      return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUintBig(bits) {
      return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUint(bits) {
      if (this.loadBit()) {
        return this.loadUint(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUintBig(bits) {
      if (this.loadBit()) {
        return this.loadUintBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadInt(bits) {
      return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadIntBig(bits) {
      return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadInt(bits) {
      return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadIntBig(bits) {
      return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeInt(bits) {
      if (this.loadBit()) {
        return this.loadInt(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeIntBig(bits) {
      if (this.loadBit()) {
        return this.loadIntBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUint(bits) {
      return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUintBig(bits) {
      return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUint(bits) {
      return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUintBig(bits) {
      return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarInt(bits) {
      return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarIntBig(bits) {
      return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarInt(bits) {
      return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarIntBig(bits) {
      return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */
    loadCoins() {
      return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */
    preloadCoins() {
      return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */
    loadMaybeCoins() {
      if (this._reader.loadBit()) {
        return this._reader.loadCoins();
      } else {
        return null;
      }
    }
    /**
     * Load internal Address
     * @returns Address
     */
    loadAddress() {
      return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */
    loadMaybeAddress() {
      return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */
    loadAddressAny() {
      return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */
    loadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */
    preloadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */
    loadMaybeRef() {
      if (this.loadBit()) {
        return this.loadRef();
      } else {
        return null;
      }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */
    preloadMaybeRef() {
      if (this.preloadBit()) {
        return this.preloadRef();
      } else {
        return null;
      }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    loadBuffer(bytes) {
      return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    preloadBuffer(bytes) {
      return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */
    loadStringTail() {
      return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */
    loadMaybeStringTail() {
      if (this.loadBit()) {
        return (0, strings_1.readString)(this);
      } else {
        return null;
      }
    }
    /**
     * Load string tail from ref
     * @returns string
     */
    loadStringRefTail() {
      return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */
    loadMaybeStringRefTail() {
      const ref = this.loadMaybeRef();
      if (ref) {
        return (0, strings_1.readString)(ref.beginParse());
      } else {
        return null;
      }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDict(key, value) {
      return Dictionary_1.Dictionary.load(key, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDictDirect(key, value) {
      return Dictionary_1.Dictionary.loadDirect(key, value, this);
    }
    /**
     * Checks if slice is empty
     */
    endParse() {
      if (this.remainingBits > 0 || this.remainingRefs > 0) {
        throw new Error("Slice is not empty");
      }
    }
    /**
     * Convert slice to cell
     */
    asCell() {
      return (0, Builder_12.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */
    clone(fromStart = false) {
      if (fromStart) {
        let reader2 = this._reader.clone();
        reader2.reset();
        return new Slice2(reader2, this._refs);
      } else {
        let res = new Slice2(this._reader, this._refs);
        res._refsOffset = this._refsOffset;
        return res;
      }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */
    toString() {
      return this.asCell().toString();
    }
  }
  Slice$1.Slice = Slice2;
  _a2 = symbol_inspect_1.default;
  return Slice$1;
}
var resolveExotic$1 = {};
var exoticLibrary$1 = {};
var hasRequiredExoticLibrary$1;
function requireExoticLibrary$1() {
  if (hasRequiredExoticLibrary$1) return exoticLibrary$1;
  hasRequiredExoticLibrary$1 = 1;
  Object.defineProperty(exoticLibrary$1, "__esModule", { value: true });
  exoticLibrary$1.exoticLibrary = void 0;
  const BitReader_1 = requireBitReader$1();
  function exoticLibrary2(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256;
    if (bits.length !== size) {
      throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 2) {
      throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
  }
  exoticLibrary$1.exoticLibrary = exoticLibrary2;
  return exoticLibrary$1;
}
var exoticMerkleUpdate$1 = {};
var hasRequiredExoticMerkleUpdate$1;
function requireExoticMerkleUpdate$1() {
  if (hasRequiredExoticMerkleUpdate$1) return exoticMerkleUpdate$1;
  hasRequiredExoticMerkleUpdate$1 = 1;
  Object.defineProperty(exoticMerkleUpdate$1, "__esModule", { value: true });
  exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
  const BitReader_1 = requireBitReader$1();
  function exoticMerkleUpdate2(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
      throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
      throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 4) {
      throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader2.loadBuffer(32);
    const proofHash2 = reader2.loadBuffer(32);
    const proofDepth1 = reader2.loadUint(16);
    const proofDepth2 = reader2.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
    }
    return {
      proofDepth1,
      proofDepth2,
      proofHash1,
      proofHash2
    };
  }
  exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate2;
  return exoticMerkleUpdate$1;
}
var exoticPruned$1 = {};
var LevelMask$1 = {};
var hasRequiredLevelMask$1;
function requireLevelMask$1() {
  if (hasRequiredLevelMask$1) return LevelMask$1;
  hasRequiredLevelMask$1 = 1;
  Object.defineProperty(LevelMask$1, "__esModule", { value: true });
  LevelMask$1.LevelMask = void 0;
  class LevelMask2 {
    constructor(mask = 0) {
      this._mask = 0;
      this._mask = mask;
      this._hashIndex = countSetBits(this._mask);
      this._hashCount = this._hashIndex + 1;
    }
    get value() {
      return this._mask;
    }
    get level() {
      return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
      return this._hashIndex;
    }
    get hashCount() {
      return this._hashCount;
    }
    apply(level) {
      return new LevelMask2(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
      let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
      return res;
    }
  }
  LevelMask$1.LevelMask = LevelMask2;
  function countSetBits(n) {
    n = n - (n >> 1 & 1431655765);
    n = (n & 858993459) + (n >> 2 & 858993459);
    return (n + (n >> 4) & 252645135) * 16843009 >> 24;
  }
  return LevelMask$1;
}
var hasRequiredExoticPruned$1;
function requireExoticPruned$1() {
  if (hasRequiredExoticPruned$1) return exoticPruned$1;
  hasRequiredExoticPruned$1 = 1;
  Object.defineProperty(exoticPruned$1, "__esModule", { value: true });
  exoticPruned$1.exoticPruned = void 0;
  const BitReader_1 = requireBitReader$1();
  const LevelMask_1 = requireLevelMask$1();
  function exoticPruned2(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.loadUint(8);
    if (type !== 1) {
      throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    if (refs.length !== 0) {
      throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    let mask;
    if (bits.length === 280) {
      mask = new LevelMask_1.LevelMask(1);
    } else {
      mask = new LevelMask_1.LevelMask(reader2.loadUint(8));
      if (mask.level < 1 || mask.level > 3) {
        throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
      }
      const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
      }
    }
    let pruned = [];
    let hashes = [];
    let depths = [];
    for (let i = 0; i < mask.level; i++) {
      hashes.push(reader2.loadBuffer(32));
    }
    for (let i = 0; i < mask.level; i++) {
      depths.push(reader2.loadUint(16));
    }
    for (let i = 0; i < mask.level; i++) {
      pruned.push({
        depth: depths[i],
        hash: hashes[i]
      });
    }
    return {
      mask: mask.value,
      pruned
    };
  }
  exoticPruned$1.exoticPruned = exoticPruned2;
  return exoticPruned$1;
}
var hasRequiredResolveExotic$1;
function requireResolveExotic$1() {
  if (hasRequiredResolveExotic$1) return resolveExotic$1;
  hasRequiredResolveExotic$1 = 1;
  Object.defineProperty(resolveExotic$1, "__esModule", { value: true });
  resolveExotic$1.resolveExotic = void 0;
  const BitReader_1 = requireBitReader$1();
  const CellType_1 = requireCellType$1();
  const exoticLibrary_1 = requireExoticLibrary$1();
  const exoticMerkleProof_1 = requireExoticMerkleProof$1();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate$1();
  const exoticPruned_1 = requireExoticPruned$1();
  const LevelMask_1 = requireLevelMask$1();
  function resolvePruned(bits, refs) {
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for (let i = 0; i < pruned.pruned.length; i++) {
      depths.push(pruned.pruned[i].depth);
      hashes.push(pruned.pruned[i].hash);
    }
    return {
      type: CellType_1.CellType.PrunedBranch,
      depths,
      hashes,
      mask
    };
  }
  function resolveLibrary(bits, refs) {
    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
      type: CellType_1.CellType.Library,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleProof(bits, refs) {
    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
      type: CellType_1.CellType.MerkleProof,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleUpdate(bits, refs) {
    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
      type: CellType_1.CellType.MerkleUpdate,
      depths,
      hashes,
      mask
    };
  }
  function resolveExotic2(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.preloadUint(8);
    if (type === 1) {
      return resolvePruned(bits, refs);
    }
    if (type === 2) {
      return resolveLibrary(bits, refs);
    }
    if (type === 3) {
      return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
      return resolveMerkleUpdate(bits, refs);
    }
    throw Error("Invalid exotic cell type: " + type);
  }
  resolveExotic$1.resolveExotic = resolveExotic2;
  return resolveExotic$1;
}
var wonderCalculator$1 = {};
var descriptor$1 = {};
var hasRequiredDescriptor$1;
function requireDescriptor$1() {
  if (hasRequiredDescriptor$1) return descriptor$1;
  hasRequiredDescriptor$1 = 1;
  Object.defineProperty(descriptor$1, "__esModule", { value: true });
  descriptor$1.getRepr = descriptor$1.getBitsDescriptor = descriptor$1.getRefsDescriptor = void 0;
  const CellType_1 = requireCellType$1();
  const paddedBits_1 = requirePaddedBits$1();
  function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
  }
  descriptor$1.getRefsDescriptor = getRefsDescriptor;
  function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
  }
  descriptor$1.getBitsDescriptor = getBitsDescriptor;
  function getRepr(originalBits, bits, refs, level, levelMask, type) {
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    for (const c of refs) {
      let childDepth;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childDepth = c.depth(level + 1);
      } else {
        childDepth = c.depth(level);
      }
      repr[reprCursor++] = Math.floor(childDepth / 256);
      repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs) {
      let childHash;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childHash = c.hash(level + 1);
      } else {
        childHash = c.hash(level);
      }
      childHash.copy(repr, reprCursor);
      reprCursor += 32;
    }
    return repr;
  }
  descriptor$1.getRepr = getRepr;
  return descriptor$1;
}
var dist$3 = {};
var sha256$1 = {};
var sha$1 = { exports: {} };
var sha = sha$1.exports;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1.exports;
  hasRequiredSha = 1;
  (function(module, exports) {
    !(function(n, r) {
      module.exports = r();
    })(sha, (function() {
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o5, u2, f3 = r2 || [0], w3 = (t2 = t2 || 0) >>> 3, s3 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1) o5 = (u2 = i2 + w3) >>> 2, f3.length <= o5 && f3.push(0), f3[o5] |= n2[i2] << 8 * (s3 + e2 * (u2 % 4));
        return { value: f3, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o5, u2, f3;
                if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
                var w3 = r3 || [0], s3 = (t4 = t4 || 0) >>> 3, a3 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o5 = parseInt(n3.substr(i3, 2), 16), isNaN(o5)) throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f3 = (i3 >>> 1) + s3) >>> 2; w3.length <= u2; ) w3.push(0);
                  w3[u2] |= o5 << 8 * (a3 + e3 * (f3 % 4));
                }
                return { value: w3, binLen: 4 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3, i3) {
                var o5, u2, f3, w3, s3, a3, h3, c2, v3 = 0, A3 = t4 || [0], E3 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3) for (h3 = -1 === i3 ? 3 : 0, f3 = 0; f3 < n3.length; f3 += 1) for (u2 = [], 128 > (o5 = n3.charCodeAt(f3)) ? u2.push(o5) : 2048 > o5 ? (u2.push(192 | o5 >>> 6), u2.push(128 | 63 & o5)) : 55296 > o5 || 57344 <= o5 ? u2.push(224 | o5 >>> 12, 128 | o5 >>> 6 & 63, 128 | 63 & o5) : (f3 += 1, o5 = 65536 + ((1023 & o5) << 10 | 1023 & n3.charCodeAt(f3)), u2.push(240 | o5 >>> 18, 128 | o5 >>> 12 & 63, 128 | o5 >>> 6 & 63, 128 | 63 & o5)), w3 = 0; w3 < u2.length; w3 += 1) {
                  for (s3 = (a3 = v3 + E3) >>> 2; A3.length <= s3; ) A3.push(0);
                  A3[s3] |= u2[w3] << 8 * (h3 + i3 * (a3 % 4)), v3 += 1;
                }
                else for (h3 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f3 = 0; f3 < n3.length; f3 += 1) {
                  for (o5 = n3.charCodeAt(f3), true === c2 && (o5 = (w3 = 255 & o5) << 8 | o5 >>> 8), s3 = (a3 = v3 + E3) >>> 2; A3.length <= s3; ) A3.push(0);
                  A3[s3] |= o5 << 8 * (h3 + i3 * (a3 % 4)), v3 += 2;
                }
                return { value: A3, binLen: 8 * v3 + e3 };
              })(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return (function(r3, t4, e4, i3) {
                var o5, u2, f3, w3, s3, a3, h3 = 0, c2 = t4 || [0], v3 = (e4 = e4 || 0) >>> 3, A3 = -1 === i3 ? 3 : 0, E3 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E3 && E3 < r3.length) throw new Error("Invalid '=' found in base-64 string");
                for (o5 = 0; o5 < r3.length; o5 += 4) {
                  for (w3 = r3.substr(o5, 4), f3 = 0, u2 = 0; u2 < w3.length; u2 += 1) f3 |= n.indexOf(w3.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w3.length - 1; u2 += 1) {
                    for (s3 = (a3 = h3 + v3) >>> 2; c2.length <= s3; ) c2.push(0);
                    c2[s3] |= (f3 >>> 16 - 8 * u2 & 255) << 8 * (A3 + i3 * (a3 % 4)), h3 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h3 + e4 };
              })(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o5, u2, f3, w3 = r3 || [0], s3 = (t4 = t4 || 0) >>> 3, a3 = -1 === e3 ? 3 : 0;
                for (o5 = 0; o5 < n3.length; o5 += 1) i3 = n3.charCodeAt(o5), u2 = (f3 = o5 + s3) >>> 2, w3.length <= u2 && w3.push(0), w3[u2] |= i3 << 8 * (a3 + e3 * (f3 % 4));
                return { value: w3, binLen: 8 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return (function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              })(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return (function(n3, r3, t3, e3) {
                var i3, o5, u2 = "", f3 = r3 / 8, w3 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f3; i3 += 1) o5 = n3[i3 >>> 2] >>> 8 * (w3 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o5 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o5);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              })(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return (function(r4, t3, e3, i3) {
                var o5, u2, f3, w3, s3, a3 = "", h3 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o5 = 0; o5 < h3; o5 += 3) for (w3 = o5 + 1 < h3 ? r4[o5 + 1 >>> 2] : 0, s3 = o5 + 2 < h3 ? r4[o5 + 2 >>> 2] : 0, f3 = (r4[o5 >>> 2] >>> 8 * (c2 + e3 * (o5 % 4)) & 255) << 16 | (w3 >>> 8 * (c2 + e3 * ((o5 + 1) % 4)) & 255) << 8 | s3 >>> 8 * (c2 + e3 * ((o5 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1) a3 += 8 * o5 + 6 * u2 <= t3 ? n.charAt(f3 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a3;
              })(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3, o5 = "", u2 = r3 / 8, f3 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f3 + t3 * (e3 % 4)) & 255, o5 += String.fromCharCode(i3);
                return o5;
              })(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o5 = new ArrayBuffer(i3), u2 = new Uint8Array(o5), f3 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (f3 + t3 * (e3 % 4)) & 255;
                return o5;
              })(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o5 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (o5 + t3 * (e3 % 4)) & 255;
                return u2;
              })(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o4 = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f2 = "Chosen SHA variant is not supported";
      function w2(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o5 = r2.binLen >>> 3, u2 = i2 << 3, f3 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o5; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f3;
          return (n2.value.length << 2) - 4 >= o5 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s2(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a2(n2, r2, e2, i2) {
        var o5 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2) throw new Error(o5);
          return i2;
        }
        if (void 0 === r2.value || !r2.format) throw new Error(o5);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h2 = (function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o5 = i2.binLen, u2 = i2.value, f3 = o5 >>> 5;
          for (r2 = 0; r2 < f3; r2 += e2) t2 + this.S <= o5 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o5 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o5 = this.U, u2 = s2(r2);
          if (this.T) {
            if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
            o5 = u2.outputLen;
          }
          var f3 = e(n3, o5, this.C, u2);
          if (this.A && this.F) return f3(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o5), t2 = 1; t2 < this.numRounds; t2 += 1) this.T && o5 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o5 % 32), i2 = this.K(i2, o5, 0, this.L(this.o), o5);
          return f3(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g) throw new Error("Variant does not support HMAC");
          if (this.h) throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
          if (this.A) throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; ) n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1) this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s2(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      })(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v2(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A2(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E2(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b2(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H2(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S2(n2) {
        return E2(n2, 2) ^ E2(n2, 13) ^ E2(n2, 22);
      }
      function p2(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m2(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y2(n2, r2, t2, e2, i2) {
        var o5 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o5 >>> 16)) << 16 | 65535 & o5;
      }
      function R2(n2) {
        return E2(n2, 7) ^ E2(n2, 18) ^ l(n2, 3);
      }
      function U2(n2) {
        return E2(n2, 6) ^ E2(n2, 11) ^ E2(n2, 25);
      }
      function T10(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w3, s3 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o5 = r2[3], u2 = r2[4], w3 = 0; w3 < 80; w3 += 1) s3[w3] = w3 < 16 ? n2[w3] : A2(s3[w3 - 3] ^ s3[w3 - 8] ^ s3[w3 - 14] ^ s3[w3 - 16], 1), f3 = w3 < 20 ? y2(A2(t2, 5), H2(e2, i2, o5), u2, 1518500249, s3[w3]) : w3 < 40 ? y2(A2(t2, 5), b2(e2, i2, o5), u2, 1859775393, s3[w3]) : w3 < 60 ? y2(A2(t2, 5), d(e2, i2, o5), u2, 2400959708, s3[w3]) : y2(A2(t2, 5), b2(e2, i2, o5), u2, 3395469782, s3[w3]), u2 = o5, o5 = i2, i2 = A2(e2, 30), e2 = t2, t2 = f3;
        return r2[0] = p2(t2, r2[0]), r2[1] = p2(e2, r2[1]), r2[2] = p2(i2, r2[2]), r2[3] = p2(o5, r2[3]), r2[4] = p2(u2, r2[4]), r2;
      }
      function F2(n2, r2, t2, e2) {
        for (var i2, o5 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o5; ) n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o5] = 4294967295 & u2, n2[o5 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = C2(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-1" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).g = true, o5.F = o5.Y, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = C2, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = T10, o5.K = F2, o5.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o5.S = 512, o5.U = 160, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2);
      function B2(n2) {
        return "SHA-224" == n2 ? o4.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o5, u2, f3, w3, s3, a3, h3, c2, v3, A3, b3 = [];
        for (t2 = r2[0], e2 = r2[1], o5 = r2[2], u2 = r2[3], f3 = r2[4], w3 = r2[5], s3 = r2[6], a3 = r2[7], v3 = 0; v3 < 64; v3 += 1) b3[v3] = v3 < 16 ? n2[v3] : m2(E2(A3 = b3[v3 - 2], 17) ^ E2(A3, 19) ^ l(A3, 10), b3[v3 - 7], R2(b3[v3 - 15]), b3[v3 - 16]), h3 = y2(a3, U2(f3), H2(f3, w3, s3), i[v3], b3[v3]), c2 = p2(S2(t2), d(t2, e2, o5)), a3 = s3, s3 = w3, w3 = f3, f3 = p2(u2, h3), u2 = o5, o5 = e2, e2 = t2, t2 = p2(h3, c2);
        return r2[0] = p2(t2, r2[0]), r2[1] = p2(e2, r2[1]), r2[2] = p2(o5, r2[2]), r2[3] = p2(u2, r2[3]), r2[4] = p2(f3, r2[4]), r2[5] = p2(w3, r2[5]), r2[6] = p2(s3, r2[6]), r2[7] = p2(a3, r2[7]), r2;
      }
      var g2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).F = o5.Y, o5.g = true, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = L, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = B2, o5.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o6, u3 = 15 + (r4 + 65 >>> 9 << 4), f3 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f3, n4[u3 - 1] = f3 / 4294967296 | 0, o6 = 0; o6 < n4.length; o6 += 16) e4 = L(n4.slice(o6, o6 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            })(n3, t2, e3, i3, r3);
          }, o5.m = B2(r3), o5.S = 512, o5.U = "SHA-224" === r3 ? 224 : 256, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2), k2 = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k2(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k2(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N2(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k2(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k2(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I2(n2, r2) {
        return new k2(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M2(n2, r2, t2) {
        return new k2(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X2(n2, r2, t2) {
        return new k2(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z2(n2) {
        var r2 = N2(n2, 28), t2 = N2(n2, 34), e2 = N2(n2, 39);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O2(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k2((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j2(n2, r2, t2, e2) {
        var i2, o5;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o5 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o5 >>> 16), o5 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k2((65535 & o5) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o5, u2;
        o5 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f3 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o5 >>> 16))) << 16 | 65535 & o5;
        return o5 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o5 >>> 16), new k2((65535 & u2) << 16 | 65535 & o5, f3);
      }
      function P2(n2, r2) {
        return new k2(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x2(n2) {
        var r2 = N2(n2, 1), t2 = N2(n2, 8), e2 = I2(n2, 7);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V2(n2) {
        var r2 = N2(n2, 14), t2 = N2(n2, 18), e2 = N2(n2, 41);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z2 = [new k2(i[0], 3609767458), new k2(i[1], 602891725), new k2(i[2], 3964484399), new k2(i[3], 2173295548), new k2(i[4], 4081628472), new k2(i[5], 3053834265), new k2(i[6], 2937671579), new k2(i[7], 3664609560), new k2(i[8], 2734883394), new k2(i[9], 1164996542), new k2(i[10], 1323610764), new k2(i[11], 3590304994), new k2(i[12], 4068182383), new k2(i[13], 991336113), new k2(i[14], 633803317), new k2(i[15], 3479774868), new k2(i[16], 2666613458), new k2(i[17], 944711139), new k2(i[18], 2341262773), new k2(i[19], 2007800933), new k2(i[20], 1495990901), new k2(i[21], 1856431235), new k2(i[22], 3175218132), new k2(i[23], 2198950837), new k2(i[24], 3999719339), new k2(i[25], 766784016), new k2(i[26], 2566594879), new k2(i[27], 3203337956), new k2(i[28], 1034457026), new k2(i[29], 2466948901), new k2(i[30], 3758326383), new k2(i[31], 168717936), new k2(i[32], 1188179964), new k2(i[33], 1546045734), new k2(i[34], 1522805485), new k2(i[35], 2643833823), new k2(i[36], 2343527390), new k2(i[37], 1014477480), new k2(i[38], 1206759142), new k2(i[39], 344077627), new k2(i[40], 1290863460), new k2(i[41], 3158454273), new k2(i[42], 3505952657), new k2(i[43], 106217008), new k2(i[44], 3606008344), new k2(i[45], 1432725776), new k2(i[46], 1467031594), new k2(i[47], 851169720), new k2(i[48], 3100823752), new k2(i[49], 1363258195), new k2(i[50], 3750685593), new k2(i[51], 3785050280), new k2(i[52], 3318307427), new k2(i[53], 3812723403), new k2(i[54], 2003034995), new k2(i[55], 3602036899), new k2(i[56], 1575990012), new k2(i[57], 1125592928), new k2(i[58], 2716904306), new k2(i[59], 442776044), new k2(i[60], 593698344), new k2(i[61], 3733110249), new k2(i[62], 2999351573), new k2(i[63], 3815920427), new k2(3391569614, 3928383900), new k2(3515267271, 566280711), new k2(3940187606, 3454069534), new k2(4118630271, 4000239992), new k2(116418474, 1914138554), new k2(174292421, 2731055270), new k2(289380356, 3203993006), new k2(460393269, 320620315), new k2(685471733, 587496836), new k2(852142971, 1086792851), new k2(1017036298, 365543100), new k2(1126000580, 2618297676), new k2(1288033470, 3409855158), new k2(1501505948, 4234509866), new k2(1607167915, 987167468), new k2(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k2(3418070365, o4[0]), new k2(1654270250, o4[1]), new k2(2438529370, o4[2]), new k2(355462360, o4[3]), new k2(1731405415, o4[4]), new k2(41048885895, o4[5]), new k2(3675008525, o4[6]), new k2(1203062813, o4[7])] : [new k2(u[0], 4089235720), new k2(u[1], 2227873595), new k2(u[2], 4271175723), new k2(u[3], 1595750129), new k2(u[4], 2917565137), new k2(u[5], 725511199), new k2(u[6], 4215389547), new k2(u[7], 327033209)];
      }
      function D2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w3, s3, a3, h3, c2, v3, A3, E3, l2, b3, H3 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o5 = r2[3], u2 = r2[4], f3 = r2[5], w3 = r2[6], s3 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v3 = 2 * c2, H3[c2] = new k2(n2[v3], n2[v3 + 1])) : H3[c2] = j2((A3 = H3[c2 - 2], E3 = void 0, l2 = void 0, b3 = void 0, E3 = N2(A3, 19), l2 = N2(A3, 61), b3 = I2(A3, 6), new k2(E3.N ^ l2.N ^ b3.N, E3.I ^ l2.I ^ b3.I)), H3[c2 - 7], x2(H3[c2 - 15]), H3[c2 - 16]), a3 = _(s3, V2(u2), M2(u2, f3, w3), Z2[c2], H3[c2]), h3 = O2(z2(t2), X2(t2, e2, i2)), s3 = w3, w3 = f3, f3 = u2, u2 = O2(o5, a3), o5 = i2, i2 = e2, e2 = t2, t2 = O2(a3, h3);
        return r2[0] = O2(t2, r2[0]), r2[1] = O2(e2, r2[1]), r2[2] = O2(i2, r2[2]), r2[3] = O2(o5, r2[3]), r2[4] = O2(u2, r2[4]), r2[5] = O2(f3, r2[5]), r2[6] = O2(w3, r2[6]), r2[7] = O2(s3, r2[7]), r2;
      }
      var G2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).F = o5.Y, o5.g = true, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = D2, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = q, o5.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o6, u3 = 31 + (r4 + 129 >>> 10 << 5), f3 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f3, n4[u3 - 1] = f3 / 4294967296 | 0, o6 = 0; o6 < n4.length; o6 += 32) e4 = D2(n4.slice(o6, o6 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            })(n3, t2, e3, i3, r3);
          }, o5.m = q(r3), o5.S = 1024, o5.U = "SHA-384" === r3 ? 384 : 512, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2), J2 = [new k2(0, 1), new k2(0, 32898), new k2(2147483648, 32906), new k2(2147483648, 2147516416), new k2(0, 32907), new k2(0, 2147483649), new k2(2147483648, 2147516545), new k2(2147483648, 32777), new k2(0, 138), new k2(0, 136), new k2(0, 2147516425), new k2(0, 2147483658), new k2(0, 2147516555), new k2(2147483648, 139), new k2(2147483648, 32905), new k2(2147483648, 32771), new k2(2147483648, 32770), new k2(2147483648, 128), new k2(0, 32778), new k2(2147483648, 2147483658), new k2(2147483648, 2147516545), new k2(2147483648, 32896), new k2(0, 2147483649), new k2(2147483648, 2147516424)], Q2 = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W2(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new k2(0, 0), new k2(0, 0), new k2(0, 0), new k2(0, 0), new k2(0, 0)];
        return t2;
      }
      function $2(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w3, s3, a3, h3 = [], c2 = [];
        if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P2(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k2(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o5 = W2(), e2 = 0; e2 < 5; e2 += 1) h3[e2] = (u2 = r2[e2][0], f3 = r2[e2][1], w3 = r2[e2][2], s3 = r2[e2][3], a3 = r2[e2][4], new k2(u2.N ^ f3.N ^ w3.N ^ s3.N ^ a3.N, u2.I ^ f3.I ^ w3.I ^ s3.I ^ a3.I));
          for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = P2(h3[(e2 + 4) % 5], Y(h3[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o5[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q2[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(o5[e2][i2], new k2(~o5[(e2 + 1) % 5][i2].N & o5[(e2 + 2) % 5][i2].N, ~o5[(e2 + 1) % 5][i2].I & o5[(e2 + 2) % 5][i2].I));
          r2[0][0] = P2(r2[0][0], J2[t2]);
        }
        return r2;
      }
      function rn2(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o5 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o5[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn2(n2) {
        return w2(rn2(n2.binLen), n2);
      }
      function en2(n2, r2) {
        var t2, e2 = rn2(r2), i2 = r2 >>> 2, o5 = (i2 - (e2 = w2(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o5; t2++) e2.value.push(0);
        return e2.value;
      }
      var on2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this, u2 = 6, w3 = 0, s3 = i2 || {};
          if (1 !== (o5 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s3.kmacKey || s3.hmacKey) throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o5.o || "CSHAKE256" === o5.o) throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o5.C = 1, o5.p = t(o5.t, o5.i, o5.C), o5.R = nn2, o5.B = $2, o5.L = W2, o5.m = W2(), o5.T = false, r3) {
            case "SHA3-224":
              o5.S = w3 = 1152, o5.U = 224, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-256":
              o5.S = w3 = 1088, o5.U = 256, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-384":
              o5.S = w3 = 832, o5.U = 384, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-512":
              o5.S = w3 = 576, o5.U = 512, o5.g = true, o5.F = o5.Y;
              break;
            case "SHAKE128":
              u2 = 31, o5.S = w3 = 1344, o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o5.S = w3 = 1088, o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "KMAC128":
              u2 = 4, o5.S = w3 = 1344, o5.M(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = o5.X;
              break;
            case "KMAC256":
              u2 = 4, o5.S = w3 = 1088, o5.M(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = o5.X;
              break;
            case "CSHAKE128":
              o5.S = w3 = 1344, u2 = o5.O(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "CSHAKE256":
              o5.S = w3 = 1088, u2 = o5.O(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            default:
              throw new Error(f2);
          }
          return o5.K = function(n3, r4, t2, e3, i3) {
            return (function(n4, r5, t3, e4, i4, o6, u3) {
              var f3, w4, s4 = 0, a3 = [], h3 = i4 >>> 5, c2 = r5 >>> 5;
              for (f3 = 0; f3 < c2 && r5 >= i4; f3 += h3) e4 = nn2(n4.slice(f3, f3 + h3), e4), r5 -= i4;
              for (n4 = n4.slice(f3), r5 %= i4; n4.length < h3; ) n4.push(0);
              for (n4[(f3 = r5 >>> 3) >> 2] ^= o6 << f3 % 4 * 8, n4[h3 - 1] ^= 2147483648, e4 = nn2(n4, e4); 32 * a3.length < u3 && (w4 = e4[s4 % 5][s4 / 5 | 0], a3.push(w4.I), !(32 * a3.length >= u3)); ) a3.push(w4.N), 0 == 64 * (s4 += 1) % i4 && (nn2(null, e4), s4 = 0);
              return a3;
            })(n3, r4, 0, e3, w3, u2, i3);
          }, s3.hmacKey && o5.k(a2("hmacKey", s3.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = (function(n4) {
            var r4 = n4 || {};
            return { funcName: a2("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a2("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w2(tn2(t2.funcName), tn2(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en2(e2, this.S >>> 3), o5 = 0; o5 < i2.length; o5 += this.S >>> 5) this.m = this.R(i2.slice(o5, o5 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = (function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a2("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a2("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en2(tn2(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5) this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w2({ value: this.u.slice(), binLen: this.s }, (function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o5 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o5[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          })(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      })(h2);
      return (function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3) this.j = new K2(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3) this.j = new g2(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3) this.j = new G2(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(f2);
            this.j = new on2(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      })();
    }));
  })(sha$1);
  return sha$1.exports;
}
var browser = {};
var getSecureRandom$1 = {};
var hasRequiredGetSecureRandom$1;
function requireGetSecureRandom$1() {
  if (hasRequiredGetSecureRandom$1) return getSecureRandom$1;
  hasRequiredGetSecureRandom$1 = 1;
  Object.defineProperty(getSecureRandom$1, "__esModule", { value: true });
  getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
  function getSecureRandomBytes(size) {
    return Buffer.from(window.crypto.getRandomValues(new Uint8Array(size)));
  }
  getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes;
  function getSecureRandomWords(size) {
    return window.crypto.getRandomValues(new Uint16Array(size));
  }
  getSecureRandom$1.getSecureRandomWords = getSecureRandomWords;
  return getSecureRandom$1;
}
var hmac_sha512$1 = {};
var hasRequiredHmac_sha512$1;
function requireHmac_sha512$1() {
  if (hasRequiredHmac_sha512$1) return hmac_sha512$1;
  hasRequiredHmac_sha512$1 = 1;
  Object.defineProperty(hmac_sha512$1, "__esModule", { value: true });
  hmac_sha512$1.hmac_sha512 = void 0;
  async function hmac_sha5122(key, data) {
    let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
    const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
    return Buffer.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
  }
  hmac_sha512$1.hmac_sha512 = hmac_sha5122;
  return hmac_sha512$1;
}
var pbkdf2_sha512$1 = {};
var hasRequiredPbkdf2_sha512$1;
function requirePbkdf2_sha512$1() {
  if (hasRequiredPbkdf2_sha512$1) return pbkdf2_sha512$1;
  hasRequiredPbkdf2_sha512$1 = 1;
  Object.defineProperty(pbkdf2_sha512$1, "__esModule", { value: true });
  pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
  async function pbkdf2_sha5122(key, salt, iterations, keyLen) {
    const keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
    const saltBuffer = typeof salt === "string" ? Buffer.from(salt, "utf-8") : salt;
    const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
    const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
    return Buffer.from(derivedBits);
  }
  pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha5122;
  return pbkdf2_sha512$1;
}
var sha256 = {};
var hasRequiredSha256$1;
function requireSha256$1() {
  if (hasRequiredSha256$1) return sha256;
  hasRequiredSha256$1 = 1;
  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.sha256 = void 0;
  async function sha256$12(source) {
    if (typeof source === "string") {
      return Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(source, "utf-8")));
    }
    return Buffer.from(await crypto.subtle.digest("SHA-256", source));
  }
  sha256.sha256 = sha256$12;
  return sha256;
}
var sha512$2 = {};
var hasRequiredSha512$1;
function requireSha512$1() {
  if (hasRequiredSha512$1) return sha512$2;
  hasRequiredSha512$1 = 1;
  Object.defineProperty(sha512$2, "__esModule", { value: true });
  sha512$2.sha512 = void 0;
  async function sha5122(source) {
    if (typeof source === "string") {
      return Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(source, "utf-8")));
    }
    return Buffer.from(await crypto.subtle.digest("SHA-512", source));
  }
  sha512$2.sha512 = sha5122;
  return sha512$2;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = requireGetSecureRandom$1();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = requireHmac_sha512$1();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512$1();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = requireSha256$1();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = requireSha512$1();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  })(browser);
  return browser;
}
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1;
  hasRequiredSha256 = 1;
  var __importDefault = sha256$1 && sha256$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha256$1, "__esModule", { value: true });
  sha256$1.sha256 = sha256$1.sha256_fallback = sha256$1.sha256_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireBrowser();
  function sha256_sync(source) {
    let src;
    if (typeof source === "string") {
      src = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-256", "HEX");
    hasher.update(src);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha256$1.sha256_sync = sha256_sync;
  async function sha256_fallback(source) {
    return sha256_sync(source);
  }
  sha256$1.sha256_fallback = sha256_fallback;
  function sha2562(source) {
    return (0, crypto_primitives_1.sha256)(source);
  }
  sha256$1.sha256 = sha2562;
  return sha256$1;
}
var sha512$1 = {};
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var __importDefault = sha512$1 && sha512$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha512$1, "__esModule", { value: true });
  sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireBrowser();
  function sha512_sync(source) {
    let src;
    if (typeof source === "string") {
      src = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-512", "HEX");
    hasher.update(src);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha512$1.sha512_sync = sha512_sync;
  async function sha512_fallback(source) {
    return sha512_sync(source);
  }
  sha512$1.sha512_fallback = sha512_fallback;
  async function sha5122(source) {
    return (0, crypto_primitives_1.sha512)(source);
  }
  sha512$1.sha512 = sha5122;
  return sha512$1;
}
var pbkdf2_sha512 = {};
var hasRequiredPbkdf2_sha512;
function requirePbkdf2_sha512() {
  if (hasRequiredPbkdf2_sha512) return pbkdf2_sha512;
  hasRequiredPbkdf2_sha512 = 1;
  Object.defineProperty(pbkdf2_sha512, "__esModule", { value: true });
  pbkdf2_sha512.pbkdf2_sha512 = void 0;
  const crypto_primitives_1 = requireBrowser();
  function pbkdf2_sha512$12(key, salt, iterations, keyLen) {
    return (0, crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
  }
  pbkdf2_sha512.pbkdf2_sha512 = pbkdf2_sha512$12;
  return pbkdf2_sha512;
}
var hmac_sha512 = {};
var hasRequiredHmac_sha512;
function requireHmac_sha512() {
  if (hasRequiredHmac_sha512) return hmac_sha512;
  hasRequiredHmac_sha512 = 1;
  var __importDefault = hmac_sha512 && hmac_sha512.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(hmac_sha512, "__esModule", { value: true });
  hmac_sha512.hmac_sha512 = hmac_sha512.hmac_sha512_fallback = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireBrowser();
  async function hmac_sha512_fallback(key, data) {
    let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const shaObj = new jssha_1.default("SHA-512", "HEX", {
      hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
    });
    shaObj.update(dataBuffer.toString("hex"));
    const hmac2 = shaObj.getHash("HEX");
    return Buffer.from(hmac2, "hex");
  }
  hmac_sha512.hmac_sha512_fallback = hmac_sha512_fallback;
  function hmac_sha512$12(key, data) {
    return (0, crypto_primitives_1.hmac_sha512)(key, data);
  }
  hmac_sha512.hmac_sha512 = hmac_sha512$12;
  return hmac_sha512;
}
var getSecureRandom = {};
var hasRequiredGetSecureRandom;
function requireGetSecureRandom() {
  if (hasRequiredGetSecureRandom) return getSecureRandom;
  hasRequiredGetSecureRandom = 1;
  Object.defineProperty(getSecureRandom, "__esModule", { value: true });
  getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
  const crypto_primitives_1 = requireBrowser();
  async function getSecureRandomBytes(size) {
    return (0, crypto_primitives_1.getSecureRandomBytes)(size);
  }
  getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
  async function getSecureRandomWords(size) {
    return getSecureRandomWords();
  }
  getSecureRandom.getSecureRandomWords = getSecureRandomWords;
  async function getSecureRandomNumber(min, max) {
    let range = max - min;
    var bitsNeeded = Math.ceil(Math.log2(range));
    if (bitsNeeded > 53) {
      throw new Error("Range is too large");
    }
    var bytesNeeded = Math.ceil(bitsNeeded / 8);
    var mask = Math.pow(2, bitsNeeded) - 1;
    while (true) {
      let res = await getSecureRandomBytes(bitsNeeded);
      let power = (bytesNeeded - 1) * 8;
      let numberValue = 0;
      for (var i = 0; i < bytesNeeded; i++) {
        numberValue += res[i] * Math.pow(2, power);
        power -= 8;
      }
      numberValue = numberValue & mask;
      if (numberValue >= range) {
        continue;
      }
      return min + numberValue;
    }
  }
  getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
  return getSecureRandom;
}
var newSecureWords = {};
var wordlist$1 = {};
var hasRequiredWordlist$1;
function requireWordlist$1() {
  if (hasRequiredWordlist$1) return wordlist$1;
  hasRequiredWordlist$1 = 1;
  Object.defineProperty(wordlist$1, "__esModule", { value: true });
  wordlist$1.wordlist = void 0;
  wordlist$1.wordlist = [
    "abacus",
    "abdomen",
    "abdominal",
    "abide",
    "abiding",
    "ability",
    "ablaze",
    "able",
    "abnormal",
    "abrasion",
    "abrasive",
    "abreast",
    "abridge",
    "abroad",
    "abruptly",
    "absence",
    "absentee",
    "absently",
    "absinthe",
    "absolute",
    "absolve",
    "abstain",
    "abstract",
    "absurd",
    "accent",
    "acclaim",
    "acclimate",
    "accompany",
    "account",
    "accuracy",
    "accurate",
    "accustom",
    "acetone",
    "achiness",
    "aching",
    "acid",
    "acorn",
    "acquaint",
    "acquire",
    "acre",
    "acrobat",
    "acronym",
    "acting",
    "action",
    "activate",
    "activator",
    "active",
    "activism",
    "activist",
    "activity",
    "actress",
    "acts",
    "acutely",
    "acuteness",
    "aeration",
    "aerobics",
    "aerosol",
    "aerospace",
    "afar",
    "affair",
    "affected",
    "affecting",
    "affection",
    "affidavit",
    "affiliate",
    "affirm",
    "affix",
    "afflicted",
    "affluent",
    "afford",
    "affront",
    "aflame",
    "afloat",
    "aflutter",
    "afoot",
    "afraid",
    "afterglow",
    "afterlife",
    "aftermath",
    "aftermost",
    "afternoon",
    "aged",
    "ageless",
    "agency",
    "agenda",
    "agent",
    "aggregate",
    "aghast",
    "agile",
    "agility",
    "aging",
    "agnostic",
    "agonize",
    "agonizing",
    "agony",
    "agreeable",
    "agreeably",
    "agreed",
    "agreeing",
    "agreement",
    "aground",
    "ahead",
    "ahoy",
    "aide",
    "aids",
    "aim",
    "ajar",
    "alabaster",
    "alarm",
    "albatross",
    "album",
    "alfalfa",
    "algebra",
    "algorithm",
    "alias",
    "alibi",
    "alienable",
    "alienate",
    "aliens",
    "alike",
    "alive",
    "alkaline",
    "alkalize",
    "almanac",
    "almighty",
    "almost",
    "aloe",
    "aloft",
    "aloha",
    "alone",
    "alongside",
    "aloof",
    "alphabet",
    "alright",
    "although",
    "altitude",
    "alto",
    "aluminum",
    "alumni",
    "always",
    "amaretto",
    "amaze",
    "amazingly",
    "amber",
    "ambiance",
    "ambiguity",
    "ambiguous",
    "ambition",
    "ambitious",
    "ambulance",
    "ambush",
    "amendable",
    "amendment",
    "amends",
    "amenity",
    "amiable",
    "amicably",
    "amid",
    "amigo",
    "amino",
    "amiss",
    "ammonia",
    "ammonium",
    "amnesty",
    "amniotic",
    "among",
    "amount",
    "amperage",
    "ample",
    "amplifier",
    "amplify",
    "amply",
    "amuck",
    "amulet",
    "amusable",
    "amused",
    "amusement",
    "amuser",
    "amusing",
    "anaconda",
    "anaerobic",
    "anagram",
    "anatomist",
    "anatomy",
    "anchor",
    "anchovy",
    "ancient",
    "android",
    "anemia",
    "anemic",
    "aneurism",
    "anew",
    "angelfish",
    "angelic",
    "anger",
    "angled",
    "angler",
    "angles",
    "angling",
    "angrily",
    "angriness",
    "anguished",
    "angular",
    "animal",
    "animate",
    "animating",
    "animation",
    "animator",
    "anime",
    "animosity",
    "ankle",
    "annex",
    "annotate",
    "announcer",
    "annoying",
    "annually",
    "annuity",
    "anointer",
    "another",
    "answering",
    "antacid",
    "antarctic",
    "anteater",
    "antelope",
    "antennae",
    "anthem",
    "anthill",
    "anthology",
    "antibody",
    "antics",
    "antidote",
    "antihero",
    "antiquely",
    "antiques",
    "antiquity",
    "antirust",
    "antitoxic",
    "antitrust",
    "antiviral",
    "antivirus",
    "antler",
    "antonym",
    "antsy",
    "anvil",
    "anybody",
    "anyhow",
    "anymore",
    "anyone",
    "anyplace",
    "anything",
    "anytime",
    "anyway",
    "anywhere",
    "aorta",
    "apache",
    "apostle",
    "appealing",
    "appear",
    "appease",
    "appeasing",
    "appendage",
    "appendix",
    "appetite",
    "appetizer",
    "applaud",
    "applause",
    "apple",
    "appliance",
    "applicant",
    "applied",
    "apply",
    "appointee",
    "appraisal",
    "appraiser",
    "apprehend",
    "approach",
    "approval",
    "approve",
    "apricot",
    "april",
    "apron",
    "aptitude",
    "aptly",
    "aqua",
    "aqueduct",
    "arbitrary",
    "arbitrate",
    "ardently",
    "area",
    "arena",
    "arguable",
    "arguably",
    "argue",
    "arise",
    "armadillo",
    "armband",
    "armchair",
    "armed",
    "armful",
    "armhole",
    "arming",
    "armless",
    "armoire",
    "armored",
    "armory",
    "armrest",
    "army",
    "aroma",
    "arose",
    "around",
    "arousal",
    "arrange",
    "array",
    "arrest",
    "arrival",
    "arrive",
    "arrogance",
    "arrogant",
    "arson",
    "art",
    "ascend",
    "ascension",
    "ascent",
    "ascertain",
    "ashamed",
    "ashen",
    "ashes",
    "ashy",
    "aside",
    "askew",
    "asleep",
    "asparagus",
    "aspect",
    "aspirate",
    "aspire",
    "aspirin",
    "astonish",
    "astound",
    "astride",
    "astrology",
    "astronaut",
    "astronomy",
    "astute",
    "atlantic",
    "atlas",
    "atom",
    "atonable",
    "atop",
    "atrium",
    "atrocious",
    "atrophy",
    "attach",
    "attain",
    "attempt",
    "attendant",
    "attendee",
    "attention",
    "attentive",
    "attest",
    "attic",
    "attire",
    "attitude",
    "attractor",
    "attribute",
    "atypical",
    "auction",
    "audacious",
    "audacity",
    "audible",
    "audibly",
    "audience",
    "audio",
    "audition",
    "augmented",
    "august",
    "authentic",
    "author",
    "autism",
    "autistic",
    "autograph",
    "automaker",
    "automated",
    "automatic",
    "autopilot",
    "available",
    "avalanche",
    "avatar",
    "avenge",
    "avenging",
    "avenue",
    "average",
    "aversion",
    "avert",
    "aviation",
    "aviator",
    "avid",
    "avoid",
    "await",
    "awaken",
    "award",
    "aware",
    "awhile",
    "awkward",
    "awning",
    "awoke",
    "awry",
    "axis",
    "babble",
    "babbling",
    "babied",
    "baboon",
    "backache",
    "backboard",
    "backboned",
    "backdrop",
    "backed",
    "backer",
    "backfield",
    "backfire",
    "backhand",
    "backing",
    "backlands",
    "backlash",
    "backless",
    "backlight",
    "backlit",
    "backlog",
    "backpack",
    "backpedal",
    "backrest",
    "backroom",
    "backshift",
    "backside",
    "backslid",
    "backspace",
    "backspin",
    "backstab",
    "backstage",
    "backtalk",
    "backtrack",
    "backup",
    "backward",
    "backwash",
    "backwater",
    "backyard",
    "bacon",
    "bacteria",
    "bacterium",
    "badass",
    "badge",
    "badland",
    "badly",
    "badness",
    "baffle",
    "baffling",
    "bagel",
    "bagful",
    "baggage",
    "bagged",
    "baggie",
    "bagginess",
    "bagging",
    "baggy",
    "bagpipe",
    "baguette",
    "baked",
    "bakery",
    "bakeshop",
    "baking",
    "balance",
    "balancing",
    "balcony",
    "balmy",
    "balsamic",
    "bamboo",
    "banana",
    "banish",
    "banister",
    "banjo",
    "bankable",
    "bankbook",
    "banked",
    "banker",
    "banking",
    "banknote",
    "bankroll",
    "banner",
    "bannister",
    "banshee",
    "banter",
    "barbecue",
    "barbed",
    "barbell",
    "barber",
    "barcode",
    "barge",
    "bargraph",
    "barista",
    "baritone",
    "barley",
    "barmaid",
    "barman",
    "barn",
    "barometer",
    "barrack",
    "barracuda",
    "barrel",
    "barrette",
    "barricade",
    "barrier",
    "barstool",
    "bartender",
    "barterer",
    "bash",
    "basically",
    "basics",
    "basil",
    "basin",
    "basis",
    "basket",
    "batboy",
    "batch",
    "bath",
    "baton",
    "bats",
    "battalion",
    "battered",
    "battering",
    "battery",
    "batting",
    "battle",
    "bauble",
    "bazooka",
    "blabber",
    "bladder",
    "blade",
    "blah",
    "blame",
    "blaming",
    "blanching",
    "blandness",
    "blank",
    "blaspheme",
    "blasphemy",
    "blast",
    "blatancy",
    "blatantly",
    "blazer",
    "blazing",
    "bleach",
    "bleak",
    "bleep",
    "blemish",
    "blend",
    "bless",
    "blighted",
    "blimp",
    "bling",
    "blinked",
    "blinker",
    "blinking",
    "blinks",
    "blip",
    "blissful",
    "blitz",
    "blizzard",
    "bloated",
    "bloating",
    "blob",
    "blog",
    "bloomers",
    "blooming",
    "blooper",
    "blot",
    "blouse",
    "blubber",
    "bluff",
    "bluish",
    "blunderer",
    "blunt",
    "blurb",
    "blurred",
    "blurry",
    "blurt",
    "blush",
    "blustery",
    "boaster",
    "boastful",
    "boasting",
    "boat",
    "bobbed",
    "bobbing",
    "bobble",
    "bobcat",
    "bobsled",
    "bobtail",
    "bodacious",
    "body",
    "bogged",
    "boggle",
    "bogus",
    "boil",
    "bok",
    "bolster",
    "bolt",
    "bonanza",
    "bonded",
    "bonding",
    "bondless",
    "boned",
    "bonehead",
    "boneless",
    "bonelike",
    "boney",
    "bonfire",
    "bonnet",
    "bonsai",
    "bonus",
    "bony",
    "boogeyman",
    "boogieman",
    "book",
    "boondocks",
    "booted",
    "booth",
    "bootie",
    "booting",
    "bootlace",
    "bootleg",
    "boots",
    "boozy",
    "borax",
    "boring",
    "borough",
    "borrower",
    "borrowing",
    "boss",
    "botanical",
    "botanist",
    "botany",
    "botch",
    "both",
    "bottle",
    "bottling",
    "bottom",
    "bounce",
    "bouncing",
    "bouncy",
    "bounding",
    "boundless",
    "bountiful",
    "bovine",
    "boxcar",
    "boxer",
    "boxing",
    "boxlike",
    "boxy",
    "breach",
    "breath",
    "breeches",
    "breeching",
    "breeder",
    "breeding",
    "breeze",
    "breezy",
    "brethren",
    "brewery",
    "brewing",
    "briar",
    "bribe",
    "brick",
    "bride",
    "bridged",
    "brigade",
    "bright",
    "brilliant",
    "brim",
    "bring",
    "brink",
    "brisket",
    "briskly",
    "briskness",
    "bristle",
    "brittle",
    "broadband",
    "broadcast",
    "broaden",
    "broadly",
    "broadness",
    "broadside",
    "broadways",
    "broiler",
    "broiling",
    "broken",
    "broker",
    "bronchial",
    "bronco",
    "bronze",
    "bronzing",
    "brook",
    "broom",
    "brought",
    "browbeat",
    "brownnose",
    "browse",
    "browsing",
    "bruising",
    "brunch",
    "brunette",
    "brunt",
    "brush",
    "brussels",
    "brute",
    "brutishly",
    "bubble",
    "bubbling",
    "bubbly",
    "buccaneer",
    "bucked",
    "bucket",
    "buckle",
    "buckshot",
    "buckskin",
    "bucktooth",
    "buckwheat",
    "buddhism",
    "buddhist",
    "budding",
    "buddy",
    "budget",
    "buffalo",
    "buffed",
    "buffer",
    "buffing",
    "buffoon",
    "buggy",
    "bulb",
    "bulge",
    "bulginess",
    "bulgur",
    "bulk",
    "bulldog",
    "bulldozer",
    "bullfight",
    "bullfrog",
    "bullhorn",
    "bullion",
    "bullish",
    "bullpen",
    "bullring",
    "bullseye",
    "bullwhip",
    "bully",
    "bunch",
    "bundle",
    "bungee",
    "bunion",
    "bunkbed",
    "bunkhouse",
    "bunkmate",
    "bunny",
    "bunt",
    "busboy",
    "bush",
    "busily",
    "busload",
    "bust",
    "busybody",
    "buzz",
    "cabana",
    "cabbage",
    "cabbie",
    "cabdriver",
    "cable",
    "caboose",
    "cache",
    "cackle",
    "cacti",
    "cactus",
    "caddie",
    "caddy",
    "cadet",
    "cadillac",
    "cadmium",
    "cage",
    "cahoots",
    "cake",
    "calamari",
    "calamity",
    "calcium",
    "calculate",
    "calculus",
    "caliber",
    "calibrate",
    "calm",
    "caloric",
    "calorie",
    "calzone",
    "camcorder",
    "cameo",
    "camera",
    "camisole",
    "camper",
    "campfire",
    "camping",
    "campsite",
    "campus",
    "canal",
    "canary",
    "cancel",
    "candied",
    "candle",
    "candy",
    "cane",
    "canine",
    "canister",
    "cannabis",
    "canned",
    "canning",
    "cannon",
    "cannot",
    "canola",
    "canon",
    "canopener",
    "canopy",
    "canteen",
    "canyon",
    "capable",
    "capably",
    "capacity",
    "cape",
    "capillary",
    "capital",
    "capitol",
    "capped",
    "capricorn",
    "capsize",
    "capsule",
    "caption",
    "captivate",
    "captive",
    "captivity",
    "capture",
    "caramel",
    "carat",
    "caravan",
    "carbon",
    "cardboard",
    "carded",
    "cardiac",
    "cardigan",
    "cardinal",
    "cardstock",
    "carefully",
    "caregiver",
    "careless",
    "caress",
    "caretaker",
    "cargo",
    "caring",
    "carless",
    "carload",
    "carmaker",
    "carnage",
    "carnation",
    "carnival",
    "carnivore",
    "carol",
    "carpenter",
    "carpentry",
    "carpool",
    "carport",
    "carried",
    "carrot",
    "carrousel",
    "carry",
    "cartel",
    "cartload",
    "carton",
    "cartoon",
    "cartridge",
    "cartwheel",
    "carve",
    "carving",
    "carwash",
    "cascade",
    "case",
    "cash",
    "casing",
    "casino",
    "casket",
    "cassette",
    "casually",
    "casualty",
    "catacomb",
    "catalog",
    "catalyst",
    "catalyze",
    "catapult",
    "cataract",
    "catatonic",
    "catcall",
    "catchable",
    "catcher",
    "catching",
    "catchy",
    "caterer",
    "catering",
    "catfight",
    "catfish",
    "cathedral",
    "cathouse",
    "catlike",
    "catnap",
    "catnip",
    "catsup",
    "cattail",
    "cattishly",
    "cattle",
    "catty",
    "catwalk",
    "caucasian",
    "caucus",
    "causal",
    "causation",
    "cause",
    "causing",
    "cauterize",
    "caution",
    "cautious",
    "cavalier",
    "cavalry",
    "caviar",
    "cavity",
    "cedar",
    "celery",
    "celestial",
    "celibacy",
    "celibate",
    "celtic",
    "cement",
    "census",
    "ceramics",
    "ceremony",
    "certainly",
    "certainty",
    "certified",
    "certify",
    "cesarean",
    "cesspool",
    "chafe",
    "chaffing",
    "chain",
    "chair",
    "chalice",
    "challenge",
    "chamber",
    "chamomile",
    "champion",
    "chance",
    "change",
    "channel",
    "chant",
    "chaos",
    "chaperone",
    "chaplain",
    "chapped",
    "chaps",
    "chapter",
    "character",
    "charbroil",
    "charcoal",
    "charger",
    "charging",
    "chariot",
    "charity",
    "charm",
    "charred",
    "charter",
    "charting",
    "chase",
    "chasing",
    "chaste",
    "chastise",
    "chastity",
    "chatroom",
    "chatter",
    "chatting",
    "chatty",
    "cheating",
    "cheddar",
    "cheek",
    "cheer",
    "cheese",
    "cheesy",
    "chef",
    "chemicals",
    "chemist",
    "chemo",
    "cherisher",
    "cherub",
    "chess",
    "chest",
    "chevron",
    "chevy",
    "chewable",
    "chewer",
    "chewing",
    "chewy",
    "chief",
    "chihuahua",
    "childcare",
    "childhood",
    "childish",
    "childless",
    "childlike",
    "chili",
    "chill",
    "chimp",
    "chip",
    "chirping",
    "chirpy",
    "chitchat",
    "chivalry",
    "chive",
    "chloride",
    "chlorine",
    "choice",
    "chokehold",
    "choking",
    "chomp",
    "chooser",
    "choosing",
    "choosy",
    "chop",
    "chosen",
    "chowder",
    "chowtime",
    "chrome",
    "chubby",
    "chuck",
    "chug",
    "chummy",
    "chump",
    "chunk",
    "churn",
    "chute",
    "cider",
    "cilantro",
    "cinch",
    "cinema",
    "cinnamon",
    "circle",
    "circling",
    "circular",
    "circulate",
    "circus",
    "citable",
    "citadel",
    "citation",
    "citizen",
    "citric",
    "citrus",
    "city",
    "civic",
    "civil",
    "clad",
    "claim",
    "clambake",
    "clammy",
    "clamor",
    "clamp",
    "clamshell",
    "clang",
    "clanking",
    "clapped",
    "clapper",
    "clapping",
    "clarify",
    "clarinet",
    "clarity",
    "clash",
    "clasp",
    "class",
    "clatter",
    "clause",
    "clavicle",
    "claw",
    "clay",
    "clean",
    "clear",
    "cleat",
    "cleaver",
    "cleft",
    "clench",
    "clergyman",
    "clerical",
    "clerk",
    "clever",
    "clicker",
    "client",
    "climate",
    "climatic",
    "cling",
    "clinic",
    "clinking",
    "clip",
    "clique",
    "cloak",
    "clobber",
    "clock",
    "clone",
    "cloning",
    "closable",
    "closure",
    "clothes",
    "clothing",
    "cloud",
    "clover",
    "clubbed",
    "clubbing",
    "clubhouse",
    "clump",
    "clumsily",
    "clumsy",
    "clunky",
    "clustered",
    "clutch",
    "clutter",
    "coach",
    "coagulant",
    "coastal",
    "coaster",
    "coasting",
    "coastland",
    "coastline",
    "coat",
    "coauthor",
    "cobalt",
    "cobbler",
    "cobweb",
    "cocoa",
    "coconut",
    "cod",
    "coeditor",
    "coerce",
    "coexist",
    "coffee",
    "cofounder",
    "cognition",
    "cognitive",
    "cogwheel",
    "coherence",
    "coherent",
    "cohesive",
    "coil",
    "coke",
    "cola",
    "cold",
    "coleslaw",
    "coliseum",
    "collage",
    "collapse",
    "collar",
    "collected",
    "collector",
    "collide",
    "collie",
    "collision",
    "colonial",
    "colonist",
    "colonize",
    "colony",
    "colossal",
    "colt",
    "coma",
    "come",
    "comfort",
    "comfy",
    "comic",
    "coming",
    "comma",
    "commence",
    "commend",
    "comment",
    "commerce",
    "commode",
    "commodity",
    "commodore",
    "common",
    "commotion",
    "commute",
    "commuting",
    "compacted",
    "compacter",
    "compactly",
    "compactor",
    "companion",
    "company",
    "compare",
    "compel",
    "compile",
    "comply",
    "component",
    "composed",
    "composer",
    "composite",
    "compost",
    "composure",
    "compound",
    "compress",
    "comprised",
    "computer",
    "computing",
    "comrade",
    "concave",
    "conceal",
    "conceded",
    "concept",
    "concerned",
    "concert",
    "conch",
    "concierge",
    "concise",
    "conclude",
    "concrete",
    "concur",
    "condense",
    "condiment",
    "condition",
    "condone",
    "conducive",
    "conductor",
    "conduit",
    "cone",
    "confess",
    "confetti",
    "confidant",
    "confident",
    "confider",
    "confiding",
    "configure",
    "confined",
    "confining",
    "confirm",
    "conflict",
    "conform",
    "confound",
    "confront",
    "confused",
    "confusing",
    "confusion",
    "congenial",
    "congested",
    "congrats",
    "congress",
    "conical",
    "conjoined",
    "conjure",
    "conjuror",
    "connected",
    "connector",
    "consensus",
    "consent",
    "console",
    "consoling",
    "consonant",
    "constable",
    "constant",
    "constrain",
    "constrict",
    "construct",
    "consult",
    "consumer",
    "consuming",
    "contact",
    "container",
    "contempt",
    "contend",
    "contented",
    "contently",
    "contents",
    "contest",
    "context",
    "contort",
    "contour",
    "contrite",
    "control",
    "contusion",
    "convene",
    "convent",
    "copartner",
    "cope",
    "copied",
    "copier",
    "copilot",
    "coping",
    "copious",
    "copper",
    "copy",
    "coral",
    "cork",
    "cornball",
    "cornbread",
    "corncob",
    "cornea",
    "corned",
    "corner",
    "cornfield",
    "cornflake",
    "cornhusk",
    "cornmeal",
    "cornstalk",
    "corny",
    "coronary",
    "coroner",
    "corporal",
    "corporate",
    "corral",
    "correct",
    "corridor",
    "corrode",
    "corroding",
    "corrosive",
    "corsage",
    "corset",
    "cortex",
    "cosigner",
    "cosmetics",
    "cosmic",
    "cosmos",
    "cosponsor",
    "cost",
    "cottage",
    "cotton",
    "couch",
    "cough",
    "could",
    "countable",
    "countdown",
    "counting",
    "countless",
    "country",
    "county",
    "courier",
    "covenant",
    "cover",
    "coveted",
    "coveting",
    "coyness",
    "cozily",
    "coziness",
    "cozy",
    "crabbing",
    "crabgrass",
    "crablike",
    "crabmeat",
    "cradle",
    "cradling",
    "crafter",
    "craftily",
    "craftsman",
    "craftwork",
    "crafty",
    "cramp",
    "cranberry",
    "crane",
    "cranial",
    "cranium",
    "crank",
    "crate",
    "crave",
    "craving",
    "crawfish",
    "crawlers",
    "crawling",
    "crayfish",
    "crayon",
    "crazed",
    "crazily",
    "craziness",
    "crazy",
    "creamed",
    "creamer",
    "creamlike",
    "crease",
    "creasing",
    "creatable",
    "create",
    "creation",
    "creative",
    "creature",
    "credible",
    "credibly",
    "credit",
    "creed",
    "creme",
    "creole",
    "crepe",
    "crept",
    "crescent",
    "crested",
    "cresting",
    "crestless",
    "crevice",
    "crewless",
    "crewman",
    "crewmate",
    "crib",
    "cricket",
    "cried",
    "crier",
    "crimp",
    "crimson",
    "cringe",
    "cringing",
    "crinkle",
    "crinkly",
    "crisped",
    "crisping",
    "crisply",
    "crispness",
    "crispy",
    "criteria",
    "critter",
    "croak",
    "crock",
    "crook",
    "croon",
    "crop",
    "cross",
    "crouch",
    "crouton",
    "crowbar",
    "crowd",
    "crown",
    "crucial",
    "crudely",
    "crudeness",
    "cruelly",
    "cruelness",
    "cruelty",
    "crumb",
    "crummiest",
    "crummy",
    "crumpet",
    "crumpled",
    "cruncher",
    "crunching",
    "crunchy",
    "crusader",
    "crushable",
    "crushed",
    "crusher",
    "crushing",
    "crust",
    "crux",
    "crying",
    "cryptic",
    "crystal",
    "cubbyhole",
    "cube",
    "cubical",
    "cubicle",
    "cucumber",
    "cuddle",
    "cuddly",
    "cufflink",
    "culinary",
    "culminate",
    "culpable",
    "culprit",
    "cultivate",
    "cultural",
    "culture",
    "cupbearer",
    "cupcake",
    "cupid",
    "cupped",
    "cupping",
    "curable",
    "curator",
    "curdle",
    "cure",
    "curfew",
    "curing",
    "curled",
    "curler",
    "curliness",
    "curling",
    "curly",
    "curry",
    "curse",
    "cursive",
    "cursor",
    "curtain",
    "curtly",
    "curtsy",
    "curvature",
    "curve",
    "curvy",
    "cushy",
    "cusp",
    "cussed",
    "custard",
    "custodian",
    "custody",
    "customary",
    "customer",
    "customize",
    "customs",
    "cut",
    "cycle",
    "cyclic",
    "cycling",
    "cyclist",
    "cylinder",
    "cymbal",
    "cytoplasm",
    "cytoplast",
    "dab",
    "dad",
    "daffodil",
    "dagger",
    "daily",
    "daintily",
    "dainty",
    "dairy",
    "daisy",
    "dallying",
    "dance",
    "dancing",
    "dandelion",
    "dander",
    "dandruff",
    "dandy",
    "danger",
    "dangle",
    "dangling",
    "daredevil",
    "dares",
    "daringly",
    "darkened",
    "darkening",
    "darkish",
    "darkness",
    "darkroom",
    "darling",
    "darn",
    "dart",
    "darwinism",
    "dash",
    "dastardly",
    "data",
    "datebook",
    "dating",
    "daughter",
    "daunting",
    "dawdler",
    "dawn",
    "daybed",
    "daybreak",
    "daycare",
    "daydream",
    "daylight",
    "daylong",
    "dayroom",
    "daytime",
    "dazzler",
    "dazzling",
    "deacon",
    "deafening",
    "deafness",
    "dealer",
    "dealing",
    "dealmaker",
    "dealt",
    "dean",
    "debatable",
    "debate",
    "debating",
    "debit",
    "debrief",
    "debtless",
    "debtor",
    "debug",
    "debunk",
    "decade",
    "decaf",
    "decal",
    "decathlon",
    "decay",
    "deceased",
    "deceit",
    "deceiver",
    "deceiving",
    "december",
    "decency",
    "decent",
    "deception",
    "deceptive",
    "decibel",
    "decidable",
    "decimal",
    "decimeter",
    "decipher",
    "deck",
    "declared",
    "decline",
    "decode",
    "decompose",
    "decorated",
    "decorator",
    "decoy",
    "decrease",
    "decree",
    "dedicate",
    "dedicator",
    "deduce",
    "deduct",
    "deed",
    "deem",
    "deepen",
    "deeply",
    "deepness",
    "deface",
    "defacing",
    "defame",
    "default",
    "defeat",
    "defection",
    "defective",
    "defendant",
    "defender",
    "defense",
    "defensive",
    "deferral",
    "deferred",
    "defiance",
    "defiant",
    "defile",
    "defiling",
    "define",
    "definite",
    "deflate",
    "deflation",
    "deflator",
    "deflected",
    "deflector",
    "defog",
    "deforest",
    "defraud",
    "defrost",
    "deftly",
    "defuse",
    "defy",
    "degraded",
    "degrading",
    "degrease",
    "degree",
    "dehydrate",
    "deity",
    "dejected",
    "delay",
    "delegate",
    "delegator",
    "delete",
    "deletion",
    "delicacy",
    "delicate",
    "delicious",
    "delighted",
    "delirious",
    "delirium",
    "deliverer",
    "delivery",
    "delouse",
    "delta",
    "deluge",
    "delusion",
    "deluxe",
    "demanding",
    "demeaning",
    "demeanor",
    "demise",
    "democracy",
    "democrat",
    "demote",
    "demotion",
    "demystify",
    "denatured",
    "deniable",
    "denial",
    "denim",
    "denote",
    "dense",
    "density",
    "dental",
    "dentist",
    "denture",
    "deny",
    "deodorant",
    "deodorize",
    "departed",
    "departure",
    "depict",
    "deplete",
    "depletion",
    "deplored",
    "deploy",
    "deport",
    "depose",
    "depraved",
    "depravity",
    "deprecate",
    "depress",
    "deprive",
    "depth",
    "deputize",
    "deputy",
    "derail",
    "deranged",
    "derby",
    "derived",
    "desecrate",
    "deserve",
    "deserving",
    "designate",
    "designed",
    "designer",
    "designing",
    "deskbound",
    "desktop",
    "deskwork",
    "desolate",
    "despair",
    "despise",
    "despite",
    "destiny",
    "destitute",
    "destruct",
    "detached",
    "detail",
    "detection",
    "detective",
    "detector",
    "detention",
    "detergent",
    "detest",
    "detonate",
    "detonator",
    "detoxify",
    "detract",
    "deuce",
    "devalue",
    "deviancy",
    "deviant",
    "deviate",
    "deviation",
    "deviator",
    "device",
    "devious",
    "devotedly",
    "devotee",
    "devotion",
    "devourer",
    "devouring",
    "devoutly",
    "dexterity",
    "dexterous",
    "diabetes",
    "diabetic",
    "diabolic",
    "diagnoses",
    "diagnosis",
    "diagram",
    "dial",
    "diameter",
    "diaper",
    "diaphragm",
    "diary",
    "dice",
    "dicing",
    "dictate",
    "dictation",
    "dictator",
    "difficult",
    "diffused",
    "diffuser",
    "diffusion",
    "diffusive",
    "dig",
    "dilation",
    "diligence",
    "diligent",
    "dill",
    "dilute",
    "dime",
    "diminish",
    "dimly",
    "dimmed",
    "dimmer",
    "dimness",
    "dimple",
    "diner",
    "dingbat",
    "dinghy",
    "dinginess",
    "dingo",
    "dingy",
    "dining",
    "dinner",
    "diocese",
    "dioxide",
    "diploma",
    "dipped",
    "dipper",
    "dipping",
    "directed",
    "direction",
    "directive",
    "directly",
    "directory",
    "direness",
    "dirtiness",
    "disabled",
    "disagree",
    "disallow",
    "disarm",
    "disarray",
    "disaster",
    "disband",
    "disbelief",
    "disburse",
    "discard",
    "discern",
    "discharge",
    "disclose",
    "discolor",
    "discount",
    "discourse",
    "discover",
    "discuss",
    "disdain",
    "disengage",
    "disfigure",
    "disgrace",
    "dish",
    "disinfect",
    "disjoin",
    "disk",
    "dislike",
    "disliking",
    "dislocate",
    "dislodge",
    "disloyal",
    "dismantle",
    "dismay",
    "dismiss",
    "dismount",
    "disobey",
    "disorder",
    "disown",
    "disparate",
    "disparity",
    "dispatch",
    "dispense",
    "dispersal",
    "dispersed",
    "disperser",
    "displace",
    "display",
    "displease",
    "disposal",
    "dispose",
    "disprove",
    "dispute",
    "disregard",
    "disrupt",
    "dissuade",
    "distance",
    "distant",
    "distaste",
    "distill",
    "distinct",
    "distort",
    "distract",
    "distress",
    "district",
    "distrust",
    "ditch",
    "ditto",
    "ditzy",
    "dividable",
    "divided",
    "dividend",
    "dividers",
    "dividing",
    "divinely",
    "diving",
    "divinity",
    "divisible",
    "divisibly",
    "division",
    "divisive",
    "divorcee",
    "dizziness",
    "dizzy",
    "doable",
    "docile",
    "dock",
    "doctrine",
    "document",
    "dodge",
    "dodgy",
    "doily",
    "doing",
    "dole",
    "dollar",
    "dollhouse",
    "dollop",
    "dolly",
    "dolphin",
    "domain",
    "domelike",
    "domestic",
    "dominion",
    "dominoes",
    "donated",
    "donation",
    "donator",
    "donor",
    "donut",
    "doodle",
    "doorbell",
    "doorframe",
    "doorknob",
    "doorman",
    "doormat",
    "doornail",
    "doorpost",
    "doorstep",
    "doorstop",
    "doorway",
    "doozy",
    "dork",
    "dormitory",
    "dorsal",
    "dosage",
    "dose",
    "dotted",
    "doubling",
    "douche",
    "dove",
    "down",
    "dowry",
    "doze",
    "drab",
    "dragging",
    "dragonfly",
    "dragonish",
    "dragster",
    "drainable",
    "drainage",
    "drained",
    "drainer",
    "drainpipe",
    "dramatic",
    "dramatize",
    "drank",
    "drapery",
    "drastic",
    "draw",
    "dreaded",
    "dreadful",
    "dreadlock",
    "dreamboat",
    "dreamily",
    "dreamland",
    "dreamless",
    "dreamlike",
    "dreamt",
    "dreamy",
    "drearily",
    "dreary",
    "drench",
    "dress",
    "drew",
    "dribble",
    "dried",
    "drier",
    "drift",
    "driller",
    "drilling",
    "drinkable",
    "drinking",
    "dripping",
    "drippy",
    "drivable",
    "driven",
    "driver",
    "driveway",
    "driving",
    "drizzle",
    "drizzly",
    "drone",
    "drool",
    "droop",
    "drop-down",
    "dropbox",
    "dropkick",
    "droplet",
    "dropout",
    "dropper",
    "drove",
    "drown",
    "drowsily",
    "drudge",
    "drum",
    "dry",
    "dubbed",
    "dubiously",
    "duchess",
    "duckbill",
    "ducking",
    "duckling",
    "ducktail",
    "ducky",
    "duct",
    "dude",
    "duffel",
    "dugout",
    "duh",
    "duke",
    "duller",
    "dullness",
    "duly",
    "dumping",
    "dumpling",
    "dumpster",
    "duo",
    "dupe",
    "duplex",
    "duplicate",
    "duplicity",
    "durable",
    "durably",
    "duration",
    "duress",
    "during",
    "dusk",
    "dust",
    "dutiful",
    "duty",
    "duvet",
    "dwarf",
    "dweeb",
    "dwelled",
    "dweller",
    "dwelling",
    "dwindle",
    "dwindling",
    "dynamic",
    "dynamite",
    "dynasty",
    "dyslexia",
    "dyslexic",
    "each",
    "eagle",
    "earache",
    "eardrum",
    "earflap",
    "earful",
    "earlobe",
    "early",
    "earmark",
    "earmuff",
    "earphone",
    "earpiece",
    "earplugs",
    "earring",
    "earshot",
    "earthen",
    "earthlike",
    "earthling",
    "earthly",
    "earthworm",
    "earthy",
    "earwig",
    "easeful",
    "easel",
    "easiest",
    "easily",
    "easiness",
    "easing",
    "eastbound",
    "eastcoast",
    "easter",
    "eastward",
    "eatable",
    "eaten",
    "eatery",
    "eating",
    "eats",
    "ebay",
    "ebony",
    "ebook",
    "ecard",
    "eccentric",
    "echo",
    "eclair",
    "eclipse",
    "ecologist",
    "ecology",
    "economic",
    "economist",
    "economy",
    "ecosphere",
    "ecosystem",
    "edge",
    "edginess",
    "edging",
    "edgy",
    "edition",
    "editor",
    "educated",
    "education",
    "educator",
    "eel",
    "effective",
    "effects",
    "efficient",
    "effort",
    "eggbeater",
    "egging",
    "eggnog",
    "eggplant",
    "eggshell",
    "egomaniac",
    "egotism",
    "egotistic",
    "either",
    "eject",
    "elaborate",
    "elastic",
    "elated",
    "elbow",
    "eldercare",
    "elderly",
    "eldest",
    "electable",
    "election",
    "elective",
    "elephant",
    "elevate",
    "elevating",
    "elevation",
    "elevator",
    "eleven",
    "elf",
    "eligible",
    "eligibly",
    "eliminate",
    "elite",
    "elitism",
    "elixir",
    "elk",
    "ellipse",
    "elliptic",
    "elm",
    "elongated",
    "elope",
    "eloquence",
    "eloquent",
    "elsewhere",
    "elude",
    "elusive",
    "elves",
    "email",
    "embargo",
    "embark",
    "embassy",
    "embattled",
    "embellish",
    "ember",
    "embezzle",
    "emblaze",
    "emblem",
    "embody",
    "embolism",
    "emboss",
    "embroider",
    "emcee",
    "emerald",
    "emergency",
    "emission",
    "emit",
    "emote",
    "emoticon",
    "emotion",
    "empathic",
    "empathy",
    "emperor",
    "emphases",
    "emphasis",
    "emphasize",
    "emphatic",
    "empirical",
    "employed",
    "employee",
    "employer",
    "emporium",
    "empower",
    "emptier",
    "emptiness",
    "empty",
    "emu",
    "enable",
    "enactment",
    "enamel",
    "enchanted",
    "enchilada",
    "encircle",
    "enclose",
    "enclosure",
    "encode",
    "encore",
    "encounter",
    "encourage",
    "encroach",
    "encrust",
    "encrypt",
    "endanger",
    "endeared",
    "endearing",
    "ended",
    "ending",
    "endless",
    "endnote",
    "endocrine",
    "endorphin",
    "endorse",
    "endowment",
    "endpoint",
    "endurable",
    "endurance",
    "enduring",
    "energetic",
    "energize",
    "energy",
    "enforced",
    "enforcer",
    "engaged",
    "engaging",
    "engine",
    "engorge",
    "engraved",
    "engraver",
    "engraving",
    "engross",
    "engulf",
    "enhance",
    "enigmatic",
    "enjoyable",
    "enjoyably",
    "enjoyer",
    "enjoying",
    "enjoyment",
    "enlarged",
    "enlarging",
    "enlighten",
    "enlisted",
    "enquirer",
    "enrage",
    "enrich",
    "enroll",
    "enslave",
    "ensnare",
    "ensure",
    "entail",
    "entangled",
    "entering",
    "entertain",
    "enticing",
    "entire",
    "entitle",
    "entity",
    "entomb",
    "entourage",
    "entrap",
    "entree",
    "entrench",
    "entrust",
    "entryway",
    "entwine",
    "enunciate",
    "envelope",
    "enviable",
    "enviably",
    "envious",
    "envision",
    "envoy",
    "envy",
    "enzyme",
    "epic",
    "epidemic",
    "epidermal",
    "epidermis",
    "epidural",
    "epilepsy",
    "epileptic",
    "epilogue",
    "epiphany",
    "episode",
    "equal",
    "equate",
    "equation",
    "equator",
    "equinox",
    "equipment",
    "equity",
    "equivocal",
    "eradicate",
    "erasable",
    "erased",
    "eraser",
    "erasure",
    "ergonomic",
    "errand",
    "errant",
    "erratic",
    "error",
    "erupt",
    "escalate",
    "escalator",
    "escapable",
    "escapade",
    "escapist",
    "escargot",
    "eskimo",
    "esophagus",
    "espionage",
    "espresso",
    "esquire",
    "essay",
    "essence",
    "essential",
    "establish",
    "estate",
    "esteemed",
    "estimate",
    "estimator",
    "estranged",
    "estrogen",
    "etching",
    "eternal",
    "eternity",
    "ethanol",
    "ether",
    "ethically",
    "ethics",
    "euphemism",
    "evacuate",
    "evacuee",
    "evade",
    "evaluate",
    "evaluator",
    "evaporate",
    "evasion",
    "evasive",
    "even",
    "everglade",
    "evergreen",
    "everybody",
    "everyday",
    "everyone",
    "evict",
    "evidence",
    "evident",
    "evil",
    "evoke",
    "evolution",
    "evolve",
    "exact",
    "exalted",
    "example",
    "excavate",
    "excavator",
    "exceeding",
    "exception",
    "excess",
    "exchange",
    "excitable",
    "exciting",
    "exclaim",
    "exclude",
    "excluding",
    "exclusion",
    "exclusive",
    "excretion",
    "excretory",
    "excursion",
    "excusable",
    "excusably",
    "excuse",
    "exemplary",
    "exemplify",
    "exemption",
    "exerciser",
    "exert",
    "exes",
    "exfoliate",
    "exhale",
    "exhaust",
    "exhume",
    "exile",
    "existing",
    "exit",
    "exodus",
    "exonerate",
    "exorcism",
    "exorcist",
    "expand",
    "expanse",
    "expansion",
    "expansive",
    "expectant",
    "expedited",
    "expediter",
    "expel",
    "expend",
    "expenses",
    "expensive",
    "expert",
    "expire",
    "expiring",
    "explain",
    "expletive",
    "explicit",
    "explode",
    "exploit",
    "explore",
    "exploring",
    "exponent",
    "exporter",
    "exposable",
    "expose",
    "exposure",
    "express",
    "expulsion",
    "exquisite",
    "extended",
    "extending",
    "extent",
    "extenuate",
    "exterior",
    "external",
    "extinct",
    "extortion",
    "extradite",
    "extras",
    "extrovert",
    "extrude",
    "extruding",
    "exuberant",
    "fable",
    "fabric",
    "fabulous",
    "facebook",
    "facecloth",
    "facedown",
    "faceless",
    "facelift",
    "faceplate",
    "faceted",
    "facial",
    "facility",
    "facing",
    "facsimile",
    "faction",
    "factoid",
    "factor",
    "factsheet",
    "factual",
    "faculty",
    "fade",
    "fading",
    "failing",
    "falcon",
    "fall",
    "false",
    "falsify",
    "fame",
    "familiar",
    "family",
    "famine",
    "famished",
    "fanatic",
    "fancied",
    "fanciness",
    "fancy",
    "fanfare",
    "fang",
    "fanning",
    "fantasize",
    "fantastic",
    "fantasy",
    "fascism",
    "fastball",
    "faster",
    "fasting",
    "fastness",
    "faucet",
    "favorable",
    "favorably",
    "favored",
    "favoring",
    "favorite",
    "fax",
    "feast",
    "federal",
    "fedora",
    "feeble",
    "feed",
    "feel",
    "feisty",
    "feline",
    "felt-tip",
    "feminine",
    "feminism",
    "feminist",
    "feminize",
    "femur",
    "fence",
    "fencing",
    "fender",
    "ferment",
    "fernlike",
    "ferocious",
    "ferocity",
    "ferret",
    "ferris",
    "ferry",
    "fervor",
    "fester",
    "festival",
    "festive",
    "festivity",
    "fetal",
    "fetch",
    "fever",
    "fiber",
    "fiction",
    "fiddle",
    "fiddling",
    "fidelity",
    "fidgeting",
    "fidgety",
    "fifteen",
    "fifth",
    "fiftieth",
    "fifty",
    "figment",
    "figure",
    "figurine",
    "filing",
    "filled",
    "filler",
    "filling",
    "film",
    "filter",
    "filth",
    "filtrate",
    "finale",
    "finalist",
    "finalize",
    "finally",
    "finance",
    "financial",
    "finch",
    "fineness",
    "finer",
    "finicky",
    "finished",
    "finisher",
    "finishing",
    "finite",
    "finless",
    "finlike",
    "fiscally",
    "fit",
    "five",
    "flaccid",
    "flagman",
    "flagpole",
    "flagship",
    "flagstick",
    "flagstone",
    "flail",
    "flakily",
    "flaky",
    "flame",
    "flammable",
    "flanked",
    "flanking",
    "flannels",
    "flap",
    "flaring",
    "flashback",
    "flashbulb",
    "flashcard",
    "flashily",
    "flashing",
    "flashy",
    "flask",
    "flatbed",
    "flatfoot",
    "flatly",
    "flatness",
    "flatten",
    "flattered",
    "flatterer",
    "flattery",
    "flattop",
    "flatware",
    "flatworm",
    "flavored",
    "flavorful",
    "flavoring",
    "flaxseed",
    "fled",
    "fleshed",
    "fleshy",
    "flick",
    "flier",
    "flight",
    "flinch",
    "fling",
    "flint",
    "flip",
    "flirt",
    "float",
    "flock",
    "flogging",
    "flop",
    "floral",
    "florist",
    "floss",
    "flounder",
    "flyable",
    "flyaway",
    "flyer",
    "flying",
    "flyover",
    "flypaper",
    "foam",
    "foe",
    "fog",
    "foil",
    "folic",
    "folk",
    "follicle",
    "follow",
    "fondling",
    "fondly",
    "fondness",
    "fondue",
    "font",
    "food",
    "fool",
    "footage",
    "football",
    "footbath",
    "footboard",
    "footer",
    "footgear",
    "foothill",
    "foothold",
    "footing",
    "footless",
    "footman",
    "footnote",
    "footpad",
    "footpath",
    "footprint",
    "footrest",
    "footsie",
    "footsore",
    "footwear",
    "footwork",
    "fossil",
    "foster",
    "founder",
    "founding",
    "fountain",
    "fox",
    "foyer",
    "fraction",
    "fracture",
    "fragile",
    "fragility",
    "fragment",
    "fragrance",
    "fragrant",
    "frail",
    "frame",
    "framing",
    "frantic",
    "fraternal",
    "frayed",
    "fraying",
    "frays",
    "freckled",
    "freckles",
    "freebase",
    "freebee",
    "freebie",
    "freedom",
    "freefall",
    "freehand",
    "freeing",
    "freeload",
    "freely",
    "freemason",
    "freeness",
    "freestyle",
    "freeware",
    "freeway",
    "freewill",
    "freezable",
    "freezing",
    "freight",
    "french",
    "frenzied",
    "frenzy",
    "frequency",
    "frequent",
    "fresh",
    "fretful",
    "fretted",
    "friction",
    "friday",
    "fridge",
    "fried",
    "friend",
    "frighten",
    "frightful",
    "frigidity",
    "frigidly",
    "frill",
    "fringe",
    "frisbee",
    "frisk",
    "fritter",
    "frivolous",
    "frolic",
    "from",
    "front",
    "frostbite",
    "frosted",
    "frostily",
    "frosting",
    "frostlike",
    "frosty",
    "froth",
    "frown",
    "frozen",
    "fructose",
    "frugality",
    "frugally",
    "fruit",
    "frustrate",
    "frying",
    "gab",
    "gaffe",
    "gag",
    "gainfully",
    "gaining",
    "gains",
    "gala",
    "gallantly",
    "galleria",
    "gallery",
    "galley",
    "gallon",
    "gallows",
    "gallstone",
    "galore",
    "galvanize",
    "gambling",
    "game",
    "gaming",
    "gamma",
    "gander",
    "gangly",
    "gangrene",
    "gangway",
    "gap",
    "garage",
    "garbage",
    "garden",
    "gargle",
    "garland",
    "garlic",
    "garment",
    "garnet",
    "garnish",
    "garter",
    "gas",
    "gatherer",
    "gathering",
    "gating",
    "gauging",
    "gauntlet",
    "gauze",
    "gave",
    "gawk",
    "gazing",
    "gear",
    "gecko",
    "geek",
    "geiger",
    "gem",
    "gender",
    "generic",
    "generous",
    "genetics",
    "genre",
    "gentile",
    "gentleman",
    "gently",
    "gents",
    "geography",
    "geologic",
    "geologist",
    "geology",
    "geometric",
    "geometry",
    "geranium",
    "gerbil",
    "geriatric",
    "germicide",
    "germinate",
    "germless",
    "germproof",
    "gestate",
    "gestation",
    "gesture",
    "getaway",
    "getting",
    "getup",
    "giant",
    "gibberish",
    "giblet",
    "giddily",
    "giddiness",
    "giddy",
    "gift",
    "gigabyte",
    "gigahertz",
    "gigantic",
    "giggle",
    "giggling",
    "giggly",
    "gigolo",
    "gilled",
    "gills",
    "gimmick",
    "girdle",
    "giveaway",
    "given",
    "giver",
    "giving",
    "gizmo",
    "gizzard",
    "glacial",
    "glacier",
    "glade",
    "gladiator",
    "gladly",
    "glamorous",
    "glamour",
    "glance",
    "glancing",
    "glandular",
    "glare",
    "glaring",
    "glass",
    "glaucoma",
    "glazing",
    "gleaming",
    "gleeful",
    "glider",
    "gliding",
    "glimmer",
    "glimpse",
    "glisten",
    "glitch",
    "glitter",
    "glitzy",
    "gloater",
    "gloating",
    "gloomily",
    "gloomy",
    "glorified",
    "glorifier",
    "glorify",
    "glorious",
    "glory",
    "gloss",
    "glove",
    "glowing",
    "glowworm",
    "glucose",
    "glue",
    "gluten",
    "glutinous",
    "glutton",
    "gnarly",
    "gnat",
    "goal",
    "goatskin",
    "goes",
    "goggles",
    "going",
    "goldfish",
    "goldmine",
    "goldsmith",
    "golf",
    "goliath",
    "gonad",
    "gondola",
    "gone",
    "gong",
    "good",
    "gooey",
    "goofball",
    "goofiness",
    "goofy",
    "google",
    "goon",
    "gopher",
    "gore",
    "gorged",
    "gorgeous",
    "gory",
    "gosling",
    "gossip",
    "gothic",
    "gotten",
    "gout",
    "gown",
    "grab",
    "graceful",
    "graceless",
    "gracious",
    "gradation",
    "graded",
    "grader",
    "gradient",
    "grading",
    "gradually",
    "graduate",
    "graffiti",
    "grafted",
    "grafting",
    "grain",
    "granddad",
    "grandkid",
    "grandly",
    "grandma",
    "grandpa",
    "grandson",
    "granite",
    "granny",
    "granola",
    "grant",
    "granular",
    "grape",
    "graph",
    "grapple",
    "grappling",
    "grasp",
    "grass",
    "gratified",
    "gratify",
    "grating",
    "gratitude",
    "gratuity",
    "gravel",
    "graveness",
    "graves",
    "graveyard",
    "gravitate",
    "gravity",
    "gravy",
    "gray",
    "grazing",
    "greasily",
    "greedily",
    "greedless",
    "greedy",
    "green",
    "greeter",
    "greeting",
    "grew",
    "greyhound",
    "grid",
    "grief",
    "grievance",
    "grieving",
    "grievous",
    "grill",
    "grimace",
    "grimacing",
    "grime",
    "griminess",
    "grimy",
    "grinch",
    "grinning",
    "grip",
    "gristle",
    "grit",
    "groggily",
    "groggy",
    "groin",
    "groom",
    "groove",
    "grooving",
    "groovy",
    "grope",
    "ground",
    "grouped",
    "grout",
    "grove",
    "grower",
    "growing",
    "growl",
    "grub",
    "grudge",
    "grudging",
    "grueling",
    "gruffly",
    "grumble",
    "grumbling",
    "grumbly",
    "grumpily",
    "grunge",
    "grunt",
    "guacamole",
    "guidable",
    "guidance",
    "guide",
    "guiding",
    "guileless",
    "guise",
    "gulf",
    "gullible",
    "gully",
    "gulp",
    "gumball",
    "gumdrop",
    "gumminess",
    "gumming",
    "gummy",
    "gurgle",
    "gurgling",
    "guru",
    "gush",
    "gusto",
    "gusty",
    "gutless",
    "guts",
    "gutter",
    "guy",
    "guzzler",
    "gyration",
    "habitable",
    "habitant",
    "habitat",
    "habitual",
    "hacked",
    "hacker",
    "hacking",
    "hacksaw",
    "had",
    "haggler",
    "haiku",
    "half",
    "halogen",
    "halt",
    "halved",
    "halves",
    "hamburger",
    "hamlet",
    "hammock",
    "hamper",
    "hamster",
    "hamstring",
    "handbag",
    "handball",
    "handbook",
    "handbrake",
    "handcart",
    "handclap",
    "handclasp",
    "handcraft",
    "handcuff",
    "handed",
    "handful",
    "handgrip",
    "handgun",
    "handheld",
    "handiness",
    "handiwork",
    "handlebar",
    "handled",
    "handler",
    "handling",
    "handmade",
    "handoff",
    "handpick",
    "handprint",
    "handrail",
    "handsaw",
    "handset",
    "handsfree",
    "handshake",
    "handstand",
    "handwash",
    "handwork",
    "handwoven",
    "handwrite",
    "handyman",
    "hangnail",
    "hangout",
    "hangover",
    "hangup",
    "hankering",
    "hankie",
    "hanky",
    "haphazard",
    "happening",
    "happier",
    "happiest",
    "happily",
    "happiness",
    "happy",
    "harbor",
    "hardcopy",
    "hardcore",
    "hardcover",
    "harddisk",
    "hardened",
    "hardener",
    "hardening",
    "hardhat",
    "hardhead",
    "hardiness",
    "hardly",
    "hardness",
    "hardship",
    "hardware",
    "hardwired",
    "hardwood",
    "hardy",
    "harmful",
    "harmless",
    "harmonica",
    "harmonics",
    "harmonize",
    "harmony",
    "harness",
    "harpist",
    "harsh",
    "harvest",
    "hash",
    "hassle",
    "haste",
    "hastily",
    "hastiness",
    "hasty",
    "hatbox",
    "hatchback",
    "hatchery",
    "hatchet",
    "hatching",
    "hatchling",
    "hate",
    "hatless",
    "hatred",
    "haunt",
    "haven",
    "hazard",
    "hazelnut",
    "hazily",
    "haziness",
    "hazing",
    "hazy",
    "headache",
    "headband",
    "headboard",
    "headcount",
    "headdress",
    "headed",
    "header",
    "headfirst",
    "headgear",
    "heading",
    "headlamp",
    "headless",
    "headlock",
    "headphone",
    "headpiece",
    "headrest",
    "headroom",
    "headscarf",
    "headset",
    "headsman",
    "headstand",
    "headstone",
    "headway",
    "headwear",
    "heap",
    "heat",
    "heave",
    "heavily",
    "heaviness",
    "heaving",
    "hedge",
    "hedging",
    "heftiness",
    "hefty",
    "helium",
    "helmet",
    "helper",
    "helpful",
    "helping",
    "helpless",
    "helpline",
    "hemlock",
    "hemstitch",
    "hence",
    "henchman",
    "henna",
    "herald",
    "herbal",
    "herbicide",
    "herbs",
    "heritage",
    "hermit",
    "heroics",
    "heroism",
    "herring",
    "herself",
    "hertz",
    "hesitancy",
    "hesitant",
    "hesitate",
    "hexagon",
    "hexagram",
    "hubcap",
    "huddle",
    "huddling",
    "huff",
    "hug",
    "hula",
    "hulk",
    "hull",
    "human",
    "humble",
    "humbling",
    "humbly",
    "humid",
    "humiliate",
    "humility",
    "humming",
    "hummus",
    "humongous",
    "humorist",
    "humorless",
    "humorous",
    "humpback",
    "humped",
    "humvee",
    "hunchback",
    "hundredth",
    "hunger",
    "hungrily",
    "hungry",
    "hunk",
    "hunter",
    "hunting",
    "huntress",
    "huntsman",
    "hurdle",
    "hurled",
    "hurler",
    "hurling",
    "hurray",
    "hurricane",
    "hurried",
    "hurry",
    "hurt",
    "husband",
    "hush",
    "husked",
    "huskiness",
    "hut",
    "hybrid",
    "hydrant",
    "hydrated",
    "hydration",
    "hydrogen",
    "hydroxide",
    "hyperlink",
    "hypertext",
    "hyphen",
    "hypnoses",
    "hypnosis",
    "hypnotic",
    "hypnotism",
    "hypnotist",
    "hypnotize",
    "hypocrisy",
    "hypocrite",
    "ibuprofen",
    "ice",
    "iciness",
    "icing",
    "icky",
    "icon",
    "icy",
    "idealism",
    "idealist",
    "idealize",
    "ideally",
    "idealness",
    "identical",
    "identify",
    "identity",
    "ideology",
    "idiocy",
    "idiom",
    "idly",
    "igloo",
    "ignition",
    "ignore",
    "iguana",
    "illicitly",
    "illusion",
    "illusive",
    "image",
    "imaginary",
    "imagines",
    "imaging",
    "imbecile",
    "imitate",
    "imitation",
    "immature",
    "immerse",
    "immersion",
    "imminent",
    "immobile",
    "immodest",
    "immorally",
    "immortal",
    "immovable",
    "immovably",
    "immunity",
    "immunize",
    "impaired",
    "impale",
    "impart",
    "impatient",
    "impeach",
    "impeding",
    "impending",
    "imperfect",
    "imperial",
    "impish",
    "implant",
    "implement",
    "implicate",
    "implicit",
    "implode",
    "implosion",
    "implosive",
    "imply",
    "impolite",
    "important",
    "importer",
    "impose",
    "imposing",
    "impotence",
    "impotency",
    "impotent",
    "impound",
    "imprecise",
    "imprint",
    "imprison",
    "impromptu",
    "improper",
    "improve",
    "improving",
    "improvise",
    "imprudent",
    "impulse",
    "impulsive",
    "impure",
    "impurity",
    "iodine",
    "iodize",
    "ion",
    "ipad",
    "iphone",
    "ipod",
    "irate",
    "irk",
    "iron",
    "irregular",
    "irrigate",
    "irritable",
    "irritably",
    "irritant",
    "irritate",
    "islamic",
    "islamist",
    "isolated",
    "isolating",
    "isolation",
    "isotope",
    "issue",
    "issuing",
    "italicize",
    "italics",
    "item",
    "itinerary",
    "itunes",
    "ivory",
    "ivy",
    "jab",
    "jackal",
    "jacket",
    "jackknife",
    "jackpot",
    "jailbird",
    "jailbreak",
    "jailer",
    "jailhouse",
    "jalapeno",
    "jam",
    "janitor",
    "january",
    "jargon",
    "jarring",
    "jasmine",
    "jaundice",
    "jaunt",
    "java",
    "jawed",
    "jawless",
    "jawline",
    "jaws",
    "jaybird",
    "jaywalker",
    "jazz",
    "jeep",
    "jeeringly",
    "jellied",
    "jelly",
    "jersey",
    "jester",
    "jet",
    "jiffy",
    "jigsaw",
    "jimmy",
    "jingle",
    "jingling",
    "jinx",
    "jitters",
    "jittery",
    "job",
    "jockey",
    "jockstrap",
    "jogger",
    "jogging",
    "john",
    "joining",
    "jokester",
    "jokingly",
    "jolliness",
    "jolly",
    "jolt",
    "jot",
    "jovial",
    "joyfully",
    "joylessly",
    "joyous",
    "joyride",
    "joystick",
    "jubilance",
    "jubilant",
    "judge",
    "judgingly",
    "judicial",
    "judiciary",
    "judo",
    "juggle",
    "juggling",
    "jugular",
    "juice",
    "juiciness",
    "juicy",
    "jujitsu",
    "jukebox",
    "july",
    "jumble",
    "jumbo",
    "jump",
    "junction",
    "juncture",
    "june",
    "junior",
    "juniper",
    "junkie",
    "junkman",
    "junkyard",
    "jurist",
    "juror",
    "jury",
    "justice",
    "justifier",
    "justify",
    "justly",
    "justness",
    "juvenile",
    "kabob",
    "kangaroo",
    "karaoke",
    "karate",
    "karma",
    "kebab",
    "keenly",
    "keenness",
    "keep",
    "keg",
    "kelp",
    "kennel",
    "kept",
    "kerchief",
    "kerosene",
    "kettle",
    "kick",
    "kiln",
    "kilobyte",
    "kilogram",
    "kilometer",
    "kilowatt",
    "kilt",
    "kimono",
    "kindle",
    "kindling",
    "kindly",
    "kindness",
    "kindred",
    "kinetic",
    "kinfolk",
    "king",
    "kinship",
    "kinsman",
    "kinswoman",
    "kissable",
    "kisser",
    "kissing",
    "kitchen",
    "kite",
    "kitten",
    "kitty",
    "kiwi",
    "kleenex",
    "knapsack",
    "knee",
    "knelt",
    "knickers",
    "knoll",
    "koala",
    "kooky",
    "kosher",
    "krypton",
    "kudos",
    "kung",
    "labored",
    "laborer",
    "laboring",
    "laborious",
    "labrador",
    "ladder",
    "ladies",
    "ladle",
    "ladybug",
    "ladylike",
    "lagged",
    "lagging",
    "lagoon",
    "lair",
    "lake",
    "lance",
    "landed",
    "landfall",
    "landfill",
    "landing",
    "landlady",
    "landless",
    "landline",
    "landlord",
    "landmark",
    "landmass",
    "landmine",
    "landowner",
    "landscape",
    "landside",
    "landslide",
    "language",
    "lankiness",
    "lanky",
    "lantern",
    "lapdog",
    "lapel",
    "lapped",
    "lapping",
    "laptop",
    "lard",
    "large",
    "lark",
    "lash",
    "lasso",
    "last",
    "latch",
    "late",
    "lather",
    "latitude",
    "latrine",
    "latter",
    "latticed",
    "launch",
    "launder",
    "laundry",
    "laurel",
    "lavender",
    "lavish",
    "laxative",
    "lazily",
    "laziness",
    "lazy",
    "lecturer",
    "left",
    "legacy",
    "legal",
    "legend",
    "legged",
    "leggings",
    "legible",
    "legibly",
    "legislate",
    "lego",
    "legroom",
    "legume",
    "legwarmer",
    "legwork",
    "lemon",
    "lend",
    "length",
    "lens",
    "lent",
    "leotard",
    "lesser",
    "letdown",
    "lethargic",
    "lethargy",
    "letter",
    "lettuce",
    "level",
    "leverage",
    "levers",
    "levitate",
    "levitator",
    "liability",
    "liable",
    "liberty",
    "librarian",
    "library",
    "licking",
    "licorice",
    "lid",
    "life",
    "lifter",
    "lifting",
    "liftoff",
    "ligament",
    "likely",
    "likeness",
    "likewise",
    "liking",
    "lilac",
    "lilly",
    "lily",
    "limb",
    "limeade",
    "limelight",
    "limes",
    "limit",
    "limping",
    "limpness",
    "line",
    "lingo",
    "linguini",
    "linguist",
    "lining",
    "linked",
    "linoleum",
    "linseed",
    "lint",
    "lion",
    "lip",
    "liquefy",
    "liqueur",
    "liquid",
    "lisp",
    "list",
    "litigate",
    "litigator",
    "litmus",
    "litter",
    "little",
    "livable",
    "lived",
    "lively",
    "liver",
    "livestock",
    "lividly",
    "living",
    "lizard",
    "lubricant",
    "lubricate",
    "lucid",
    "luckily",
    "luckiness",
    "luckless",
    "lucrative",
    "ludicrous",
    "lugged",
    "lukewarm",
    "lullaby",
    "lumber",
    "luminance",
    "luminous",
    "lumpiness",
    "lumping",
    "lumpish",
    "lunacy",
    "lunar",
    "lunchbox",
    "luncheon",
    "lunchroom",
    "lunchtime",
    "lung",
    "lurch",
    "lure",
    "luridness",
    "lurk",
    "lushly",
    "lushness",
    "luster",
    "lustfully",
    "lustily",
    "lustiness",
    "lustrous",
    "lusty",
    "luxurious",
    "luxury",
    "lying",
    "lyrically",
    "lyricism",
    "lyricist",
    "lyrics",
    "macarena",
    "macaroni",
    "macaw",
    "mace",
    "machine",
    "machinist",
    "magazine",
    "magenta",
    "maggot",
    "magical",
    "magician",
    "magma",
    "magnesium",
    "magnetic",
    "magnetism",
    "magnetize",
    "magnifier",
    "magnify",
    "magnitude",
    "magnolia",
    "mahogany",
    "maimed",
    "majestic",
    "majesty",
    "majorette",
    "majority",
    "makeover",
    "maker",
    "makeshift",
    "making",
    "malformed",
    "malt",
    "mama",
    "mammal",
    "mammary",
    "mammogram",
    "manager",
    "managing",
    "manatee",
    "mandarin",
    "mandate",
    "mandatory",
    "mandolin",
    "manger",
    "mangle",
    "mango",
    "mangy",
    "manhandle",
    "manhole",
    "manhood",
    "manhunt",
    "manicotti",
    "manicure",
    "manifesto",
    "manila",
    "mankind",
    "manlike",
    "manliness",
    "manly",
    "manmade",
    "manned",
    "mannish",
    "manor",
    "manpower",
    "mantis",
    "mantra",
    "manual",
    "many",
    "map",
    "marathon",
    "marauding",
    "marbled",
    "marbles",
    "marbling",
    "march",
    "mardi",
    "margarine",
    "margarita",
    "margin",
    "marigold",
    "marina",
    "marine",
    "marital",
    "maritime",
    "marlin",
    "marmalade",
    "maroon",
    "married",
    "marrow",
    "marry",
    "marshland",
    "marshy",
    "marsupial",
    "marvelous",
    "marxism",
    "mascot",
    "masculine",
    "mashed",
    "mashing",
    "massager",
    "masses",
    "massive",
    "mastiff",
    "matador",
    "matchbook",
    "matchbox",
    "matcher",
    "matching",
    "matchless",
    "material",
    "maternal",
    "maternity",
    "math",
    "mating",
    "matriarch",
    "matrimony",
    "matrix",
    "matron",
    "matted",
    "matter",
    "maturely",
    "maturing",
    "maturity",
    "mauve",
    "maverick",
    "maximize",
    "maximum",
    "maybe",
    "mayday",
    "mayflower",
    "moaner",
    "moaning",
    "mobile",
    "mobility",
    "mobilize",
    "mobster",
    "mocha",
    "mocker",
    "mockup",
    "modified",
    "modify",
    "modular",
    "modulator",
    "module",
    "moisten",
    "moistness",
    "moisture",
    "molar",
    "molasses",
    "mold",
    "molecular",
    "molecule",
    "molehill",
    "mollusk",
    "mom",
    "monastery",
    "monday",
    "monetary",
    "monetize",
    "moneybags",
    "moneyless",
    "moneywise",
    "mongoose",
    "mongrel",
    "monitor",
    "monkhood",
    "monogamy",
    "monogram",
    "monologue",
    "monopoly",
    "monorail",
    "monotone",
    "monotype",
    "monoxide",
    "monsieur",
    "monsoon",
    "monstrous",
    "monthly",
    "monument",
    "moocher",
    "moodiness",
    "moody",
    "mooing",
    "moonbeam",
    "mooned",
    "moonlight",
    "moonlike",
    "moonlit",
    "moonrise",
    "moonscape",
    "moonshine",
    "moonstone",
    "moonwalk",
    "mop",
    "morale",
    "morality",
    "morally",
    "morbidity",
    "morbidly",
    "morphine",
    "morphing",
    "morse",
    "mortality",
    "mortally",
    "mortician",
    "mortified",
    "mortify",
    "mortuary",
    "mosaic",
    "mossy",
    "most",
    "mothball",
    "mothproof",
    "motion",
    "motivate",
    "motivator",
    "motive",
    "motocross",
    "motor",
    "motto",
    "mountable",
    "mountain",
    "mounted",
    "mounting",
    "mourner",
    "mournful",
    "mouse",
    "mousiness",
    "moustache",
    "mousy",
    "mouth",
    "movable",
    "move",
    "movie",
    "moving",
    "mower",
    "mowing",
    "much",
    "muck",
    "mud",
    "mug",
    "mulberry",
    "mulch",
    "mule",
    "mulled",
    "mullets",
    "multiple",
    "multiply",
    "multitask",
    "multitude",
    "mumble",
    "mumbling",
    "mumbo",
    "mummified",
    "mummify",
    "mummy",
    "mumps",
    "munchkin",
    "mundane",
    "municipal",
    "muppet",
    "mural",
    "murkiness",
    "murky",
    "murmuring",
    "muscular",
    "museum",
    "mushily",
    "mushiness",
    "mushroom",
    "mushy",
    "music",
    "musket",
    "muskiness",
    "musky",
    "mustang",
    "mustard",
    "muster",
    "mustiness",
    "musty",
    "mutable",
    "mutate",
    "mutation",
    "mute",
    "mutilated",
    "mutilator",
    "mutiny",
    "mutt",
    "mutual",
    "muzzle",
    "myself",
    "myspace",
    "mystified",
    "mystify",
    "myth",
    "nacho",
    "nag",
    "nail",
    "name",
    "naming",
    "nanny",
    "nanometer",
    "nape",
    "napkin",
    "napped",
    "napping",
    "nappy",
    "narrow",
    "nastily",
    "nastiness",
    "national",
    "native",
    "nativity",
    "natural",
    "nature",
    "naturist",
    "nautical",
    "navigate",
    "navigator",
    "navy",
    "nearby",
    "nearest",
    "nearly",
    "nearness",
    "neatly",
    "neatness",
    "nebula",
    "nebulizer",
    "nectar",
    "negate",
    "negation",
    "negative",
    "neglector",
    "negligee",
    "negligent",
    "negotiate",
    "nemeses",
    "nemesis",
    "neon",
    "nephew",
    "nerd",
    "nervous",
    "nervy",
    "nest",
    "net",
    "neurology",
    "neuron",
    "neurosis",
    "neurotic",
    "neuter",
    "neutron",
    "never",
    "next",
    "nibble",
    "nickname",
    "nicotine",
    "niece",
    "nifty",
    "nimble",
    "nimbly",
    "nineteen",
    "ninetieth",
    "ninja",
    "nintendo",
    "ninth",
    "nuclear",
    "nuclei",
    "nucleus",
    "nugget",
    "nullify",
    "number",
    "numbing",
    "numbly",
    "numbness",
    "numeral",
    "numerate",
    "numerator",
    "numeric",
    "numerous",
    "nuptials",
    "nursery",
    "nursing",
    "nurture",
    "nutcase",
    "nutlike",
    "nutmeg",
    "nutrient",
    "nutshell",
    "nuttiness",
    "nutty",
    "nuzzle",
    "nylon",
    "oaf",
    "oak",
    "oasis",
    "oat",
    "obedience",
    "obedient",
    "obituary",
    "object",
    "obligate",
    "obliged",
    "oblivion",
    "oblivious",
    "oblong",
    "obnoxious",
    "oboe",
    "obscure",
    "obscurity",
    "observant",
    "observer",
    "observing",
    "obsessed",
    "obsession",
    "obsessive",
    "obsolete",
    "obstacle",
    "obstinate",
    "obstruct",
    "obtain",
    "obtrusive",
    "obtuse",
    "obvious",
    "occultist",
    "occupancy",
    "occupant",
    "occupier",
    "occupy",
    "ocean",
    "ocelot",
    "octagon",
    "octane",
    "october",
    "octopus",
    "ogle",
    "oil",
    "oink",
    "ointment",
    "okay",
    "old",
    "olive",
    "olympics",
    "omega",
    "omen",
    "ominous",
    "omission",
    "omit",
    "omnivore",
    "onboard",
    "oncoming",
    "ongoing",
    "onion",
    "online",
    "onlooker",
    "only",
    "onscreen",
    "onset",
    "onshore",
    "onslaught",
    "onstage",
    "onto",
    "onward",
    "onyx",
    "oops",
    "ooze",
    "oozy",
    "opacity",
    "opal",
    "open",
    "operable",
    "operate",
    "operating",
    "operation",
    "operative",
    "operator",
    "opium",
    "opossum",
    "opponent",
    "oppose",
    "opposing",
    "opposite",
    "oppressed",
    "oppressor",
    "opt",
    "opulently",
    "osmosis",
    "other",
    "otter",
    "ouch",
    "ought",
    "ounce",
    "outage",
    "outback",
    "outbid",
    "outboard",
    "outbound",
    "outbreak",
    "outburst",
    "outcast",
    "outclass",
    "outcome",
    "outdated",
    "outdoors",
    "outer",
    "outfield",
    "outfit",
    "outflank",
    "outgoing",
    "outgrow",
    "outhouse",
    "outing",
    "outlast",
    "outlet",
    "outline",
    "outlook",
    "outlying",
    "outmatch",
    "outmost",
    "outnumber",
    "outplayed",
    "outpost",
    "outpour",
    "output",
    "outrage",
    "outrank",
    "outreach",
    "outright",
    "outscore",
    "outsell",
    "outshine",
    "outshoot",
    "outsider",
    "outskirts",
    "outsmart",
    "outsource",
    "outspoken",
    "outtakes",
    "outthink",
    "outward",
    "outweigh",
    "outwit",
    "oval",
    "ovary",
    "oven",
    "overact",
    "overall",
    "overarch",
    "overbid",
    "overbill",
    "overbite",
    "overblown",
    "overboard",
    "overbook",
    "overbuilt",
    "overcast",
    "overcoat",
    "overcome",
    "overcook",
    "overcrowd",
    "overdraft",
    "overdrawn",
    "overdress",
    "overdrive",
    "overdue",
    "overeager",
    "overeater",
    "overexert",
    "overfed",
    "overfeed",
    "overfill",
    "overflow",
    "overfull",
    "overgrown",
    "overhand",
    "overhang",
    "overhaul",
    "overhead",
    "overhear",
    "overheat",
    "overhung",
    "overjoyed",
    "overkill",
    "overlabor",
    "overlaid",
    "overlap",
    "overlay",
    "overload",
    "overlook",
    "overlord",
    "overlying",
    "overnight",
    "overpass",
    "overpay",
    "overplant",
    "overplay",
    "overpower",
    "overprice",
    "overrate",
    "overreach",
    "overreact",
    "override",
    "overripe",
    "overrule",
    "overrun",
    "overshoot",
    "overshot",
    "oversight",
    "oversized",
    "oversleep",
    "oversold",
    "overspend",
    "overstate",
    "overstay",
    "overstep",
    "overstock",
    "overstuff",
    "oversweet",
    "overtake",
    "overthrow",
    "overtime",
    "overtly",
    "overtone",
    "overture",
    "overturn",
    "overuse",
    "overvalue",
    "overview",
    "overwrite",
    "owl",
    "oxford",
    "oxidant",
    "oxidation",
    "oxidize",
    "oxidizing",
    "oxygen",
    "oxymoron",
    "oyster",
    "ozone",
    "paced",
    "pacemaker",
    "pacific",
    "pacifier",
    "pacifism",
    "pacifist",
    "pacify",
    "padded",
    "padding",
    "paddle",
    "paddling",
    "padlock",
    "pagan",
    "pager",
    "paging",
    "pajamas",
    "palace",
    "palatable",
    "palm",
    "palpable",
    "palpitate",
    "paltry",
    "pampered",
    "pamperer",
    "pampers",
    "pamphlet",
    "panama",
    "pancake",
    "pancreas",
    "panda",
    "pandemic",
    "pang",
    "panhandle",
    "panic",
    "panning",
    "panorama",
    "panoramic",
    "panther",
    "pantomime",
    "pantry",
    "pants",
    "pantyhose",
    "paparazzi",
    "papaya",
    "paper",
    "paprika",
    "papyrus",
    "parabola",
    "parachute",
    "parade",
    "paradox",
    "paragraph",
    "parakeet",
    "paralegal",
    "paralyses",
    "paralysis",
    "paralyze",
    "paramedic",
    "parameter",
    "paramount",
    "parasail",
    "parasite",
    "parasitic",
    "parcel",
    "parched",
    "parchment",
    "pardon",
    "parish",
    "parka",
    "parking",
    "parkway",
    "parlor",
    "parmesan",
    "parole",
    "parrot",
    "parsley",
    "parsnip",
    "partake",
    "parted",
    "parting",
    "partition",
    "partly",
    "partner",
    "partridge",
    "party",
    "passable",
    "passably",
    "passage",
    "passcode",
    "passenger",
    "passerby",
    "passing",
    "passion",
    "passive",
    "passivism",
    "passover",
    "passport",
    "password",
    "pasta",
    "pasted",
    "pastel",
    "pastime",
    "pastor",
    "pastrami",
    "pasture",
    "pasty",
    "patchwork",
    "patchy",
    "paternal",
    "paternity",
    "path",
    "patience",
    "patient",
    "patio",
    "patriarch",
    "patriot",
    "patrol",
    "patronage",
    "patronize",
    "pauper",
    "pavement",
    "paver",
    "pavestone",
    "pavilion",
    "paving",
    "pawing",
    "payable",
    "payback",
    "paycheck",
    "payday",
    "payee",
    "payer",
    "paying",
    "payment",
    "payphone",
    "payroll",
    "pebble",
    "pebbly",
    "pecan",
    "pectin",
    "peculiar",
    "peddling",
    "pediatric",
    "pedicure",
    "pedigree",
    "pedometer",
    "pegboard",
    "pelican",
    "pellet",
    "pelt",
    "pelvis",
    "penalize",
    "penalty",
    "pencil",
    "pendant",
    "pending",
    "penholder",
    "penknife",
    "pennant",
    "penniless",
    "penny",
    "penpal",
    "pension",
    "pentagon",
    "pentagram",
    "pep",
    "perceive",
    "percent",
    "perch",
    "percolate",
    "perennial",
    "perfected",
    "perfectly",
    "perfume",
    "periscope",
    "perish",
    "perjurer",
    "perjury",
    "perkiness",
    "perky",
    "perm",
    "peroxide",
    "perpetual",
    "perplexed",
    "persecute",
    "persevere",
    "persuaded",
    "persuader",
    "pesky",
    "peso",
    "pessimism",
    "pessimist",
    "pester",
    "pesticide",
    "petal",
    "petite",
    "petition",
    "petri",
    "petroleum",
    "petted",
    "petticoat",
    "pettiness",
    "petty",
    "petunia",
    "phantom",
    "phobia",
    "phoenix",
    "phonebook",
    "phoney",
    "phonics",
    "phoniness",
    "phony",
    "phosphate",
    "photo",
    "phrase",
    "phrasing",
    "placard",
    "placate",
    "placidly",
    "plank",
    "planner",
    "plant",
    "plasma",
    "plaster",
    "plastic",
    "plated",
    "platform",
    "plating",
    "platinum",
    "platonic",
    "platter",
    "platypus",
    "plausible",
    "plausibly",
    "playable",
    "playback",
    "player",
    "playful",
    "playgroup",
    "playhouse",
    "playing",
    "playlist",
    "playmaker",
    "playmate",
    "playoff",
    "playpen",
    "playroom",
    "playset",
    "plaything",
    "playtime",
    "plaza",
    "pleading",
    "pleat",
    "pledge",
    "plentiful",
    "plenty",
    "plethora",
    "plexiglas",
    "pliable",
    "plod",
    "plop",
    "plot",
    "plow",
    "ploy",
    "pluck",
    "plug",
    "plunder",
    "plunging",
    "plural",
    "plus",
    "plutonium",
    "plywood",
    "poach",
    "pod",
    "poem",
    "poet",
    "pogo",
    "pointed",
    "pointer",
    "pointing",
    "pointless",
    "pointy",
    "poise",
    "poison",
    "poker",
    "poking",
    "polar",
    "police",
    "policy",
    "polio",
    "polish",
    "politely",
    "polka",
    "polo",
    "polyester",
    "polygon",
    "polygraph",
    "polymer",
    "poncho",
    "pond",
    "pony",
    "popcorn",
    "pope",
    "poplar",
    "popper",
    "poppy",
    "popsicle",
    "populace",
    "popular",
    "populate",
    "porcupine",
    "pork",
    "porous",
    "porridge",
    "portable",
    "portal",
    "portfolio",
    "porthole",
    "portion",
    "portly",
    "portside",
    "poser",
    "posh",
    "posing",
    "possible",
    "possibly",
    "possum",
    "postage",
    "postal",
    "postbox",
    "postcard",
    "posted",
    "poster",
    "posting",
    "postnasal",
    "posture",
    "postwar",
    "pouch",
    "pounce",
    "pouncing",
    "pound",
    "pouring",
    "pout",
    "powdered",
    "powdering",
    "powdery",
    "power",
    "powwow",
    "pox",
    "praising",
    "prance",
    "prancing",
    "pranker",
    "prankish",
    "prankster",
    "prayer",
    "praying",
    "preacher",
    "preaching",
    "preachy",
    "preamble",
    "precinct",
    "precise",
    "precision",
    "precook",
    "precut",
    "predator",
    "predefine",
    "predict",
    "preface",
    "prefix",
    "preflight",
    "preformed",
    "pregame",
    "pregnancy",
    "pregnant",
    "preheated",
    "prelaunch",
    "prelaw",
    "prelude",
    "premiere",
    "premises",
    "premium",
    "prenatal",
    "preoccupy",
    "preorder",
    "prepaid",
    "prepay",
    "preplan",
    "preppy",
    "preschool",
    "prescribe",
    "preseason",
    "preset",
    "preshow",
    "president",
    "presoak",
    "press",
    "presume",
    "presuming",
    "preteen",
    "pretended",
    "pretender",
    "pretense",
    "pretext",
    "pretty",
    "pretzel",
    "prevail",
    "prevalent",
    "prevent",
    "preview",
    "previous",
    "prewar",
    "prewashed",
    "prideful",
    "pried",
    "primal",
    "primarily",
    "primary",
    "primate",
    "primer",
    "primp",
    "princess",
    "print",
    "prior",
    "prism",
    "prison",
    "prissy",
    "pristine",
    "privacy",
    "private",
    "privatize",
    "prize",
    "proactive",
    "probable",
    "probably",
    "probation",
    "probe",
    "probing",
    "probiotic",
    "problem",
    "procedure",
    "process",
    "proclaim",
    "procreate",
    "procurer",
    "prodigal",
    "prodigy",
    "produce",
    "product",
    "profane",
    "profanity",
    "professed",
    "professor",
    "profile",
    "profound",
    "profusely",
    "progeny",
    "prognosis",
    "program",
    "progress",
    "projector",
    "prologue",
    "prolonged",
    "promenade",
    "prominent",
    "promoter",
    "promotion",
    "prompter",
    "promptly",
    "prone",
    "prong",
    "pronounce",
    "pronto",
    "proofing",
    "proofread",
    "proofs",
    "propeller",
    "properly",
    "property",
    "proponent",
    "proposal",
    "propose",
    "props",
    "prorate",
    "protector",
    "protegee",
    "proton",
    "prototype",
    "protozoan",
    "protract",
    "protrude",
    "proud",
    "provable",
    "proved",
    "proven",
    "provided",
    "provider",
    "providing",
    "province",
    "proving",
    "provoke",
    "provoking",
    "provolone",
    "prowess",
    "prowler",
    "prowling",
    "proximity",
    "proxy",
    "prozac",
    "prude",
    "prudishly",
    "prune",
    "pruning",
    "pry",
    "psychic",
    "public",
    "publisher",
    "pucker",
    "pueblo",
    "pug",
    "pull",
    "pulmonary",
    "pulp",
    "pulsate",
    "pulse",
    "pulverize",
    "puma",
    "pumice",
    "pummel",
    "punch",
    "punctual",
    "punctuate",
    "punctured",
    "pungent",
    "punisher",
    "punk",
    "pupil",
    "puppet",
    "puppy",
    "purchase",
    "pureblood",
    "purebred",
    "purely",
    "pureness",
    "purgatory",
    "purge",
    "purging",
    "purifier",
    "purify",
    "purist",
    "puritan",
    "purity",
    "purple",
    "purplish",
    "purposely",
    "purr",
    "purse",
    "pursuable",
    "pursuant",
    "pursuit",
    "purveyor",
    "pushcart",
    "pushchair",
    "pusher",
    "pushiness",
    "pushing",
    "pushover",
    "pushpin",
    "pushup",
    "pushy",
    "putdown",
    "putt",
    "puzzle",
    "puzzling",
    "pyramid",
    "pyromania",
    "python",
    "quack",
    "quadrant",
    "quail",
    "quaintly",
    "quake",
    "quaking",
    "qualified",
    "qualifier",
    "qualify",
    "quality",
    "qualm",
    "quantum",
    "quarrel",
    "quarry",
    "quartered",
    "quarterly",
    "quarters",
    "quartet",
    "quench",
    "query",
    "quicken",
    "quickly",
    "quickness",
    "quicksand",
    "quickstep",
    "quiet",
    "quill",
    "quilt",
    "quintet",
    "quintuple",
    "quirk",
    "quit",
    "quiver",
    "quizzical",
    "quotable",
    "quotation",
    "quote",
    "rabid",
    "race",
    "racing",
    "racism",
    "rack",
    "racoon",
    "radar",
    "radial",
    "radiance",
    "radiantly",
    "radiated",
    "radiation",
    "radiator",
    "radio",
    "radish",
    "raffle",
    "raft",
    "rage",
    "ragged",
    "raging",
    "ragweed",
    "raider",
    "railcar",
    "railing",
    "railroad",
    "railway",
    "raisin",
    "rake",
    "raking",
    "rally",
    "ramble",
    "rambling",
    "ramp",
    "ramrod",
    "ranch",
    "rancidity",
    "random",
    "ranged",
    "ranger",
    "ranging",
    "ranked",
    "ranking",
    "ransack",
    "ranting",
    "rants",
    "rare",
    "rarity",
    "rascal",
    "rash",
    "rasping",
    "ravage",
    "raven",
    "ravine",
    "raving",
    "ravioli",
    "ravishing",
    "reabsorb",
    "reach",
    "reacquire",
    "reaction",
    "reactive",
    "reactor",
    "reaffirm",
    "ream",
    "reanalyze",
    "reappear",
    "reapply",
    "reappoint",
    "reapprove",
    "rearrange",
    "rearview",
    "reason",
    "reassign",
    "reassure",
    "reattach",
    "reawake",
    "rebalance",
    "rebate",
    "rebel",
    "rebirth",
    "reboot",
    "reborn",
    "rebound",
    "rebuff",
    "rebuild",
    "rebuilt",
    "reburial",
    "rebuttal",
    "recall",
    "recant",
    "recapture",
    "recast",
    "recede",
    "recent",
    "recess",
    "recharger",
    "recipient",
    "recital",
    "recite",
    "reckless",
    "reclaim",
    "recliner",
    "reclining",
    "recluse",
    "reclusive",
    "recognize",
    "recoil",
    "recollect",
    "recolor",
    "reconcile",
    "reconfirm",
    "reconvene",
    "recopy",
    "record",
    "recount",
    "recoup",
    "recovery",
    "recreate",
    "rectal",
    "rectangle",
    "rectified",
    "rectify",
    "recycled",
    "recycler",
    "recycling",
    "reemerge",
    "reenact",
    "reenter",
    "reentry",
    "reexamine",
    "referable",
    "referee",
    "reference",
    "refill",
    "refinance",
    "refined",
    "refinery",
    "refining",
    "refinish",
    "reflected",
    "reflector",
    "reflex",
    "reflux",
    "refocus",
    "refold",
    "reforest",
    "reformat",
    "reformed",
    "reformer",
    "reformist",
    "refract",
    "refrain",
    "refreeze",
    "refresh",
    "refried",
    "refueling",
    "refund",
    "refurbish",
    "refurnish",
    "refusal",
    "refuse",
    "refusing",
    "refutable",
    "refute",
    "regain",
    "regalia",
    "regally",
    "reggae",
    "regime",
    "region",
    "register",
    "registrar",
    "registry",
    "regress",
    "regretful",
    "regroup",
    "regular",
    "regulate",
    "regulator",
    "rehab",
    "reheat",
    "rehire",
    "rehydrate",
    "reimburse",
    "reissue",
    "reiterate",
    "rejoice",
    "rejoicing",
    "rejoin",
    "rekindle",
    "relapse",
    "relapsing",
    "relatable",
    "related",
    "relation",
    "relative",
    "relax",
    "relay",
    "relearn",
    "release",
    "relenting",
    "reliable",
    "reliably",
    "reliance",
    "reliant",
    "relic",
    "relieve",
    "relieving",
    "relight",
    "relish",
    "relive",
    "reload",
    "relocate",
    "relock",
    "reluctant",
    "rely",
    "remake",
    "remark",
    "remarry",
    "rematch",
    "remedial",
    "remedy",
    "remember",
    "reminder",
    "remindful",
    "remission",
    "remix",
    "remnant",
    "remodeler",
    "remold",
    "remorse",
    "remote",
    "removable",
    "removal",
    "removed",
    "remover",
    "removing",
    "rename",
    "renderer",
    "rendering",
    "rendition",
    "renegade",
    "renewable",
    "renewably",
    "renewal",
    "renewed",
    "renounce",
    "renovate",
    "renovator",
    "rentable",
    "rental",
    "rented",
    "renter",
    "reoccupy",
    "reoccur",
    "reopen",
    "reorder",
    "repackage",
    "repacking",
    "repaint",
    "repair",
    "repave",
    "repaying",
    "repayment",
    "repeal",
    "repeated",
    "repeater",
    "repent",
    "rephrase",
    "replace",
    "replay",
    "replica",
    "reply",
    "reporter",
    "repose",
    "repossess",
    "repost",
    "repressed",
    "reprimand",
    "reprint",
    "reprise",
    "reproach",
    "reprocess",
    "reproduce",
    "reprogram",
    "reps",
    "reptile",
    "reptilian",
    "repugnant",
    "repulsion",
    "repulsive",
    "repurpose",
    "reputable",
    "reputably",
    "request",
    "require",
    "requisite",
    "reroute",
    "rerun",
    "resale",
    "resample",
    "rescuer",
    "reseal",
    "research",
    "reselect",
    "reseller",
    "resemble",
    "resend",
    "resent",
    "reset",
    "reshape",
    "reshoot",
    "reshuffle",
    "residence",
    "residency",
    "resident",
    "residual",
    "residue",
    "resigned",
    "resilient",
    "resistant",
    "resisting",
    "resize",
    "resolute",
    "resolved",
    "resonant",
    "resonate",
    "resort",
    "resource",
    "respect",
    "resubmit",
    "result",
    "resume",
    "resupply",
    "resurface",
    "resurrect",
    "retail",
    "retainer",
    "retaining",
    "retake",
    "retaliate",
    "retention",
    "rethink",
    "retinal",
    "retired",
    "retiree",
    "retiring",
    "retold",
    "retool",
    "retorted",
    "retouch",
    "retrace",
    "retract",
    "retrain",
    "retread",
    "retreat",
    "retrial",
    "retrieval",
    "retriever",
    "retry",
    "return",
    "retying",
    "retype",
    "reunion",
    "reunite",
    "reusable",
    "reuse",
    "reveal",
    "reveler",
    "revenge",
    "revenue",
    "reverb",
    "revered",
    "reverence",
    "reverend",
    "reversal",
    "reverse",
    "reversing",
    "reversion",
    "revert",
    "revisable",
    "revise",
    "revision",
    "revisit",
    "revivable",
    "revival",
    "reviver",
    "reviving",
    "revocable",
    "revoke",
    "revolt",
    "revolver",
    "revolving",
    "reward",
    "rewash",
    "rewind",
    "rewire",
    "reword",
    "rework",
    "rewrap",
    "rewrite",
    "rhyme",
    "ribbon",
    "ribcage",
    "rice",
    "riches",
    "richly",
    "richness",
    "rickety",
    "ricotta",
    "riddance",
    "ridden",
    "ride",
    "riding",
    "rifling",
    "rift",
    "rigging",
    "rigid",
    "rigor",
    "rimless",
    "rimmed",
    "rind",
    "rink",
    "rinse",
    "rinsing",
    "riot",
    "ripcord",
    "ripeness",
    "ripening",
    "ripping",
    "ripple",
    "rippling",
    "riptide",
    "rise",
    "rising",
    "risk",
    "risotto",
    "ritalin",
    "ritzy",
    "rival",
    "riverbank",
    "riverbed",
    "riverboat",
    "riverside",
    "riveter",
    "riveting",
    "roamer",
    "roaming",
    "roast",
    "robbing",
    "robe",
    "robin",
    "robotics",
    "robust",
    "rockband",
    "rocker",
    "rocket",
    "rockfish",
    "rockiness",
    "rocking",
    "rocklike",
    "rockslide",
    "rockstar",
    "rocky",
    "rogue",
    "roman",
    "romp",
    "rope",
    "roping",
    "roster",
    "rosy",
    "rotten",
    "rotting",
    "rotunda",
    "roulette",
    "rounding",
    "roundish",
    "roundness",
    "roundup",
    "roundworm",
    "routine",
    "routing",
    "rover",
    "roving",
    "royal",
    "rubbed",
    "rubber",
    "rubbing",
    "rubble",
    "rubdown",
    "ruby",
    "ruckus",
    "rudder",
    "rug",
    "ruined",
    "rule",
    "rumble",
    "rumbling",
    "rummage",
    "rumor",
    "runaround",
    "rundown",
    "runner",
    "running",
    "runny",
    "runt",
    "runway",
    "rupture",
    "rural",
    "ruse",
    "rush",
    "rust",
    "rut",
    "sabbath",
    "sabotage",
    "sacrament",
    "sacred",
    "sacrifice",
    "sadden",
    "saddlebag",
    "saddled",
    "saddling",
    "sadly",
    "sadness",
    "safari",
    "safeguard",
    "safehouse",
    "safely",
    "safeness",
    "saffron",
    "saga",
    "sage",
    "sagging",
    "saggy",
    "said",
    "saint",
    "sake",
    "salad",
    "salami",
    "salaried",
    "salary",
    "saline",
    "salon",
    "saloon",
    "salsa",
    "salt",
    "salutary",
    "salute",
    "salvage",
    "salvaging",
    "salvation",
    "same",
    "sample",
    "sampling",
    "sanction",
    "sanctity",
    "sanctuary",
    "sandal",
    "sandbag",
    "sandbank",
    "sandbar",
    "sandblast",
    "sandbox",
    "sanded",
    "sandfish",
    "sanding",
    "sandlot",
    "sandpaper",
    "sandpit",
    "sandstone",
    "sandstorm",
    "sandworm",
    "sandy",
    "sanitary",
    "sanitizer",
    "sank",
    "santa",
    "sapling",
    "sappiness",
    "sappy",
    "sarcasm",
    "sarcastic",
    "sardine",
    "sash",
    "sasquatch",
    "sassy",
    "satchel",
    "satiable",
    "satin",
    "satirical",
    "satisfied",
    "satisfy",
    "saturate",
    "saturday",
    "sauciness",
    "saucy",
    "sauna",
    "savage",
    "savanna",
    "saved",
    "savings",
    "savior",
    "savor",
    "saxophone",
    "say",
    "scabbed",
    "scabby",
    "scalded",
    "scalding",
    "scale",
    "scaling",
    "scallion",
    "scallop",
    "scalping",
    "scam",
    "scandal",
    "scanner",
    "scanning",
    "scant",
    "scapegoat",
    "scarce",
    "scarcity",
    "scarecrow",
    "scared",
    "scarf",
    "scarily",
    "scariness",
    "scarring",
    "scary",
    "scavenger",
    "scenic",
    "schedule",
    "schematic",
    "scheme",
    "scheming",
    "schilling",
    "schnapps",
    "scholar",
    "science",
    "scientist",
    "scion",
    "scoff",
    "scolding",
    "scone",
    "scoop",
    "scooter",
    "scope",
    "scorch",
    "scorebook",
    "scorecard",
    "scored",
    "scoreless",
    "scorer",
    "scoring",
    "scorn",
    "scorpion",
    "scotch",
    "scoundrel",
    "scoured",
    "scouring",
    "scouting",
    "scouts",
    "scowling",
    "scrabble",
    "scraggly",
    "scrambled",
    "scrambler",
    "scrap",
    "scratch",
    "scrawny",
    "screen",
    "scribble",
    "scribe",
    "scribing",
    "scrimmage",
    "script",
    "scroll",
    "scrooge",
    "scrounger",
    "scrubbed",
    "scrubber",
    "scruffy",
    "scrunch",
    "scrutiny",
    "scuba",
    "scuff",
    "sculptor",
    "sculpture",
    "scurvy",
    "scuttle",
    "secluded",
    "secluding",
    "seclusion",
    "second",
    "secrecy",
    "secret",
    "sectional",
    "sector",
    "secular",
    "securely",
    "security",
    "sedan",
    "sedate",
    "sedation",
    "sedative",
    "sediment",
    "seduce",
    "seducing",
    "segment",
    "seismic",
    "seizing",
    "seldom",
    "selected",
    "selection",
    "selective",
    "selector",
    "self",
    "seltzer",
    "semantic",
    "semester",
    "semicolon",
    "semifinal",
    "seminar",
    "semisoft",
    "semisweet",
    "senate",
    "senator",
    "send",
    "senior",
    "senorita",
    "sensation",
    "sensitive",
    "sensitize",
    "sensually",
    "sensuous",
    "sepia",
    "september",
    "septic",
    "septum",
    "sequel",
    "sequence",
    "sequester",
    "series",
    "sermon",
    "serotonin",
    "serpent",
    "serrated",
    "serve",
    "service",
    "serving",
    "sesame",
    "sessions",
    "setback",
    "setting",
    "settle",
    "settling",
    "setup",
    "sevenfold",
    "seventeen",
    "seventh",
    "seventy",
    "severity",
    "shabby",
    "shack",
    "shaded",
    "shadily",
    "shadiness",
    "shading",
    "shadow",
    "shady",
    "shaft",
    "shakable",
    "shakily",
    "shakiness",
    "shaking",
    "shaky",
    "shale",
    "shallot",
    "shallow",
    "shame",
    "shampoo",
    "shamrock",
    "shank",
    "shanty",
    "shape",
    "shaping",
    "share",
    "sharpener",
    "sharper",
    "sharpie",
    "sharply",
    "sharpness",
    "shawl",
    "sheath",
    "shed",
    "sheep",
    "sheet",
    "shelf",
    "shell",
    "shelter",
    "shelve",
    "shelving",
    "sherry",
    "shield",
    "shifter",
    "shifting",
    "shiftless",
    "shifty",
    "shimmer",
    "shimmy",
    "shindig",
    "shine",
    "shingle",
    "shininess",
    "shining",
    "shiny",
    "ship",
    "shirt",
    "shivering",
    "shock",
    "shone",
    "shoplift",
    "shopper",
    "shopping",
    "shoptalk",
    "shore",
    "shortage",
    "shortcake",
    "shortcut",
    "shorten",
    "shorter",
    "shorthand",
    "shortlist",
    "shortly",
    "shortness",
    "shorts",
    "shortwave",
    "shorty",
    "shout",
    "shove",
    "showbiz",
    "showcase",
    "showdown",
    "shower",
    "showgirl",
    "showing",
    "showman",
    "shown",
    "showoff",
    "showpiece",
    "showplace",
    "showroom",
    "showy",
    "shrank",
    "shrapnel",
    "shredder",
    "shredding",
    "shrewdly",
    "shriek",
    "shrill",
    "shrimp",
    "shrine",
    "shrink",
    "shrivel",
    "shrouded",
    "shrubbery",
    "shrubs",
    "shrug",
    "shrunk",
    "shucking",
    "shudder",
    "shuffle",
    "shuffling",
    "shun",
    "shush",
    "shut",
    "shy",
    "siamese",
    "siberian",
    "sibling",
    "siding",
    "sierra",
    "siesta",
    "sift",
    "sighing",
    "silenced",
    "silencer",
    "silent",
    "silica",
    "silicon",
    "silk",
    "silliness",
    "silly",
    "silo",
    "silt",
    "silver",
    "similarly",
    "simile",
    "simmering",
    "simple",
    "simplify",
    "simply",
    "sincere",
    "sincerity",
    "singer",
    "singing",
    "single",
    "singular",
    "sinister",
    "sinless",
    "sinner",
    "sinuous",
    "sip",
    "siren",
    "sister",
    "sitcom",
    "sitter",
    "sitting",
    "situated",
    "situation",
    "sixfold",
    "sixteen",
    "sixth",
    "sixties",
    "sixtieth",
    "sixtyfold",
    "sizable",
    "sizably",
    "size",
    "sizing",
    "sizzle",
    "sizzling",
    "skater",
    "skating",
    "skedaddle",
    "skeletal",
    "skeleton",
    "skeptic",
    "sketch",
    "skewed",
    "skewer",
    "skid",
    "skied",
    "skier",
    "skies",
    "skiing",
    "skilled",
    "skillet",
    "skillful",
    "skimmed",
    "skimmer",
    "skimming",
    "skimpily",
    "skincare",
    "skinhead",
    "skinless",
    "skinning",
    "skinny",
    "skintight",
    "skipper",
    "skipping",
    "skirmish",
    "skirt",
    "skittle",
    "skydiver",
    "skylight",
    "skyline",
    "skype",
    "skyrocket",
    "skyward",
    "slab",
    "slacked",
    "slacker",
    "slacking",
    "slackness",
    "slacks",
    "slain",
    "slam",
    "slander",
    "slang",
    "slapping",
    "slapstick",
    "slashed",
    "slashing",
    "slate",
    "slather",
    "slaw",
    "sled",
    "sleek",
    "sleep",
    "sleet",
    "sleeve",
    "slept",
    "sliceable",
    "sliced",
    "slicer",
    "slicing",
    "slick",
    "slider",
    "slideshow",
    "sliding",
    "slighted",
    "slighting",
    "slightly",
    "slimness",
    "slimy",
    "slinging",
    "slingshot",
    "slinky",
    "slip",
    "slit",
    "sliver",
    "slobbery",
    "slogan",
    "sloped",
    "sloping",
    "sloppily",
    "sloppy",
    "slot",
    "slouching",
    "slouchy",
    "sludge",
    "slug",
    "slum",
    "slurp",
    "slush",
    "sly",
    "small",
    "smartly",
    "smartness",
    "smasher",
    "smashing",
    "smashup",
    "smell",
    "smelting",
    "smile",
    "smilingly",
    "smirk",
    "smite",
    "smith",
    "smitten",
    "smock",
    "smog",
    "smoked",
    "smokeless",
    "smokiness",
    "smoking",
    "smoky",
    "smolder",
    "smooth",
    "smother",
    "smudge",
    "smudgy",
    "smuggler",
    "smuggling",
    "smugly",
    "smugness",
    "snack",
    "snagged",
    "snaking",
    "snap",
    "snare",
    "snarl",
    "snazzy",
    "sneak",
    "sneer",
    "sneeze",
    "sneezing",
    "snide",
    "sniff",
    "snippet",
    "snipping",
    "snitch",
    "snooper",
    "snooze",
    "snore",
    "snoring",
    "snorkel",
    "snort",
    "snout",
    "snowbird",
    "snowboard",
    "snowbound",
    "snowcap",
    "snowdrift",
    "snowdrop",
    "snowfall",
    "snowfield",
    "snowflake",
    "snowiness",
    "snowless",
    "snowman",
    "snowplow",
    "snowshoe",
    "snowstorm",
    "snowsuit",
    "snowy",
    "snub",
    "snuff",
    "snuggle",
    "snugly",
    "snugness",
    "speak",
    "spearfish",
    "spearhead",
    "spearman",
    "spearmint",
    "species",
    "specimen",
    "specked",
    "speckled",
    "specks",
    "spectacle",
    "spectator",
    "spectrum",
    "speculate",
    "speech",
    "speed",
    "spellbind",
    "speller",
    "spelling",
    "spendable",
    "spender",
    "spending",
    "spent",
    "spew",
    "sphere",
    "spherical",
    "sphinx",
    "spider",
    "spied",
    "spiffy",
    "spill",
    "spilt",
    "spinach",
    "spinal",
    "spindle",
    "spinner",
    "spinning",
    "spinout",
    "spinster",
    "spiny",
    "spiral",
    "spirited",
    "spiritism",
    "spirits",
    "spiritual",
    "splashed",
    "splashing",
    "splashy",
    "splatter",
    "spleen",
    "splendid",
    "splendor",
    "splice",
    "splicing",
    "splinter",
    "splotchy",
    "splurge",
    "spoilage",
    "spoiled",
    "spoiler",
    "spoiling",
    "spoils",
    "spoken",
    "spokesman",
    "sponge",
    "spongy",
    "sponsor",
    "spoof",
    "spookily",
    "spooky",
    "spool",
    "spoon",
    "spore",
    "sporting",
    "sports",
    "sporty",
    "spotless",
    "spotlight",
    "spotted",
    "spotter",
    "spotting",
    "spotty",
    "spousal",
    "spouse",
    "spout",
    "sprain",
    "sprang",
    "sprawl",
    "spray",
    "spree",
    "sprig",
    "spring",
    "sprinkled",
    "sprinkler",
    "sprint",
    "sprite",
    "sprout",
    "spruce",
    "sprung",
    "spry",
    "spud",
    "spur",
    "sputter",
    "spyglass",
    "squabble",
    "squad",
    "squall",
    "squander",
    "squash",
    "squatted",
    "squatter",
    "squatting",
    "squeak",
    "squealer",
    "squealing",
    "squeamish",
    "squeegee",
    "squeeze",
    "squeezing",
    "squid",
    "squiggle",
    "squiggly",
    "squint",
    "squire",
    "squirt",
    "squishier",
    "squishy",
    "stability",
    "stabilize",
    "stable",
    "stack",
    "stadium",
    "staff",
    "stage",
    "staging",
    "stagnant",
    "stagnate",
    "stainable",
    "stained",
    "staining",
    "stainless",
    "stalemate",
    "staleness",
    "stalling",
    "stallion",
    "stamina",
    "stammer",
    "stamp",
    "stand",
    "stank",
    "staple",
    "stapling",
    "starboard",
    "starch",
    "stardom",
    "stardust",
    "starfish",
    "stargazer",
    "staring",
    "stark",
    "starless",
    "starlet",
    "starlight",
    "starlit",
    "starring",
    "starry",
    "starship",
    "starter",
    "starting",
    "startle",
    "startling",
    "startup",
    "starved",
    "starving",
    "stash",
    "state",
    "static",
    "statistic",
    "statue",
    "stature",
    "status",
    "statute",
    "statutory",
    "staunch",
    "stays",
    "steadfast",
    "steadier",
    "steadily",
    "steadying",
    "steam",
    "steed",
    "steep",
    "steerable",
    "steering",
    "steersman",
    "stegosaur",
    "stellar",
    "stem",
    "stench",
    "stencil",
    "step",
    "stereo",
    "sterile",
    "sterility",
    "sterilize",
    "sterling",
    "sternness",
    "sternum",
    "stew",
    "stick",
    "stiffen",
    "stiffly",
    "stiffness",
    "stifle",
    "stifling",
    "stillness",
    "stilt",
    "stimulant",
    "stimulate",
    "stimuli",
    "stimulus",
    "stinger",
    "stingily",
    "stinging",
    "stingray",
    "stingy",
    "stinking",
    "stinky",
    "stipend",
    "stipulate",
    "stir",
    "stitch",
    "stock",
    "stoic",
    "stoke",
    "stole",
    "stomp",
    "stonewall",
    "stoneware",
    "stonework",
    "stoning",
    "stony",
    "stood",
    "stooge",
    "stool",
    "stoop",
    "stoplight",
    "stoppable",
    "stoppage",
    "stopped",
    "stopper",
    "stopping",
    "stopwatch",
    "storable",
    "storage",
    "storeroom",
    "storewide",
    "storm",
    "stout",
    "stove",
    "stowaway",
    "stowing",
    "straddle",
    "straggler",
    "strained",
    "strainer",
    "straining",
    "strangely",
    "stranger",
    "strangle",
    "strategic",
    "strategy",
    "stratus",
    "straw",
    "stray",
    "streak",
    "stream",
    "street",
    "strength",
    "strenuous",
    "strep",
    "stress",
    "stretch",
    "strewn",
    "stricken",
    "strict",
    "stride",
    "strife",
    "strike",
    "striking",
    "strive",
    "striving",
    "strobe",
    "strode",
    "stroller",
    "strongbox",
    "strongly",
    "strongman",
    "struck",
    "structure",
    "strudel",
    "struggle",
    "strum",
    "strung",
    "strut",
    "stubbed",
    "stubble",
    "stubbly",
    "stubborn",
    "stucco",
    "stuck",
    "student",
    "studied",
    "studio",
    "study",
    "stuffed",
    "stuffing",
    "stuffy",
    "stumble",
    "stumbling",
    "stump",
    "stung",
    "stunned",
    "stunner",
    "stunning",
    "stunt",
    "stupor",
    "sturdily",
    "sturdy",
    "styling",
    "stylishly",
    "stylist",
    "stylized",
    "stylus",
    "suave",
    "subarctic",
    "subatomic",
    "subdivide",
    "subdued",
    "subduing",
    "subfloor",
    "subgroup",
    "subheader",
    "subject",
    "sublease",
    "sublet",
    "sublevel",
    "sublime",
    "submarine",
    "submerge",
    "submersed",
    "submitter",
    "subpanel",
    "subpar",
    "subplot",
    "subprime",
    "subscribe",
    "subscript",
    "subsector",
    "subside",
    "subsiding",
    "subsidize",
    "subsidy",
    "subsoil",
    "subsonic",
    "substance",
    "subsystem",
    "subtext",
    "subtitle",
    "subtly",
    "subtotal",
    "subtract",
    "subtype",
    "suburb",
    "subway",
    "subwoofer",
    "subzero",
    "succulent",
    "such",
    "suction",
    "sudden",
    "sudoku",
    "suds",
    "sufferer",
    "suffering",
    "suffice",
    "suffix",
    "suffocate",
    "suffrage",
    "sugar",
    "suggest",
    "suing",
    "suitable",
    "suitably",
    "suitcase",
    "suitor",
    "sulfate",
    "sulfide",
    "sulfite",
    "sulfur",
    "sulk",
    "sullen",
    "sulphate",
    "sulphuric",
    "sultry",
    "superbowl",
    "superglue",
    "superhero",
    "superior",
    "superjet",
    "superman",
    "supermom",
    "supernova",
    "supervise",
    "supper",
    "supplier",
    "supply",
    "support",
    "supremacy",
    "supreme",
    "surcharge",
    "surely",
    "sureness",
    "surface",
    "surfacing",
    "surfboard",
    "surfer",
    "surgery",
    "surgical",
    "surging",
    "surname",
    "surpass",
    "surplus",
    "surprise",
    "surreal",
    "surrender",
    "surrogate",
    "surround",
    "survey",
    "survival",
    "survive",
    "surviving",
    "survivor",
    "sushi",
    "suspect",
    "suspend",
    "suspense",
    "sustained",
    "sustainer",
    "swab",
    "swaddling",
    "swagger",
    "swampland",
    "swan",
    "swapping",
    "swarm",
    "sway",
    "swear",
    "sweat",
    "sweep",
    "swell",
    "swept",
    "swerve",
    "swifter",
    "swiftly",
    "swiftness",
    "swimmable",
    "swimmer",
    "swimming",
    "swimsuit",
    "swimwear",
    "swinger",
    "swinging",
    "swipe",
    "swirl",
    "switch",
    "swivel",
    "swizzle",
    "swooned",
    "swoop",
    "swoosh",
    "swore",
    "sworn",
    "swung",
    "sycamore",
    "sympathy",
    "symphonic",
    "symphony",
    "symptom",
    "synapse",
    "syndrome",
    "synergy",
    "synopses",
    "synopsis",
    "synthesis",
    "synthetic",
    "syrup",
    "system",
    "t-shirt",
    "tabasco",
    "tabby",
    "tableful",
    "tables",
    "tablet",
    "tableware",
    "tabloid",
    "tackiness",
    "tacking",
    "tackle",
    "tackling",
    "tacky",
    "taco",
    "tactful",
    "tactical",
    "tactics",
    "tactile",
    "tactless",
    "tadpole",
    "taekwondo",
    "tag",
    "tainted",
    "take",
    "taking",
    "talcum",
    "talisman",
    "tall",
    "talon",
    "tamale",
    "tameness",
    "tamer",
    "tamper",
    "tank",
    "tanned",
    "tannery",
    "tanning",
    "tantrum",
    "tapeless",
    "tapered",
    "tapering",
    "tapestry",
    "tapioca",
    "tapping",
    "taps",
    "tarantula",
    "target",
    "tarmac",
    "tarnish",
    "tarot",
    "tartar",
    "tartly",
    "tartness",
    "task",
    "tassel",
    "taste",
    "tastiness",
    "tasting",
    "tasty",
    "tattered",
    "tattle",
    "tattling",
    "tattoo",
    "taunt",
    "tavern",
    "thank",
    "that",
    "thaw",
    "theater",
    "theatrics",
    "thee",
    "theft",
    "theme",
    "theology",
    "theorize",
    "thermal",
    "thermos",
    "thesaurus",
    "these",
    "thesis",
    "thespian",
    "thicken",
    "thicket",
    "thickness",
    "thieving",
    "thievish",
    "thigh",
    "thimble",
    "thing",
    "think",
    "thinly",
    "thinner",
    "thinness",
    "thinning",
    "thirstily",
    "thirsting",
    "thirsty",
    "thirteen",
    "thirty",
    "thong",
    "thorn",
    "those",
    "thousand",
    "thrash",
    "thread",
    "threaten",
    "threefold",
    "thrift",
    "thrill",
    "thrive",
    "thriving",
    "throat",
    "throbbing",
    "throng",
    "throttle",
    "throwaway",
    "throwback",
    "thrower",
    "throwing",
    "thud",
    "thumb",
    "thumping",
    "thursday",
    "thus",
    "thwarting",
    "thyself",
    "tiara",
    "tibia",
    "tidal",
    "tidbit",
    "tidiness",
    "tidings",
    "tidy",
    "tiger",
    "tighten",
    "tightly",
    "tightness",
    "tightrope",
    "tightwad",
    "tigress",
    "tile",
    "tiling",
    "till",
    "tilt",
    "timid",
    "timing",
    "timothy",
    "tinderbox",
    "tinfoil",
    "tingle",
    "tingling",
    "tingly",
    "tinker",
    "tinkling",
    "tinsel",
    "tinsmith",
    "tint",
    "tinwork",
    "tiny",
    "tipoff",
    "tipped",
    "tipper",
    "tipping",
    "tiptoeing",
    "tiptop",
    "tiring",
    "tissue",
    "trace",
    "tracing",
    "track",
    "traction",
    "tractor",
    "trade",
    "trading",
    "tradition",
    "traffic",
    "tragedy",
    "trailing",
    "trailside",
    "train",
    "traitor",
    "trance",
    "tranquil",
    "transfer",
    "transform",
    "translate",
    "transpire",
    "transport",
    "transpose",
    "trapdoor",
    "trapeze",
    "trapezoid",
    "trapped",
    "trapper",
    "trapping",
    "traps",
    "trash",
    "travel",
    "traverse",
    "travesty",
    "tray",
    "treachery",
    "treading",
    "treadmill",
    "treason",
    "treat",
    "treble",
    "tree",
    "trekker",
    "tremble",
    "trembling",
    "tremor",
    "trench",
    "trend",
    "trespass",
    "triage",
    "trial",
    "triangle",
    "tribesman",
    "tribunal",
    "tribune",
    "tributary",
    "tribute",
    "triceps",
    "trickery",
    "trickily",
    "tricking",
    "trickle",
    "trickster",
    "tricky",
    "tricolor",
    "tricycle",
    "trident",
    "tried",
    "trifle",
    "trifocals",
    "trillion",
    "trilogy",
    "trimester",
    "trimmer",
    "trimming",
    "trimness",
    "trinity",
    "trio",
    "tripod",
    "tripping",
    "triumph",
    "trivial",
    "trodden",
    "trolling",
    "trombone",
    "trophy",
    "tropical",
    "tropics",
    "trouble",
    "troubling",
    "trough",
    "trousers",
    "trout",
    "trowel",
    "truce",
    "truck",
    "truffle",
    "trump",
    "trunks",
    "trustable",
    "trustee",
    "trustful",
    "trusting",
    "trustless",
    "truth",
    "try",
    "tubby",
    "tubeless",
    "tubular",
    "tucking",
    "tuesday",
    "tug",
    "tuition",
    "tulip",
    "tumble",
    "tumbling",
    "tummy",
    "turban",
    "turbine",
    "turbofan",
    "turbojet",
    "turbulent",
    "turf",
    "turkey",
    "turmoil",
    "turret",
    "turtle",
    "tusk",
    "tutor",
    "tutu",
    "tux",
    "tweak",
    "tweed",
    "tweet",
    "tweezers",
    "twelve",
    "twentieth",
    "twenty",
    "twerp",
    "twice",
    "twiddle",
    "twiddling",
    "twig",
    "twilight",
    "twine",
    "twins",
    "twirl",
    "twistable",
    "twisted",
    "twister",
    "twisting",
    "twisty",
    "twitch",
    "twitter",
    "tycoon",
    "tying",
    "tyke",
    "udder",
    "ultimate",
    "ultimatum",
    "ultra",
    "umbilical",
    "umbrella",
    "umpire",
    "unabashed",
    "unable",
    "unadorned",
    "unadvised",
    "unafraid",
    "unaired",
    "unaligned",
    "unaltered",
    "unarmored",
    "unashamed",
    "unaudited",
    "unawake",
    "unaware",
    "unbaked",
    "unbalance",
    "unbeaten",
    "unbend",
    "unbent",
    "unbiased",
    "unbitten",
    "unblended",
    "unblessed",
    "unblock",
    "unbolted",
    "unbounded",
    "unboxed",
    "unbraided",
    "unbridle",
    "unbroken",
    "unbuckled",
    "unbundle",
    "unburned",
    "unbutton",
    "uncanny",
    "uncapped",
    "uncaring",
    "uncertain",
    "unchain",
    "unchanged",
    "uncharted",
    "uncheck",
    "uncivil",
    "unclad",
    "unclaimed",
    "unclamped",
    "unclasp",
    "uncle",
    "unclip",
    "uncloak",
    "unclog",
    "unclothed",
    "uncoated",
    "uncoiled",
    "uncolored",
    "uncombed",
    "uncommon",
    "uncooked",
    "uncork",
    "uncorrupt",
    "uncounted",
    "uncouple",
    "uncouth",
    "uncover",
    "uncross",
    "uncrown",
    "uncrushed",
    "uncured",
    "uncurious",
    "uncurled",
    "uncut",
    "undamaged",
    "undated",
    "undaunted",
    "undead",
    "undecided",
    "undefined",
    "underage",
    "underarm",
    "undercoat",
    "undercook",
    "undercut",
    "underdog",
    "underdone",
    "underfed",
    "underfeed",
    "underfoot",
    "undergo",
    "undergrad",
    "underhand",
    "underline",
    "underling",
    "undermine",
    "undermost",
    "underpaid",
    "underpass",
    "underpay",
    "underrate",
    "undertake",
    "undertone",
    "undertook",
    "undertow",
    "underuse",
    "underwear",
    "underwent",
    "underwire",
    "undesired",
    "undiluted",
    "undivided",
    "undocked",
    "undoing",
    "undone",
    "undrafted",
    "undress",
    "undrilled",
    "undusted",
    "undying",
    "unearned",
    "unearth",
    "unease",
    "uneasily",
    "uneasy",
    "uneatable",
    "uneaten",
    "unedited",
    "unelected",
    "unending",
    "unengaged",
    "unenvied",
    "unequal",
    "unethical",
    "uneven",
    "unexpired",
    "unexposed",
    "unfailing",
    "unfair",
    "unfasten",
    "unfazed",
    "unfeeling",
    "unfiled",
    "unfilled",
    "unfitted",
    "unfitting",
    "unfixable",
    "unfixed",
    "unflawed",
    "unfocused",
    "unfold",
    "unfounded",
    "unframed",
    "unfreeze",
    "unfrosted",
    "unfrozen",
    "unfunded",
    "unglazed",
    "ungloved",
    "unglue",
    "ungodly",
    "ungraded",
    "ungreased",
    "unguarded",
    "unguided",
    "unhappily",
    "unhappy",
    "unharmed",
    "unhealthy",
    "unheard",
    "unhearing",
    "unheated",
    "unhelpful",
    "unhidden",
    "unhinge",
    "unhitched",
    "unholy",
    "unhook",
    "unicorn",
    "unicycle",
    "unified",
    "unifier",
    "uniformed",
    "uniformly",
    "unify",
    "unimpeded",
    "uninjured",
    "uninstall",
    "uninsured",
    "uninvited",
    "union",
    "uniquely",
    "unisexual",
    "unison",
    "unissued",
    "unit",
    "universal",
    "universe",
    "unjustly",
    "unkempt",
    "unkind",
    "unknotted",
    "unknowing",
    "unknown",
    "unlaced",
    "unlatch",
    "unlawful",
    "unleaded",
    "unlearned",
    "unleash",
    "unless",
    "unleveled",
    "unlighted",
    "unlikable",
    "unlimited",
    "unlined",
    "unlinked",
    "unlisted",
    "unlit",
    "unlivable",
    "unloaded",
    "unloader",
    "unlocked",
    "unlocking",
    "unlovable",
    "unloved",
    "unlovely",
    "unloving",
    "unluckily",
    "unlucky",
    "unmade",
    "unmanaged",
    "unmanned",
    "unmapped",
    "unmarked",
    "unmasked",
    "unmasking",
    "unmatched",
    "unmindful",
    "unmixable",
    "unmixed",
    "unmolded",
    "unmoral",
    "unmovable",
    "unmoved",
    "unmoving",
    "unnamable",
    "unnamed",
    "unnatural",
    "unneeded",
    "unnerve",
    "unnerving",
    "unnoticed",
    "unopened",
    "unopposed",
    "unpack",
    "unpadded",
    "unpaid",
    "unpainted",
    "unpaired",
    "unpaved",
    "unpeeled",
    "unpicked",
    "unpiloted",
    "unpinned",
    "unplanned",
    "unplanted",
    "unpleased",
    "unpledged",
    "unplowed",
    "unplug",
    "unpopular",
    "unproven",
    "unquote",
    "unranked",
    "unrated",
    "unraveled",
    "unreached",
    "unread",
    "unreal",
    "unreeling",
    "unrefined",
    "unrelated",
    "unrented",
    "unrest",
    "unretired",
    "unrevised",
    "unrigged",
    "unripe",
    "unrivaled",
    "unroasted",
    "unrobed",
    "unroll",
    "unruffled",
    "unruly",
    "unrushed",
    "unsaddle",
    "unsafe",
    "unsaid",
    "unsalted",
    "unsaved",
    "unsavory",
    "unscathed",
    "unscented",
    "unscrew",
    "unsealed",
    "unseated",
    "unsecured",
    "unseeing",
    "unseemly",
    "unseen",
    "unselect",
    "unselfish",
    "unsent",
    "unsettled",
    "unshackle",
    "unshaken",
    "unshaved",
    "unshaven",
    "unsheathe",
    "unshipped",
    "unsightly",
    "unsigned",
    "unskilled",
    "unsliced",
    "unsmooth",
    "unsnap",
    "unsocial",
    "unsoiled",
    "unsold",
    "unsolved",
    "unsorted",
    "unspoiled",
    "unspoken",
    "unstable",
    "unstaffed",
    "unstamped",
    "unsteady",
    "unsterile",
    "unstirred",
    "unstitch",
    "unstopped",
    "unstuck",
    "unstuffed",
    "unstylish",
    "unsubtle",
    "unsubtly",
    "unsuited",
    "unsure",
    "unsworn",
    "untagged",
    "untainted",
    "untaken",
    "untamed",
    "untangled",
    "untapped",
    "untaxed",
    "unthawed",
    "unthread",
    "untidy",
    "untie",
    "until",
    "untimed",
    "untimely",
    "untitled",
    "untoasted",
    "untold",
    "untouched",
    "untracked",
    "untrained",
    "untreated",
    "untried",
    "untrimmed",
    "untrue",
    "untruth",
    "unturned",
    "untwist",
    "untying",
    "unusable",
    "unused",
    "unusual",
    "unvalued",
    "unvaried",
    "unvarying",
    "unveiled",
    "unveiling",
    "unvented",
    "unviable",
    "unvisited",
    "unvocal",
    "unwanted",
    "unwarlike",
    "unwary",
    "unwashed",
    "unwatched",
    "unweave",
    "unwed",
    "unwelcome",
    "unwell",
    "unwieldy",
    "unwilling",
    "unwind",
    "unwired",
    "unwitting",
    "unwomanly",
    "unworldly",
    "unworn",
    "unworried",
    "unworthy",
    "unwound",
    "unwoven",
    "unwrapped",
    "unwritten",
    "unzip",
    "upbeat",
    "upchuck",
    "upcoming",
    "upcountry",
    "update",
    "upfront",
    "upgrade",
    "upheaval",
    "upheld",
    "uphill",
    "uphold",
    "uplifted",
    "uplifting",
    "upload",
    "upon",
    "upper",
    "upright",
    "uprising",
    "upriver",
    "uproar",
    "uproot",
    "upscale",
    "upside",
    "upstage",
    "upstairs",
    "upstart",
    "upstate",
    "upstream",
    "upstroke",
    "upswing",
    "uptake",
    "uptight",
    "uptown",
    "upturned",
    "upward",
    "upwind",
    "uranium",
    "urban",
    "urchin",
    "urethane",
    "urgency",
    "urgent",
    "urging",
    "urologist",
    "urology",
    "usable",
    "usage",
    "useable",
    "used",
    "uselessly",
    "user",
    "usher",
    "usual",
    "utensil",
    "utility",
    "utilize",
    "utmost",
    "utopia",
    "utter",
    "vacancy",
    "vacant",
    "vacate",
    "vacation",
    "vagabond",
    "vagrancy",
    "vagrantly",
    "vaguely",
    "vagueness",
    "valiant",
    "valid",
    "valium",
    "valley",
    "valuables",
    "value",
    "vanilla",
    "vanish",
    "vanity",
    "vanquish",
    "vantage",
    "vaporizer",
    "variable",
    "variably",
    "varied",
    "variety",
    "various",
    "varmint",
    "varnish",
    "varsity",
    "varying",
    "vascular",
    "vaseline",
    "vastly",
    "vastness",
    "veal",
    "vegan",
    "veggie",
    "vehicular",
    "velcro",
    "velocity",
    "velvet",
    "vendetta",
    "vending",
    "vendor",
    "veneering",
    "vengeful",
    "venomous",
    "ventricle",
    "venture",
    "venue",
    "venus",
    "verbalize",
    "verbally",
    "verbose",
    "verdict",
    "verify",
    "verse",
    "version",
    "versus",
    "vertebrae",
    "vertical",
    "vertigo",
    "very",
    "vessel",
    "vest",
    "veteran",
    "veto",
    "vexingly",
    "viability",
    "viable",
    "vibes",
    "vice",
    "vicinity",
    "victory",
    "video",
    "viewable",
    "viewer",
    "viewing",
    "viewless",
    "viewpoint",
    "vigorous",
    "village",
    "villain",
    "vindicate",
    "vineyard",
    "vintage",
    "violate",
    "violation",
    "violator",
    "violet",
    "violin",
    "viper",
    "viral",
    "virtual",
    "virtuous",
    "virus",
    "visa",
    "viscosity",
    "viscous",
    "viselike",
    "visible",
    "visibly",
    "vision",
    "visiting",
    "visitor",
    "visor",
    "vista",
    "vitality",
    "vitalize",
    "vitally",
    "vitamins",
    "vivacious",
    "vividly",
    "vividness",
    "vixen",
    "vocalist",
    "vocalize",
    "vocally",
    "vocation",
    "voice",
    "voicing",
    "void",
    "volatile",
    "volley",
    "voltage",
    "volumes",
    "voter",
    "voting",
    "voucher",
    "vowed",
    "vowel",
    "voyage",
    "wackiness",
    "wad",
    "wafer",
    "waffle",
    "waged",
    "wager",
    "wages",
    "waggle",
    "wagon",
    "wake",
    "waking",
    "walk",
    "walmart",
    "walnut",
    "walrus",
    "waltz",
    "wand",
    "wannabe",
    "wanted",
    "wanting",
    "wasabi",
    "washable",
    "washbasin",
    "washboard",
    "washbowl",
    "washcloth",
    "washday",
    "washed",
    "washer",
    "washhouse",
    "washing",
    "washout",
    "washroom",
    "washstand",
    "washtub",
    "wasp",
    "wasting",
    "watch",
    "water",
    "waviness",
    "waving",
    "wavy",
    "whacking",
    "whacky",
    "wham",
    "wharf",
    "wheat",
    "whenever",
    "whiff",
    "whimsical",
    "whinny",
    "whiny",
    "whisking",
    "whoever",
    "whole",
    "whomever",
    "whoopee",
    "whooping",
    "whoops",
    "why",
    "wick",
    "widely",
    "widen",
    "widget",
    "widow",
    "width",
    "wieldable",
    "wielder",
    "wife",
    "wifi",
    "wikipedia",
    "wildcard",
    "wildcat",
    "wilder",
    "wildfire",
    "wildfowl",
    "wildland",
    "wildlife",
    "wildly",
    "wildness",
    "willed",
    "willfully",
    "willing",
    "willow",
    "willpower",
    "wilt",
    "wimp",
    "wince",
    "wincing",
    "wind",
    "wing",
    "winking",
    "winner",
    "winnings",
    "winter",
    "wipe",
    "wired",
    "wireless",
    "wiring",
    "wiry",
    "wisdom",
    "wise",
    "wish",
    "wisplike",
    "wispy",
    "wistful",
    "wizard",
    "wobble",
    "wobbling",
    "wobbly",
    "wok",
    "wolf",
    "wolverine",
    "womanhood",
    "womankind",
    "womanless",
    "womanlike",
    "womanly",
    "womb",
    "woof",
    "wooing",
    "wool",
    "woozy",
    "word",
    "work",
    "worried",
    "worrier",
    "worrisome",
    "worry",
    "worsening",
    "worshiper",
    "worst",
    "wound",
    "woven",
    "wow",
    "wrangle",
    "wrath",
    "wreath",
    "wreckage",
    "wrecker",
    "wrecking",
    "wrench",
    "wriggle",
    "wriggly",
    "wrinkle",
    "wrinkly",
    "wrist",
    "writing",
    "written",
    "wrongdoer",
    "wronged",
    "wrongful",
    "wrongly",
    "wrongness",
    "wrought",
    "xbox",
    "xerox",
    "yahoo",
    "yam",
    "yanking",
    "yapping",
    "yard",
    "yarn",
    "yeah",
    "yearbook",
    "yearling",
    "yearly",
    "yearning",
    "yeast",
    "yelling",
    "yelp",
    "yen",
    "yesterday",
    "yiddish",
    "yield",
    "yin",
    "yippee",
    "yo-yo",
    "yodel",
    "yoga",
    "yogurt",
    "yonder",
    "yoyo",
    "yummy",
    "zap",
    "zealous",
    "zebra",
    "zen",
    "zeppelin",
    "zero",
    "zestfully",
    "zesty",
    "zigzagged",
    "zipfile",
    "zipping",
    "zippy",
    "zips",
    "zit",
    "zodiac",
    "zombie",
    "zone",
    "zoning",
    "zookeeper",
    "zoologist",
    "zoology",
    "zoom"
  ];
  return wordlist$1;
}
var hasRequiredNewSecureWords;
function requireNewSecureWords() {
  if (hasRequiredNewSecureWords) return newSecureWords;
  hasRequiredNewSecureWords = 1;
  Object.defineProperty(newSecureWords, "__esModule", { value: true });
  newSecureWords.newSecureWords = void 0;
  const getSecureRandom_1 = requireGetSecureRandom();
  const wordlist_1 = requireWordlist$1();
  async function newSecureWords$1(size = 6) {
    let words = [];
    for (let i = 0; i < size; i++) {
      words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
    }
    return words;
  }
  newSecureWords.newSecureWords = newSecureWords$1;
  return newSecureWords;
}
var newSecurePassphrase = {};
var hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
  if (hasRequiredNewSecurePassphrase) return newSecurePassphrase;
  hasRequiredNewSecurePassphrase = 1;
  Object.defineProperty(newSecurePassphrase, "__esModule", { value: true });
  newSecurePassphrase.newSecurePassphrase = void 0;
  const __1 = requireDist$4();
  async function newSecurePassphrase$1(size = 6) {
    return (await (0, __1.newSecureWords)(size)).join("-");
  }
  newSecurePassphrase.newSecurePassphrase = newSecurePassphrase$1;
  return newSecurePassphrase;
}
var mnemonic = {};
var binary = {};
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  Object.defineProperty(binary, "__esModule", { value: true });
  binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  binary.lpad = lpad;
  function bytesToBits(bytes) {
    let res = "";
    for (let i = 0; i < bytes.length; i++) {
      let x2 = bytes.at(i);
      res += lpad(x2.toString(2), "0", 8);
    }
    return res;
  }
  binary.bytesToBits = bytesToBits;
  function bitsToBytes(src) {
    if (src.length % 8 !== 0) {
      throw Error("Uneven bits");
    }
    let res = [];
    while (src.length > 0) {
      res.push(parseInt(src.slice(0, 8), 2));
      src = src.slice(8);
    }
    return Buffer.from(res);
  }
  binary.bitsToBytes = bitsToBytes;
  return binary;
}
var wordlist = {};
var hasRequiredWordlist;
function requireWordlist() {
  if (hasRequiredWordlist) return wordlist;
  hasRequiredWordlist = 1;
  Object.defineProperty(wordlist, "__esModule", { value: true });
  wordlist.wordlist = void 0;
  const EN = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  wordlist.wordlist = EN;
  return wordlist;
}
var hasRequiredMnemonic;
function requireMnemonic() {
  if (hasRequiredMnemonic) return mnemonic;
  hasRequiredMnemonic = 1;
  var __importDefault = mnemonic && mnemonic.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(mnemonic, "__esModule", { value: true });
  mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  const getSecureRandom_1 = requireGetSecureRandom();
  const hmac_sha512_1 = requireHmac_sha512();
  const pbkdf2_sha512_1 = requirePbkdf2_sha512();
  const binary_1 = requireBinary();
  const wordlist_1 = requireWordlist();
  const PBKDF_ITERATIONS = 1e5;
  async function isPasswordNeeded(mnemonicArray) {
    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
    return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
  }
  function normalizeMnemonic(src) {
    return src.map((v2) => v2.toLowerCase().trim());
  }
  async function isBasicSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
    return seed[0] == 0;
  }
  async function isPasswordSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
    return seed[0] == 1;
  }
  async function mnemonicToEntropy(mnemonicArray, password) {
    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
  }
  mnemonic.mnemonicToEntropy = mnemonicToEntropy;
  async function mnemonicToSeed2(mnemonicArray, seed, password) {
    const entropy = await mnemonicToEntropy(mnemonicArray, password);
    return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
  }
  mnemonic.mnemonicToSeed = mnemonicToSeed2;
  async function mnemonicToPrivateKey(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    const seed = await mnemonicToSeed2(mnemonicArray, "TON default seed", password);
    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
  async function mnemonicToWalletKey(mnemonicArray, password) {
    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
    let seedSecret = seedPk.secretKey.slice(0, 32);
    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
  async function mnemonicToHDSeed(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    return await mnemonicToSeed2(mnemonicArray, "TON HD Keys seed", password);
  }
  mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
  async function mnemonicValidate(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    for (let word of mnemonicArray) {
      if (wordlist_1.wordlist.indexOf(word) < 0) {
        return false;
      }
    }
    if (password && password.length > 0) {
      if (!await isPasswordNeeded(mnemonicArray)) {
        return false;
      }
    }
    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
  }
  mnemonic.mnemonicValidate = mnemonicValidate;
  async function mnemonicNew(wordsCount = 24, password) {
    let mnemonicArray = [];
    while (true) {
      mnemonicArray = [];
      for (let i = 0; i < wordsCount; i++) {
        let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
        mnemonicArray.push(wordlist_1.wordlist[ind]);
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          continue;
        }
      }
      if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
        continue;
      }
      break;
    }
    return mnemonicArray;
  }
  mnemonic.mnemonicNew = mnemonicNew;
  function bytesToMnemonicIndexes(src, wordsCount) {
    let bits = (0, binary_1.bytesToBits)(src);
    let indexes = [];
    for (let i = 0; i < wordsCount; i++) {
      let sl = bits.slice(i * 11, i * 11 + 11);
      indexes.push(parseInt(sl, 2));
    }
    return indexes;
  }
  mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
  function bytesToMnemonics(src, wordsCount) {
    let mnemonics2 = bytesToMnemonicIndexes(src, wordsCount);
    let res = [];
    for (let m2 of mnemonics2) {
      res.push(wordlist_1.wordlist[m2]);
    }
    return res;
  }
  mnemonic.bytesToMnemonics = bytesToMnemonics;
  function mnemonicIndexesToBytes(src) {
    let res = "";
    for (let s2 of src) {
      if (!Number.isSafeInteger(s2)) {
        throw Error("Invalid input");
      }
      if (s2 < 0 || s2 >= 2028) {
        throw Error("Invalid input");
      }
      res += (0, binary_1.lpad)(s2.toString(2), "0", 11);
    }
    while (res.length % 8 !== 0) {
      res = res + "0";
    }
    return (0, binary_1.bitsToBytes)(res);
  }
  mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
  async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
    const bytesLength = Math.ceil(wordsCount * 11 / 8);
    let currentSeed = seed;
    while (true) {
      let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
      let mnemonics2 = bytesToMnemonics(entropy, wordsCount);
      if (await mnemonicValidate(mnemonics2, password)) {
        return mnemonics2;
      }
      currentSeed = entropy;
    }
  }
  mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
  return mnemonic;
}
var nacl = {};
var hasRequiredNacl;
function requireNacl() {
  if (hasRequiredNacl) return nacl;
  hasRequiredNacl = 1;
  var __importDefault = nacl && nacl.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(nacl, "__esModule", { value: true });
  nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  function keyPairFromSecretKey(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSecretKey = keyPairFromSecretKey;
  function keyPairFromSeed(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSeed = keyPairFromSeed;
  function sign2(data, secretKey) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
  }
  nacl.sign = sign2;
  function signVerify(data, signature, publicKey) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
  }
  nacl.signVerify = signVerify;
  function sealBox(data, nonce, key) {
    return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
  }
  nacl.sealBox = sealBox;
  function openBox(data, nonce, key) {
    let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
    if (!res) {
      return null;
    }
    return Buffer.from(res);
  }
  nacl.openBox = openBox;
  return nacl;
}
var ed25519 = {};
var hasRequiredEd25519;
function requireEd25519() {
  if (hasRequiredEd25519) return ed25519;
  hasRequiredEd25519 = 1;
  Object.defineProperty(ed25519, "__esModule", { value: true });
  ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const ED25519_CURVE = "ed25519 seed";
  const HARDENED_OFFSET = 2147483648;
  async function getED25519MasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
  async function deriveED25519HardenedKey(parent, index2) {
    if (index2 >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index2 + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
  async function deriveEd25519Path(seed, path) {
    let state = await getED25519MasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index2 = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveED25519HardenedKey(state, index2);
    }
    return state.key;
  }
  ed25519.deriveEd25519Path = deriveEd25519Path;
  return ed25519;
}
var symmetric = {};
var hasRequiredSymmetric;
function requireSymmetric() {
  if (hasRequiredSymmetric) return symmetric;
  hasRequiredSymmetric = 1;
  Object.defineProperty(symmetric, "__esModule", { value: true });
  symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const SYMMETRIC_SEED = "Symmetric key seed";
  async function getSymmetricMasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
    const IL = I2.slice(32);
    const IR = I2.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
  async function deriveSymmetricHardenedKey(parent, offset) {
    const data = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(offset)]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(32);
    const IR = I2.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
  async function deriveSymmetricPath(seed, path) {
    let state = await getSymmetricMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index2 = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveSymmetricHardenedKey(state, index2);
    }
    return state.key;
  }
  symmetric.deriveSymmetricPath = deriveSymmetricPath;
  return symmetric;
}
var mnemonics = {};
var hasRequiredMnemonics;
function requireMnemonics() {
  if (hasRequiredMnemonics) return mnemonics;
  hasRequiredMnemonics = 1;
  Object.defineProperty(mnemonics, "__esModule", { value: true });
  mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
  const mnemonic_1 = requireMnemonic();
  const hmac_sha512_1 = requireHmac_sha512();
  const HARDENED_OFFSET = 2147483648;
  const MNEMONICS_SEED = "TON Mnemonics HD seed";
  async function getMnemonicsMasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
  async function deriveMnemonicHardenedKey(parent, index2) {
    if (index2 >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index2 + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
  async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
    let state = await getMnemonicsMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index2 = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveMnemonicHardenedKey(state, index2);
    }
    return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
  }
  mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
  return mnemonics;
}
var hasRequiredDist$4;
function requireDist$4() {
  if (hasRequiredDist$4) return dist$3;
  hasRequiredDist$4 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = requireSha256();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = requireSha512();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = requireHmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = requireGetSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var newSecureWords_1 = requireNewSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = requireNewSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
    var mnemonic_1 = requireMnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToHDSeed;
    } });
    var wordlist_1 = requireWordlist();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = requireNacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    var nacl_2 = requireNacl();
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSeed;
    } });
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var ed25519_1 = requireEd25519();
    Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
      return ed25519_1.getED25519MasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
      return ed25519_1.deriveED25519HardenedKey;
    } });
    Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
      return ed25519_1.deriveEd25519Path;
    } });
    var symmetric_1 = requireSymmetric();
    Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
      return symmetric_1.getSymmetricMasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricHardenedKey;
    } });
    Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricPath;
    } });
    var mnemonics_1 = requireMnemonics();
    Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicsPath;
    } });
    Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicHardenedKey;
    } });
    Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
      return mnemonics_1.getMnemonicsMasterKeyFromSeed;
    } });
  })(dist$3);
  return dist$3;
}
var hasRequiredWonderCalculator$1;
function requireWonderCalculator$1() {
  if (hasRequiredWonderCalculator$1) return wonderCalculator$1;
  hasRequiredWonderCalculator$1 = 1;
  Object.defineProperty(wonderCalculator$1, "__esModule", { value: true });
  wonderCalculator$1.wonderCalculator = void 0;
  const BitString_1 = requireBitString$1();
  const CellType_1 = requireCellType$1();
  const LevelMask_1 = requireLevelMask$1();
  const exoticPruned_1 = requireExoticPruned$1();
  const exoticMerkleProof_1 = requireExoticMerkleProof$1();
  const descriptor_1 = requireDescriptor$1();
  const crypto_1 = requireDist$4();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate$1();
  const exoticLibrary_1 = requireExoticLibrary$1();
  function wonderCalculator2(type, bits, refs) {
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
      let mask = 0;
      for (let r of refs) {
        mask = mask | r.mask.value;
      }
      levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
      pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
      (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
      (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
      (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      levelMask = new LevelMask_1.LevelMask();
    } else {
      throw new Error("Unsupported exotic type");
    }
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
      if (!levelMask.isSignificant(levelI)) {
        continue;
      }
      if (hashI < hashIOffset) {
        hashI++;
        continue;
      }
      let currentBits;
      if (hashI === hashIOffset) {
        if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid");
        }
        currentBits = bits;
      } else {
        if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid: " + levelI + ", " + type);
        }
        currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
      }
      let currentDepth = 0;
      for (let c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(levelI + 1);
        } else {
          childDepth = c.depth(levelI);
        }
        currentDepth = Math.max(currentDepth, childDepth);
      }
      if (refs.length > 0) {
        currentDepth++;
      }
      let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
      let hash = (0, crypto_1.sha256_sync)(repr);
      let destI = hashI - hashIOffset;
      depths[destI] = currentDepth;
      hashes[destI] = hash;
      hashI++;
    }
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
      for (let i = 0; i < 4; i++) {
        const { hashIndex } = levelMask.apply(i);
        const { hashIndex: thisHashIndex } = levelMask;
        if (hashIndex !== thisHashIndex) {
          resolvedHashes.push(pruned.pruned[hashIndex].hash);
          resolvedDepths.push(pruned.pruned[hashIndex].depth);
        } else {
          resolvedHashes.push(hashes[0]);
          resolvedDepths.push(depths[0]);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
        resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
      }
    }
    return {
      mask: levelMask,
      hashes: resolvedHashes,
      depths: resolvedDepths
    };
  }
  wonderCalculator$1.wonderCalculator = wonderCalculator2;
  return wonderCalculator$1;
}
var serialization$1 = {};
var topologicalSort$1 = {};
var hasRequiredTopologicalSort$1;
function requireTopologicalSort$1() {
  if (hasRequiredTopologicalSort$1) return topologicalSort$1;
  hasRequiredTopologicalSort$1 = 1;
  Object.defineProperty(topologicalSort$1, "__esModule", { value: true });
  topologicalSort$1.topologicalSort = void 0;
  function topologicalSort2(src) {
    let pending = [src];
    let allCells = /* @__PURE__ */ new Map();
    let notPermCells = /* @__PURE__ */ new Set();
    let sorted = [];
    while (pending.length > 0) {
      const cells = [...pending];
      pending = [];
      for (let cell of cells) {
        const hash = cell.hash().toString("hex");
        if (allCells.has(hash)) {
          continue;
        }
        notPermCells.add(hash);
        allCells.set(hash, { cell, refs: cell.refs.map((v2) => v2.hash().toString("hex")) });
        for (let r of cell.refs) {
          pending.push(r);
        }
      }
    }
    let tempMark = /* @__PURE__ */ new Set();
    function visit2(hash) {
      if (!notPermCells.has(hash)) {
        return;
      }
      if (tempMark.has(hash)) {
        throw Error("Not a DAG");
      }
      tempMark.add(hash);
      let refs = allCells.get(hash).refs;
      for (let ci = refs.length - 1; ci >= 0; ci--) {
        visit2(refs[ci]);
      }
      sorted.push(hash);
      tempMark.delete(hash);
      notPermCells.delete(hash);
    }
    while (notPermCells.size > 0) {
      const id = Array.from(notPermCells)[0];
      visit2(id);
    }
    let indexes = /* @__PURE__ */ new Map();
    for (let i = 0; i < sorted.length; i++) {
      indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      let ent = sorted[i];
      const rrr = allCells.get(ent);
      result.push({ cell: rrr.cell, refs: rrr.refs.map((v2) => indexes.get(v2)) });
    }
    return result;
  }
  topologicalSort$1.topologicalSort = topologicalSort2;
  return topologicalSort$1;
}
var bitsForNumber$1 = {};
var hasRequiredBitsForNumber$1;
function requireBitsForNumber$1() {
  if (hasRequiredBitsForNumber$1) return bitsForNumber$1;
  hasRequiredBitsForNumber$1 = 1;
  Object.defineProperty(bitsForNumber$1, "__esModule", { value: true });
  bitsForNumber$1.bitsForNumber = void 0;
  function bitsForNumber2(src, mode) {
    let v2 = BigInt(src);
    if (mode === "int") {
      if (v2 === 0n || v2 === -1n) {
        return 1;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      return v22.toString(2).length + 1;
    } else if (mode === "uint") {
      if (v2 < 0) {
        throw Error(`value is negative. Got ${src}`);
      }
      return v2.toString(2).length;
    } else {
      throw Error(`invalid mode. Got ${mode}`);
    }
  }
  bitsForNumber$1.bitsForNumber = bitsForNumber2;
  return bitsForNumber$1;
}
var crc32c$1 = {};
var hasRequiredCrc32c$1;
function requireCrc32c$1() {
  if (hasRequiredCrc32c$1) return crc32c$1;
  hasRequiredCrc32c$1 = 1;
  Object.defineProperty(crc32c$1, "__esModule", { value: true });
  crc32c$1.crc32c = void 0;
  const POLY = 2197175160;
  function crc32c2(source) {
    let crc = 0 ^ 4294967295;
    for (let n = 0; n < source.length; n++) {
      crc ^= source[n];
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 4294967295;
    let res = Buffer.alloc(4);
    res.writeInt32LE(crc);
    return res;
  }
  crc32c$1.crc32c = crc32c2;
  return crc32c$1;
}
var hasRequiredSerialization$1;
function requireSerialization$1() {
  if (hasRequiredSerialization$1) return serialization$1;
  hasRequiredSerialization$1 = 1;
  Object.defineProperty(serialization$1, "__esModule", { value: true });
  serialization$1.serializeBoc = serialization$1.deserializeBoc = serialization$1.parseBoc = void 0;
  const BitReader_1 = requireBitReader$1();
  const BitString_1 = requireBitString$1();
  const Cell_1 = requireCell$1();
  const topologicalSort_1 = requireTopologicalSort$1();
  const bitsForNumber_1 = requireBitsForNumber$1();
  const BitBuilder_1 = requireBitBuilder$1();
  const descriptor_1 = requireDescriptor$1();
  const paddedBits_1 = requirePaddedBits$1();
  const crc32c_1 = requireCrc32c$1();
  function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
  }
  function getHashesCountFromMask(mask) {
    let n = 0;
    for (let i = 0; i < 3; i++) {
      n += mask & 1;
      mask = mask >> 1;
    }
    return n + 1;
  }
  function readCell(reader2, sizeBytes) {
    const d1 = reader2.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    const d2 = reader2.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader2.skip(hashesSize * 8);
    reader2.skip(depthSize * 8);
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
      if (paddingAdded) {
        bits = reader2.loadPaddedBits(dataBytesize * 8);
      } else {
        bits = reader2.loadBits(dataBytesize * 8);
      }
    }
    let refs = [];
    for (let i = 0; i < refsCount; i++) {
      refs.push(reader2.loadUint(sizeBytes * 8));
    }
    return {
      bits,
      refs,
      exotic
    };
  }
  function calcCellSize(cell, sizeBytes) {
    return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
  }
  function parseBoc(src) {
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
    let magic = reader2.loadUint(32);
    if (magic === 1761568243) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index2 = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root: [0]
      };
    } else if (magic === 2898503464) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index2 = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      let crc32 = reader2.loadBuffer(4);
      if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
        throw Error("Invalid CRC32C");
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root: [0]
      };
    } else if (magic === 3052313714) {
      let hasIdx = reader2.loadUint(1);
      let hasCrc32c = reader2.loadUint(1);
      reader2.loadUint(1);
      reader2.loadUint(2);
      let size = reader2.loadUint(3);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let root = [];
      for (let i = 0; i < roots; i++) {
        root.push(reader2.loadUint(size * 8));
      }
      let index2 = null;
      if (hasIdx) {
        index2 = reader2.loadBuffer(cells * offBytes);
      }
      let cellData = reader2.loadBuffer(totalCellSize);
      if (hasCrc32c) {
        let crc32 = reader2.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root
      };
    } else {
      throw Error("Invalid magic");
    }
  }
  serialization$1.parseBoc = parseBoc;
  function deserializeBoc(src) {
    let boc = parseBoc(src);
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    let cells = [];
    for (let i = 0; i < boc.cells; i++) {
      let cll = readCell(reader2, boc.size);
      cells.push({ ...cll, result: null });
    }
    for (let i = cells.length - 1; i >= 0; i--) {
      if (cells[i].result) {
        throw Error("Impossible");
      }
      let refs = [];
      for (let r of cells[i].refs) {
        if (!cells[r].result) {
          throw Error("Invalid BOC file");
        }
        refs.push(cells[r].result);
      }
      cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
    }
    let roots = [];
    for (let i = 0; i < boc.root.length; i++) {
      roots.push(cells[boc.root[i]].result);
    }
    return roots;
  }
  serialization$1.deserializeBoc = deserializeBoc;
  function writeCellToBuilder(cell, refs, sizeBytes, to2) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to2.writeUint(d1, 8);
    to2.writeUint(d2, 8);
    to2.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs) {
      to2.writeUint(r, sizeBytes * 8);
    }
  }
  function serializeBoc(root, opts) {
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
    let totalCellSize = 0;
    let index2 = [];
    for (let c of allCells) {
      let sz = calcCellSize(c.cell, sizeBytes);
      totalCellSize += sz;
      index2.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    let builder2 = new BitBuilder_1.BitBuilder(totalSize);
    builder2.writeUint(3052313714, 32);
    builder2.writeBit(has_idx);
    builder2.writeBit(has_crc32c);
    builder2.writeBit(has_cache_bits);
    builder2.writeUint(flags, 2);
    builder2.writeUint(sizeBytes, 3);
    builder2.writeUint(offsetBytes, 8);
    builder2.writeUint(cellsNum, sizeBytes * 8);
    builder2.writeUint(1, sizeBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    builder2.writeUint(totalCellSize, offsetBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    if (has_idx) {
      for (let i = 0; i < cellsNum; i++) {
        builder2.writeUint(index2[i], offsetBytes * 8);
      }
    }
    for (let i = 0; i < cellsNum; i++) {
      writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder2);
    }
    if (has_crc32c) {
      let crc32 = (0, crc32c_1.crc32c)(builder2.buffer());
      builder2.writeBuffer(crc32);
    }
    let res = builder2.buffer();
    if (res.length !== totalSize / 8) {
      throw Error("Internal error");
    }
    return res;
  }
  serialization$1.serializeBoc = serializeBoc;
  return serialization$1;
}
var hasRequiredCell$1;
function requireCell$1() {
  if (hasRequiredCell$1) return Cell$1;
  hasRequiredCell$1 = 1;
  var __importDefault = Cell$1 && Cell$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Cell$1, "__esModule", { value: true });
  Cell$1.Cell = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const BitString_1 = requireBitString$1();
  const CellType_1 = requireCellType$1();
  const Slice_1 = requireSlice$1();
  const resolveExotic_1 = requireResolveExotic$1();
  const wonderCalculator_1 = requireWonderCalculator$1();
  const serialization_1 = requireSerialization$1();
  const BitReader_1 = requireBitReader$1();
  const Builder_12 = requireBuilder$3();
  class Cell2 {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */
    static fromBoc(src) {
      return (0, serialization_1.deserializeBoc)(src);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */
    static fromBase64(src) {
      let parsed = Cell2.fromBoc(Buffer.from(src, "base64"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */
    static fromHex(src) {
      let parsed = Cell2.fromBoc(Buffer.from(src, "hex"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    constructor(opts) {
      this._hashes = [];
      this._depths = [];
      this.beginParse = (allowExotic = false) => {
        if (this.isExotic && !allowExotic) {
          throw new Error("Exotic cells cannot be parsed");
        }
        return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
      };
      this.hash = (level = 3) => {
        return this._hashes[Math.min(this._hashes.length - 1, level)];
      };
      this.depth = (level = 3) => {
        return this._depths[Math.min(this._depths.length - 1, level)];
      };
      this.level = () => {
        return this.mask.level;
      };
      this.equals = (other) => {
        return this.hash().equals(other.hash());
      };
      this[_a2] = () => this.toString();
      let bits = BitString_1.BitString.EMPTY;
      if (opts && opts.bits) {
        bits = opts.bits;
      }
      let refs = [];
      if (opts && opts.refs) {
        refs = [...opts.refs];
      }
      let hashes;
      let depths;
      let mask;
      let type = CellType_1.CellType.Ordinary;
      if (opts && opts.exotic) {
        let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
        let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = resolved.type;
      } else {
        if (refs.length > 4) {
          throw new Error("Invalid number of references");
        }
        if (bits.length > 1023) {
          throw new Error(`Bits overflow: ${bits.length} > 1023`);
        }
        let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = CellType_1.CellType.Ordinary;
      }
      this.type = type;
      this.bits = bits;
      this.refs = refs;
      this.mask = mask;
      this._depths = depths;
      this._hashes = hashes;
      Object.freeze(this);
      Object.freeze(this.refs);
      Object.freeze(this.bits);
      Object.freeze(this.mask);
      Object.freeze(this._depths);
      Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */
    get isExotic() {
      return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */
    toBoc(opts) {
      let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
      let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
      return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */
    toString(indent) {
      let id = indent || "";
      let t = "x";
      if (this.isExotic) {
        if (this.type === CellType_1.CellType.MerkleProof) {
          t = "p";
        } else if (this.type === CellType_1.CellType.MerkleUpdate) {
          t = "u";
        } else if (this.type === CellType_1.CellType.PrunedBranch) {
          t = "p";
        }
      }
      let s2 = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
      for (let k2 in this.refs) {
        const i = this.refs[k2];
        s2 += "\n" + i.toString(id + " ");
      }
      return s2;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */
    asSlice() {
      return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this.asSlice());
    }
  }
  Cell$1.Cell = Cell2;
  _a2 = symbol_inspect_1.default;
  Cell2.EMPTY = new Cell2();
  return Cell$1;
}
var hasRequiredBuilder$3;
function requireBuilder$3() {
  if (hasRequiredBuilder$3) return Builder$4;
  hasRequiredBuilder$3 = 1;
  Object.defineProperty(Builder$4, "__esModule", { value: true });
  Builder$4.Builder = Builder$4.beginCell = void 0;
  const BitBuilder_1 = requireBitBuilder$1();
  const Cell_1 = requireCell$1();
  const strings_1 = requireStrings$1();
  function beginCell() {
    return new Builder2();
  }
  Builder$4.beginCell = beginCell;
  class Builder2 {
    constructor() {
      this._bits = new BitBuilder_1.BitBuilder();
      this._refs = [];
    }
    /**
     * Bits written so far
     */
    get bits() {
      return this._bits.length;
    }
    /**
     * References written so far
     */
    get refs() {
      return this._refs.length;
    }
    /**
     * Available bits
     */
    get availableBits() {
      return 1023 - this.bits;
    }
    /**
     * Available references
     */
    get availableRefs() {
      return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */
    storeBit(value) {
      this._bits.writeBit(value);
      return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */
    storeBits(src) {
      this._bits.writeBits(src);
      return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeBuffer(src, bytes) {
      if (bytes !== void 0 && bytes !== null) {
        if (src.length !== bytes) {
          throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
        }
      }
      this._bits.writeBuffer(src);
      return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeMaybeBuffer(src, bytes) {
      if (src !== null) {
        this.storeBit(1);
        this.storeBuffer(src, bytes);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeUint(value, bits) {
      this._bits.writeUint(value, bits);
      return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeInt(value, bits) {
      this._bits.writeInt(value, bits);
      return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarUint(value, bits) {
      this._bits.writeVarUint(value, bits);
      return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarInt(value, bits) {
      this._bits.writeVarInt(value, bits);
      return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */
    storeCoins(amount) {
      this._bits.writeCoins(amount);
      return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */
    storeMaybeCoins(amount) {
      if (amount !== null && amount !== void 0) {
        this.storeBit(1);
        this.storeCoins(amount);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */
    storeAddress(address) {
      this._bits.writeAddress(address);
      return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeRef(cell) {
      if (this._refs.length >= 4) {
        throw new Error("Too many references");
      }
      if (cell instanceof Cell_1.Cell) {
        this._refs.push(cell);
      } else if (cell instanceof Builder2) {
        this._refs.push(cell.endCell());
      } else {
        throw new Error("Invalid argument");
      }
      return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeMaybeRef(cell) {
      if (cell) {
        this.storeBit(1);
        this.storeRef(cell);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */
    storeSlice(src) {
      let c = src.clone();
      if (c.remainingBits > 0) {
        this.storeBits(c.loadBits(c.remainingBits));
      }
      while (c.remainingRefs > 0) {
        this.storeRef(c.loadRef());
      }
      return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */
    storeMaybeSlice(src) {
      if (src) {
        this.storeBit(1);
        this.storeSlice(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */
    storeBuilder(src) {
      return this.storeSlice(src.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */
    storeMaybeBuilder(src) {
      if (src) {
        this.storeBit(1);
        this.storeBuilder(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeWritable(writer) {
      if (typeof writer === "object") {
        writer.writeTo(this);
      } else {
        writer(this);
      }
      return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeMaybeWritable(writer) {
      if (writer) {
        this.storeBit(1);
        this.storeWritable(writer);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */
    store(writer) {
      this.storeWritable(writer);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeStringTail(src) {
      (0, strings_1.writeString)(src, this);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringTail(src) {
      if (src !== null && src !== void 0) {
        this.storeBit(1);
        (0, strings_1.writeString)(src, this);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeStringRefTail(src) {
      this.storeRef(beginCell().storeStringTail(src));
      return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringRefTail(src) {
      if (src !== null && src !== void 0) {
        this.storeBit(1);
        this.storeStringRefTail(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDict(dict, key, value) {
      if (dict) {
        dict.store(this, key, value);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDictDirect(dict, key, value) {
      dict.storeDirect(this, key, value);
      return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */
    endCell(opts) {
      return new Cell_1.Cell({
        bits: this._bits.build(),
        refs: this._refs,
        exotic: opts?.exotic
      });
    }
    /**
     * Convert to cell
     * @returns cell
     */
    asCell() {
      return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */
    asSlice() {
      return this.endCell().beginParse();
    }
  }
  Builder$4.Builder = Builder2;
  return Builder$4;
}
var StateInit$1 = {};
var SimpleLibrary$1 = {};
var hasRequiredSimpleLibrary$1;
function requireSimpleLibrary$1() {
  if (hasRequiredSimpleLibrary$1) return SimpleLibrary$1;
  hasRequiredSimpleLibrary$1 = 1;
  Object.defineProperty(SimpleLibrary$1, "__esModule", { value: true });
  SimpleLibrary$1.SimpleLibraryValue = SimpleLibrary$1.storeSimpleLibrary = SimpleLibrary$1.loadSimpleLibrary = void 0;
  function loadSimpleLibrary(slice) {
    return {
      public: slice.loadBit(),
      root: slice.loadRef()
    };
  }
  SimpleLibrary$1.loadSimpleLibrary = loadSimpleLibrary;
  function storeSimpleLibrary(src) {
    return (builder2) => {
      builder2.storeBit(src.public);
      builder2.storeRef(src.root);
    };
  }
  SimpleLibrary$1.storeSimpleLibrary = storeSimpleLibrary;
  SimpleLibrary$1.SimpleLibraryValue = {
    serialize(src, builder2) {
      storeSimpleLibrary(src)(builder2);
    },
    parse(src) {
      return loadSimpleLibrary(src);
    }
  };
  return SimpleLibrary$1;
}
var TickTock$1 = {};
var hasRequiredTickTock$1;
function requireTickTock$1() {
  if (hasRequiredTickTock$1) return TickTock$1;
  hasRequiredTickTock$1 = 1;
  Object.defineProperty(TickTock$1, "__esModule", { value: true });
  TickTock$1.storeTickTock = TickTock$1.loadTickTock = void 0;
  function loadTickTock(slice) {
    return {
      tick: slice.loadBit(),
      tock: slice.loadBit()
    };
  }
  TickTock$1.loadTickTock = loadTickTock;
  function storeTickTock(src) {
    return (builder2) => {
      builder2.storeBit(src.tick);
      builder2.storeBit(src.tock);
    };
  }
  TickTock$1.storeTickTock = storeTickTock;
  return TickTock$1;
}
var hasRequiredStateInit$1;
function requireStateInit$1() {
  if (hasRequiredStateInit$1) return StateInit$1;
  hasRequiredStateInit$1 = 1;
  Object.defineProperty(StateInit$1, "__esModule", { value: true });
  StateInit$1.storeStateInit = StateInit$1.loadStateInit = void 0;
  const Dictionary_1 = requireDictionary$1();
  const SimpleLibrary_1 = requireSimpleLibrary$1();
  const TickTock_1 = requireTickTock$1();
  function loadStateInit(slice) {
    let splitDepth;
    if (slice.loadBit()) {
      splitDepth = slice.loadUint(5);
    }
    let special;
    if (slice.loadBit()) {
      special = (0, TickTock_1.loadTickTock)(slice);
    }
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
      libraries = void 0;
    }
    return {
      splitDepth,
      special,
      code,
      data,
      libraries
    };
  }
  StateInit$1.loadStateInit = loadStateInit;
  function storeStateInit(src) {
    return (builder2) => {
      if (src.splitDepth !== null && src.splitDepth !== void 0) {
        builder2.storeBit(true);
        builder2.storeUint(src.splitDepth, 5);
      } else {
        builder2.storeBit(false);
      }
      if (src.special !== null && src.special !== void 0) {
        builder2.storeBit(true);
        builder2.store((0, TickTock_1.storeTickTock)(src.special));
      } else {
        builder2.storeBit(false);
      }
      builder2.storeMaybeRef(src.code);
      builder2.storeMaybeRef(src.data);
      builder2.storeDict(src.libraries);
    };
  }
  StateInit$1.storeStateInit = storeStateInit;
  return StateInit$1;
}
var hasRequiredContractAddress$1;
function requireContractAddress$1() {
  if (hasRequiredContractAddress$1) return contractAddress$1;
  hasRequiredContractAddress$1 = 1;
  Object.defineProperty(contractAddress$1, "__esModule", { value: true });
  contractAddress$1.contractAddress = void 0;
  const Builder_12 = requireBuilder$3();
  const StateInit_1 = requireStateInit$1();
  const Address_1 = requireAddress$1();
  function contractAddress2(workchain, init2) {
    let hash = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(init2)).endCell().hash();
    return new Address_1.Address(workchain, hash);
  }
  contractAddress$1.contractAddress = contractAddress2;
  return contractAddress$1;
}
var tuple$1 = {};
var hasRequiredTuple$1;
function requireTuple$1() {
  if (hasRequiredTuple$1) return tuple$1;
  hasRequiredTuple$1 = 1;
  Object.defineProperty(tuple$1, "__esModule", { value: true });
  tuple$1.parseTuple = tuple$1.serializeTuple = tuple$1.parseTupleItem = tuple$1.serializeTupleItem = void 0;
  const Builder_12 = requireBuilder$3();
  const INT64_MIN = BigInt("-9223372036854775808");
  const INT64_MAX = BigInt("9223372036854775807");
  function serializeTupleItem(src, builder2) {
    if (src.type === "null") {
      builder2.storeUint(0, 8);
    } else if (src.type === "int") {
      if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
        builder2.storeUint(1, 8);
        builder2.storeInt(src.value, 64);
      } else {
        builder2.storeUint(256, 15);
        builder2.storeInt(src.value, 257);
      }
    } else if (src.type === "nan") {
      builder2.storeInt(767, 16);
    } else if (src.type === "cell") {
      builder2.storeUint(3, 8);
      builder2.storeRef(src.cell);
    } else if (src.type === "slice") {
      builder2.storeUint(4, 8);
      builder2.storeUint(0, 10);
      builder2.storeUint(src.cell.bits.length, 10);
      builder2.storeUint(0, 3);
      builder2.storeUint(src.cell.refs.length, 3);
      builder2.storeRef(src.cell);
    } else if (src.type === "builder") {
      builder2.storeUint(5, 8);
      builder2.storeRef(src.cell);
    } else if (src.type === "tuple") {
      let head = null;
      let tail = null;
      for (let i = 0; i < src.items.length; i++) {
        let s2 = head;
        head = tail;
        tail = s2;
        if (i > 1) {
          head = (0, Builder_12.beginCell)().storeRef(tail).storeRef(head).endCell();
        }
        let bc = (0, Builder_12.beginCell)();
        serializeTupleItem(src.items[i], bc);
        tail = bc.endCell();
      }
      builder2.storeUint(7, 8);
      builder2.storeUint(src.items.length, 16);
      if (head) {
        builder2.storeRef(head);
      }
      if (tail) {
        builder2.storeRef(tail);
      }
    } else {
      throw Error("Invalid value");
    }
  }
  tuple$1.serializeTupleItem = serializeTupleItem;
  function parseTupleItem(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
      return { type: "null" };
    } else if (kind === 1) {
      return { type: "int", value: cs.loadIntBig(64) };
    } else if (kind === 2) {
      if (cs.loadUint(7) === 0) {
        return { type: "int", value: cs.loadIntBig(257) };
      } else {
        cs.loadBit();
        return { type: "nan" };
      }
    } else if (kind === 3) {
      return { type: "cell", cell: cs.loadRef() };
    } else if (kind === 4) {
      let startBits = cs.loadUint(10);
      let endBits = cs.loadUint(10);
      let startRefs = cs.loadUint(3);
      let endRefs = cs.loadUint(3);
      let rs = cs.loadRef().beginParse();
      rs.skip(startBits);
      let dt2 = rs.loadBits(endBits - startBits);
      let builder2 = (0, Builder_12.beginCell)().storeBits(dt2);
      if (startRefs < endRefs) {
        for (let i = 0; i < startRefs; i++) {
          rs.loadRef();
        }
        for (let i = 0; i < endRefs - startRefs; i++) {
          builder2.storeRef(rs.loadRef());
        }
      }
      return { type: "slice", cell: builder2.endCell() };
    } else if (kind === 5) {
      return { type: "builder", cell: cs.loadRef() };
    } else if (kind === 7) {
      let length = cs.loadUint(16);
      let items = [];
      if (length > 1) {
        let head = cs.loadRef().beginParse();
        let tail = cs.loadRef().beginParse();
        items.unshift(parseTupleItem(tail));
        for (let i = 0; i < length - 2; i++) {
          let ohead = head;
          head = ohead.loadRef().beginParse();
          tail = ohead.loadRef().beginParse();
          items.unshift(parseTupleItem(tail));
        }
        items.unshift(parseTupleItem(head));
      } else if (length === 1) {
        items.push(parseTupleItem(cs.loadRef().beginParse()));
      }
      return { type: "tuple", items };
    } else {
      throw Error("Unsupported stack item");
    }
  }
  tuple$1.parseTupleItem = parseTupleItem;
  function serializeTupleTail(src, builder2) {
    if (src.length > 0) {
      let tail = (0, Builder_12.beginCell)();
      serializeTupleTail(src.slice(0, src.length - 1), tail);
      builder2.storeRef(tail.endCell());
      serializeTupleItem(src[src.length - 1], builder2);
    }
  }
  function serializeTuple(src) {
    let builder2 = (0, Builder_12.beginCell)();
    builder2.storeUint(src.length, 24);
    let r = [...src];
    serializeTupleTail(r, builder2);
    return builder2.endCell();
  }
  tuple$1.serializeTuple = serializeTuple;
  function parseTuple(src) {
    let res = [];
    let cs = src.beginParse();
    let size = cs.loadUint(24);
    for (let i = 0; i < size; i++) {
      let next = cs.loadRef();
      res.unshift(parseTupleItem(cs));
      cs = next.beginParse();
    }
    return res;
  }
  tuple$1.parseTuple = parseTuple;
  return tuple$1;
}
var reader$1 = {};
var hasRequiredReader$1;
function requireReader$1() {
  if (hasRequiredReader$1) return reader$1;
  hasRequiredReader$1 = 1;
  Object.defineProperty(reader$1, "__esModule", { value: true });
  reader$1.TupleReader = void 0;
  class TupleReader {
    constructor(items) {
      this.items = [...items];
    }
    get remaining() {
      return this.items.length;
    }
    peek() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      return this.items[0];
    }
    pop() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      let res = this.items[0];
      this.items.splice(0, 1);
      return res;
    }
    skip(num = 1) {
      for (let i = 0; i < num; i++) {
        this.pop();
      }
      return this;
    }
    readBigNumber() {
      let popped = this.pop();
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readBigNumberOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readNumber() {
      return Number(this.readBigNumber());
    }
    readNumberOpt() {
      let r = this.readBigNumberOpt();
      if (r !== null) {
        return Number(r);
      } else {
        return null;
      }
    }
    readBoolean() {
      let res = this.readNumber();
      return res === 0 ? false : true;
    }
    readBooleanOpt() {
      let res = this.readNumberOpt();
      if (res !== null) {
        return res === 0 ? false : true;
      } else {
        return null;
      }
    }
    readAddress() {
      let r = this.readCell().beginParse().loadAddress();
      if (r !== null) {
        return r;
      } else {
        throw Error("Not an address");
      }
    }
    readAddressOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        return r.beginParse().loadMaybeAddress();
      } else {
        return null;
      }
    }
    readCell() {
      let popped = this.pop();
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell: " + popped.type);
      }
      return popped.cell;
    }
    readCellOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell");
      }
      return popped.cell;
    }
    readTuple() {
      let popped = this.pop();
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    readTupleOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    static readLispList(reader2) {
      const result = [];
      let tail = reader2;
      while (tail !== null) {
        var head = tail.pop();
        if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
          throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
        }
        tail = tail.readTupleOpt();
        result.push(head);
      }
      return result;
    }
    readLispListDirect() {
      if (this.items.length === 1 && this.items[0].type === "null") {
        return [];
      }
      return TupleReader.readLispList(this);
    }
    readLispList() {
      return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
      let s2 = this.readCell().beginParse();
      if (s2.remainingRefs !== 0) {
        throw Error("Not a buffer");
      }
      if (s2.remainingBits % 8 !== 0) {
        throw Error("Not a buffer");
      }
      return s2.loadBuffer(s2.remainingBits / 8);
    }
    readBufferOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        if (s2.remainingRefs !== 0 || s2.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s2.loadBuffer(s2.remainingBits / 8);
      } else {
        return null;
      }
    }
    readString() {
      let s2 = this.readCell().beginParse();
      return s2.loadStringTail();
    }
    readStringOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        return s2.loadStringTail();
      } else {
        return null;
      }
    }
  }
  reader$1.TupleReader = TupleReader;
  return reader$1;
}
var builder$1 = {};
var hasRequiredBuilder$2;
function requireBuilder$2() {
  if (hasRequiredBuilder$2) return builder$1;
  hasRequiredBuilder$2 = 1;
  Object.defineProperty(builder$1, "__esModule", { value: true });
  builder$1.TupleBuilder = void 0;
  const Builder_12 = requireBuilder$3();
  const Cell_1 = requireCell$1();
  const Slice_1 = requireSlice$1();
  class TupleBuilder {
    constructor() {
      this._tuple = [];
    }
    writeNumber(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: BigInt(v2) });
      }
    }
    writeBoolean(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: v2 ? -1n : 0n });
      }
    }
    writeBuffer(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeBuffer(v2).endCell() });
      }
    }
    writeString(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeStringTail(v2).endCell() });
      }
    }
    writeCell(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "cell", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "cell", cell: v2.asCell() });
        }
      }
    }
    writeSlice(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "slice", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "slice", cell: v2.asCell() });
        }
      }
    }
    writeBuilder(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "builder", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "builder", cell: v2.asCell() });
        }
      }
    }
    writeTuple(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "tuple", items: v2 });
      }
    }
    writeAddress(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeAddress(v2).endCell() });
      }
    }
    build() {
      return [...this._tuple];
    }
  }
  builder$1.TupleBuilder = TupleBuilder;
  return builder$1;
}
var _export$1 = {};
var _helpers$1 = {};
var convert$1 = {};
var hasRequiredConvert$1;
function requireConvert$1() {
  if (hasRequiredConvert$1) return convert$1;
  hasRequiredConvert$1 = 1;
  Object.defineProperty(convert$1, "__esModule", { value: true });
  convert$1.fromNano = convert$1.toNano = void 0;
  function toNano(src) {
    if (typeof src === "bigint") {
      return src * 1000000000n;
    } else {
      if (typeof src === "number") {
        if (!Number.isFinite(src)) {
          throw Error("Invalid number");
        }
        if (Math.log10(src) <= 6) {
          src = src.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
        } else if (src - Math.trunc(src) === 0) {
          src = src.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
        } else {
          throw Error("Not enough precision for a number value. Use string value instead");
        }
      }
      let neg = false;
      while (src.startsWith("-")) {
        neg = !neg;
        src = src.slice(1);
      }
      if (src === ".") {
        throw Error("Invalid number");
      }
      let parts = src.split(".");
      if (parts.length > 2) {
        throw Error("Invalid number");
      }
      let whole = parts[0];
      let frac = parts[1];
      if (!whole) {
        whole = "0";
      }
      if (!frac) {
        frac = "0";
      }
      if (frac.length > 9) {
        throw Error("Invalid number");
      }
      while (frac.length < 9) {
        frac += "0";
      }
      let r = BigInt(whole) * 1000000000n + BigInt(frac);
      if (neg) {
        r = -r;
      }
      return r;
    }
  }
  convert$1.toNano = toNano;
  function fromNano(src) {
    let v2 = BigInt(src);
    let neg = false;
    if (v2 < 0) {
      neg = true;
      v2 = -v2;
    }
    let frac = v2 % 1000000000n;
    let facStr = frac.toString();
    while (facStr.length < 9) {
      facStr = "0" + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let whole = v2 / 1000000000n;
    let wholeStr = whole.toString();
    let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
    if (neg) {
      value = "-" + value;
    }
    return value;
  }
  convert$1.fromNano = fromNano;
  return convert$1;
}
var ExtraCurrency$1 = {};
var hasRequiredExtraCurrency$1;
function requireExtraCurrency$1() {
  if (hasRequiredExtraCurrency$1) return ExtraCurrency$1;
  hasRequiredExtraCurrency$1 = 1;
  Object.defineProperty(ExtraCurrency$1, "__esModule", { value: true });
  ExtraCurrency$1.packExtraCurrencyCell = ExtraCurrency$1.packExtraCurrencyDict = ExtraCurrency$1.storeExtraCurrency = ExtraCurrency$1.loadMaybeExtraCurrency = ExtraCurrency$1.loadExtraCurrency = void 0;
  const Builder_12 = requireBuilder$3();
  const Dictionary_1 = requireDictionary$1();
  function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k2, v2] of ecDict) {
      ecMap[k2] = v2;
    }
    return ecMap;
  }
  ExtraCurrency$1.loadExtraCurrency = loadExtraCurrency;
  function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
  }
  ExtraCurrency$1.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
  function storeExtraCurrency(extracurrency) {
    return (builder2) => {
      builder2.storeDict(packExtraCurrencyDict(extracurrency));
    };
  }
  ExtraCurrency$1.storeExtraCurrency = storeExtraCurrency;
  function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k2, v2]) => resEc.set(Number(k2), v2));
    return resEc;
  }
  ExtraCurrency$1.packExtraCurrencyDict = packExtraCurrencyDict;
  function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_12.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
  }
  ExtraCurrency$1.packExtraCurrencyCell = packExtraCurrencyCell;
  return ExtraCurrency$1;
}
var hasRequired_helpers$1;
function require_helpers$1() {
  if (hasRequired_helpers$1) return _helpers$1;
  hasRequired_helpers$1 = 1;
  Object.defineProperty(_helpers$1, "__esModule", { value: true });
  _helpers$1.comment = _helpers$1.external = _helpers$1.internal = void 0;
  const Address_1 = requireAddress$1();
  const Cell_1 = requireCell$1();
  const Builder_12 = requireBuilder$3();
  const convert_1 = requireConvert$1();
  const ExtraCurrency_1 = requireExtraCurrency$1();
  function internal(src) {
    let bounce = true;
    if (src.bounce !== null && src.bounce !== void 0) {
      bounce = src.bounce;
    }
    let to2;
    if (typeof src.to === "string") {
      to2 = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
      to2 = src.to;
    } else {
      throw new Error(`Invalid address ${src.to}`);
    }
    let value;
    if (typeof src.value === "string") {
      value = (0, convert_1.toNano)(src.value);
    } else {
      value = src.value;
    }
    let other;
    if (src.extracurrency) {
      other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src.extracurrency);
    }
    let body = Cell_1.Cell.EMPTY;
    if (typeof src.body === "string") {
      body = (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
    } else if (src.body) {
      body = src.body;
    }
    return {
      info: {
        type: "internal",
        dest: to2,
        value: { coins: value, other },
        bounce,
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
      },
      init: src.init ?? void 0,
      body
    };
  }
  _helpers$1.internal = internal;
  function external(src) {
    let to2;
    if (typeof src.to === "string") {
      to2 = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
      to2 = src.to;
    } else {
      throw new Error(`Invalid address ${src.to}`);
    }
    return {
      info: {
        type: "external-in",
        dest: to2,
        importFee: 0n
      },
      init: src.init ?? void 0,
      body: src.body || Cell_1.Cell.EMPTY
    };
  }
  _helpers$1.external = external;
  function comment(src) {
    return (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
  }
  _helpers$1.comment = comment;
  return _helpers$1;
}
var Account$1 = {};
var AccountStorage$1 = {};
var AccountState$1 = {};
var hasRequiredAccountState$1;
function requireAccountState$1() {
  if (hasRequiredAccountState$1) return AccountState$1;
  hasRequiredAccountState$1 = 1;
  Object.defineProperty(AccountState$1, "__esModule", { value: true });
  AccountState$1.storeAccountState = AccountState$1.loadAccountState = void 0;
  const StateInit_1 = requireStateInit$1();
  function loadAccountState(cs) {
    if (cs.loadBit()) {
      return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
    } else if (cs.loadBit()) {
      return { type: "frozen", stateHash: cs.loadUintBig(256) };
    } else {
      return { type: "uninit" };
    }
  }
  AccountState$1.loadAccountState = loadAccountState;
  function storeAccountState(src) {
    return (builder2) => {
      if (src.type === "active") {
        builder2.storeBit(true);
        builder2.store((0, StateInit_1.storeStateInit)(src.state));
      } else if (src.type === "frozen") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.storeUint(src.stateHash, 256);
      } else if (src.type === "uninit") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      }
    };
  }
  AccountState$1.storeAccountState = storeAccountState;
  return AccountState$1;
}
var CurrencyCollection$1 = {};
var hasRequiredCurrencyCollection$1;
function requireCurrencyCollection$1() {
  if (hasRequiredCurrencyCollection$1) return CurrencyCollection$1;
  hasRequiredCurrencyCollection$1 = 1;
  Object.defineProperty(CurrencyCollection$1, "__esModule", { value: true });
  CurrencyCollection$1.storeCurrencyCollection = CurrencyCollection$1.loadCurrencyCollection = void 0;
  const Dictionary_1 = requireDictionary$1();
  function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
      5
      /* log2(32) */
    ));
    if (other.size === 0) {
      return { coins };
    } else {
      return { other, coins };
    }
  }
  CurrencyCollection$1.loadCurrencyCollection = loadCurrencyCollection;
  function storeCurrencyCollection(collection) {
    return (builder2) => {
      builder2.storeCoins(collection.coins);
      if (collection.other) {
        builder2.storeDict(collection.other);
      } else {
        builder2.storeBit(0);
      }
    };
  }
  CurrencyCollection$1.storeCurrencyCollection = storeCurrencyCollection;
  return CurrencyCollection$1;
}
var hasRequiredAccountStorage$1;
function requireAccountStorage$1() {
  if (hasRequiredAccountStorage$1) return AccountStorage$1;
  hasRequiredAccountStorage$1 = 1;
  Object.defineProperty(AccountStorage$1, "__esModule", { value: true });
  AccountStorage$1.storeAccountStorage = AccountStorage$1.loadAccountStorage = void 0;
  const AccountState_1 = requireAccountState$1();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadAccountStorage(slice) {
    return {
      lastTransLt: slice.loadUintBig(64),
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
      state: (0, AccountState_1.loadAccountState)(slice)
    };
  }
  AccountStorage$1.loadAccountStorage = loadAccountStorage;
  function storeAccountStorage(src) {
    return (builder2) => {
      builder2.storeUint(src.lastTransLt, 64);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
      builder2.store((0, AccountState_1.storeAccountState)(src.state));
    };
  }
  AccountStorage$1.storeAccountStorage = storeAccountStorage;
  return AccountStorage$1;
}
var StorageInfo$1 = {};
var StorageExtraInfo$1 = {};
var hasRequiredStorageExtraInfo$1;
function requireStorageExtraInfo$1() {
  if (hasRequiredStorageExtraInfo$1) return StorageExtraInfo$1;
  hasRequiredStorageExtraInfo$1 = 1;
  Object.defineProperty(StorageExtraInfo$1, "__esModule", { value: true });
  StorageExtraInfo$1.storeStorageExtraInfo = StorageExtraInfo$1.loadStorageExtraInfo = void 0;
  function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
      return null;
    }
    if (header === 1) {
      return {
        dictHash: slice.loadUintBig(256)
      };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
  }
  StorageExtraInfo$1.loadStorageExtraInfo = loadStorageExtraInfo;
  function storeStorageExtraInfo(src) {
    return (builder2) => {
      if (src === null || typeof src === "undefined") {
        builder2.storeUint(0, 3);
      } else {
        builder2.storeUint(1, 3);
        builder2.storeUint(src.dictHash, 256);
      }
    };
  }
  StorageExtraInfo$1.storeStorageExtraInfo = storeStorageExtraInfo;
  return StorageExtraInfo$1;
}
var StorageUsed$1 = {};
var hasRequiredStorageUsed$1;
function requireStorageUsed$1() {
  if (hasRequiredStorageUsed$1) return StorageUsed$1;
  hasRequiredStorageUsed$1 = 1;
  Object.defineProperty(StorageUsed$1, "__esModule", { value: true });
  StorageUsed$1.storeStorageUsed = StorageUsed$1.loadStorageUsed = void 0;
  function loadStorageUsed(cs) {
    return {
      cells: cs.loadVarUintBig(3),
      bits: cs.loadVarUintBig(3)
    };
  }
  StorageUsed$1.loadStorageUsed = loadStorageUsed;
  function storeStorageUsed(src) {
    return (builder2) => {
      builder2.storeVarUint(src.cells, 3);
      builder2.storeVarUint(src.bits, 3);
    };
  }
  StorageUsed$1.storeStorageUsed = storeStorageUsed;
  return StorageUsed$1;
}
var hasRequiredStorageInfo$1;
function requireStorageInfo$1() {
  if (hasRequiredStorageInfo$1) return StorageInfo$1;
  hasRequiredStorageInfo$1 = 1;
  Object.defineProperty(StorageInfo$1, "__esModule", { value: true });
  StorageInfo$1.storeStorageInfo = StorageInfo$1.loadStorageInfo = void 0;
  const StorageExtraInfo_1 = requireStorageExtraInfo$1();
  const StorageUsed_1 = requireStorageUsed$1();
  function loadStorageInfo(slice) {
    return {
      used: (0, StorageUsed_1.loadStorageUsed)(slice),
      storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
      lastPaid: slice.loadUint(32),
      duePayment: slice.loadMaybeCoins()
    };
  }
  StorageInfo$1.loadStorageInfo = loadStorageInfo;
  function storeStorageInfo(src) {
    return (builder2) => {
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src.used));
      builder2.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src.storageExtra));
      builder2.storeUint(src.lastPaid, 32);
      builder2.storeMaybeCoins(src.duePayment);
    };
  }
  StorageInfo$1.storeStorageInfo = storeStorageInfo;
  return StorageInfo$1;
}
var hasRequiredAccount$1;
function requireAccount$1() {
  if (hasRequiredAccount$1) return Account$1;
  hasRequiredAccount$1 = 1;
  Object.defineProperty(Account$1, "__esModule", { value: true });
  Account$1.storeAccount = Account$1.loadAccount = void 0;
  const AccountStorage_1 = requireAccountStorage$1();
  const StorageInfo_1 = requireStorageInfo$1();
  function loadAccount(slice) {
    return {
      addr: slice.loadAddress(),
      storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
      storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
  }
  Account$1.loadAccount = loadAccount;
  function storeAccount(src) {
    return (builder2) => {
      builder2.storeAddress(src.addr);
      builder2.store((0, StorageInfo_1.storeStorageInfo)(src.storageStats));
      builder2.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
    };
  }
  Account$1.storeAccount = storeAccount;
  return Account$1;
}
var AccountStatus$1 = {};
var hasRequiredAccountStatus$1;
function requireAccountStatus$1() {
  if (hasRequiredAccountStatus$1) return AccountStatus$1;
  hasRequiredAccountStatus$1 = 1;
  Object.defineProperty(AccountStatus$1, "__esModule", { value: true });
  AccountStatus$1.storeAccountStatus = AccountStatus$1.loadAccountStatus = void 0;
  function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0) {
      return "uninitialized";
    }
    if (status === 1) {
      return "frozen";
    }
    if (status === 2) {
      return "active";
    }
    if (status === 3) {
      return "non-existing";
    }
    throw Error("Invalid data");
  }
  AccountStatus$1.loadAccountStatus = loadAccountStatus;
  function storeAccountStatus(src) {
    return (builder2) => {
      if (src === "uninitialized") {
        builder2.storeUint(0, 2);
      } else if (src === "frozen") {
        builder2.storeUint(1, 2);
      } else if (src === "active") {
        builder2.storeUint(2, 2);
      } else if (src === "non-existing") {
        builder2.storeUint(3, 2);
      } else {
        throw Error("Invalid data");
      }
      return builder2;
    };
  }
  AccountStatus$1.storeAccountStatus = storeAccountStatus;
  return AccountStatus$1;
}
var AccountStatusChange$1 = {};
var hasRequiredAccountStatusChange$1;
function requireAccountStatusChange$1() {
  if (hasRequiredAccountStatusChange$1) return AccountStatusChange$1;
  hasRequiredAccountStatusChange$1 = 1;
  Object.defineProperty(AccountStatusChange$1, "__esModule", { value: true });
  AccountStatusChange$1.storeAccountStatusChange = AccountStatusChange$1.loadAccountStatusChange = void 0;
  function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
      return "unchanged";
    }
    if (slice.loadBit()) {
      return "deleted";
    } else {
      return "frozen";
    }
  }
  AccountStatusChange$1.loadAccountStatusChange = loadAccountStatusChange;
  function storeAccountStatusChange(src) {
    return (builder2) => {
      if (src == "unchanged") {
        builder2.storeBit(0);
      } else if (src === "frozen") {
        builder2.storeBit(1);
        builder2.storeBit(0);
      } else if (src === "deleted") {
        builder2.storeBit(1);
        builder2.storeBit(1);
      } else {
        throw Error("Invalid account status change");
      }
    };
  }
  AccountStatusChange$1.storeAccountStatusChange = storeAccountStatusChange;
  return AccountStatusChange$1;
}
var OutList$1 = {};
var MessageRelaxed$1 = {};
var CommonMessageInfoRelaxed$1 = {};
var hasRequiredCommonMessageInfoRelaxed$1;
function requireCommonMessageInfoRelaxed$1() {
  if (hasRequiredCommonMessageInfoRelaxed$1) return CommonMessageInfoRelaxed$1;
  hasRequiredCommonMessageInfoRelaxed$1 = 1;
  Object.defineProperty(CommonMessageInfoRelaxed$1, "__esModule", { value: true });
  CommonMessageInfoRelaxed$1.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed$1.loadCommonMessageInfoRelaxed = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadCommonMessageInfoRelaxed(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src2 = slice.loadMaybeAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src2,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    }
    const src = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfoRelaxed$1.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
  function storeCommonMessageInfoRelaxed(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfoRelaxed$1.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  return CommonMessageInfoRelaxed$1;
}
var hasRequiredMessageRelaxed$1;
function requireMessageRelaxed$1() {
  if (hasRequiredMessageRelaxed$1) return MessageRelaxed$1;
  hasRequiredMessageRelaxed$1 = 1;
  Object.defineProperty(MessageRelaxed$1, "__esModule", { value: true });
  MessageRelaxed$1.storeMessageRelaxed = MessageRelaxed$1.loadMessageRelaxed = void 0;
  const Builder_12 = requireBuilder$3();
  const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed$1();
  const StateInit_1 = requireStateInit$1();
  function loadMessageRelaxed(slice) {
    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init2 = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init2 = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init2 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init: init2,
      body
    };
  }
  MessageRelaxed$1.loadMessageRelaxed = loadMessageRelaxed;
  function storeMessageRelaxed(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          if (builder2.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        if (builder2.availableBits - 1 >= message.body.bits.length && builder2.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
          needRef = false;
        } else {
          needRef = true;
        }
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  MessageRelaxed$1.storeMessageRelaxed = storeMessageRelaxed;
  return MessageRelaxed$1;
}
var LibRef$1 = {};
var hasRequiredLibRef$1;
function requireLibRef$1() {
  if (hasRequiredLibRef$1) return LibRef$1;
  hasRequiredLibRef$1 = 1;
  Object.defineProperty(LibRef$1, "__esModule", { value: true });
  LibRef$1.storeLibRef = LibRef$1.loadLibRef = void 0;
  function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
      return {
        type: "hash",
        libHash: slice.loadBuffer(32)
      };
    } else {
      return {
        type: "ref",
        library: slice.loadRef()
      };
    }
  }
  LibRef$1.loadLibRef = loadLibRef;
  function storeLibRef(src) {
    return (builder2) => {
      if (src.type === "hash") {
        builder2.storeUint(0, 1);
        builder2.storeBuffer(src.libHash);
      } else {
        builder2.storeUint(1, 1);
        builder2.storeRef(src.library);
      }
    };
  }
  LibRef$1.storeLibRef = storeLibRef;
  return LibRef$1;
}
var hasRequiredOutList$1;
function requireOutList$1() {
  if (hasRequiredOutList$1) return OutList$1;
  hasRequiredOutList$1 = 1;
  Object.defineProperty(OutList$1, "__esModule", { value: true });
  OutList$1.loadOutList = OutList$1.storeOutList = OutList$1.loadOutAction = OutList$1.storeOutAction = void 0;
  const MessageRelaxed_1 = requireMessageRelaxed$1();
  const Builder_12 = requireBuilder$3();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  const LibRef_1 = requireLibRef$1();
  function storeOutAction(action) {
    switch (action.type) {
      case "sendMsg":
        return storeOutActionSendMsg(action);
      case "setCode":
        return storeOutActionSetCode(action);
      case "reserve":
        return storeOutActionReserve(action);
      case "changeLibrary":
        return storeOutActionChangeLibrary(action);
      default:
        throw new Error(`Unknown action type ${action.type}`);
    }
  }
  OutList$1.storeOutAction = storeOutAction;
  const outActionSendMsgTag = 247711853;
  function storeOutActionSendMsg(action) {
    return (builder2) => {
      builder2.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_12.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
  }
  const outActionSetCodeTag = 2907562126;
  function storeOutActionSetCode(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
  }
  const outActionReserveTag = 921090057;
  function storeOutActionReserve(action) {
    return (builder2) => {
      builder2.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
  }
  const outActionChangeLibraryTag = 653925844;
  function storeOutActionChangeLibrary(action) {
    return (builder2) => {
      builder2.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
  }
  function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
      const mode = slice.loadUint(8);
      const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
      return {
        type: "sendMsg",
        mode,
        outMsg
      };
    }
    if (tag === outActionSetCodeTag) {
      const newCode = slice.loadRef();
      return {
        type: "setCode",
        newCode
      };
    }
    if (tag === outActionReserveTag) {
      const mode = slice.loadUint(8);
      const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        type: "reserve",
        mode,
        currency
      };
    }
    if (tag === outActionChangeLibraryTag) {
      const mode = slice.loadUint(7);
      const libRef = (0, LibRef_1.loadLibRef)(slice);
      return {
        type: "changeLibrary",
        mode,
        libRef
      };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
  }
  OutList$1.loadOutAction = loadOutAction;
  function storeOutList(actions) {
    const cell = actions.reduce((cell2, action) => (0, Builder_12.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_12.beginCell)().endCell());
    return (builder2) => {
      builder2.storeSlice(cell.beginParse());
    };
  }
  OutList$1.storeOutList = storeOutList;
  function loadOutList(slice) {
    const actions = [];
    while (slice.remainingRefs) {
      const nextCell = slice.loadRef();
      actions.push(loadOutAction(slice));
      slice = nextCell.beginParse();
    }
    return actions.reverse();
  }
  OutList$1.loadOutList = loadOutList;
  return OutList$1;
}
var CommonMessageInfo$1 = {};
var hasRequiredCommonMessageInfo$1;
function requireCommonMessageInfo$1() {
  if (hasRequiredCommonMessageInfo$1) return CommonMessageInfo$1;
  hasRequiredCommonMessageInfo$1 = 1;
  Object.defineProperty(CommonMessageInfo$1, "__esModule", { value: true });
  CommonMessageInfo$1.storeCommonMessageInfo = CommonMessageInfo$1.loadCommonMessageInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadCommonMessageInfo(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src2 = slice.loadAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src2,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      const src2 = slice.loadMaybeExternalAddress();
      const dest2 = slice.loadAddress();
      const importFee = slice.loadCoins();
      return {
        type: "external-in",
        src: src2,
        dest: dest2,
        importFee
      };
    }
    const src = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfo$1.loadCommonMessageInfo = loadCommonMessageInfo;
  function storeCommonMessageInfo(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-in") {
        builder2.storeBit(1);
        builder2.storeBit(0);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeCoins(source.importFee);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfo$1.storeCommonMessageInfo = storeCommonMessageInfo;
  return CommonMessageInfo$1;
}
var ComputeSkipReason$1 = {};
var hasRequiredComputeSkipReason$1;
function requireComputeSkipReason$1() {
  if (hasRequiredComputeSkipReason$1) return ComputeSkipReason$1;
  hasRequiredComputeSkipReason$1 = 1;
  Object.defineProperty(ComputeSkipReason$1, "__esModule", { value: true });
  ComputeSkipReason$1.storeComputeSkipReason = ComputeSkipReason$1.loadComputeSkipReason = void 0;
  function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0) {
      return "no-state";
    } else if (reason === 1) {
      return "bad-state";
    } else if (reason === 2) {
      return "no-gas";
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
  }
  ComputeSkipReason$1.loadComputeSkipReason = loadComputeSkipReason;
  function storeComputeSkipReason(src) {
    return (builder2) => {
      if (src === "no-state") {
        builder2.storeUint(0, 2);
      } else if (src === "bad-state") {
        builder2.storeUint(1, 2);
      } else if (src === "no-gas") {
        builder2.storeUint(2, 2);
      } else {
        throw new Error(`Unknown ComputeSkipReason: ${src}`);
      }
    };
  }
  ComputeSkipReason$1.storeComputeSkipReason = storeComputeSkipReason;
  return ComputeSkipReason$1;
}
var DepthBalanceInfo$1 = {};
var hasRequiredDepthBalanceInfo$1;
function requireDepthBalanceInfo$1() {
  if (hasRequiredDepthBalanceInfo$1) return DepthBalanceInfo$1;
  hasRequiredDepthBalanceInfo$1 = 1;
  Object.defineProperty(DepthBalanceInfo$1, "__esModule", { value: true });
  DepthBalanceInfo$1.storeDepthBalanceInfo = DepthBalanceInfo$1.loadDepthBalanceInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
      splitDepth,
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
  }
  DepthBalanceInfo$1.loadDepthBalanceInfo = loadDepthBalanceInfo;
  function storeDepthBalanceInfo(src) {
    return (builder2) => {
      builder2.storeUint(src.splitDepth, 5);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
    };
  }
  DepthBalanceInfo$1.storeDepthBalanceInfo = storeDepthBalanceInfo;
  return DepthBalanceInfo$1;
}
var HashUpdate$1 = {};
var hasRequiredHashUpdate$1;
function requireHashUpdate$1() {
  if (hasRequiredHashUpdate$1) return HashUpdate$1;
  hasRequiredHashUpdate$1 = 1;
  Object.defineProperty(HashUpdate$1, "__esModule", { value: true });
  HashUpdate$1.storeHashUpdate = HashUpdate$1.loadHashUpdate = void 0;
  function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 114) {
      throw Error("Invalid data");
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return { oldHash, newHash };
  }
  HashUpdate$1.loadHashUpdate = loadHashUpdate;
  function storeHashUpdate(src) {
    return (builder2) => {
      builder2.storeUint(114, 8);
      builder2.storeBuffer(src.oldHash);
      builder2.storeBuffer(src.newHash);
    };
  }
  HashUpdate$1.storeHashUpdate = storeHashUpdate;
  return HashUpdate$1;
}
var MasterchainStateExtra$1 = {};
var hasRequiredMasterchainStateExtra$1;
function requireMasterchainStateExtra$1() {
  if (hasRequiredMasterchainStateExtra$1) return MasterchainStateExtra$1;
  hasRequiredMasterchainStateExtra$1 = 1;
  Object.defineProperty(MasterchainStateExtra$1, "__esModule", { value: true });
  MasterchainStateExtra$1.loadMasterchainStateExtra = void 0;
  const Dictionary_1 = requireDictionary$1();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadMasterchainStateExtra(cs) {
    if (cs.loadUint(16) !== 52262) {
      throw Error("Invalid data");
    }
    if (cs.loadBit()) {
      cs.loadRef();
    }
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
      config,
      configAddress,
      globalBalance
    };
  }
  MasterchainStateExtra$1.loadMasterchainStateExtra = loadMasterchainStateExtra;
  return MasterchainStateExtra$1;
}
var Message$1 = {};
var hasRequiredMessage$1;
function requireMessage$1() {
  if (hasRequiredMessage$1) return Message$1;
  hasRequiredMessage$1 = 1;
  Object.defineProperty(Message$1, "__esModule", { value: true });
  Message$1.MessageValue = Message$1.storeMessage = Message$1.loadMessage = void 0;
  const Builder_12 = requireBuilder$3();
  const CommonMessageInfo_1 = requireCommonMessageInfo$1();
  const StateInit_1 = requireStateInit$1();
  function loadMessage(slice) {
    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init2 = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init2 = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init2 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init: init2,
      body
    };
  }
  Message$1.loadMessage = loadMessage;
  function storeMessage(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          needRef2 = builder2.availableBits - 2 < initCell.bits + message.body.bits.length;
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        needRef = builder2.availableBits - 1 < message.body.bits.length || builder2.refs + message.body.refs.length > 4;
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  Message$1.storeMessage = storeMessage;
  Message$1.MessageValue = {
    serialize(src, builder2) {
      builder2.storeRef((0, Builder_12.beginCell)().store(storeMessage(src)));
    },
    parse(slice) {
      return loadMessage(slice.loadRef().beginParse());
    }
  };
  return Message$1;
}
var SendMode$1 = {};
var hasRequiredSendMode$1;
function requireSendMode$1() {
  if (hasRequiredSendMode$1) return SendMode$1;
  hasRequiredSendMode$1 = 1;
  Object.defineProperty(SendMode$1, "__esModule", { value: true });
  SendMode$1.SendMode = void 0;
  var SendMode2;
  (function(SendMode3) {
    SendMode3[SendMode3["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode3[SendMode3["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode3[SendMode3["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode3[SendMode3["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode3[SendMode3["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode3[SendMode3["NONE"] = 0] = "NONE";
  })(SendMode2 || (SendMode$1.SendMode = SendMode2 = {}));
  return SendMode$1;
}
var ReserveMode$1 = {};
var hasRequiredReserveMode$1;
function requireReserveMode$1() {
  if (hasRequiredReserveMode$1) return ReserveMode$1;
  hasRequiredReserveMode$1 = 1;
  Object.defineProperty(ReserveMode$1, "__esModule", { value: true });
  ReserveMode$1.ReserveMode = void 0;
  var ReserveMode2;
  (function(ReserveMode3) {
    ReserveMode3[ReserveMode3["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
  })(ReserveMode2 || (ReserveMode$1.ReserveMode = ReserveMode2 = {}));
  return ReserveMode$1;
}
var ShardAccount$1 = {};
var hasRequiredShardAccount$1;
function requireShardAccount$1() {
  if (hasRequiredShardAccount$1) return ShardAccount$1;
  hasRequiredShardAccount$1 = 1;
  Object.defineProperty(ShardAccount$1, "__esModule", { value: true });
  ShardAccount$1.storeShardAccount = ShardAccount$1.loadShardAccount = void 0;
  const Builder_12 = requireBuilder$3();
  const Account_1 = requireAccount$1();
  function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = void 0;
    if (!accountRef.isExotic) {
      let accountSlice = accountRef.beginParse();
      if (accountSlice.loadBit()) {
        account = (0, Account_1.loadAccount)(accountSlice);
      }
    }
    return {
      account,
      lastTransactionHash: slice.loadUintBig(256),
      lastTransactionLt: slice.loadUintBig(64)
    };
  }
  ShardAccount$1.loadShardAccount = loadShardAccount;
  function storeShardAccount(src) {
    return (builder2) => {
      if (src.account) {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
      } else {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(false));
      }
      builder2.storeUint(src.lastTransactionHash, 256);
      builder2.storeUint(src.lastTransactionLt, 64);
    };
  }
  ShardAccount$1.storeShardAccount = storeShardAccount;
  return ShardAccount$1;
}
var ShardAccounts$1 = {};
var hasRequiredShardAccounts$1;
function requireShardAccounts$1() {
  if (hasRequiredShardAccounts$1) return ShardAccounts$1;
  hasRequiredShardAccounts$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    const Dictionary_1 = requireDictionary$1();
    const DepthBalanceInfo_1 = requireDepthBalanceInfo$1();
    const ShardAccount_1 = requireShardAccount$1();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src, builder2) {
        builder2.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder2.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src) {
      return (Builder2) => {
        Builder2.storeDict(src);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  })(ShardAccounts$1);
  return ShardAccounts$1;
}
var ShardIdent$1 = {};
var hasRequiredShardIdent$1;
function requireShardIdent$1() {
  if (hasRequiredShardIdent$1) return ShardIdent$1;
  hasRequiredShardIdent$1 = 1;
  Object.defineProperty(ShardIdent$1, "__esModule", { value: true });
  ShardIdent$1.storeShardIdent = ShardIdent$1.loadShardIdent = void 0;
  function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
      throw Error("Invalid data");
    }
    return {
      shardPrefixBits: slice.loadUint(6),
      workchainId: slice.loadInt(32),
      shardPrefix: slice.loadUintBig(64)
    };
  }
  ShardIdent$1.loadShardIdent = loadShardIdent;
  function storeShardIdent(src) {
    return (builder2) => {
      builder2.storeUint(0, 2);
      builder2.storeUint(src.shardPrefixBits, 6);
      builder2.storeInt(src.workchainId, 32);
      builder2.storeUint(src.shardPrefix, 64);
    };
  }
  ShardIdent$1.storeShardIdent = storeShardIdent;
  return ShardIdent$1;
}
var ShardStateUnsplit$1 = {};
var hasRequiredShardStateUnsplit$1;
function requireShardStateUnsplit$1() {
  if (hasRequiredShardStateUnsplit$1) return ShardStateUnsplit$1;
  hasRequiredShardStateUnsplit$1 = 1;
  Object.defineProperty(ShardStateUnsplit$1, "__esModule", { value: true });
  ShardStateUnsplit$1.loadShardStateUnsplit = void 0;
  const MasterchainStateExtra_1 = requireMasterchainStateExtra$1();
  const ShardAccounts_1 = requireShardAccounts$1();
  const ShardIdent_1 = requireShardIdent$1();
  function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 2418257890) {
      throw Error("Invalid data");
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    let shardAccountsRef = cs.loadRef();
    let accounts = void 0;
    if (!shardAccountsRef.isExotic) {
      accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    cs.loadRef();
    let mcStateExtra = cs.loadBit();
    let extras2 = null;
    if (mcStateExtra) {
      let cell = cs.loadRef();
      if (!cell.isExotic) {
        extras2 = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
      }
    }
    return {
      globalId,
      shardId,
      seqno,
      vertSeqNo,
      genUtime,
      genLt,
      minRefMcSeqno,
      beforeSplit,
      accounts,
      extras: extras2
    };
  }
  ShardStateUnsplit$1.loadShardStateUnsplit = loadShardStateUnsplit;
  return ShardStateUnsplit$1;
}
var SplitMergeInfo$1 = {};
var hasRequiredSplitMergeInfo$1;
function requireSplitMergeInfo$1() {
  if (hasRequiredSplitMergeInfo$1) return SplitMergeInfo$1;
  hasRequiredSplitMergeInfo$1 = 1;
  Object.defineProperty(SplitMergeInfo$1, "__esModule", { value: true });
  SplitMergeInfo$1.storeSplitMergeInfo = SplitMergeInfo$1.loadSplitMergeInfo = void 0;
  function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
      currentShardPrefixLength,
      accountSplitDepth,
      thisAddress,
      siblingAddress
    };
  }
  SplitMergeInfo$1.loadSplitMergeInfo = loadSplitMergeInfo;
  function storeSplitMergeInfo(src) {
    return (builder2) => {
      builder2.storeUint(src.currentShardPrefixLength, 6);
      builder2.storeUint(src.accountSplitDepth, 6);
      builder2.storeUint(src.thisAddress, 256);
      builder2.storeUint(src.siblingAddress, 256);
    };
  }
  SplitMergeInfo$1.storeSplitMergeInfo = storeSplitMergeInfo;
  return SplitMergeInfo$1;
}
var Transaction$1 = {};
var TransactionDescription$1 = {};
var TransactionActionPhase$1 = {};
var hasRequiredTransactionActionPhase$1;
function requireTransactionActionPhase$1() {
  if (hasRequiredTransactionActionPhase$1) return TransactionActionPhase$1;
  hasRequiredTransactionActionPhase$1 = 1;
  Object.defineProperty(TransactionActionPhase$1, "__esModule", { value: true });
  TransactionActionPhase$1.storeTransactionActionPhase = TransactionActionPhase$1.loadTransactionActionPhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange$1();
  const StorageUsed_1 = requireStorageUsed$1();
  function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
      success,
      valid,
      noFunds,
      statusChange,
      totalFwdFees,
      totalActionFees,
      resultCode,
      resultArg,
      totalActions,
      specActions,
      skippedActions,
      messagesCreated,
      actionListHash,
      totalMessageSize
    };
  }
  TransactionActionPhase$1.loadTransactionActionPhase = loadTransactionActionPhase;
  function storeTransactionActionPhase(src) {
    return (builder2) => {
      builder2.storeBit(src.success);
      builder2.storeBit(src.valid);
      builder2.storeBit(src.noFunds);
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
      builder2.storeMaybeCoins(src.totalFwdFees);
      builder2.storeMaybeCoins(src.totalActionFees);
      builder2.storeInt(src.resultCode, 32);
      builder2.storeMaybeInt(src.resultArg, 32);
      builder2.storeUint(src.totalActions, 16);
      builder2.storeUint(src.specActions, 16);
      builder2.storeUint(src.skippedActions, 16);
      builder2.storeUint(src.messagesCreated, 16);
      builder2.storeUint(src.actionListHash, 256);
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src.totalMessageSize));
    };
  }
  TransactionActionPhase$1.storeTransactionActionPhase = storeTransactionActionPhase;
  return TransactionActionPhase$1;
}
var TransactionBouncePhase$1 = {};
var hasRequiredTransactionBouncePhase$1;
function requireTransactionBouncePhase$1() {
  if (hasRequiredTransactionBouncePhase$1) return TransactionBouncePhase$1;
  hasRequiredTransactionBouncePhase$1 = 1;
  Object.defineProperty(TransactionBouncePhase$1, "__esModule", { value: true });
  TransactionBouncePhase$1.storeTransactionBouncePhase = TransactionBouncePhase$1.loadTransactionBouncePhase = void 0;
  const StorageUsed_1 = requireStorageUsed$1();
  function loadTransactionBouncePhase(slice) {
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let messageFees = slice.loadCoins();
      let forwardFees = slice.loadCoins();
      return {
        type: "ok",
        messageSize,
        messageFees,
        forwardFees
      };
    }
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let requiredForwardFees = slice.loadCoins();
      return {
        type: "no-funds",
        messageSize,
        requiredForwardFees
      };
    }
    return {
      type: "negative-funds"
    };
  }
  TransactionBouncePhase$1.loadTransactionBouncePhase = loadTransactionBouncePhase;
  function storeTransactionBouncePhase(src) {
    return (builder2) => {
      if (src.type === "ok") {
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
        builder2.storeCoins(src.messageFees);
        builder2.storeCoins(src.forwardFees);
      } else if (src.type === "negative-funds") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      } else if (src.type === "no-funds") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
        builder2.storeCoins(src.requiredForwardFees);
      } else {
        throw new Error("Invalid TransactionBouncePhase type");
      }
    };
  }
  TransactionBouncePhase$1.storeTransactionBouncePhase = storeTransactionBouncePhase;
  return TransactionBouncePhase$1;
}
var TransactionComputePhase$1 = {};
var hasRequiredTransactionComputePhase$1;
function requireTransactionComputePhase$1() {
  if (hasRequiredTransactionComputePhase$1) return TransactionComputePhase$1;
  hasRequiredTransactionComputePhase$1 = 1;
  Object.defineProperty(TransactionComputePhase$1, "__esModule", { value: true });
  TransactionComputePhase$1.storeTransactionComputePhase = TransactionComputePhase$1.loadTransactionComputePhase = void 0;
  const Builder_12 = requireBuilder$3();
  const ComputeSkipReason_1 = requireComputeSkipReason$1();
  function loadTransactionComputePhase(slice) {
    if (!slice.loadBit()) {
      let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
      return {
        type: "skipped",
        reason
      };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
      type: "vm",
      success,
      messageStateUsed,
      accountActivated,
      gasFees,
      gasUsed,
      gasLimit,
      gasCredit,
      mode,
      exitCode,
      exitArg,
      vmSteps,
      vmInitStateHash,
      vmFinalStateHash
    };
  }
  TransactionComputePhase$1.loadTransactionComputePhase = loadTransactionComputePhase;
  function storeTransactionComputePhase(src) {
    return (builder2) => {
      if (src.type === "skipped") {
        builder2.storeBit(0);
        builder2.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
        return;
      }
      builder2.storeBit(1);
      builder2.storeBit(src.success);
      builder2.storeBit(src.messageStateUsed);
      builder2.storeBit(src.accountActivated);
      builder2.storeCoins(src.gasFees);
      builder2.storeRef((0, Builder_12.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b2) => src.gasCredit !== void 0 && src.gasCredit !== null ? b2.storeBit(1).storeVarUint(src.gasCredit, 2) : b2.storeBit(0)).storeUint(src.mode, 8).storeInt(src.exitCode, 32).store((b2) => src.exitArg !== void 0 && src.exitArg !== null ? b2.storeBit(1).storeInt(src.exitArg, 32) : b2.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
    };
  }
  TransactionComputePhase$1.storeTransactionComputePhase = storeTransactionComputePhase;
  return TransactionComputePhase$1;
}
var TransactionCreditPhase$1 = {};
var hasRequiredTransactionCreditPhase$1;
function requireTransactionCreditPhase$1() {
  if (hasRequiredTransactionCreditPhase$1) return TransactionCreditPhase$1;
  hasRequiredTransactionCreditPhase$1 = 1;
  Object.defineProperty(TransactionCreditPhase$1, "__esModule", { value: true });
  TransactionCreditPhase$1.storeTransactionCreditPhase = TransactionCreditPhase$1.loadTransactionCreditPhase = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
      dueFeesColelcted,
      credit
    };
  }
  TransactionCreditPhase$1.loadTransactionCreditPhase = loadTransactionCreditPhase;
  function storeTransactionCreditPhase(src) {
    return (builder2) => {
      if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src.dueFeesColelcted);
      }
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
    };
  }
  TransactionCreditPhase$1.storeTransactionCreditPhase = storeTransactionCreditPhase;
  return TransactionCreditPhase$1;
}
var TransactionStoragePhase$1 = {};
var hasRequiredTransactionStoragePhase$1;
function requireTransactionStoragePhase$1() {
  if (hasRequiredTransactionStoragePhase$1) return TransactionStoragePhase$1;
  hasRequiredTransactionStoragePhase$1 = 1;
  Object.defineProperty(TransactionStoragePhase$1, "__esModule", { value: true });
  TransactionStoragePhase$1.storeTransactionsStoragePhase = TransactionStoragePhase$1.loadTransactionStoragePhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange$1();
  function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = void 0;
    if (slice.loadBit()) {
      storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
      storageFeesCollected,
      storageFeesDue,
      statusChange
    };
  }
  TransactionStoragePhase$1.loadTransactionStoragePhase = loadTransactionStoragePhase;
  function storeTransactionsStoragePhase(src) {
    return (builder2) => {
      builder2.storeCoins(src.storageFeesCollected);
      if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src.storageFeesDue);
      }
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
    };
  }
  TransactionStoragePhase$1.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  return TransactionStoragePhase$1;
}
var hasRequiredTransactionDescription$1;
function requireTransactionDescription$1() {
  if (hasRequiredTransactionDescription$1) return TransactionDescription$1;
  hasRequiredTransactionDescription$1 = 1;
  Object.defineProperty(TransactionDescription$1, "__esModule", { value: true });
  TransactionDescription$1.storeTransactionDescription = TransactionDescription$1.loadTransactionDescription = void 0;
  const Builder_12 = requireBuilder$3();
  const SplitMergeInfo_1 = requireSplitMergeInfo$1();
  const Transaction_1 = requireTransaction$1();
  const TransactionActionPhase_1 = requireTransactionActionPhase$1();
  const TransactionBouncePhase_1 = requireTransactionBouncePhase$1();
  const TransactionComputePhase_1 = requireTransactionComputePhase$1();
  const TransactionCreditPhase_1 = requireTransactionCreditPhase$1();
  const TransactionStoragePhase_1 = requireTransactionStoragePhase$1();
  function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0) {
      const creditFirst = slice.loadBit();
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let creditPhase = void 0;
      if (slice.loadBit()) {
        creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      let aborted = slice.loadBit();
      let bouncePhase = void 0;
      if (slice.loadBit()) {
        bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
      }
      const destroyed = slice.loadBit();
      return {
        type: "generic",
        creditFirst,
        storagePhase,
        creditPhase,
        computePhase,
        actionPhase,
        bouncePhase,
        aborted,
        destroyed
      };
    }
    if (type === 1) {
      return {
        type: "storage",
        storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
      };
    }
    if (type === 2 || type === 3) {
      const isTock = type === 3;
      let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "tick-tock",
        isTock,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 4) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "split-prepare",
        splitInfo,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 5) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
      const installed = slice.loadBit();
      return {
        type: "split-install",
        splitInfo,
        prepareTransaction,
        installed
      };
    }
    throw Error(`Unsupported transaction description type ${type}`);
  }
  TransactionDescription$1.loadTransactionDescription = loadTransactionDescription;
  function storeTransactionDescription(src) {
    return (builder2) => {
      if (src.type === "generic") {
        builder2.storeUint(0, 4);
        builder2.storeBit(src.creditFirst);
        if (src.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        if (src.creditPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        if (src.bouncePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.destroyed);
      } else if (src.type === "storage") {
        builder2.storeUint(1, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
      } else if (src.type === "tick-tock") {
        builder2.storeUint(src.isTock ? 3 : 2, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        builder2.storeBit(src.destroyed);
      } else if (src.type === "split-prepare") {
        builder2.storeUint(4, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
        if (src.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        builder2.storeBit(src.destroyed);
      } else if (src.type === "split-install") {
        builder2.storeUint(5, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
        builder2.storeRef((0, Builder_12.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
        builder2.storeBit(src.installed);
      } else {
        throw Error(`Unsupported transaction description type ${src.type}`);
      }
    };
  }
  TransactionDescription$1.storeTransactionDescription = storeTransactionDescription;
  return TransactionDescription$1;
}
var hasRequiredTransaction$1;
function requireTransaction$1() {
  if (hasRequiredTransaction$1) return Transaction$1;
  hasRequiredTransaction$1 = 1;
  Object.defineProperty(Transaction$1, "__esModule", { value: true });
  Transaction$1.storeTransaction = Transaction$1.loadTransaction = void 0;
  const Builder_12 = requireBuilder$3();
  const Dictionary_1 = requireDictionary$1();
  const AccountStatus_1 = requireAccountStatus$1();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  const HashUpdate_1 = requireHashUpdate$1();
  const Message_1 = requireMessage$1();
  const TransactionDescription_1 = requireTransactionDescription$1();
  function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 7) {
      throw Error("Invalid data");
    }
    let address = slice.loadUintBig(256);
    let lt2 = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
      address,
      lt: lt2,
      prevTransactionHash,
      prevTransactionLt,
      now,
      outMessagesCount,
      oldStatus,
      endStatus,
      inMessage,
      outMessages,
      totalFees,
      stateUpdate,
      description,
      raw,
      hash: () => raw.hash()
    };
  }
  Transaction$1.loadTransaction = loadTransaction;
  function storeTransaction(src) {
    return (builder2) => {
      builder2.storeUint(7, 4);
      builder2.storeUint(src.address, 256);
      builder2.storeUint(src.lt, 64);
      builder2.storeUint(src.prevTransactionHash, 256);
      builder2.storeUint(src.prevTransactionLt, 64);
      builder2.storeUint(src.now, 32);
      builder2.storeUint(src.outMessagesCount, 15);
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
      let msgBuilder = (0, Builder_12.beginCell)();
      if (src.inMessage) {
        msgBuilder.storeBit(true);
        msgBuilder.storeRef((0, Builder_12.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
      } else {
        msgBuilder.storeBit(false);
      }
      msgBuilder.storeDict(src.outMessages);
      builder2.storeRef(msgBuilder);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
    };
  }
  Transaction$1.storeTransaction = storeTransaction;
  return Transaction$1;
}
var hasRequired_export$1;
function require_export$1() {
  if (hasRequired_export$1) return _export$1;
  hasRequired_export$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
    var _helpers_1 = require_helpers$1();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = requireAccount$1();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = requireAccountState$1();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = requireAccountStatus$1();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = requireAccountStatusChange$1();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = requireAccountStorage$1();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = requireOutList$1();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = requireCommonMessageInfo$1();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed$1();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = requireComputeSkipReason$1();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = requireCurrencyCollection$1();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = requireDepthBalanceInfo$1();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var ExtraCurrency_1 = requireExtraCurrency$1();
    Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyCell;
    } });
    Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyDict;
    } });
    Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadExtraCurrency;
    } });
    Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadMaybeExtraCurrency;
    } });
    Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.storeExtraCurrency;
    } });
    var HashUpdate_1 = requireHashUpdate$1();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = requireMasterchainStateExtra$1();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = requireMessage$1();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = requireMessageRelaxed$1();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = requireSendMode$1();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ReserveMode_1 = requireReserveMode$1();
    Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function() {
      return ReserveMode_1.ReserveMode;
    } });
    var ShardAccount_1 = requireShardAccount$1();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = requireShardAccounts$1();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = requireShardIdent$1();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = requireShardStateUnsplit$1();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = requireSimpleLibrary$1();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var LibRef_1 = requireLibRef$1();
    Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function() {
      return LibRef_1.loadLibRef;
    } });
    Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function() {
      return LibRef_1.storeLibRef;
    } });
    var SplitMergeInfo_1 = requireSplitMergeInfo$1();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = requireStateInit$1();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInfo_1 = requireStorageInfo$1();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.storeStorageInfo;
    } });
    var StorageUsed_1 = requireStorageUsed$1();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var TickTock_1 = requireTickTock$1();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = requireTransaction$1();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = requireTransactionActionPhase$1();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = requireTransactionBouncePhase$1();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = requireTransactionComputePhase$1();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = requireTransactionCreditPhase$1();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = requireTransactionDescription$1();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = requireTransactionStoragePhase$1();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  })(_export$1);
  return _export$1;
}
var openContract$1 = {};
var hasRequiredOpenContract$1;
function requireOpenContract$1() {
  if (hasRequiredOpenContract$1) return openContract$1;
  hasRequiredOpenContract$1 = 1;
  Object.defineProperty(openContract$1, "__esModule", { value: true });
  openContract$1.openContract = void 0;
  const Address_1 = requireAddress$1();
  const Cell_1 = requireCell$1();
  function openContract2(src, factory) {
    let address;
    let init2 = null;
    if (!Address_1.Address.isAddress(src.address)) {
      throw Error("Invalid address");
    }
    address = src.address;
    if (src.init) {
      if (!(src.init.code instanceof Cell_1.Cell)) {
        throw Error("Invalid init.code");
      }
      if (!(src.init.data instanceof Cell_1.Cell)) {
        throw Error("Invalid init.data");
      }
      init2 = src.init;
    }
    let executor = factory({ address, init: init2 });
    return new Proxy(src, {
      get(target, prop) {
        const value = target[prop];
        if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send") || prop.startsWith("is"))) {
          if (typeof value === "function") {
            return (...args) => value.apply(target, [executor, ...args]);
          }
        }
        return value;
      }
    });
  }
  openContract$1.openContract = openContract2;
  return openContract$1;
}
var ComputeError$1 = {};
var hasRequiredComputeError$1;
function requireComputeError$1() {
  if (hasRequiredComputeError$1) return ComputeError$1;
  hasRequiredComputeError$1 = 1;
  Object.defineProperty(ComputeError$1, "__esModule", { value: true });
  ComputeError$1.ComputeError = void 0;
  class ComputeError2 extends Error {
    constructor(message, exitCode, opts) {
      super(message);
      this.exitCode = exitCode;
      this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
      this.logs = opts && opts.logs ? opts.logs : null;
      Object.setPrototypeOf(this, ComputeError2.prototype);
    }
  }
  ComputeError$1.ComputeError = ComputeError2;
  return ComputeError$1;
}
var getMethodId$1 = {};
var hasRequiredGetMethodId$1;
function requireGetMethodId$1() {
  if (hasRequiredGetMethodId$1) return getMethodId$1;
  hasRequiredGetMethodId$1 = 1;
  Object.defineProperty(getMethodId$1, "__esModule", { value: true });
  getMethodId$1.getMethodId = void 0;
  const TABLE = new Int16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ]);
  function crc162(data) {
    if (!(data instanceof Buffer)) {
      data = Buffer.from(data);
    }
    let crc = 0;
    for (let index2 = 0; index2 < data.length; index2++) {
      const byte = data[index2];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  }
  function getMethodId2(name) {
    return crc162(name) & 65535 | 65536;
  }
  getMethodId$1.getMethodId = getMethodId2;
  return getMethodId$1;
}
var safeSign$1 = {};
var hasRequiredSafeSign$1;
function requireSafeSign$1() {
  if (hasRequiredSafeSign$1) return safeSign$1;
  hasRequiredSafeSign$1 = 1;
  Object.defineProperty(safeSign$1, "__esModule", { value: true });
  safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
  const crypto_1 = requireDist$4();
  const MIN_SEED_LENGTH = 8;
  const MAX_SEED_LENGTH = 64;
  function createSafeSignHash(cell, seed) {
    let seedData = Buffer.from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
      throw Error("Seed can	 be longer than 64 bytes");
    }
    if (seedData.length < MIN_SEED_LENGTH) {
      throw Error("Seed must be at least 8 bytes");
    }
    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
  }
  function safeSign2(cell, secretKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
  }
  safeSign$1.safeSign = safeSign2;
  function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
  }
  safeSign$1.safeSignVerify = safeSignVerify;
  return safeSign$1;
}
var hasRequiredDist$3;
function requireDist$3() {
  if (hasRequiredDist$3) return dist$4;
  hasRequiredDist$3 = 1;
  (function(exports) {
    var __createBinding = dist$4 && dist$4.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = dist$4 && dist$4.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTupleItem = exports.parseTupleItem = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = requireAddress$1();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = requireExternalAddress$1();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = requireADNLAddress$1();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = requireContractAddress$1();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = requireBitString$1();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = requireBitReader$1();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = requireBitBuilder$1();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_12 = requireBuilder$3();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_12.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_12.beginCell;
    } });
    var Slice_1 = requireSlice$1();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = requireCellType$1();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = requireCell$1();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = requireDictionary$1();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = requireExoticMerkleProof$1();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.convertToMerkleProof;
    } });
    var exoticMerkleUpdate_1 = requireExoticMerkleUpdate$1();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = requireExoticPruned$1();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = requireGenerateMerkleProof$1();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProofDirect;
    } });
    var generateMerkleUpdate_1 = requireGenerateMerkleUpdate$1();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = requireTuple$1();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    Object.defineProperty(exports, "parseTupleItem", { enumerable: true, get: function() {
      return tuple_1.parseTupleItem;
    } });
    Object.defineProperty(exports, "serializeTupleItem", { enumerable: true, get: function() {
      return tuple_1.serializeTupleItem;
    } });
    var reader_1 = requireReader$1();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = requireBuilder$2();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export$1(), exports);
    var openContract_1 = requireOpenContract$1();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = requireComputeError$1();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = requireConvert$1();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = requireCrc16$1();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = requireCrc32c$1();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = requireBase32$1();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = requireGetMethodId$1();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = requireSafeSign$1();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  })(dist$4);
  return dist$4;
}
var distExports$2 = requireDist$3();
const DEFAULT_DURABLE_EVENTS_CONFIG = {
  recoveryIntervalMs: 10 * 1e3,
  // 10 seconds
  processingTimeoutMs: 60 * 1e3,
  // 1 minute
  cleanupIntervalMs: 60 * 1e3,
  // 1 minute
  retentionMs: 60 * 10 * 1e3,
  // 10 minutes
  retryDelayMs: 500,
  // 500 milliseconds
  maxRetries: 20
  // 20 retry attempts
};
class JettonError extends Error {
  code;
  details;
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "JettonError";
  }
}
var JettonErrorCode;
(function(JettonErrorCode2) {
  JettonErrorCode2["INVALID_ADDRESS"] = "INVALID_ADDRESS";
  JettonErrorCode2["JETTON_NOT_FOUND"] = "JETTON_NOT_FOUND";
  JettonErrorCode2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
  JettonErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  JettonErrorCode2["INVALID_AMOUNT"] = "INVALID_AMOUNT";
  JettonErrorCode2["PREPARATION_FAILED"] = "PREPARATION_FAILED";
})(JettonErrorCode || (JettonErrorCode = {}));
function asMaybeAddressFriendly(data) {
  try {
    return asAddressFriendly(data);
  } catch {
    return null;
  }
}
function asAddressFriendly(data) {
  if (data instanceof distExports$2.Address) {
    return data.toString();
  }
  try {
    if (data)
      return distExports$2.Address.parse(data).toString();
  } catch {
  }
  throw new Error(`Can not convert to AddressFriendly from "${data}"`);
}
function formatWalletAddress(address, isTestnet = false) {
  if (typeof address === "string") {
    return distExports$2.Address.parse(address).toString({ bounceable: false, testOnly: isTestnet });
  }
  return address.toString({ bounceable: false, testOnly: isTestnet });
}
function isValidAddress(address) {
  if (typeof address !== "string") {
    return false;
  }
  try {
    distExports$2.Address.parse(address);
  } catch (_) {
    return false;
  }
  return true;
}
function isFriendlyTonAddress(address) {
  try {
    distExports$2.Address.parseFriendly(address);
  } catch (_) {
    return false;
  }
  return true;
}
function asHex(data) {
  if (!/^0x[0-9a-fA-F]+$/.test(data) || data.length % 2 !== 0) {
    throw new Error("Not a valid hex");
  }
  return data;
}
const ERROR_CODES = {
  // Bridge Manager Errors (7000-7099)
  BRIDGE_NOT_INITIALIZED: 7e3,
  BRIDGE_CONNECTION_FAILED: 7001,
  BRIDGE_EVENT_PROCESSING_FAILED: 7002,
  BRIDGE_RESPONSE_SEND_FAILED: 7003,
  // Session Errors (7100-7199)
  SESSION_NOT_FOUND: 7100,
  SESSION_ID_REQUIRED: 7101,
  SESSION_CREATION_FAILED: 7102,
  SESSION_DOMAIN_REQUIRED: 7103,
  SESSION_RESTORATION_FAILED: 7104,
  // Event Store Errors (7200-7299)
  EVENT_STORE_NOT_INITIALIZED: 7200,
  EVENT_STORE_OPERATION_FAILED: 7201,
  // Storage Errors (7300-7399)
  STORAGE_READ_FAILED: 7300,
  STORAGE_WRITE_FAILED: 7301,
  // Wallet Errors (7400-7499)
  WALLET_NOT_FOUND: 7400,
  WALLET_REQUIRED: 7401,
  WALLET_INVALID: 7402,
  WALLET_CREATION_FAILED: 7403,
  WALLET_INITIALIZATION_FAILED: 7404,
  LEDGER_DEVICE_ERROR: 7405,
  // Request Processing Errors (7500-7599)
  INVALID_REQUEST_EVENT: 7500,
  REQUEST_PROCESSING_FAILED: 7501,
  RESPONSE_CREATION_FAILED: 7502,
  APPROVAL_FAILED: 7503,
  REJECTION_FAILED: 7504,
  // API Client Errors (7600-7699)
  API_CLIENT_ERROR: 7600,
  TON_CLIENT_INITIALIZATION_FAILED: 7601,
  API_REQUEST_FAILED: 7602,
  ACCOUNT_NOT_FOUND: 7603,
  // Jetton/NFT Errors (7700-7799)
  JETTONS_MANAGER_ERROR: 7700,
  NFT_MANAGER_ERROR: 7701,
  // Contract Errors (7800-7899)
  CONTRACT_DEPLOYMENT_FAILED: 7800,
  CONTRACT_EXECUTION_FAILED: 7801,
  CONTRACT_VALIDATION_FAILED: 7802,
  // Network Errors (7850-7899)
  NETWORK_NOT_CONFIGURED: 7850,
  // Generic Errors (7900-7999)
  UNKNOWN_ERROR: 7900,
  VALIDATION_ERROR: 7901,
  INITIALIZATION_ERROR: 7902,
  CONFIGURATION_ERROR: 7903,
  NETWORK_ERROR: 7904,
  UNKNOWN_EMULATION_ERROR: 7905,
  INVALID_CONFIG: 7906
};
function getErrorCodeName(code) {
  const entry = Object.entries(ERROR_CODES).find(([, value]) => value === code);
  return entry ? entry[0] : `UNKNOWN_CODE_${code}`;
}
class WalletKitError extends Error {
  code;
  codeName;
  originalError;
  context;
  constructor(code, message, originalError, context) {
    const fullMessage = originalError ? `${message}: ${originalError.message}` : message;
    super(fullMessage);
    this.name = "WalletKitError";
    this.code = code;
    this.codeName = getErrorCodeName(code);
    this.originalError = originalError;
    this.context = context;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, WalletKitError);
    }
    if (originalError?.stack) {
      this.stack = `${this.stack}
Caused by: ${originalError.stack}`;
    }
  }
  /**
   * Create a WalletKitError from an unknown error
   */
  static fromError(code, message, error2, context) {
    if (error2 instanceof Error) {
      return new WalletKitError(code, message, error2, context);
    }
    const errorMessage = error2 && typeof error2 === "object" && "message" in error2 ? String(error2.message) : String(error2);
    return new WalletKitError(code, `${message}: ${errorMessage}`, void 0, { ...context, originalValue: error2 });
  }
  /**
   * Check if an error is a WalletKitError with a specific code
   */
  static isWalletKitError(error2, code) {
    if (!(error2 instanceof WalletKitError)) {
      return false;
    }
    if (code !== void 0) {
      return error2.code === code;
    }
    return true;
  }
  /**
   * Serialize error to JSON
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      codeName: this.codeName,
      context: this.context,
      stack: this.stack,
      originalError: this.originalError ? {
        name: this.originalError.name,
        message: this.originalError.message,
        stack: this.originalError.stack
      } : void 0
    };
  }
}
class BridgeError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.BRIDGE_NOT_INITIALIZED, message, originalError, context);
    this.name = "BridgeError";
  }
}
class SessionError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.SESSION_NOT_FOUND, message, originalError, context);
    this.name = "SessionError";
  }
}
class EventStoreError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.EVENT_STORE_NOT_INITIALIZED, message, originalError, context);
    this.name = "EventStoreError";
  }
}
class StorageError extends WalletKitError {
  constructor(message, originalError, context) {
    super(ERROR_CODES.STORAGE_READ_FAILED, message, originalError, context);
    this.name = "StorageError";
  }
}
function Base64Normalize(data) {
  return data.replace(/\s+/g, "").replace(/-/g, "+").replace(/_/g, "/");
}
function Base64NormalizeUrl(data) {
  const normalized = Base64Normalize(data);
  const burl = normalized.replace(/-/g, "+").replace(/\//g, "_").replace(/=/g, "");
  return burl;
}
function ParseBase64(data) {
  if (typeof atob === "undefined" && typeof Buffer === "undefined") {
    throw new WalletKitError(ERROR_CODES.CONFIGURATION_ERROR, "atob function is not available in this environment");
  }
  data = Base64Normalize(data);
  return typeof atob === "function" ? atob(data) : Buffer.from(data, "base64").toString("utf-8");
}
function Base64ToHex(data) {
  if (!data)
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid hash: data is required");
  const binary2 = Base64ToUint8Array(data);
  if (!binary2)
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid hash: binary is required");
  return Uint8ArrayToHex(binary2);
}
function Uint8ArrayToHex(data) {
  return asHex(`0x${[...data].map((b2) => {
    if (b2 < 0 || b2 > 255)
      throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid byte: expected 0-255", void 0, {
        actualByte: b2
      });
    return b2.toString(16).padStart(2, "0");
  }).join("")}`);
}
function Base64ToUint8Array(data) {
  if (!data)
    return null;
  const binary2 = ParseBase64(data);
  const len = binary2.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary2.charCodeAt(i);
  }
  return bytes;
}
function Uint8ArrayToBase64(data) {
  if (typeof btoa === "undefined" && typeof Buffer === "undefined") {
    throw new Error("btoa is not available in this environment");
  }
  let binary2 = "";
  for (let i = 0; i < data.length; i++) {
    binary2 += String.fromCharCode(data[i]);
  }
  return typeof btoa === "function" ? btoa(binary2) : Buffer.from(data).toString("base64");
}
function Base64ToBigInt(data) {
  if (!data || data === "")
    return 0n;
  const binary2 = ParseBase64(data);
  const len = binary2.length;
  let result = 0n;
  for (let i = 0; i < len; i++) {
    result = (result << 8n) + BigInt(binary2.charCodeAt(i));
  }
  return result;
}
function BigIntToBase64(data) {
  if (data === 0n)
    return "";
  const bytes = [];
  let temp = data;
  while (temp > 0n) {
    bytes.push(Number(temp & 0xffn));
    temp >>= 8n;
  }
  const arr = new Uint8Array(bytes.reverse());
  return Uint8ArrayToBase64(arr);
}
function Uint8ArrayToBigInt(data) {
  let result = 0n;
  for (let i = 0; i < data.length; i++) {
    result = (result << 8n) + BigInt(data[i]);
  }
  return result;
}
function HexToBigInt(data) {
  return BigInt(data);
}
function HexToUint8Array(data) {
  const hex = data.slice(2);
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}
function HexToBase64(data) {
  return Uint8ArrayToBase64(HexToUint8Array(data));
}
function parseOutgoingTonTransfers(tx, addressBook, status) {
  const actions = [];
  for (const msg of tx.out_msgs || []) {
    const valueNum = toPositiveNumber(msg.value);
    if (valueNum === null) {
      continue;
    }
    const sender = msg.source ?? tx.account;
    const recipient = msg.destination;
    const amount = BigInt(valueNum);
    const recipientAccount = msg.init_state ? toContractAccount$3(recipient, addressBook) : toAccount(recipient, addressBook);
    const comment = extractComment(msg) ?? void 0;
    actions.push({
      type: "TonTransfer",
      id: Base64ToHex(tx.hash),
      status,
      TonTransfer: {
        sender: toAccount(sender, addressBook),
        recipient: recipientAccount,
        amount,
        ...comment !== void 0 ? { comment } : {}
      },
      simplePreview: {
        name: "Ton Transfer",
        description: `Transferring ${distExports$2.fromNano(String(amount))} TON`,
        value: `${distExports$2.fromNano(String(amount))} TON`,
        accounts: [toAccount(sender, addressBook), recipientAccount]
      },
      baseTransactions: [Base64ToHex(tx.hash)]
    });
  }
  return actions;
}
function parseIncomingTonTransfers(tx, addressBook, status) {
  const actions = [];
  const msg = tx.in_msg;
  if (!msg) {
    return actions;
  }
  const valueNum = toPositiveNumber(msg.value);
  if (valueNum === null) {
    return actions;
  }
  const sender = msg.source ?? tx.account;
  const recipient = msg.destination;
  const amount = BigInt(valueNum);
  const incomingStatus = computeIncomingTonTransferStatus(tx, status);
  const recipientAccount = msg.init_state ? toContractAccount$3(recipient, addressBook) : toAccount(recipient, addressBook);
  const comment = extractComment(msg) ?? void 0;
  actions.push({
    type: "TonTransfer",
    id: Base64ToHex(tx.hash),
    status: incomingStatus,
    TonTransfer: {
      sender: toAccount(sender, addressBook),
      recipient: recipientAccount,
      amount,
      ...comment !== void 0 ? { comment } : {}
    },
    simplePreview: {
      name: "Ton Transfer",
      description: `Transferring ${distExports$2.fromNano(String(amount))} TON`,
      value: `${distExports$2.fromNano(String(amount))} TON`,
      accounts: [toAccount(sender, addressBook), recipientAccount]
    },
    baseTransactions: [Base64ToHex(tx.hash)]
  });
  return actions;
}
function computeStatus$1(tx) {
  const aborted = Boolean(tx.description?.aborted);
  const computeSuccess = Boolean(tx.description?.compute_ph?.success);
  const actionSuccess = Boolean(tx.description?.action?.success);
  return !aborted && computeSuccess && actionSuccess ? "success" : "failure";
}
function computeIncomingTonTransferStatus(tx, defaultStatus) {
  const description = tx.description;
  const creditPh = description?.credit_ph;
  const credit = creditPh?.credit;
  if (credit && Number(credit) > 0) {
    return "success";
  }
  return defaultStatus;
}
function toPositiveNumber(value) {
  if (value === null || value === void 0) {
    return null;
  }
  const n = Number(value);
  if (!Number.isFinite(n) || n <= 0) {
    return null;
  }
  return n;
}
function extractComment(msg) {
  const decoded = msg.message_content && msg.message_content.decoded;
  if (decoded && typeof decoded === "object") {
    if (typeof decoded.comment === "string" && decoded.comment.length > 0) {
      return decoded.comment;
    }
    if (decoded["@type"] === "text_comment" && typeof decoded.text === "string" && decoded.text.length > 0) {
      return decoded.text;
    }
  }
  return null;
}
function toContractAccount$3(address, addressBook) {
  const acc = toAccount(address, addressBook);
  return { ...acc, isWallet: false };
}
function parseContractActions(ownerFriendly, transactions, addressBook) {
  const actions = [];
  for (const hash of Object.keys(transactions)) {
    const tx = transactions[hash];
    if (asAddressFriendly(tx.account) !== ownerFriendly)
      continue;
    const status = computeStatus$1(tx);
    for (const msg of tx.out_msgs || []) {
      if (!msg || !msg.destination)
        continue;
      if (!msg.opcode)
        continue;
      const contractAddress2 = msg.destination;
      const tonAttached = BigInt(Number(msg.value || "0"));
      const operation = msg.opcode;
      const child = findChildTransactionByInMsgHash(transactions, msg.hash);
      const baseTx = child ? Base64ToHex(child.hash) : Base64ToHex(tx.hash);
      const exec = {
        type: "SmartContractExec",
        id: Base64ToHex(tx.hash),
        status,
        SmartContractExec: {
          executor: toAccount(ownerFriendly, addressBook),
          contract: toContractAccount$2(contractAddress2, addressBook),
          tonAttached,
          operation,
          payload: ""
        },
        simplePreview: {
          name: "Smart Contract Execution",
          description: "Execution of smart contract",
          value: `${distExports$2.fromNano(String(tonAttached))} TON`,
          accounts: [toAccount(ownerFriendly, addressBook), toContractAccount$2(contractAddress2, addressBook)]
        },
        baseTransactions: [baseTx]
      };
      actions.push(exec);
      if (child && isDeploy(child, msg)) {
        const deploy = {
          type: "ContractDeploy",
          id: Base64ToHex(child.hash),
          status: computeStatus$1(child),
          ContractDeploy: {
            address: asAddressFriendly(contractAddress2),
            interfaces: []
          },
          simplePreview: {
            name: "Contract Deploy",
            description: "Deploying a contract",
            value: "",
            accounts: [toContractAccount$2(contractAddress2, addressBook)]
          },
          baseTransactions: [baseTx]
        };
        actions.push(deploy);
      }
    }
  }
  return actions;
}
function isDeploy(child, msg) {
  const created = child.orig_status === "nonexist" && child.end_status === "active";
  const hasInit = Boolean(msg.init_state) || Boolean(child.in_msg && child.in_msg.init_state);
  return created || hasInit;
}
function findChildTransactionByInMsgHash(transactions, inMsgHashBase64) {
  for (const key of Object.keys(transactions)) {
    const t = transactions[key];
    if (t.in_msg && t.in_msg.hash === inMsgHashBase64)
      return t;
  }
  return null;
}
function toContractAccount$2(address, addressBook) {
  const acc = toAccount(address, addressBook);
  return { ...acc, isWallet: false };
}
var OpCode;
(function(OpCode2) {
  OpCode2["JettonTransfer"] = "0x0f8a7ea5";
  OpCode2["JettonInternalTransfer"] = "0x178d4519";
  OpCode2["JettonNotify"] = "0x7362d09c";
  OpCode2["JettonBurn"] = "0x595f07bc";
  OpCode2["JettonMint"] = "0x15";
  OpCode2["NftTransfer"] = "0x5fcc3d14";
  OpCode2["NftOwnershipAssigned"] = "0x05138d91";
  OpCode2["NftOwnerChanged"] = "0x7bdd97de";
  OpCode2["NftGetStaticData"] = "0x2fcb26a2";
  OpCode2["NftReportStaticData"] = "0x8b771735";
  OpCode2["Excess"] = "0xd53276db";
  OpCode2["WalletV4Transfer"] = "0x0";
  OpCode2["DnsResolve"] = "0x19f02441";
  OpCode2["DnsChangeRecord"] = "0x4eb1f0f9";
  OpCode2["DexSwap"] = "0x25938561";
  OpCode2["DexProvideLiquidity"] = "0xfcf9e58f";
})(OpCode || (OpCode = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["JettonTransfer"] = "jetton_transfer";
  MessageType2["JettonInternalTransfer"] = "jetton_internal_transfer";
  MessageType2["JettonNotify"] = "jetton_notify";
  MessageType2["JettonBurn"] = "jetton_burn";
  MessageType2["JettonMint"] = "jetton_mint";
  MessageType2["NftTransfer"] = "nft_transfer";
  MessageType2["NftOwnershipAssigned"] = "nft_ownership_assigned";
  MessageType2["NftOwnerChanged"] = "nft_owner_changed";
  MessageType2["Excess"] = "excess";
  MessageType2["TonTransfer"] = "ton_transfer";
  MessageType2["ContractExec"] = "contract_exec";
  MessageType2["ContractDeploy"] = "contract_deploy";
  MessageType2["Unknown"] = "unknown";
})(MessageType || (MessageType = {}));
const OpCodeMapping = {
  [OpCode.JettonTransfer]: MessageType.JettonTransfer,
  [OpCode.JettonInternalTransfer]: MessageType.JettonInternalTransfer,
  [OpCode.JettonNotify]: MessageType.JettonNotify,
  [OpCode.JettonBurn]: MessageType.JettonBurn,
  [OpCode.JettonMint]: MessageType.JettonMint,
  [OpCode.NftTransfer]: MessageType.NftTransfer,
  [OpCode.NftOwnershipAssigned]: MessageType.NftOwnershipAssigned,
  [OpCode.NftOwnerChanged]: MessageType.NftOwnerChanged,
  [OpCode.NftGetStaticData]: MessageType.Unknown,
  [OpCode.NftReportStaticData]: MessageType.Unknown,
  [OpCode.Excess]: MessageType.Excess,
  [OpCode.WalletV4Transfer]: MessageType.TonTransfer,
  [OpCode.DnsResolve]: MessageType.Unknown,
  [OpCode.DnsChangeRecord]: MessageType.Unknown,
  [OpCode.DexSwap]: MessageType.Unknown,
  [OpCode.DexProvideLiquidity]: MessageType.Unknown
};
({
  [MessageType.JettonTransfer]: OpCode.JettonTransfer,
  [MessageType.JettonInternalTransfer]: OpCode.JettonInternalTransfer,
  [MessageType.JettonNotify]: OpCode.JettonNotify,
  [MessageType.JettonBurn]: OpCode.JettonBurn,
  [MessageType.JettonMint]: OpCode.JettonMint,
  [MessageType.NftTransfer]: OpCode.NftTransfer,
  [MessageType.NftOwnershipAssigned]: OpCode.NftOwnershipAssigned,
  [MessageType.NftOwnerChanged]: OpCode.NftOwnerChanged,
  [MessageType.Excess]: OpCode.Excess,
  [MessageType.TonTransfer]: OpCode.WalletV4Transfer,
  [MessageType.ContractExec]: void 0,
  [MessageType.ContractDeploy]: void 0,
  [MessageType.Unknown]: void 0
});
const LegacyOpCodeMap = {
  "0x0f8a7ea5": "jetton_transfer",
  "0x178d4519": "jetton_internal_transfer",
  "0x7362d09c": "jetton_notify",
  "0x595f07bc": "jetton_burn",
  "0xd53276db": "excess",
  "0x5fcc3d14": "nft_transfer",
  "0x05138d91": "nft_ownership_assigned",
  "0x7bdd97de": "nft_owner_changed"
};
function resolveOpCode(opcode) {
  const normalized = opcode.toLowerCase();
  for (const [_key, value] of Object.entries(OpCode)) {
    if (value.toLowerCase() === normalized) {
      return OpCodeMapping[value];
    }
  }
  const legacy = LegacyOpCodeMap[normalized];
  if (legacy) {
    return legacy;
  }
  return MessageType.Unknown;
}
class MessagePatternRegistry {
  patterns = /* @__PURE__ */ new Map();
  /**
   * Register a pattern for a message type
   */
  register(pattern) {
    const existing = this.patterns.get(pattern.messageType) || [];
    existing.push(pattern);
    this.patterns.set(pattern.messageType, existing);
  }
  /**
   * Find matching pattern for a message
   */
  match(msg) {
    for (const patterns of this.patterns.values()) {
      for (const pattern of patterns) {
        if (pattern.match(msg)) {
          return pattern;
        }
      }
    }
    return null;
  }
  /**
   * Get all patterns for a message type
   */
  getPatterns(messageType) {
    return this.patterns.get(messageType) || [];
  }
}
const messagePatternRegistry = new MessagePatternRegistry();
function getDecodedBody(msg) {
  if (!msg)
    return null;
  const mc = msg.message_content;
  if (isRecord$2(mc)) {
    const decoded = mc.decoded;
    return isRecord$2(decoded) ? decoded : null;
  }
  return null;
}
function getDecodedType(msg) {
  const decoded = getDecodedBody(msg);
  if (decoded) {
    const type = decoded["@type"];
    if (typeof type === "string")
      return type;
    const value = decoded["value"];
    if (isRecord$2(value) && typeof value["@type"] === "string") {
      return value["@type"];
    }
  }
  return null;
}
function isRecord$2(v2) {
  return typeof v2 === "object" && v2 !== null;
}
messagePatternRegistry.register({
  messageType: MessageType.JettonTransfer,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x0f8a7ea5" || type === "jetton_transfer" || decoded !== null && decoded["@type"] === "jetton_transfer";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.JettonInternalTransfer,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x178d4519" || type === "jetton_internal_transfer" || decoded !== null && decoded["@type"] === "jetton_internal_transfer";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.JettonNotify,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x7362d09c" || type === "jetton_notify" || decoded !== null && decoded["@type"] === "jetton_notify";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.NftTransfer,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x5fcc3d14" || type === "nft_transfer" || decoded !== null && decoded["@type"] === "nft_transfer";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.NftOwnershipAssigned,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x05138d91" || type === "nft_ownership_assigned" || decoded !== null && decoded["@type"] === "nft_ownership_assigned";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.NftOwnerChanged,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0x7bdd97de" || type === "nft_owner_changed" || decoded !== null && decoded["@type"] === "nft_owner_changed";
  },
  decode: (msg) => getDecodedBody(msg)
});
messagePatternRegistry.register({
  messageType: MessageType.Excess,
  match: (msg) => {
    const decoded = getDecodedBody(msg);
    const type = getDecodedType(msg);
    return msg.opcode === "0xd53276db" || type === "excess" || decoded !== null && decoded["@type"] === "excess";
  },
  decode: (msg) => getDecodedBody(msg)
});
function getDecoded(msg) {
  return getDecodedBody(msg);
}
function extractOpFromBody(msg) {
  return getDecodedType(msg);
}
function matchOpWithMap(op, types, mapping) {
  if (!op)
    return "";
  const messageType = resolveOpCode(op);
  if (messageType !== MessageType.Unknown) {
    const typeString = messageType;
    if (types.includes(typeString)) {
      return typeString;
    }
  }
  const normalized = mapping[op] ?? op;
  return types.includes(normalized) ? normalized : "";
}
function parseJettonActions(ownerFriendly, item, addressBook) {
  const actions = [];
  const txs = item.transactions || {};
  let added = false;
  for (const key of Object.keys(txs)) {
    const tx = txs[key];
    const inMsg = tx.in_msg;
    const decoded = getDecoded(inMsg);
    if (!decoded)
      continue;
    if (decoded["@type"] === "jetton_transfer" && inMsg?.source && asAddressFriendly(inMsg.source) === ownerFriendly) {
      const amount = toBigInt(readAmountValue(getProp$2(decoded, "amount")));
      const dest = toAddr$1(getProp$2(decoded, "destination"));
      const comment = extractCommentFromDecoded(getForwardPayloadValue(decoded)) ?? void 0;
      const senderWallet = asAddressFriendly(tx.account);
      const recipientWallet = findRecipientJettonWalletFromOut(tx);
      const status = computeStatus(tx);
      const id = findFirstOwnerTxId(ownerFriendly, item) ?? Base64ToHex(tx.hash);
      const base = collectBaseTransactionsSent(item, ownerFriendly);
      const jetton = buildJettonInfo(item, senderWallet, addressBook);
      const action = {
        type: "JettonTransfer",
        id,
        status,
        JettonTransfer: {
          sender: toAccount(ownerFriendly, addressBook),
          recipient: toAccount(dest, addressBook),
          sendersWallet: senderWallet,
          recipientsWallet: recipientWallet ?? "",
          amount,
          comment,
          jetton
        },
        simplePreview: jettonPreview(amount, jetton.symbol, jetton.decimals, jetton.image, [
          toAccount(dest, addressBook),
          toAccount(ownerFriendly, addressBook),
          toContractAccount$1(jetton.address || inferMinterFromAddressBook(addressBook)?.address || "", addressBook)
        ]),
        baseTransactions: base
      };
      actions.push(action);
      added = true;
    }
  }
  if (!added)
    for (const key of Object.keys(txs)) {
      const tx = txs[key];
      if (asAddressFriendly(tx.account) === ownerFriendly)
        continue;
      const inMsg = tx.in_msg;
      const decoded = getDecoded(inMsg);
      if (!decoded)
        continue;
      if (decoded["@type"] === "jetton_internal_transfer") {
        const amount = toBigInt(readAmountValue(getProp$2(decoded, "amount")));
        const senderMain = toAddr$1(getProp$2(decoded, "from"));
        const recipientWallet = asAddressFriendly(tx.account);
        const senderWallet = asAddressFriendly(inMsg.source);
        const status = computeStatus(tx);
        const id = getTraceRootId(item) ?? Base64ToHex(tx.hash);
        const base = collectBaseTransactionsReceived(item, ownerFriendly);
        const jetton = buildJettonInfo(item, recipientWallet, addressBook);
        const action = {
          type: "JettonTransfer",
          id,
          status,
          JettonTransfer: {
            sender: toAccount(senderMain, addressBook),
            recipient: toAccount(ownerFriendly, addressBook),
            sendersWallet: senderWallet,
            recipientsWallet: recipientWallet,
            amount,
            jetton
          },
          simplePreview: jettonPreview(amount, jetton.symbol, jetton.decimals, jetton.image, [
            toAccount(ownerFriendly, addressBook),
            toAccount(senderMain, addressBook),
            toContractAccount$1(jetton.address || inferMinterFromAddressBook(addressBook)?.address || "", addressBook)
          ]),
          baseTransactions: base
        };
        actions.push(action);
        added = true;
      }
    }
  return actions;
}
function extractCommentFromDecoded(decoded) {
  if (!isRecord$1(decoded))
    return null;
  const t = decoded["@type"];
  if (t === "text_comment") {
    const txt = decoded["text"];
    if (typeof txt === "string" && txt.length > 0)
      return txt;
  }
  return null;
}
function toBigInt(value) {
  if (value === void 0 || value === null)
    return BigInt(0);
  const n = typeof value === "string" ? Number(value) : value;
  return BigInt(Number.isFinite(n) ? n : 0);
}
function toAddr$1(raw) {
  if (!raw)
    return "";
  if (typeof raw === "string") {
    if (/^[A-Fa-f0-9]{64}$/.test(raw)) {
      return asAddressFriendly(`0:${raw}`);
    }
    return asAddressFriendly(raw);
  }
  if (isRecord$1(raw)) {
    const wc = raw["workchain_id"];
    const addr = raw["address"];
    if ((typeof wc === "string" || typeof wc === "number") && typeof addr === "string") {
      return asAddressFriendly(`${wc}:${addr}`);
    }
  }
  return "";
}
function jettonPreview(amount, symbol, decimals, image, accounts) {
  let denom = BigInt(1);
  for (let i = 0; i < (decimals || 0); i++)
    denom = denom * BigInt(10);
  const value = Number(amount) / Number(denom);
  const human = symbol ? `${trimAmount(value)} ${symbol}` : `${trimAmount(value)}`;
  const preview = {
    name: "Jetton Transfer",
    description: `Transferring ${human}`,
    value: human,
    accounts
  };
  if (image)
    preview.valueImage = image;
  return preview;
}
function computeStatus(tx) {
  const aborted = Boolean(tx.description?.aborted);
  const computePh = tx.description?.["compute_ph"];
  const action = tx.description?.["action"];
  const computeSuccess = Boolean(computePh && Boolean(computePh["success"]));
  const actionSuccess = Boolean(action && Boolean(action["success"]));
  return !aborted && computeSuccess && actionSuccess ? "success" : "failure";
}
function findFirstOwnerTxId(ownerFriendly, item) {
  for (const h2 of item.transactions_order || []) {
    const tx = item.transactions[h2];
    if (tx && asAddressFriendly(tx.account) === ownerFriendly) {
      return Base64ToHex(h2);
    }
  }
  return null;
}
function getTraceRootId(item) {
  const first = (item.transactions_order || [])[0];
  return first ? Base64ToHex(first) : null;
}
function findRecipientJettonWalletFromOut(tx) {
  for (const m2 of tx.out_msgs || []) {
    const d = getDecoded(m2);
    if (m2.opcode === OpCode.JettonInternalTransfer || d && d["@type"] === "jetton_internal_transfer") {
      return asAddressFriendly(m2.destination);
    }
  }
  return null;
}
function collectBaseTransactionsSent(item, ownerFriendly) {
  const order = item.transactions_order || [];
  const pairs = [];
  for (const h2 of order) {
    const tx = item.transactions[h2];
    if (!tx)
      continue;
    if (asAddressFriendly(tx.account) === ownerFriendly)
      continue;
    const t = getTxType(tx);
    if (t)
      pairs.push({ type: t, hex: Base64ToHex(h2) });
  }
  const priority = {
    jetton_transfer: 1,
    jetton_notify: 2,
    jetton_internal_transfer: 3,
    excess: 4
  };
  pairs.sort((a2, b2) => (priority[a2.type] ?? 99) - (priority[b2.type] ?? 99));
  return pairs.map((p2) => p2.hex);
}
function collectBaseTransactionsReceived(item, ownerFriendly) {
  const order = item.transactions_order || [];
  const findTx = (predicate) => {
    for (const h2 of order) {
      const tx = item.transactions[h2];
      if (!tx)
        continue;
      if (predicate(tx))
        return Base64ToHex(h2);
    }
    return null;
  };
  const root = getTraceRootId(item);
  const isType = (tx, type) => getTxType(tx) === type;
  const jt2 = findTx((tx) => isType(tx, "jetton_transfer"));
  const internal = findTx((tx) => isType(tx, "jetton_internal_transfer") && asAddressFriendly(tx.account) !== ownerFriendly);
  const excess = findTx((tx) => isType(tx, "excess"));
  const out = [];
  if (root)
    out.push(root);
  if (jt2)
    out.push(jt2);
  if (internal)
    out.push(internal);
  if (excess)
    out.push(excess);
  return out;
}
function getTxType(tx) {
  const fromBody = extractOpFromBody(tx.in_msg);
  return matchOpWithMap(fromBody || tx.in_msg?.opcode || "", ["jetton_transfer", "jetton_internal_transfer", "jetton_notify", "excess"], {
    [OpCode.JettonTransfer]: "jetton_transfer",
    [OpCode.JettonInternalTransfer]: "jetton_internal_transfer",
    [OpCode.JettonNotify]: "jetton_notify",
    [OpCode.Excess]: "excess"
  });
}
function buildJettonInfo(item, walletFriendly, addressBook) {
  const walletInfo = addressBook[walletFriendly];
  if (walletInfo?.jettonWallet?.jettonMaster) {
    const masterAddress = asMaybeAddressFriendly(walletInfo.jettonWallet.jettonMaster);
    const masterInfo = masterAddress ? addressBook[masterAddress] : void 0;
    if (masterInfo?.jetton) {
      return masterInfo.jetton;
    }
  }
  const metadata = item.metadata;
  let master;
  if (metadata) {
    for (const [raw, infoAny] of Object.entries(metadata)) {
      const info = infoAny;
      const tokenInfo = info["token_info"];
      if (!Array.isArray(tokenInfo))
        continue;
      for (const tAny of tokenInfo) {
        const t = tAny;
        if (t["type"] === "jetton_wallets") {
          const extra = t["extra"];
          const owner = extra?.["owner"];
          if (typeof owner === "string" && asAddressFriendly(owner) && asAddressFriendly(raw) === walletFriendly) {
            const j2 = extra?.["jetton"];
            if (typeof j2 === "string")
              master = j2;
          }
        }
      }
    }
  }
  let name = "";
  let symbol = "";
  let decimals = 0;
  let image;
  if (master && metadata && metadata[master]) {
    const m2 = metadata[master];
    name = m2["name"] || "";
    symbol = m2["symbol"] || "";
    const extra = m2["extra"];
    const dec = extra?.["decimals"];
    decimals = typeof dec === "string" ? parseInt(dec, 10) : 0;
    image = m2["image"] || extra?.["_image_small"] || extra?.["_image_medium"] || extra?.["_image_big"];
  }
  let outAddress = master ? asAddressFriendly(master) : "";
  if (!outAddress) {
    const inferred = inferMinterFromAddressBook(addressBook);
    if (inferred) {
      outAddress = inferred.address;
      if (!name)
        name = inferred.name;
      if (!symbol)
        symbol = inferred.symbol;
      if (!decimals)
        decimals = inferred.decimals;
      if (!image)
        image = inferred.image;
    }
  }
  return {
    address: outAddress,
    name,
    symbol,
    decimals,
    image: image ?? "",
    verification: "whitelist",
    score: 100
  };
}
function toContractAccount$1(address, addressBook) {
  const acct = toAccount(address, addressBook);
  return { ...acct, isWallet: false };
}
function inferMinterFromAddressBook(addressBook) {
  const knownMinterByDomain = "usdt-minter.ton";
  for (const key of Object.keys(addressBook)) {
    const entry = addressBook[key];
    const domain = entry && entry.domain;
    if (domain === knownMinterByDomain || typeof domain === "string" && domain.includes("minter")) {
      return {
        address: key,
        name: "Tether USD",
        symbol: "USD",
        decimals: 6,
        image: "https://cache.tonapi.io/imgproxy/T3PB4s7oprNVaJkwqbGg54nexKE0zzKhcrPv8jcWYzU/rs:fill:200:200:1/g:no/aHR0cHM6Ly90ZXRoZXIudG8vaW1hZ2VzL2xvZ29DaXJjbGUucG5n.webp"
      };
    }
  }
  return null;
}
function trimAmount(v2) {
  if (v2 >= 1)
    return `${Number(v2.toFixed(3)).toString().replace(/\.0+$/, "")}`;
  const s2 = v2.toFixed(9);
  return s2.replace(/0+$/, "").replace(/\.$/, "");
}
function isRecord$1(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getProp$2(obj, key) {
  return isRecord$1(obj) ? obj[key] : void 0;
}
function readAmountValue(obj) {
  if (!isRecord$1(obj))
    return void 0;
  const v2 = obj["value"];
  if (typeof v2 === "string" || typeof v2 === "number")
    return v2;
  return void 0;
}
function getForwardPayloadValue(decoded) {
  const fp = getProp$2(decoded, "forward_payload");
  return isRecord$1(fp) ? fp["value"] : void 0;
}
function parseNftActions(ownerFriendly, item, addressBook) {
  const actions = [];
  const txs = item.transactions || {};
  for (const key of Object.keys(txs)) {
    const tx = txs[key];
    if (asAddressFriendly(tx.account) !== ownerFriendly)
      continue;
    for (const out of tx.out_msgs || []) {
      const decoded = getDecoded(out);
      if (decoded?.["@type"] === "nft_transfer") {
        const newOwner = toAddr(getProp$1(decoded, "new_owner"));
        const nftAddr = out.destination ? asAddressFriendly(out.destination) : "";
        const status = computeStatus$1(tx);
        const base = collectBaseTransactionsForSent(item, ownerFriendly, newOwner, nftAddr);
        const action = buildNftAction(status, ownerFriendly, newOwner, nftAddr, addressBook, base);
        actions.push(action);
      }
    }
  }
  for (const key of Object.keys(txs)) {
    const tx = txs[key];
    const acc = asAddressFriendly(tx.account);
    const decoded = getDecoded(tx.in_msg);
    if (!decoded)
      continue;
    const t = decoded["@type"];
    if (acc === ownerFriendly && (t === "nft_ownership_assigned" || t === "nft_owner_changed")) {
      const prevOwner = toAddr(getProp$1(decoded, "prev_owner")) || toAddr(getProp$1(decoded, "old_owner"));
      const nftAddr = tx.in_msg?.source ? asAddressFriendly(tx.in_msg.source) : "";
      const nftTx = findTransactionByAccount(item, nftAddr);
      const status = nftTx ? computeStatus$1(nftTx) : computeStatus$1(tx);
      const base = collectBaseTransactionsForReceived(item, ownerFriendly, nftAddr);
      const action = buildNftAction(status, prevOwner, ownerFriendly, nftAddr, addressBook, base);
      actions.push(action);
    }
  }
  return actions;
}
function buildNftAction(status, senderFriendly, recipientFriendly, nftAddress, addressBook, base) {
  const preview = {
    name: "NFT Transfer",
    description: "Transferring 1 NFT",
    value: "1 NFT",
    accounts: [
      toAccount(recipientFriendly, addressBook),
      toAccount(senderFriendly, addressBook),
      toContractAccount(nftAddress, addressBook)
    ]
  };
  return {
    type: "NftItemTransfer",
    id: base[0] || "",
    status,
    NftItemTransfer: {
      sender: toAccount(senderFriendly, addressBook),
      recipient: toAccount(recipientFriendly, addressBook),
      nft: nftAddress
    },
    simplePreview: preview,
    baseTransactions: base
  };
}
function collectBaseTransactionsForSent(item, ownerFriendly, newOwner, nftAddr) {
  const order = item.transactions_order || [];
  let ownerTonFromNft = null;
  let assignToNewOwner = null;
  let nftTransferHash = null;
  for (const h2 of order) {
    const tx = item.transactions[h2];
    if (!tx)
      continue;
    const acc = asAddressFriendly(tx.account);
    const t = getNftType(tx);
    if (!ownerTonFromNft && acc === ownerFriendly && tx.in_msg?.source && asAddressFriendly(tx.in_msg.source) === nftAddr) {
      ownerTonFromNft = Base64ToHex(h2);
    }
    if (!assignToNewOwner && acc === asAddressFriendly(newOwner) && (t === "nft_ownership_assigned" || t === "nft_owner_changed")) {
      assignToNewOwner = Base64ToHex(h2);
    }
    if (!nftTransferHash && acc === nftAddr && t === "nft_transfer") {
      nftTransferHash = Base64ToHex(h2);
    }
  }
  return [ownerTonFromNft, assignToNewOwner, nftTransferHash].filter(Boolean);
}
function getNftType(tx) {
  const t = extractOpFromBody(tx.in_msg) || tx.in_msg?.opcode || "";
  return matchOpWithMap(t, ["nft_transfer", "nft_ownership_assigned", "nft_owner_changed", "excess"], {
    [OpCode.NftTransfer]: "nft_transfer",
    [OpCode.NftOwnershipAssigned]: "nft_ownership_assigned",
    [OpCode.NftOwnerChanged]: "nft_owner_changed",
    [OpCode.Excess]: "excess"
  });
}
function collectBaseTransactionsForReceived(item, ownerFriendly, nftAddr) {
  const order = item.transactions_order || [];
  let ownerFromNft = null;
  const outToOwner = [];
  const others = [];
  for (const h2 of order) {
    const tx = item.transactions[h2];
    if (!tx)
      continue;
    const acc = asAddressFriendly(tx.account);
    if (!ownerFromNft && acc === ownerFriendly && tx.in_msg?.source && asAddressFriendly(tx.in_msg.source) === nftAddr) {
      ownerFromNft = Base64ToHex(h2);
      continue;
    }
    if (acc !== ownerFriendly) {
      const hex = Base64ToHex(h2);
      const targetsOwner = (tx.out_msgs || []).some((m2) => asAddressFriendly(m2.destination) === ownerFriendly);
      if (targetsOwner)
        outToOwner.push(hex);
      others.push(hex);
    }
  }
  const firstOther = outToOwner[0] || null;
  const base = [];
  if (firstOther)
    base.push(firstOther);
  const second = others.find((h2) => h2 !== firstOther) || null;
  if (second)
    base.push(second);
  if (ownerFromNft)
    base.push(ownerFromNft);
  return base;
}
function toContractAccount(address, addressBook) {
  const acc = toAccount(address, addressBook);
  return { ...acc, isWallet: false };
}
function findTransactionByAccount(item, account) {
  for (const key of Object.keys(item.transactions || {})) {
    const t = item.transactions[key];
    if (t && asAddressFriendly(t.account) === account)
      return t;
  }
  return null;
}
function toAddr(raw) {
  if (!raw)
    return "";
  if (typeof raw === "string") {
    if (/^[A-Fa-f0-9]{64}$/.test(raw))
      return asAddressFriendly(`0:${raw}`);
    return asAddressFriendly(raw);
  }
  if (isRecord(raw)) {
    const wc = raw["workchain_id"];
    const addr = raw["address"];
    if ((typeof wc === "string" || typeof wc === "number") && typeof addr === "string") {
      return asAddressFriendly(`${wc}:${addr}`);
    }
  }
  return "";
}
function isRecord(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getProp$1(obj, key) {
  return isRecord(obj) ? obj[key] : void 0;
}
function toAddressBook$1(data) {
  const out = {};
  for (const [address, bookRow] of Object.entries(data.address_book)) {
    const friendly = asAddressFriendly(address);
    if (bookRow.domain) {
      out[friendly] = { domain: bookRow.domain };
    }
    if (bookRow.interfaces && Array.isArray(bookRow.interfaces)) {
      const hasWalletInterface = bookRow.interfaces.some((iface) => typeof iface === "string" && iface.toLowerCase().includes("wallet"));
      if (hasWalletInterface) {
        if (!out[friendly]) {
          out[friendly] = {};
        }
        out[friendly].isWallet = true;
      }
    }
  }
  for (const [address, meta] of Object.entries(data.metadata)) {
    const friendly = asAddressFriendly(address);
    if (!out[friendly]) {
      out[friendly] = {};
    }
    if (!meta.token_info)
      continue;
    for (const tokenInfo of meta.token_info) {
      if (tokenInfo.type === "jetton_masters") {
        const masterInfo = tokenInfo;
        const decimals = masterInfo.extra?.decimals ? parseInt(masterInfo.extra.decimals, 10) : 0;
        const image = masterInfo.image || masterInfo.extra?._image_small || masterInfo.extra?._image_medium || masterInfo.extra?._image_big || "";
        out[friendly].jetton = {
          address: friendly,
          name: masterInfo.name || "",
          symbol: masterInfo.symbol || "",
          decimals,
          image,
          verification: "whitelist",
          score: 100
        };
      } else if (tokenInfo.type === "jetton_wallets") {
        const walletInfo = tokenInfo;
        out[friendly].jettonWallet = {
          balance: walletInfo.extra?.balance || "0",
          jettonMaster: asAddressFriendly(walletInfo.extra?.jetton || ""),
          owner: asAddressFriendly(walletInfo.extra?.owner || "")
        };
      }
    }
  }
  return out;
}
function buildEvent(data, account, actions, addressBook) {
  return {
    eventId: Base64ToHex(data.trace_id),
    account: toAccount(account, addressBook),
    timestamp: data.start_utime,
    actions,
    isScam: false,
    lt: Number(data.start_lt),
    inProgress: data.is_incomplete,
    trace: data.trace,
    transactions: data.transactions
  };
}
function filterActionsByPriority(actions) {
  const hasJetton = actions.some((a2) => a2.type === "JettonTransfer");
  const hasNft = actions.some((a2) => a2.type === "NftItemTransfer");
  if (hasJetton || hasNft) {
    const keepTypes = hasJetton ? ["JettonTransfer"] : ["NftItemTransfer"];
    return actions.filter((a2) => keepTypes.includes(a2.type));
  }
  return actions;
}
function toEvent(data, account, addressBook = {}) {
  const accountFriendly = asAddressFriendly(account);
  const transactions = data.transactions || {};
  const actions = [];
  for (const txHash of Object.keys(transactions)) {
    const tx = transactions[txHash];
    if (asAddressFriendly(tx.account) !== accountFriendly) {
      continue;
    }
    const status = computeStatus$1(tx);
    actions.push(...parseOutgoingTonTransfers(tx, addressBook, status), ...parseIncomingTonTransfers(tx, addressBook, status));
  }
  actions.push(...parseContractActions(accountFriendly, transactions, addressBook), ...parseJettonActions(accountFriendly, data, addressBook), ...parseNftActions(accountFriendly, data, addressBook));
  const filteredActions = filterActionsByPriority(actions);
  return buildEvent(data, account, filteredActions, addressBook);
}
function emulationEvent(data, account) {
  const txEntries = Object.entries(data.transactions);
  const byLtAsc = [...txEntries].sort((a2, b2) => BigInt(a2[1].lt) < BigInt(b2[1].lt) ? -1 : 1);
  const transactions_order = byLtAsc.map(([hash]) => hash);
  const start_lt = byLtAsc[0]?.[1].lt ?? "0";
  byLtAsc[byLtAsc.length - 1]?.[1].lt ?? "0";
  const start_utime = byLtAsc.length > 0 ? Math.min(...byLtAsc.map(([, tx]) => tx.now)) : Math.floor(Date.now() / 1e3);
  byLtAsc.length > 0 ? Math.max(...byLtAsc.map(([, tx]) => tx.now)) : start_utime;
  byLtAsc.map(([, tx]) => tx.mc_block_seqno);
  const trace_id = transactions_order[0] ?? "";
  const rootTx = trace_id ? data.transactions[trace_id] : void 0;
  rootTx?.in_msg?.hash_norm || rootTx?.in_msg?.hash || "";
  const traceItem = {
    actions: data.actions,
    is_incomplete: data.is_incomplete,
    start_lt,
    start_utime,
    trace: data.trace,
    trace_id,
    trace_info: {
      messages: byLtAsc.reduce((sum, [, tx]) => sum + (tx.in_msg ? 1 : 0) + (tx.out_msgs?.length ?? 0), 0),
      transactions: transactions_order.length
    },
    transactions: data.transactions,
    transactions_order
  };
  traceItem.metadata = data.metadata;
  let inferredAccount = account && String(account).trim() ? String(account).trim() : void 0;
  if (!inferredAccount) {
    inferredAccount = rootTx?.account;
  }
  if (!inferredAccount) {
    inferredAccount = byLtAsc[0]?.[1]?.account ?? Object.values(data.transactions || {})[0]?.account;
  }
  if (!inferredAccount) {
    inferredAccount = "";
  }
  const addressBook = toAddressBook$1(data);
  return toEvent(traceItem, inferredAccount, addressBook);
}
function toAccount(address, addressBook) {
  const friendly = asMaybeAddressFriendly(address);
  const out = {
    address: friendly ?? address ?? "",
    isScam: false,
    isWallet: Boolean(friendly)
  };
  if (friendly) {
    const record = addressBook[friendly];
    if (record) {
      if (record.isScam) {
        out.isScam = record.isScam;
      }
      if (record.isWallet) {
        out.isWallet = record.isWallet;
      }
      if (record.domain) {
        out.name = record.domain;
      }
    }
  }
  return out;
}
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
  config;
  parent;
  static defaultConfig = {
    level: LogLevel.INFO,
    prefix: "TonWalletKit",
    enableTimestamp: true,
    enableStackTrace: false
  };
  constructor(config) {
    this.parent = config?.parent;
    this.config = { ...Logger.defaultConfig, ...config };
    if (this.parent) {
      this.config = {
        ...this.parent.config,
        ...config,
        // Build hierarchical prefix
        prefix: this.buildHierarchicalPrefix(config?.prefix)
      };
    }
  }
  /**
   * Update logger configuration
   */
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * Create a child logger with a prefix that inherits from this logger
   */
  createChild(prefix, config) {
    return new Logger({
      ...config,
      parent: this,
      prefix
    });
  }
  /**
   * Build hierarchical prefix by combining parent prefix with current prefix
   */
  buildHierarchicalPrefix(currentPrefix) {
    if (!this.parent || !currentPrefix) {
      return currentPrefix || this.parent?.config.prefix || "";
    }
    const parentPrefix = this.parent.config.prefix;
    if (!parentPrefix) {
      return currentPrefix;
    }
    return `${parentPrefix}:${currentPrefix}`;
  }
  /**
   * Get the full hierarchical prefix for this logger
   */
  getPrefix() {
    return this.config.prefix || "";
  }
  /**
   * Get the parent logger if it exists
   */
  getParent() {
    return this.parent;
  }
  /**
   * Log debug messages
   */
  debug(message, context) {
    if (this.config.level <= LogLevel.DEBUG) {
      this.log("DEBUG", message, context);
    }
  }
  /**
   * Log info messages
   */
  info(message, context) {
    if (this.config.level <= LogLevel.INFO) {
      this.log("INFO", message, context);
    }
  }
  /**
   * Log warning messages
   */
  warn(message, context) {
    if (this.config.level <= LogLevel.WARN) {
      this.log("WARN", message, context);
    }
  }
  /**
   * Log error messages
   */
  error(message, context) {
    if (this.config.level <= LogLevel.ERROR) {
      this.log("ERROR", message, context);
    }
  }
  /**
   * Internal logging method
   */
  log(level, message, context) {
    const timestamp = this.config.enableTimestamp ? (/* @__PURE__ */ new Date()).toISOString() : "";
    const prefix = this.config.prefix ? `[${this.config.prefix}]` : "";
    let logMessage = "";
    if (timestamp) {
      logMessage += `${timestamp} `;
    }
    if (prefix) {
      logMessage += `${prefix} `;
    }
    logMessage += `${level}: ${message}`;
    const logArgs = [logMessage];
    if (context && Object.keys(context).length > 0) {
      logArgs.push(context);
    }
    switch (level) {
      case "DEBUG":
        console.debug(...logArgs);
        break;
      case "INFO":
        console.info(...logArgs);
        break;
      case "WARN":
        console.warn(...logArgs);
        break;
      case "ERROR":
        console.error(...logArgs);
        if (this.config.enableStackTrace) {
          console.trace();
        }
        break;
    }
  }
}
const globalLogger = new Logger({
  level: LogLevel.DEBUG,
  enableStackTrace: true
});
function delay(ms) {
  return new Promise((resolve) => setTimeout(() => {
    resolve();
  }, ms));
}
async function CallForSuccess(toCall, attempts = 20, delayMs = 100) {
  if (typeof toCall !== "function") {
    throw new Error("unknown input");
  }
  let i = 0;
  let lastError;
  while (i < attempts) {
    try {
      const res = await toCall();
      return res;
    } catch (err) {
      lastError = err;
      i++;
      await delay(delayMs);
    }
  }
  throw lastError;
}
class LocalStorageAdapter {
  prefix;
  maxRetries;
  retryDelay;
  localStorage;
  constructor(config = {}, _localStorage) {
    this.prefix = config.prefix || "tonwallet:";
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 100;
    if (_localStorage) {
      this.localStorage = _localStorage;
    } else {
      this.localStorage = window.localStorage;
    }
  }
  async get(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      return this.localStorage.getItem(fullKey);
    });
  }
  async set(key, value) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      this.localStorage.setItem(fullKey, value);
    });
  }
  async remove(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      this.localStorage.removeItem(fullKey);
    });
  }
  async clear() {
    return this.withRetry(async () => {
      const keysToRemove = this.getPrefixedKeys();
      keysToRemove.forEach((key) => this.localStorage.removeItem(key));
    });
  }
  getPrefixedKeys() {
    const keys = [];
    for (let i = 0; i < this.localStorage.length; i++) {
      const key = this.localStorage.key(i);
      if (key && key.startsWith(this.prefix)) {
        keys.push(key);
      }
    }
    return keys;
  }
  async withRetry(operation) {
    return CallForSuccess(operation, this.maxRetries, this.retryDelay);
  }
}
class MemoryStorageAdapter {
  store = /* @__PURE__ */ new Map();
  prefix;
  constructor(config = {}) {
    this.prefix = config.prefix || "";
  }
  async get(key) {
    const fullKey = this.prefix + key;
    return this.store.has(fullKey) ? this.store.get(fullKey) : null;
  }
  async set(key, value) {
    const fullKey = this.prefix + key;
    this.store.set(fullKey, value);
  }
  async remove(key) {
    const fullKey = this.prefix + key;
    this.store.delete(fullKey);
  }
  async clear() {
    if (this.prefix) {
      const keysToDelete = Array.from(this.store.keys()).filter((key) => key.startsWith(this.prefix));
      keysToDelete.forEach((key) => this.store.delete(key));
    } else {
      this.store.clear();
    }
  }
  /**
   * Get current store size (for testing/debugging)
   */
  getSize() {
    return this.store.size;
  }
  /**
   * Get all keys (for testing/debugging)
   */
  getKeys() {
    return Array.from(this.store.keys());
  }
}
const log$k = globalLogger.createChild("StorageAdapter");
function createStorageAdapter(config = {}) {
  if (typeof localStorage !== "undefined") {
    try {
      return new LocalStorageAdapter(config);
    } catch (error2) {
      log$k.warn("Failed to create LocalStorageAdapter, falling back to memory", { error: error2 });
    }
  }
  if (config.allowMemory) {
    return new MemoryStorageAdapter(config);
  } else {
    throw new Error("No storage adapter available");
  }
}
class ExtensionStorageAdapter {
  prefix;
  maxRetries;
  retryDelay;
  localStorage;
  constructor(config = {}, localStorage2) {
    this.prefix = config.prefix || "tonwallet:";
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 100;
    this.localStorage = localStorage2;
  }
  async get(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      const itemObj = await this.localStorage.get(fullKey);
      if (!itemObj) {
        return null;
      }
      const item = itemObj[fullKey];
      if (!item) {
        return null;
      }
      return item.toString();
    });
  }
  async set(key, value) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      await this.localStorage.set({
        [fullKey]: value
      });
    });
  }
  async remove(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      await this.localStorage.remove(fullKey);
    });
  }
  async clear() {
    return this.withRetry(async () => {
      return this.localStorage.clear();
    });
  }
  async withRetry(operation) {
    return CallForSuccess(operation, this.maxRetries, this.retryDelay);
  }
}
const log$j = globalLogger.createChild("Storage");
class Storage {
  adapter;
  constructor(adapter) {
    this.adapter = adapter;
  }
  /**
   * Get a value from storage by key
   * @param key The storage key
   * @returns The stored value, or null if not found
   */
  async get(key) {
    try {
      const value = await this.adapter.get(key);
      if (value === null) {
        return null;
      }
      return JSON.parse(value);
    } catch (error2) {
      log$j.warn("Failed to parse stored value", { key, error: error2 });
      return null;
    }
  }
  /**
   * Set a value in storage
   * @param key The storage key
   * @param value The value to store (will be JSON serialized)
   */
  async set(key, value) {
    try {
      const serialized = JSON.stringify(value);
      await this.adapter.set(key, serialized);
    } catch (error2) {
      log$j.error("Failed to serialize value for storage", { key, error: error2 });
      throw error2;
    }
  }
  /**
   * Remove a value from storage
   * @param key The storage key to remove
   */
  async remove(key) {
    await this.adapter.remove(key);
  }
  /**
   * Clear all storage data
   */
  async clear() {
    await this.adapter.clear();
  }
  /**
   * Get the underlying storage adapter
   * @returns The StorageAdapter instance
   */
  getAdapter() {
    return this.adapter;
  }
}
function validateWallet(_wallet, _context = {}) {
  const errors2 = [];
  const warnings = [];
  return {
    isValid: errors2.length === 0,
    errors: errors2,
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
function validateBridgeEvent(event, context = {}) {
  const errors2 = [];
  if (!event || typeof event !== "object") {
    errors2.push("event must be an object");
    return { isValid: false, errors: errors2 };
  }
  if (!event.id || typeof event.id !== "string") {
    errors2.push("event.id must be a non-empty string");
  }
  if (!event.method || typeof event.method !== "string") {
    errors2.push("event.method must be a non-empty string");
  } else if (!isValidEventMethod(event.method)) {
    if (context.strict) {
      errors2.push(`unsupported event method: ${event.method}`);
    }
  }
  if (event.params && typeof event.params !== "object") {
    errors2.push("event.params must be an object if provided");
  }
  if (event.sessionId && typeof event.sessionId !== "string") {
    errors2.push("event.sessionId must be a string if provided");
  }
  if (event.timestamp && typeof event.timestamp !== "number") {
    errors2.push("event.timestamp must be a number if provided");
  }
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function isValidEventMethod(method) {
  const supportedMethods = [
    "connect",
    "sendTransaction",
    "signData",
    "disconnect",
    "tonconnect_connect",
    "tonconnect_sendTransaction",
    "tonconnect_signData",
    "tonconnect_disconnect",
    "wallet_connect",
    "wallet_disconnect",
    "personal_sign"
  ];
  return supportedMethods.includes(method);
}
function validateTransactionMessages(messages, isTonConnect = true) {
  const errors2 = [];
  if (!Array.isArray(messages)) {
    errors2.push("messages must be an array");
    return { isValid: false, errors: errors2 };
  }
  if (messages.length === 0) {
    errors2.push("messages array cannot be empty");
    return { isValid: false, errors: errors2 };
  }
  messages.forEach((msg, index2) => {
    const msgErrors = validateTransactionMessage(msg, isTonConnect).errors;
    msgErrors.forEach((error2) => {
      errors2.push(`message[${index2}]: ${error2}`);
    });
  });
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function validateTransactionMessage(message, isTonConnect = true) {
  const errors2 = [];
  if (typeof message !== "object") {
    return { isValid: false, errors: ["Invalid message"] };
  }
  if (message === null || message === void 0) {
    return { isValid: false, errors: ["Invalid message"] };
  }
  if (isTonConnect && typeof message.mode !== "undefined") {
    errors2.push("mode must be undefined for tonconnect!");
  }
  const objErrors = validateMessageObject(message).errors;
  errors2.push(...objErrors);
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function validateMessageObject(message) {
  const errors2 = [];
  if (!message.address || typeof message.address !== "string") {
    errors2.push("to address is required and must be a string");
  } else {
    if (!isFriendlyTonAddress(message.address)) {
      errors2.push("to address must be a valid friendly TON address");
    }
  }
  if (message.amount !== void 0) {
    if (!isValidNanotonAmount(message.amount)) {
      errors2.push("value must be a valid nanonton amount (string of digits)");
    }
  } else {
    errors2.push("value must be a valid nanonton amount (string of digits)");
  }
  if (message.payload) {
    if (typeof message.payload !== "string") {
      errors2.push("payload must be a string if provided");
    } else {
      if (!isValidBOC(message.payload)) {
        errors2.push("payload must be a valid base64 string if provided");
      }
    }
  }
  if (message.stateInit) {
    if (typeof message.stateInit !== "string") {
      errors2.push("stateInit must be a string if provided");
    } else {
      if (!isValidBOC(message.stateInit)) {
        errors2.push("stateInit must be a valid base64 string if provided");
      }
    }
  }
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function isValidNanotonAmount(amount) {
  if (typeof amount !== "string") {
    return false;
  }
  const amountStr = String(amount);
  const parsed = BigInt(amountStr);
  return parsed >= 0 && parsed.toString() === amountStr;
}
function isValidBOC(bocString) {
  try {
    distExports$2.Cell.fromBase64(bocString);
    return true;
  } catch {
    return false;
  }
}
globalLogger.createChild("WalletManager");
class WalletManager {
  wallets = /* @__PURE__ */ new Map();
  storage;
  // private storageKey = 'wallets';
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Initialize manager and load persisted wallets
   */
  async initialize() {
  }
  /**
   * Get all wallets as array
   */
  getWallets() {
    return Array.from(this.wallets.values());
  }
  /**
   * Get wallet by wallet ID (network:address format)
   */
  getWallet(walletId) {
    return this.wallets.get(walletId) || void 0;
  }
  /**
   * Add a wallet with validation
   */
  async addWallet(wallet) {
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    const walletId = wallet.getWalletId();
    if (this.wallets.has(walletId)) {
      return walletId;
    }
    this.wallets.set(walletId, wallet);
    return walletId;
  }
  /**
   * Remove wallet by wallet ID or wallet adapter
   */
  async removeWallet(walletIdOrAdapter) {
    let walletId;
    if (typeof walletIdOrAdapter === "string") {
      walletId = walletIdOrAdapter;
    } else {
      walletId = walletIdOrAdapter.getWalletId();
    }
    const removed = this.wallets.delete(walletId);
    return removed;
  }
  /**
   * Update existing wallet
   */
  async updateWallet(wallet) {
    const walletId = wallet.getWalletId();
    if (!this.wallets.has(walletId)) {
      throw new Error(`Wallet with ID ${walletId} not found`);
    }
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    this.wallets.set(walletId, wallet);
  }
  /**
   * Clear all wallets
   */
  async clearWallets() {
    this.wallets.clear();
  }
  /**
   * Get wallet count
   */
  getWalletCount() {
    return this.wallets.size;
  }
  /**
   * Check if wallet exists by wallet ID
   */
  hasWallet(walletId) {
    return this.wallets.has(walletId);
  }
  /**
   * Get wallet ID for a wallet adapter
   */
  getWalletId(wallet) {
    return wallet.getWalletId();
  }
}
const log$i = globalLogger.createChild("TONConnectStoredSessionManager");
class TONConnectStoredSessionManager {
  sessions = /* @__PURE__ */ new Map();
  storage;
  walletManager;
  storageKey = "sessions";
  schemaVersion = 1;
  constructor(storage, walletManager) {
    this.storage = storage;
    this.walletManager = walletManager;
  }
  /**
   * Initialize manager and load persisted sessions
   */
  async initialize() {
    await this.loadSessions();
    await this.migrateSessions();
  }
  /**
   * Create new session
   * @param sessionId - Unique session identifier
   * @param dAppInfo - Information about the dApp
   * @param wallet - The wallet to associate with this session (optional for connect requests before wallet selection)
   * @param options - Additional options for session creation
   */
  async createSession(sessionId, dAppInfo, wallet, isJsBridge) {
    const now = /* @__PURE__ */ new Date();
    const randomKeyPair = new SessionCrypto().stringifyKeypair();
    const walletId = wallet.getWalletId();
    let domain;
    try {
      const url = new URL(dAppInfo.url || "");
      domain = url.host;
    } catch {
      throw new Error("Unable to resolve domain from dApp URL for new sessions");
    }
    const session = {
      sessionId,
      walletId,
      walletAddress: wallet?.getAddress() ?? "",
      createdAt: now.toISOString(),
      lastActivityAt: now.toISOString(),
      privateKey: randomKeyPair.secretKey,
      publicKey: randomKeyPair.publicKey,
      domain,
      dAppName: dAppInfo.name,
      dAppDescription: dAppInfo.description,
      dAppUrl: dAppInfo.url,
      dAppIconUrl: dAppInfo.iconUrl,
      isJsBridge,
      schemaVersion: this.schemaVersion
    };
    this.sessions.set(sessionId, session);
    await this.persistSessions();
    return await this.getSession(sessionId);
  }
  /**
   * Get session by ID
   */
  async getSession(sessionId) {
    return this.sessions.get(sessionId);
  }
  async getSessionByDomain(domain) {
    let host;
    try {
      host = new URL(domain).host;
    } catch {
      return void 0;
    }
    for (const session of this.sessions.values()) {
      if (session.domain === host) {
        return this.getSession(session.sessionId);
      }
    }
    return void 0;
  }
  /**
   * Get all sessions as array
   */
  async getSessions() {
    return Array.from(this.sessions.values());
  }
  /**
   * Get sessions for specific wallet by wallet ID
   */
  async getSessionsForWallet(walletId) {
    return (await this.getSessions()).filter((session) => session.walletId === walletId);
  }
  /**
   * Update session activity timestamp
   */
  async updateSessionActivity(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastActivityAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.persistSessions();
    }
  }
  /**
   * Remove session by ID
   */
  async removeSession(sessionId) {
    const removed = this.sessions.delete(sessionId);
    if (removed) {
      await this.persistSessions();
    }
  }
  /**
   * Remove all sessions for a wallet by wallet ID or wallet adapter
   */
  async removeSessionsForWallet(walletId) {
    const sessionsToRemove = await this.getSessionsForWallet(walletId);
    let removedCount = 0;
    for (const session of sessionsToRemove) {
      if (this.sessions.delete(session.sessionId)) {
        removedCount++;
      }
    }
    if (removedCount > 0) {
      await this.persistSessions();
    }
  }
  /**
   * Clear all sessions
   */
  async clearSessions() {
    this.sessions.clear();
    await this.persistSessions();
  }
  /**
   * Get session count
   */
  getSessionCount() {
    return this.sessions.size;
  }
  /**
   * Check if session exists
   */
  hasSession(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * Clean up expired sessions (optional cleanup based on inactivity)
   */
  async cleanupInactiveSessions(maxInactiveHours = 24) {
    const cutoffTime = /* @__PURE__ */ new Date();
    cutoffTime.setHours(cutoffTime.getHours() - maxInactiveHours);
    const sessionsToRemove = [];
    for (const [sessionId, session] of this.sessions.entries()) {
      if (new Date(session.lastActivityAt) < cutoffTime) {
        sessionsToRemove.push(sessionId);
      }
    }
    for (const sessionId of sessionsToRemove) {
      this.sessions.delete(sessionId);
    }
    if (sessionsToRemove.length > 0) {
      await this.persistSessions();
    }
    return sessionsToRemove.length;
  }
  /**
   * Load sessions from storage
   */
  async loadSessions() {
    try {
      const storedSessions = await this.storage.get(this.storageKey);
      if (storedSessions && Array.isArray(storedSessions)) {
        for (const session of storedSessions) {
          if (session.walletId && !session.walletAddress) {
            const wallet = this.walletManager.getWallet(session.walletId);
            if (wallet) {
              session.walletAddress = wallet.getAddress();
            } else {
              log$i.warn("Session Wallet not found for session", { sessionId: session.sessionId });
              continue;
            }
          }
          this.sessions.set(session.sessionId, session);
        }
        log$i.debug("Loaded session metadata", { count: storedSessions.length });
      }
    } catch (error2) {
      log$i.warn("Failed to load sessions from storage", { error: error2 });
    }
  }
  /**
   * Persist session metadata to storage
   */
  async persistSessions() {
    try {
      const sessionsToStore = Array.from(this.sessions.values());
      await this.storage.set(this.storageKey, sessionsToStore);
    } catch (error2) {
      log$i.warn("Failed to persist sessions to storage", { error: error2 });
    }
  }
  async migrateSessions() {
    for (const [sessionId, session] of this.sessions.entries()) {
      const migratedSession = this.migrate(session);
      if (migratedSession) {
        this.sessions.set(sessionId, migratedSession);
      } else {
        this.sessions.delete(sessionId);
      }
    }
    await this.persistSessions();
  }
  migrate(session) {
    if (session.schemaVersion === this.schemaVersion) {
      return session;
    }
    return void 0;
  }
}
var util$8;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$8;
  hasRequiredUtil = 1;
  const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
  function normalizeInput(input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (typeof input === "string") {
      const encoder = new TextEncoder();
      ret = encoder.encode(input);
    } else {
      throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
  }
  function toHex(bytes) {
    return Array.prototype.map.call(bytes, function(n) {
      return (n < 16 ? "0" : "") + n.toString(16);
    }).join("");
  }
  function uint32ToHex(val) {
    return (4294967296 + val).toString(16).substring(1);
  }
  function debugPrint(label, arr, size) {
    let msg = "\n" + label + " = ";
    for (let i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += " ";
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else throw new Error("Invalid size " + size);
      if (i % 6 === 4) {
        msg += "\n" + new Array(label.length + 4).join(" ");
      } else if (i < arr.length - 2) {
        msg += " ";
      }
    }
    console.log(msg);
  }
  function testSpeed(hashFn, N2, M2) {
    let startMs = (/* @__PURE__ */ new Date()).getTime();
    const input = new Uint8Array(N2);
    for (let i = 0; i < N2; i++) {
      input[i] = i % 256;
    }
    const genMs = (/* @__PURE__ */ new Date()).getTime();
    console.log("Generated random input in " + (genMs - startMs) + "ms");
    startMs = genMs;
    for (let i = 0; i < M2; i++) {
      const hashHex = hashFn(input);
      const hashMs = (/* @__PURE__ */ new Date()).getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
      console.log(
        Math.round(N2 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
      );
    }
  }
  util$8 = {
    normalizeInput,
    toHex,
    debugPrint,
    testSpeed
  };
  return util$8;
}
var blake2b_1;
var hasRequiredBlake2b;
function requireBlake2b() {
  if (hasRequiredBlake2b) return blake2b_1;
  hasRequiredBlake2b = 1;
  const util2 = requireUtil();
  function ADD64AA(v3, a2, b2) {
    const o0 = v3[a2] + v3[b2];
    let o1 = v3[a2 + 1] + v3[b2 + 1];
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function ADD64AC(v3, a2, b0, b1) {
    let o0 = v3[a2] + b0;
    if (b0 < 0) {
      o0 += 4294967296;
    }
    let o1 = v3[a2 + 1] + b1;
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
  }
  function B2B_G(a2, b2, c, d, ix, iy) {
    const x0 = m2[ix];
    const x1 = m2[ix + 1];
    const y0 = m2[iy];
    const y1 = m2[iy + 1];
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, x0, x1);
    let xor0 = v2[d] ^ v2[a2];
    let xor1 = v2[d + 1] ^ v2[a2 + 1];
    v2[d] = xor1;
    v2[d + 1] = xor0;
    ADD64AA(v2, c, d);
    xor0 = v2[b2] ^ v2[c];
    xor1 = v2[b2 + 1] ^ v2[c + 1];
    v2[b2] = xor0 >>> 24 ^ xor1 << 8;
    v2[b2 + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, y0, y1);
    xor0 = v2[d] ^ v2[a2];
    xor1 = v2[d + 1] ^ v2[a2 + 1];
    v2[d] = xor0 >>> 16 ^ xor1 << 16;
    v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v2, c, d);
    xor0 = v2[b2] ^ v2[c];
    xor1 = v2[b2 + 1] ^ v2[c + 1];
    v2[b2] = xor1 >>> 31 ^ xor0 << 1;
    v2[b2 + 1] = xor0 >>> 31 ^ xor1 << 1;
  }
  const BLAKE2B_IV32 = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function(x2) {
      return x2 * 2;
    })
  );
  const v2 = new Uint32Array(32);
  const m2 = new Uint32Array(32);
  function blake2bCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 16; i++) {
      v2[i] = ctx.h[i];
      v2[i + 16] = BLAKE2B_IV32[i];
    }
    v2[24] = v2[24] ^ ctx.t;
    v2[25] = v2[25] ^ ctx.t / 4294967296;
    if (last) {
      v2[28] = ~v2[28];
      v2[29] = ~v2[29];
    }
    for (i = 0; i < 32; i++) {
      m2[i] = B2B_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 12; i++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v2[i] ^ v2[i + 16];
    }
  }
  const parameterBlock = new Uint8Array([
    0,
    0,
    0,
    0,
    //  0: outlen, keylen, fanout, depth
    0,
    0,
    0,
    0,
    //  4: leaf length, sequential mode
    0,
    0,
    0,
    0,
    //  8: node offset
    0,
    0,
    0,
    0,
    // 12: node offset
    0,
    0,
    0,
    0,
    // 16: node depth, inner length, rfu
    0,
    0,
    0,
    0,
    // 20: rfu
    0,
    0,
    0,
    0,
    // 24: rfu
    0,
    0,
    0,
    0,
    // 28: rfu
    0,
    0,
    0,
    0,
    // 32: salt
    0,
    0,
    0,
    0,
    // 36: salt
    0,
    0,
    0,
    0,
    // 40: salt
    0,
    0,
    0,
    0,
    // 44: salt
    0,
    0,
    0,
    0,
    // 48: personal
    0,
    0,
    0,
    0,
    // 52: personal
    0,
    0,
    0,
    0,
    // 56: personal
    0,
    0,
    0,
    0
    // 60: personal
  ]);
  function blake2bInit(outlen, key, salt, personal) {
    if (outlen === 0 || outlen > 64) {
      throw new Error("Illegal output length, expected 0 < length <= 64");
    }
    if (key && key.length > 64) {
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    }
    if (salt && salt.length !== 16) {
      throw new Error("Illegal salt, expected Uint8Array with length is 16");
    }
    if (personal && personal.length !== 16) {
      throw new Error("Illegal personal, expected Uint8Array with length is 16");
    }
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      // input count
      c: 0,
      // pointer within buffer
      outlen
      // output length in bytes
    };
    parameterBlock.fill(0);
    parameterBlock[0] = outlen;
    if (key) parameterBlock[1] = key.length;
    parameterBlock[2] = 1;
    parameterBlock[3] = 1;
    if (salt) parameterBlock.set(salt, 32);
    if (personal) parameterBlock.set(personal, 48);
    for (let i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    if (key) {
      blake2bUpdate(ctx, key);
      ctx.c = 128;
    }
    return ctx;
  }
  function blake2bUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2bFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
  }
  function blake2b(input, key, outlen, salt, personal) {
    outlen = outlen || 64;
    input = util2.normalizeInput(input);
    if (salt) {
      salt = util2.normalizeInput(salt);
    }
    if (personal) {
      personal = util2.normalizeInput(personal);
    }
    const ctx = blake2bInit(outlen, key, salt, personal);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
  }
  function blake2bHex(input, key, outlen, salt, personal) {
    const output = blake2b(input, key, outlen, salt, personal);
    return util2.toHex(output);
  }
  blake2b_1 = {
    blake2b,
    blake2bHex,
    blake2bInit,
    blake2bUpdate,
    blake2bFinal
  };
  return blake2b_1;
}
var blake2s_1;
var hasRequiredBlake2s;
function requireBlake2s() {
  if (hasRequiredBlake2s) return blake2s_1;
  hasRequiredBlake2s = 1;
  const util2 = requireUtil();
  function B2S_GET32(v3, i) {
    return v3[i] ^ v3[i + 1] << 8 ^ v3[i + 2] << 16 ^ v3[i + 3] << 24;
  }
  function B2S_G(a2, b2, c, d, x2, y2) {
    v2[a2] = v2[a2] + v2[b2] + x2;
    v2[d] = ROTR32(v2[d] ^ v2[a2], 16);
    v2[c] = v2[c] + v2[d];
    v2[b2] = ROTR32(v2[b2] ^ v2[c], 12);
    v2[a2] = v2[a2] + v2[b2] + y2;
    v2[d] = ROTR32(v2[d] ^ v2[a2], 8);
    v2[c] = v2[c] + v2[d];
    v2[b2] = ROTR32(v2[b2] ^ v2[c], 7);
  }
  function ROTR32(x2, y2) {
    return x2 >>> y2 ^ x2 << 32 - y2;
  }
  const BLAKE2S_IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  const v2 = new Uint32Array(16);
  const m2 = new Uint32Array(16);
  function blake2sCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 8; i++) {
      v2[i] = ctx.h[i];
      v2[i + 8] = BLAKE2S_IV[i];
    }
    v2[12] ^= ctx.t;
    v2[13] ^= ctx.t / 4294967296;
    if (last) {
      v2[14] = ~v2[14];
    }
    for (i = 0; i < 16; i++) {
      m2[i] = B2S_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 10; i++) {
      B2S_G(0, 4, 8, 12, m2[SIGMA[i * 16 + 0]], m2[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m2[SIGMA[i * 16 + 2]], m2[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m2[SIGMA[i * 16 + 4]], m2[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m2[SIGMA[i * 16 + 6]], m2[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m2[SIGMA[i * 16 + 8]], m2[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m2[SIGMA[i * 16 + 10]], m2[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m2[SIGMA[i * 16 + 12]], m2[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m2[SIGMA[i * 16 + 14]], m2[SIGMA[i * 16 + 15]]);
    }
    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v2[i] ^ v2[i + 8];
    }
  }
  function blake2sInit(outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error("Incorrect output length, should be in [1, 32]");
    }
    const keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
      throw new Error("Incorrect key length, should be in [1, 32]");
    }
    const ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      // hash state
      b: new Uint8Array(64),
      // input block
      c: 0,
      // pointer within block
      t: 0,
      // input count
      outlen
      // output length in bytes
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key);
      ctx.c = 64;
    }
    return ctx;
  }
  function blake2sUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2sFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
    }
    return out;
  }
  function blake2s(input, key, outlen) {
    outlen = outlen || 32;
    input = util2.normalizeInput(input);
    const ctx = blake2sInit(outlen, key);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
  }
  function blake2sHex(input, key, outlen) {
    const output = blake2s(input, key, outlen);
    return util2.toHex(output);
  }
  blake2s_1 = {
    blake2s,
    blake2sHex,
    blake2sInit,
    blake2sUpdate,
    blake2sFinal
  };
  return blake2s_1;
}
var blakejs;
var hasRequiredBlakejs;
function requireBlakejs() {
  if (hasRequiredBlakejs) return blakejs;
  hasRequiredBlakejs = 1;
  const b2b = requireBlake2b();
  const b2s = requireBlake2s();
  blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
  return blakejs;
}
var blakejsExports = requireBlakejs();
const h = /* @__PURE__ */ getDefaultExportFromCjs(blakejsExports);
function P() {
  return typeof process < "u" && !!process.env;
}
function B(o4) {
  return process?.env?.[o4];
}
var O$1 = P() && !B("TONBRIDGE_DEBUG"), s = (...o4) => {
  O$1 || console.debug("[TON_CONNECT_BRIDGE_SDK]", ...o4);
}, b$1 = (...o4) => {
  console.error("[TON_CONNECT_BRIDGE_SDK]", ...o4);
};
var a = class o extends Error {
  static prefix = "[BRIDGE_SDK_ERROR]";
  constructor(e, t) {
    super(e, t), this.message = `${o.prefix} ${e ? `
` + e : ""}`, s(this.message), Object.setPrototypeOf(this, o.prototype);
  }
};
function k(o4) {
  return o4.slice(-1) === "/" ? o4.slice(0, -1) : o4;
}
function E(o4, e) {
  return k(o4) + "/" + e;
}
function p(o4) {
  let e = new AbortController();
  return o4?.aborted ? e.abort() : o4?.addEventListener("abort", () => e.abort(), { once: true }), e;
}
function D(o4, e) {
  let t = null, r = null, n = null;
  return { create: async (d, ...u) => {
    if (n?.abort(), n = p(d), n.signal.aborted) throw new a("Resource creation was aborted");
    let m2 = o4(n.signal, ...u);
    r = m2;
    let g2 = await m2;
    if (r !== m2 && g2 !== t) throw await e(g2), new a("Resource creation was aborted by a new resource creation");
    return t = g2, t;
  }, current: () => t ?? null, dispose: async () => {
    try {
      let d = t;
      t = null;
      let u = r;
      r = null;
      try {
        n?.abort();
      } catch {
      }
      await Promise.allSettled([d ? e(d) : Promise.resolve(), u ? e(await u) : Promise.resolve()]);
    } catch {
    }
  } };
}
function M$1(o4, e) {
  let t = e?.timeout, r = e?.signal, n = p(r);
  return new Promise(async (i, c) => {
    if (r?.aborted) {
      c(new a("Timeout aborted before setTimeout"));
      return;
    }
    let l;
    typeof t < "u" && (l = setTimeout(() => {
      n.abort(), c(new a(`Timeout after ${t}ms`));
    }, t)), n.signal.addEventListener("abort", () => {
      l && (clearTimeout(l), l = void 0, c(new a("Timeout aborted after setTimeout")));
    }, { once: true }), await o4((...d) => {
      clearTimeout(l), l = void 0, i(...d);
    }, (d) => {
      clearTimeout(l), l = void 0, c(d);
    }, { timeout: t, signal: n.signal });
  });
}
var v$1 = class o2 {
  constructor(e, t, r, n, i, c, l) {
    this.bridgeUrl = e;
    this.sessionIds = t;
    this.listener = r;
    this.errorsListener = n;
    this.lastEventId = i;
    this.heartbeatFormat = c;
    this.enableQueueDoneEvent = l;
  }
  static ssePath = "events";
  static postPath = "message";
  static defaultTtl = 300;
  eventSource = D(async (e, t) => await U({ bridgeUrl: this.bridgeUrl, ssePath: o2.ssePath, sessionIds: this.sessionIds, errorHandler: this.errorsHandler.bind(this), messageHandler: this.messagesHandler.bind(this), signal: e, connectingDeadlineMS: t, lastEventId: this.lastEventId, heartbeatFormat: this.heartbeatFormat, enableQueueDoneEvent: this.enableQueueDoneEvent }), async (e) => {
    e.close();
  });
  get isReady() {
    return this.eventSource.current()?.readyState === EventSource.OPEN;
  }
  get isClosed() {
    return this.eventSource.current()?.readyState !== EventSource.OPEN;
  }
  get isConnecting() {
    return this.eventSource.current()?.readyState === EventSource.CONNECTING;
  }
  static async open(e) {
    let t = new o2(e.bridgeUrl, e.sessionIds, e.listener, e.errorsListener, e.lastEventId, e.heartbeatFormat, e.enableQueueDoneEvent);
    try {
      return await t.registerSession(e.options), t;
    } catch (r) {
      throw await t.close(), r;
    }
  }
  async registerSession(e) {
    await this.eventSource.create(e?.signal, e?.connectingDeadlineMS);
  }
  static async sendRequest(e, t, r, n, i) {
    let c = new URL(E(e, this.postPath));
    c.searchParams.append("client_id", r), c.searchParams.append("to", n), c.searchParams.append("ttl", (i?.ttl ?? o2.defaultTtl).toString()), i?.topic && c.searchParams.append("topic", i.topic), i?.traceId && c.searchParams.append("trace_id", i.traceId);
    let l = Base64.encode(t), d = await this.post(c, l, i?.signal);
    if (!d.ok) throw new a(`Bridge send failed, status ${d.status}`);
  }
  async send(e, t, r, n) {
    return o2.sendRequest(this.bridgeUrl, e, t, r, n);
  }
  async close() {
    await this.eventSource.dispose().catch((e) => {
      b$1("[BridgeGateway] Failed to close connection:", e);
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  static async post(e, t, r) {
    let n = await fetch(e, { method: "post", body: t, signal: r });
    if (!n.ok) throw new a(`Bridge send failed, status ${n.status}`);
    return n;
  }
  async errorsHandler(e, t) {
    this.errorsListener(t);
  }
  async messagesHandler(e) {
    this.listener(e);
  }
};
async function U(o4) {
  let { lastEventId: e, heartbeatFormat: t, enableQueueDoneEvent: r } = o4;
  return await M$1(async (n, i, c) => {
    let { signal: l } = c;
    if (s("[BridgeGateway] Connecting to bridge SSE..."), l?.aborted) {
      i(new a("Bridge connection aborted before connection"));
      return;
    }
    let d = new URL(E(o4.bridgeUrl, o4.ssePath));
    if (d.searchParams.append("client_id", o4.sessionIds.join(",")), e && d.searchParams.append("last_event_id", e), t && d.searchParams.append("heartbeat", t), r && d.searchParams.append("enable_queue_done_event", "true"), l?.aborted) {
      i(new a("Bridge connection aborted after building url"));
      return;
    }
    s("[BridgeGateway] Initializing EventSource instance...");
    let u = new EventSource(d.toString()), m2 = false;
    u.onerror = async (g2) => {
      if (s("[BridgeGateway] EventSource error occurred:", JSON.stringify(g2)), l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on error callback"));
        return;
      }
      if (!m2) {
        u.close(), i(new a("Bridge error before connecting"));
        return;
      }
      try {
        u.close(), await o4.errorHandler(u, g2);
      } catch (A2) {
        u.close(), i(A2);
      }
    }, u.onopen = () => {
      if (l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on open"));
        return;
      }
      m2 = true, s("[BridgeGateway] EventSource connection established."), n(u);
    }, u.onmessage = (g2) => {
      if (l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on message"));
        return;
      }
      e = g2.lastEventId, o4.messageHandler(g2);
    }, o4.signal?.addEventListener("abort", () => {
      u.close(), i(new a("Bridge connection aborted"));
    }, { once: true });
  }, { timeout: o4.connectingDeadlineMS, signal: o4.signal });
}
async function y(o4, e) {
  if (e?.signal?.aborted) throw new a("Delay aborted before setTimeout");
  return new Promise((t, r) => {
    let n = setTimeout(t, o4);
    e?.signal?.addEventListener("abort", () => {
      clearTimeout(n), r(new a("Delay aborted after setTimeout"));
    }, { once: true });
  });
}
async function S$1(o4, e) {
  let { signal: t, attempts: r = 10, delayMs: n = 100 } = e ?? {};
  if (typeof o4 != "function") throw new a(`Expected a function, got ${typeof o4}`);
  let i = 0, c;
  for (; i < r; ) {
    if (s(`[callForSuccess] Attempt: ${i}`), t?.aborted) throw new a(`Aborted after attempts ${i}`);
    try {
      return await o4({ signal: t });
    } catch (l) {
      s(`[callForSuccess], error after attempt ${i}, ${/* @__PURE__ */ new Date()}: ${JSON.stringify(l)}`, l), c = l, i++, i < r && (await y(n, { signal: t }), e?.exponential && (n = Math.min(n * 2, e.maxDelayMs ?? Number.MAX_SAFE_INTEGER)));
    }
  }
  throw c;
}
function T$1(o4) {
  return [...new Set(o4)];
}
function x(o4, e) {
  let t = new Set(o4), r = new Set(e);
  if (t.size !== r.size) return false;
  for (let n of t) if (!r.has(n)) return false;
  return true;
}
function G(o4, e) {
  let t = h.blake2bInit(f.box.nonceLength);
  return h.blake2bUpdate(t, o4), h.blake2bUpdate(t, e), h.blake2bFinal(t);
}
function I$1(o4, e, t) {
  let r = o4.subarray(0, f.box.publicKeyLength), n = G(r, e), i = o4.subarray(f.box.publicKeyLength);
  return f.box.open(i, n, r, t);
}
var C$1 = class o3 {
  constructor(e, t = null, r = null, n = void 0) {
    this.bridgeUrl = e;
    this.listener = t;
    this.errorListener = r;
    this.heartbeatReconnectIntervalMs = n;
  }
  clients = [];
  lastEventId;
  abortController;
  gateway = null;
  onConnectingCallback;
  onQueueDoneCallback;
  heartbeatMessage = "heartbeat";
  queueEndMessage = "queue_done";
  defaultConnectingDeadlineMS = 14e3;
  defaultRetryDelayMs = 1e3;
  defaultMaxExponentialDelayMS = 7e3;
  missedHeartbeatDelay = 100;
  lastHeartbeatAt = Date.now();
  heartbeatTimer = null;
  connectionOptions = {};
  static async open(e) {
    let t = new o3(e.bridgeUrl, e.listener, e.errorListener, e.options?.heartbeatReconnectIntervalMs);
    e.onConnecting && (t.onConnecting = e.onConnecting), e.onQueueDone && (t.onQueueDone = e.onQueueDone);
    try {
      return await t.restoreConnection(e.clients, e.options), t;
    } catch (r) {
      throw await t.close(), r;
    }
  }
  get isReady() {
    return this.gateway?.isReady || false;
  }
  get isConnecting() {
    return this.gateway?.isConnecting ?? false;
  }
  get isClosed() {
    return this.gateway?.isClosed ?? false;
  }
  startHeartbeatWatcher(e) {
    if (!this.heartbeatReconnectIntervalMs) return;
    this.stopHeartbeatWatcher();
    let t = p(e), { signal: r } = t;
    this.lastHeartbeatAt = Date.now();
    let n = (c) => {
      this.heartbeatTimer = setTimeout(i, c);
    }, i = async () => {
      if (r.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      if (Date.now() - this.lastHeartbeatAt < this.heartbeatReconnectIntervalMs) {
        n(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      if (await y(this.missedHeartbeatDelay, { signal: r }), r.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      let l = Date.now() - this.lastHeartbeatAt;
      if (l <= this.heartbeatReconnectIntervalMs) {
        n(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      s(`[BridgeProvider] No heartbeat for ${l}ms, reconnecting...`);
      try {
        await this.reconnect(r);
      } catch (d) {
        b$1("[BridgeProvider] Failed to reconnect after missed heartbeat:", d), this.errorListener?.(d);
      }
    };
    n(this.heartbeatReconnectIntervalMs);
  }
  stopHeartbeatWatcher() {
    this.heartbeatTimer && (clearTimeout(this.heartbeatTimer), this.heartbeatTimer = null);
  }
  async restoreConnection(e, t) {
    if (e.length === 0) {
      s("[BridgeProvider] No clients passed");
      return;
    }
    this.clients = e, this.lastEventId = t?.lastEventId, this.connectionOptions = { connectingDeadlineMs: t?.connectingDeadlineMs, delayMs: t?.delayMs, maxDelayMs: t?.maxDelayMs, exponential: t?.exponential }, s("[BridgeProvider] Restoring connection...");
    let r = p(t?.signal);
    this.abortController?.abort(), this.abortController = r;
    let n = r.signal;
    if (n.aborted) {
      s("[BridgeProvider] Restore aborted before start.");
      return;
    }
    if (await this.reconnect(n), r.signal.aborted) {
      s("[BridgeProvider] Restore aborted after connecting.");
      return;
    }
    this.startHeartbeatWatcher(t?.signal);
  }
  async updateClients(e, t) {
    let r = this.clients.map((i) => i.session.sessionId), n = e.map((i) => i.session.sessionId);
    x(r, n) || (this.clients = e, await this.restoreConnection(e, { ...this.connectionOptions, signal: t?.signal }));
  }
  async reconnect(e) {
    try {
      await this.closeGateway();
    } catch (r) {
      s("[BridgeProvider] Error closing gateway:", JSON.stringify(r)), this.errorListener?.(r);
    }
    if (e.aborted) {
      s("[BridgeProvider] Reconnect aborted after closing gateway.");
      return;
    }
    let t = this.connectionOptions;
    await S$1(({ signal: r }) => this.openGateway(this.clients.map((n) => n.session), { lastEventId: this.lastEventId, connectingDeadlineMS: t?.connectingDeadlineMs ?? this.defaultConnectingDeadlineMS, signal: r }), { attempts: Number.MAX_SAFE_INTEGER, delayMs: t?.delayMs ?? this.defaultRetryDelayMs, signal: e, exponential: t?.exponential ?? true, maxDelayMs: t?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async send(e, t, r, n) {
    if (n?.signal?.aborted) {
      s("[BridgeProvider] Send aborted before encryption.");
      return;
    }
    let i = t.encrypt(JSON.stringify(e), hexToByteArray(r)), c = n?.topic ?? ("method" in e ? e.method : void 0);
    await S$1(async ({ signal: l }) => {
      await v$1.sendRequest(this.bridgeUrl, i, t.sessionId, r, { traceId: n?.traceId, topic: c, signal: l, ttl: n?.ttl });
    }, { attempts: n?.attempts ?? Number.MAX_SAFE_INTEGER, delayMs: n?.delayMs ?? this.defaultRetryDelayMs, signal: n?.signal, exponential: n?.exponential ?? true, maxDelayMs: n?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async close() {
    s("[BridgeProvider] Closing provider and gateway..."), await this.closeGateway(), this.stopHeartbeatWatcher(), this.lastEventId = void 0, this.clients = [], s("[BridgeProvider] Closed.");
  }
  listen(e) {
    this.listener = e;
  }
  set onQueueDone(e) {
    this.onQueueDoneCallback = () => {
      try {
        e();
      } catch (t) {
        b$1(`[BridgeProvider] Error during onQueueDone callback: ${JSON.stringify(t)}`, t), this.errorListener?.(t);
      }
    };
  }
  set onConnecting(e) {
    this.onConnectingCallback = () => {
      try {
        e();
      } catch (t) {
        b$1(`[BridgeProvider] Error during onConnecting callback: ${JSON.stringify(t)}`, t), this.errorListener?.(t);
      }
    };
  }
  getCryptoSession(e) {
    let t = this.clients.find(({ clientId: r }) => r === e);
    if (!t) throw new a("Client session does not exist");
    return t.session;
  }
  loadMaybeSource(e, t) {
    if (!t) return;
    let r = I$1(Base64.decode(t).toUint8Array(), hexToByteArray(e.sessionId), hexToByteArray(e.stringifyKeypair().secretKey));
    if (!r) throw new Error("Decrypt error ");
    let n = JSON.parse(new TextDecoder().decode(r));
    return { origin: n.origin, ip: n.ip, time: n.time, userAgent: n.user_agent };
  }
  async gatewayListener(e) {
    if (e.data === this.heartbeatMessage) {
      this.lastHeartbeatAt = Date.now();
      return;
    }
    if (e.data === this.queueEndMessage) {
      this.onQueueDoneCallback?.();
      return;
    }
    s(`[BridgeProvider] Message received. Event ID: ${e.lastEventId}`);
    let t;
    try {
      t = JSON.parse(e.data);
    } catch {
      this.errorListener?.(new a(`Failed to parse message: ${e.data}`));
      return;
    }
    let r = this.getCryptoSession(t.from), n = JSON.parse(r.decrypt(Base64.decode(t.message).toUint8Array(), hexToByteArray(t.from))), i = this.loadMaybeSource(r, t.request_source);
    s("[BridgeProvider] Incoming message decrypted:", n), this.lastEventId = e.lastEventId, this.listener?.({ lastEventId: e.lastEventId, traceId: t.trace_id, ...n, from: t.from, requestSource: i, connectSource: t.connect_source });
  }
  async gatewayErrorsListener(e) {
    if (this.gateway?.isClosed || this.gateway?.isConnecting) {
      let r = p(this.abortController?.signal);
      try {
        return s("[BridgeProvider] Error in gatewayErrorsListener, trying to reconnect:", e), this.onConnectingCallback?.(), this.reconnect(r.signal);
      } catch (n) {
        r.abort(), s("[BridgeProvider] Error in gatewayErrorsListener after reconnect:", n), this.errorListener?.(n);
      }
    }
    let t = new a(`Bridge error ${JSON.stringify(e)}`);
    b$1("[BridgeProvider] Gateway error:", t), this.errorListener?.(t);
  }
  async openGateway(e, t) {
    if (t?.signal?.aborted) {
      s("[BridgeProvider] Open gateway aborted before start.");
      return;
    }
    if (this.gateway && (s("[BridgeProvider] Existing gateway detected. Closing it..."), await this.closeGateway()), s("[BridgeProvider] Creating new BridgeGateway instance..."), t?.signal?.aborted) {
      s("[BridgeProvider] Open gateway aborted after close.");
      return;
    }
    this.gateway = new v$1(this.bridgeUrl, T$1(e.map(({ sessionId: r }) => r)), this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.lastEventId, "message", true), s("[BridgeProvider] BridgeGateway created. Connecting to bridge..."), this.onConnectingCallback?.(), await this.gateway.registerSession({ connectingDeadlineMS: t?.connectingDeadlineMS, signal: t?.signal }), s("[BridgeProvider] Connected to bridge successfully.");
  }
  async closeGateway() {
    this.gateway && (s("[BridgeProvider] Closing previous gateway..."), await this.gateway.close(), this.gateway = null, s("[BridgeProvider] Gateway closed."));
  }
};
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const _state = {};
function v7(options, buf2, offset) {
  let bytes;
  {
    const now = Date.now();
    const rnds = rng();
    updateV7State(_state, now, rnds);
    bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf2, offset);
  }
  return unsafeStringify(bytes);
}
function updateV7State(state, now, rnds) {
  state.msecs ??= -Infinity;
  state.seq ??= 0;
  if (now > state.msecs) {
    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    state.msecs = now;
  } else {
    state.seq = state.seq + 1 | 0;
    if (state.seq === 0) {
      state.msecs++;
    }
  }
  return state;
}
function v7Bytes(rnds, msecs, seq, buf2, offset = 0) {
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  if (!buf2) {
    buf2 = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf2.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
  }
  msecs ??= Date.now();
  seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
  buf2[offset++] = msecs / 1099511627776 & 255;
  buf2[offset++] = msecs / 4294967296 & 255;
  buf2[offset++] = msecs / 16777216 & 255;
  buf2[offset++] = msecs / 65536 & 255;
  buf2[offset++] = msecs / 256 & 255;
  buf2[offset++] = msecs & 255;
  buf2[offset++] = 112 | seq >>> 28 & 15;
  buf2[offset++] = seq >>> 20 & 255;
  buf2[offset++] = 128 | seq >>> 14 & 63;
  buf2[offset++] = seq >>> 6 & 255;
  buf2[offset++] = seq << 2 & 255 | rnds[10] & 3;
  buf2[offset++] = rnds[11];
  buf2[offset++] = rnds[12];
  buf2[offset++] = rnds[13];
  buf2[offset++] = rnds[14];
  buf2[offset++] = rnds[15];
  return buf2;
}
const DEFAULT_DEVICE_INFO = {
  platform: "browser",
  appName: "Wallet",
  appVersion: "1.0.0",
  maxProtocolVersion: 2,
  features: [
    "SendTransaction",
    {
      name: "SendTransaction",
      maxMessages: 1
    }
  ]
};
const DEFAULT_WALLET_INFO = {
  name: "Wallet",
  appName: "Wallet",
  imageUrl: "https://example.com/image.png",
  bridgeUrl: "https://example.com/bridge.png",
  universalLink: "https://example.com/universal-link",
  aboutUrl: "https://example.com/about",
  platforms: ["chrome", "firefox", "safari", "android", "ios", "windows", "macos", "linux"],
  jsBridgeKey: "wallet"
};
function getDeviceInfoWithDefaults(options) {
  const deviceInfo = {
    ...DEFAULT_DEVICE_INFO,
    ...options
  };
  return addLegacySendTransactionFeature(deviceInfo);
}
function createDeviceInfo(options) {
  const infoWithDefaults = getDeviceInfoWithDefaults(options);
  const features = [];
  if (infoWithDefaults.features.some((feature) => typeof feature === "object" && feature.name === "SendTransaction")) {
    const sendTransactionFeature = infoWithDefaults.features.find((feature) => typeof feature === "object" && feature.name === "SendTransaction");
    if (sendTransactionFeature) {
      features.push({
        name: "SendTransaction",
        maxMessages: sendTransactionFeature.maxMessages ?? 1
      });
      features.push("SendTransaction");
    }
  } else if (infoWithDefaults.features.some((feature) => feature === "SendTransaction")) {
    features.push("SendTransaction");
  }
  if (infoWithDefaults.features.some((feature) => typeof feature === "object" && feature.name === "SignData")) {
    const signDataFeature = infoWithDefaults.features.find((feature) => typeof feature === "object" && feature.name === "SignData");
    if (signDataFeature) {
      features.push({
        name: "SignData",
        types: signDataFeature.types
      });
    }
  }
  return infoWithDefaults;
}
function createWalletManifest(options) {
  const walletInfo = getWalletInfoWithDefaults(options);
  return walletInfo;
}
function getWalletInfoWithDefaults(options) {
  const walletInfo = {
    ...DEFAULT_WALLET_INFO,
    ...options
  };
  return walletInfo;
}
function getDeviceInfoForWallet(walletAdapter, deviceInfoOptions) {
  const baseDeviceInfo = getDeviceInfoWithDefaults(deviceInfoOptions);
  if (walletAdapter?.getSupportedFeatures) {
    const adapterFeatures = walletAdapter.getSupportedFeatures();
    const deviceInfo = {
      ...baseDeviceInfo,
      features: adapterFeatures
    };
    return addLegacySendTransactionFeature(deviceInfo);
  }
  return baseDeviceInfo;
}
function addLegacySendTransactionFeature(options) {
  const features = options.features;
  const hasSendTransactionString = features.some((feature) => feature === "SendTransaction");
  const hasSendTransactionObject = features.some((feature) => typeof feature === "object" && feature.name === "SendTransaction");
  const shouldAddString = !hasSendTransactionString && hasSendTransactionObject;
  return {
    ...options,
    features: shouldAddString ? ["SendTransaction", ...features] : features
  };
}
const DEFAULT_REQUEST_TIMEOUT = 3e5;
const RESTORE_CONNECTION_TIMEOUT = 1e4;
const TONCONNECT_BRIDGE_RESPONSE = "TONCONNECT_BRIDGE_RESPONSE";
const TONCONNECT_BRIDGE_EVENT = "TONCONNECT_BRIDGE_EVENT";
globalLogger.createChild("ExtensionTransport");
const log$h = globalLogger.createChild("BridgeManager");
class BridgeManager {
  config;
  bridgeProvider;
  sessionManager;
  storage;
  isConnected = false;
  reconnectAttempts = 0;
  lastEventId;
  storageKey = "bridge_last_event_id";
  walletKitConfig;
  jsBridgeTransport;
  // Event processing queue and concurrency control
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eventQueue = [];
  isProcessing = false;
  // Durable events support
  eventStore;
  eventRouter;
  eventEmitter;
  analytics;
  requestProcessingTimeoutId;
  constructor(walletManifest, config, sessionManager, storage, eventStore, eventRouter, walletKitConfig, eventEmitter, analyticsManager) {
    const isManifestJsBridge = walletManifest && "jsBridgeKey" in walletManifest ? true : false;
    const manifestJsBridgeKey = walletManifest && "jsBridgeKey" in walletManifest ? walletManifest.jsBridgeKey : void 0;
    const manifestBridgeUrl = walletManifest && "bridgeUrl" in walletManifest ? walletManifest.bridgeUrl : void 0;
    this.config = {
      heartbeatInterval: 5e3,
      reconnectInterval: 15e3,
      maxReconnectAttempts: 5,
      ...{
        enableJsBridge: isManifestJsBridge,
        jsBridgeKey: manifestJsBridgeKey,
        bridgeUrl: manifestBridgeUrl
      },
      ...config
    };
    this.sessionManager = sessionManager;
    this.storage = storage;
    this.eventStore = eventStore;
    this.eventEmitter = eventEmitter;
    this.eventRouter = eventRouter;
    this.analytics = analyticsManager?.scoped({
      bridge_url: this.config.bridgeUrl
    });
    this.walletKitConfig = walletKitConfig;
    this.jsBridgeTransport = config?.jsBridgeTransport;
    if (!this.jsBridgeTransport && config?.enableJsBridge) {
      throw new WalletKitError(ERROR_CODES.INVALID_CONFIG, "JS Bridge transport is not configured");
    }
  }
  /**
   * Initialize bridge connection
   */
  async start() {
    if (this.bridgeProvider) {
      log$h.warn("Bridge already initialized");
      return;
    }
    try {
      await this.loadLastEventId();
      if (!this.config?.disableHttpConnection) {
        await this.connectToSSEBridge();
      } else {
        this.isConnected = true;
        this.reconnectAttempts = 0;
      }
    } catch (error2) {
      log$h.error("Failed to start bridge", { error: error2 });
      throw error2;
    }
    const requestProcessing = () => {
      this.processBridgeEvents();
      this.requestProcessingTimeoutId = setTimeout(requestProcessing, 1e3);
    };
    requestProcessing();
  }
  /**
   * Create new session for a dApp connection
   */
  async createSession(appSessionId) {
    log$h.info("[BRIDGE] Creating session", { appSessionId });
    const session = await this.sessionManager.getSession(appSessionId);
    if (!session) {
      throw new WalletKitError(ERROR_CODES.SESSION_NOT_FOUND, `Session not found`, void 0, {
        appSessionId
      });
    }
    if (this.bridgeProvider && this.isConnected) {
      log$h.info("[BRIDGE] Updating clients");
      await this.updateClients();
    }
  }
  /**
   * Remove session
   */
  async removeSession(appSessionId) {
    if (this.bridgeProvider && this.isConnected) {
      await this.updateClients();
    }
    log$h.debug("Session removed", { appSessionId });
  }
  /**
   * Send response to dApp
   */
  async sendResponse(event, response, providedSessionCrypto) {
    if (event.isLocal) {
      return;
    }
    if (event.isJsBridge) {
      return this.sendJsBridgeResponse(event.tabId?.toString() || "", event.isJsBridge, event.messageId ?? null, response, {
        traceId: event?.traceId
      });
    }
    if (!this.bridgeProvider) {
      throw new WalletKitError(ERROR_CODES.BRIDGE_NOT_INITIALIZED, "Bridge not initialized for sending response");
    }
    const sessionId = event.from || event.sessionId;
    if (!sessionId) {
      throw new WalletKitError(ERROR_CODES.SESSION_ID_REQUIRED, "Session ID is required for sending response", void 0, { event: { id: event.id } });
    }
    let sessionCrypto = providedSessionCrypto;
    if (!sessionCrypto) {
      const session = await this.sessionManager.getSession(sessionId);
      if (session) {
        sessionCrypto = new SessionCrypto({
          publicKey: session.publicKey,
          secretKey: session.privateKey
        });
      } else {
        throw new WalletKitError(ERROR_CODES.SESSION_NOT_FOUND, `Session not found for response`, void 0, {
          sessionId,
          eventId: event.id
        });
      }
    }
    try {
      await this.bridgeProvider.send(response, sessionCrypto, sessionId, {
        traceId: event?.traceId
      });
      log$h.debug("Response sent successfully", { sessionId, requestId: event.id });
    } catch (error2) {
      log$h.error("Failed to send response through bridge", {
        sessionId,
        requestId: event.id,
        error: error2
      });
      throw WalletKitError.fromError(ERROR_CODES.BRIDGE_RESPONSE_SEND_FAILED, "Failed to send response through bridge", error2, { sessionId, requestId: event.id });
    }
  }
  async sendJsBridgeResponse(sessionId, _isJsBridge, requestId, response, options) {
    const source = this.config.jsBridgeKey + "-tonconnect";
    const message = {
      type: TONCONNECT_BRIDGE_RESPONSE,
      source,
      messageId: requestId,
      success: true,
      payload: response,
      traceId: options?.traceId
    };
    if (this.jsBridgeTransport) {
      try {
        await this.jsBridgeTransport(sessionId, message);
      } catch (e) {
        console.error("Failed to send response through JS Bridge", { error: e });
      }
    } else {
      throw new WalletKitError(ERROR_CODES.INVALID_CONFIG, "JS Bridge transport is not configured");
    }
  }
  /**
   * Close bridge connection
   */
  async close() {
    if (this.bridgeProvider) {
      await this.bridgeProvider.close();
      this.bridgeProvider = void 0;
    }
    this.eventQueue = [];
    this.isProcessing = false;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    if (this.requestProcessingTimeoutId) {
      clearTimeout(this.requestProcessingTimeoutId);
      this.requestProcessingTimeoutId = void 0;
    }
  }
  /**
   * Get connection status
   */
  isConnectedToBridge() {
    return this.isConnected;
  }
  /**
   * Get active session count
   */
  // getSessionCount(): number {
  //     return this.sessions.size;
  // }
  async getClients() {
    return (await this.sessionManager.getSessions()).map((session) => ({
      session: new SessionCrypto({
        publicKey: session.publicKey,
        secretKey: session.privateKey.length > 64 ? session.privateKey.slice(0, 64) : session.privateKey
      }),
      clientId: session.sessionId
    }));
  }
  /**
   * Connect to TON Connect bridge
   */
  async connectToSSEBridge() {
    if (!this.config.bridgeUrl) {
      return;
    }
    const connectTraceId = v7();
    try {
      const clients = await this.getClients();
      if (clients.length === 0) {
        clients.push({
          clientId: "0",
          session: new SessionCrypto()
        });
      }
      if (this.analytics) {
        const client = clients[0];
        this.analytics.emitBridgeClientConnectStarted({
          trace_id: connectTraceId,
          client_id: client?.clientId
        });
      }
      this.bridgeProvider = await C$1.open({
        bridgeUrl: this.config.bridgeUrl,
        clients,
        listener: this.queueBridgeEvent.bind(this),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        errorListener: (error2) => {
          log$h.error("Bridge listener error", { error: error2.toString() });
          this.analytics?.emitBridgeClientConnectError({
            error_message: `${error2?.toString() || "Unknown error"}${error2?.errorCode ? ` (Code: ${error2?.errorCode})` : ""}`,
            trace_id: error2?.traceId ?? connectTraceId,
            client_id: error2?.clientId
          });
        },
        options: {
          lastEventId: this.lastEventId
          // heartbeatReconnectIntervalMs: this.config.reconnectInterval,
        }
      });
      this.isConnected = true;
      this.reconnectAttempts = 0;
      log$h.info("Bridge connected successfully");
      if (this.analytics) {
        const client = clients[0];
        this.analytics.emitBridgeClientConnectEstablished({
          trace_id: connectTraceId,
          client_id: client?.clientId
        });
      }
    } catch (error2) {
      log$h.error("Bridge connection failed", { error: error2?.toString() });
      this.analytics?.emitBridgeClientConnectError({
        error_message: `${error2?.toString() || "Unknown error"}${error2?.errorCode ? ` (Code: ${error2?.errorCode})` : ""}`,
        trace_id: error2?.traceId ?? connectTraceId,
        client_id: error2?.clientId
      });
      if (!this.config.disableHttpConnection) {
        if (this.reconnectAttempts < (this.config.maxReconnectAttempts || 5)) {
          this.reconnectAttempts++;
          log$h.info("Bridge reconnection attempt", { attempt: this.reconnectAttempts });
          setTimeout(() => {
            this.connectToSSEBridge().catch((error3) => log$h.error("Bridge reconnection failed", { error: error3 }));
          }, this.config.reconnectInterval);
        }
      }
      throw WalletKitError.fromError(ERROR_CODES.BRIDGE_CONNECTION_FAILED, "Failed to connect to bridge", error2, {
        reconnectAttempts: this.reconnectAttempts,
        bridgeUrl: this.config.bridgeUrl
      });
    }
  }
  /**
   * Restart bridge connection in case of error, so we can receive events again
   */
  async restartConnection() {
    await this.close();
    await this.start();
  }
  /**
   * Add client to existing bridge connection
   */
  async updateClients() {
    log$h.debug("Updating clients");
    if (this.bridgeProvider) {
      const clients = await this.getClients();
      log$h.info("[BRIDGE] Restoring connection", { clients: clients.length });
      await this.bridgeProvider.restoreConnection(clients, {
        lastEventId: this.lastEventId
      });
    }
  }
  /**
   * Queue incoming bridge events for processing
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  queueBridgeEvent(event) {
    log$h.debug("Bridge event queued", { eventId: event?.id, event });
    this.eventQueue.push(event);
    this.processBridgeEvents().catch((error2) => {
      log$h.error("Error in background event processing", { error: error2 });
    });
  }
  queueJsBridgeEvent(messageInfo, event) {
    log$h.debug("JS Bridge event queued", { eventId: messageInfo?.messageId });
    if (!event) {
      return;
    }
    if (!event.traceId) {
      event.traceId = v7();
    }
    if (event.method == "connect") {
      this.eventQueue.push({
        ...event,
        isJsBridge: true,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId
      });
    } else if (event.method == "restoreConnection") {
      this.eventEmitter?.emit("restoreConnection", {
        ...event,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId
      });
    } else if (event.method == "send" && event?.params?.length === 1) {
      this.eventQueue.push({
        ...event,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ...event.params[0],
        isJsBridge: true,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId
      });
    }
    this.processBridgeEvents().catch((error2) => {
      log$h.error("Error in background event processing", { error: error2 });
    });
  }
  /**
   * Process events from the queue with concurrency control
   * New events from the bridge added to eventQueue to avoid concurrency
   * processBridgeEvents takes events from queue one by one and tries to store them durably
   * if event stored successfully, we will update lastEventId and proceed to the next event
   * if we've encountered error, bridge connection we be restarted from last success id, so we should try to process same event again
   */
  async processBridgeEvents() {
    if (this.isProcessing) {
      log$h.debug("Event processing already in progress, skipping");
      return;
    }
    this.isProcessing = true;
    try {
      while (this.eventQueue.length > 0) {
        const event = this.eventQueue.shift();
        if (event) {
          event.isLocal = false;
          await this.handleBridgeEvent(event);
        }
      }
    } catch (error2) {
      log$h.error("Error during event processing", { error: error2 });
      this.isProcessing = false;
      this.restartConnection();
      return;
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Handle individual bridge event (original processing logic)
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleBridgeEvent(event) {
    try {
      log$h.info("Bridge event received", { event });
      const rawEvent = {
        id: event.id || crypto.randomUUID(),
        method: event.method || "unknown",
        params: event.params || event,
        // sessionId: event.from,
        timestamp: Date.now(),
        from: event?.from,
        domain: event?.domain,
        isJsBridge: event?.isJsBridge,
        tabId: event?.tabId,
        messageId: event?.messageId,
        traceId: event?.traceId
      };
      if (!rawEvent.traceId) {
        rawEvent.traceId = v7();
      }
      await this.sessionManager.initialize();
      if (rawEvent.from) {
        const session = await this.sessionManager.getSession(rawEvent.from);
        rawEvent.domain = session?.domain || "";
        if (session) {
          if (session?.walletId) {
            rawEvent.walletId = session.walletId;
          }
          if (session?.walletAddress) {
            rawEvent.walletAddress = session.walletAddress;
          }
          rawEvent.dAppInfo = {
            name: session.dAppName,
            description: session.dAppDescription,
            url: session.dAppUrl,
            iconUrl: session.dAppIconUrl
          };
        }
      } else if (rawEvent.domain) {
        const session = await this.sessionManager.getSessionByDomain(rawEvent.domain);
        if (session?.walletId) {
          rawEvent.walletId = session.walletId;
        }
        if (session?.walletAddress) {
          rawEvent.walletAddress = session.walletAddress;
        }
        if (session?.sessionId) {
          rawEvent.from = session.sessionId;
        }
        if (session) {
          rawEvent.dAppInfo = {
            name: session.dAppName,
            description: session.dAppDescription,
            url: session.dAppUrl,
            iconUrl: session.dAppIconUrl
          };
          if (!rawEvent.from) {
            rawEvent.from = session.sessionId;
          }
        }
      }
      if (!this.eventStore) {
        throw new WalletKitError(ERROR_CODES.EVENT_STORE_NOT_INITIALIZED, "Event store is not initialized");
      }
      try {
        await this.eventStore.storeEvent(rawEvent);
        if (this.eventEmitter) {
          this.eventEmitter.emit("bridge-storage-updated");
        }
        log$h.info("Event stored durably", { eventId: rawEvent.id, method: rawEvent.method });
      } catch (error2) {
        log$h.error("Failed to store event durably", {
          eventId: rawEvent.id,
          error: error2.message
        });
        throw WalletKitError.fromError(ERROR_CODES.EVENT_STORE_OPERATION_FAILED, "Failed to store event durably", error2, { eventId: rawEvent.id, method: rawEvent.method });
      }
      log$h.info("Bridge event processed", { rawEvent });
      if (event?.lastEventId && event.lastEventId !== this.lastEventId) {
        this.lastEventId = event.lastEventId;
        await this.saveLastEventId();
      }
    } catch (error2) {
      log$h.error("Error handling bridge event", { error: error2 });
    }
  }
  /**
   * Load last event ID from storage
   */
  async loadLastEventId() {
    try {
      const savedEventId = await this.storage.get(this.storageKey);
      if (savedEventId) {
        this.lastEventId = savedEventId;
        log$h.debug("Loaded last event ID from storage", { lastEventId: this.lastEventId });
      }
    } catch (error2) {
      const storageError = WalletKitError.fromError(ERROR_CODES.STORAGE_READ_FAILED, "Failed to load last event ID from storage", error2);
      log$h.warn("Failed to load last event ID from storage", { error: storageError });
    }
  }
  /**
   * Save last event ID to storage
   */
  async saveLastEventId() {
    try {
      if (this.lastEventId) {
        await this.storage.set(this.storageKey, this.lastEventId);
        log$h.debug("Saved last event ID to storage", { lastEventId: this.lastEventId });
      }
    } catch (error2) {
      const storageError = WalletKitError.fromError(ERROR_CODES.STORAGE_WRITE_FAILED, "Failed to save last event ID to storage", error2);
      log$h.warn("Failed to save last event ID to storage", { error: storageError });
    }
  }
}
class BasicHandler {
  _notifyHandler;
  constructor(notify) {
    this._notifyHandler = notify;
  }
  async notify(event) {
    if (this._notifyHandler) {
      return await this._notifyHandler(event);
    }
    return Promise.resolve();
  }
}
function isValidHost(host) {
  if (host.indexOf(".") === -1)
    return false;
  if (host.startsWith(".") || host.endsWith("."))
    return false;
  const parts = host.split(".");
  return parts.every((part) => part.length > 0);
}
const log$g = globalLogger.createChild("ConnectHandler");
class ConnectHandler extends BasicHandler {
  analytics;
  constructor(notify, analyticsManager) {
    super(notify);
    this.analytics = analyticsManager?.scoped();
  }
  canHandle(event) {
    return event.method === "connect";
  }
  async handle(event) {
    const manifestUrl = this.extractManifestUrl(event);
    let manifest = null;
    let manifestFetchErrorCode = void 0;
    if (manifestUrl) {
      try {
        const result = await this.fetchManifest(manifestUrl);
        manifest = result.manifest;
        manifestFetchErrorCode = result.manifestFetchErrorCode;
      } catch (error2) {
        log$g.warn("Failed to fetch manifest", { error: error2 });
      }
    }
    const preview = this.createPreview(event, manifestUrl, manifest, manifestFetchErrorCode);
    const connectEvent = {
      ...event,
      id: event.id,
      requestedItems: event.params.items ? this.toConnectionRequestEventRequestedItems(event.params.items) : [],
      preview,
      dAppInfo: preview.dAppInfo,
      isJsBridge: event.isJsBridge,
      tabId: event.tabId
    };
    this.analytics?.emitWalletConnectRequestReceived({
      trace_id: event.traceId,
      client_id: event.from,
      manifest_json_url: manifestUrl || preview?.dAppInfo?.manifestUrl,
      is_ton_addr: event.params?.items?.some((item) => item.name === "ton_addr") || false,
      is_ton_proof: event.params?.items?.some((item) => item.name === "ton_proof") || false,
      proof_payload_size: event.params?.items?.some((item) => item.name === "ton_proof") ? event.params?.items?.find((item) => item.name === "ton_proof")?.payload?.length : 0
    });
    return connectEvent;
  }
  toConnectionRequestEventRequestedItems(items) {
    return items.map((item) => {
      if (item.name === "ton_addr") {
        return { type: "ton_addr" };
      } else if (item.name === "ton_proof") {
        return {
          type: "ton_proof",
          value: {
            payload: item.payload
          }
        };
      } else {
        return { type: "unknown", value: item };
      }
    });
  }
  /**
   * Extract dApp name from bridge event or manifest
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractDAppName(event, manifest) {
    const name = manifest?.name || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    event.params?.manifest?.name || "Unknown dApp";
    return name?.toString()?.trim();
  }
  /**
   * Extract manifest URL from bridge event
   */
  extractManifestUrl(event) {
    const url = event.params?.manifest?.url ?? event.params?.manifestUrl ?? "";
    return url.trim();
  }
  /**
   * Create preview object for connect request
   */
  createPreview(event, manifestUrl, fetchedManifest, manifestFetchErrorCode) {
    const eventManifest = event.params?.manifest;
    const manifest = fetchedManifest || eventManifest;
    const dAppUrl = (event?.domain || manifest?.url?.toString() || "").trim();
    let finalManifestFetchErrorCode = manifestFetchErrorCode;
    if (!finalManifestFetchErrorCode && dAppUrl) {
      try {
        const parsedDAppUrl = new URL(dAppUrl);
        if (!isValidHost(parsedDAppUrl.host)) {
          log$g.warn("Invalid dApp URL in manifest - invalid host format", {
            dAppUrl,
            host: parsedDAppUrl.host
          });
          finalManifestFetchErrorCode = CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR;
        }
      } catch (_) {
        log$g.warn("Invalid dApp URL in manifest - failed to parse", { dAppUrl });
        finalManifestFetchErrorCode = CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR;
      }
    }
    const sanitizedManifest = manifest && {
      name: manifest.name?.toString()?.trim() || "",
      description: manifest.description?.toString()?.trim() || "",
      iconUrl: manifest.iconUrl?.toString()?.trim() || ""
    };
    const requestedItems = event.params?.items || [];
    const permissions = [];
    const addrItem = requestedItems.find((item) => item.name === "ton_addr");
    if (addrItem) {
      permissions.push({
        name: "ton_addr",
        title: "TON Address",
        description: "Gives dApp information about your TON address"
      });
    }
    const proofItem = requestedItems.find((item) => item.name === "ton_proof");
    if (proofItem) {
      permissions.push({
        name: "ton_proof",
        title: "TON Proof",
        description: "Gives dApp signature, that can be used to verify your access to private key"
      });
    }
    return {
      permissions,
      dAppInfo: {
        url: dAppUrl,
        name: sanitizedManifest?.name,
        description: sanitizedManifest?.description,
        iconUrl: sanitizedManifest?.iconUrl,
        manifestUrl
      },
      manifestFetchErrorCode: finalManifestFetchErrorCode ?? void 0
    };
  }
  static MANIFEST_PROXY_URL = "https://walletbot.me/tonconnect-proxy/";
  /**
   * Fetch manifest from URL
   */
  async fetchManifest(manifestUrl) {
    try {
      const parsedUrl = new URL(manifestUrl);
      if (!isValidHost(parsedUrl.host)) {
        return {
          manifest: null,
          manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR
        };
      }
    } catch (_) {
      return {
        manifest: null,
        manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR
      };
    }
    const directResult = await this.tryFetchManifest(manifestUrl);
    if (directResult.manifest) {
      return directResult;
    }
    log$g.info("Direct manifest fetch failed, trying proxy", { manifestUrl });
    const proxyUrl = `${ConnectHandler.MANIFEST_PROXY_URL}${manifestUrl}`;
    return this.tryFetchManifest(proxyUrl);
  }
  async tryFetchManifest(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        return {
          manifest: null,
          manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR
        };
      }
      const result = await response.json();
      return {
        manifest: result,
        manifestFetchErrorCode: void 0
      };
    } catch (_) {
      return {
        manifest: null,
        manifestFetchErrorCode: CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR
      };
    }
  }
}
var SendModeBase;
(function(SendModeBase2) {
  SendModeBase2[SendModeBase2["ORDINARY"] = 0] = "ORDINARY";
  SendModeBase2[SendModeBase2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
  SendModeBase2[SendModeBase2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
})(SendModeBase || (SendModeBase = {}));
var SendModeFlag;
(function(SendModeFlag2) {
  SendModeFlag2[SendModeFlag2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
  SendModeFlag2[SendModeFlag2["BOUNCE_IF_FAILURE"] = 16] = "BOUNCE_IF_FAILURE";
  SendModeFlag2[SendModeFlag2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
  SendModeFlag2[SendModeFlag2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
})(SendModeFlag || (SendModeFlag = {}));
function SendModeFromValue(value) {
  let base;
  if (value & SendModeBase.CARRY_ALL_REMAINING_BALANCE) {
    base = SendModeBase.CARRY_ALL_REMAINING_BALANCE;
  } else if (value & SendModeBase.CARRY_ALL_REMAINING_INCOMING_VALUE) {
    base = SendModeBase.CARRY_ALL_REMAINING_INCOMING_VALUE;
  } else {
    base = SendModeBase.ORDINARY;
  }
  const flags = [];
  if (value & SendModeFlag.DESTROY_ACCOUNT_IF_ZERO) {
    flags.push(SendModeFlag.DESTROY_ACCOUNT_IF_ZERO);
  }
  if (value & SendModeFlag.BOUNCE_IF_FAILURE) {
    flags.push(SendModeFlag.BOUNCE_IF_FAILURE);
  }
  if (value & SendModeFlag.IGNORE_ERRORS) {
    flags.push(SendModeFlag.IGNORE_ERRORS);
  }
  if (value & SendModeFlag.PAY_GAS_SEPARATELY) {
    flags.push(SendModeFlag.PAY_GAS_SEPARATELY);
  }
  return { base, flags };
}
function SendModeToValue(sendMode) {
  let value = sendMode.base ?? SendModeBase.ORDINARY;
  for (const flag of sendMode.flags) {
    value |= flag;
  }
  return value;
}
function toExtraCurrencies(extraCurrency) {
  if (!extraCurrency) {
    return void 0;
  }
  return extraCurrency;
}
function toTransactionRequestMessage(msg) {
  asAddressFriendly(msg.address);
  return {
    address: msg.address,
    amount: msg.amount,
    payload: msg.payload ? msg.payload : void 0,
    stateInit: msg.stateInit ? msg.stateInit : void 0,
    extraCurrency: toExtraCurrencies(msg.extraCurrency),
    mode: msg.mode ? SendModeFromValue(msg.mode) : void 0
  };
}
function toConnectTransactionParamMessage(message) {
  return {
    address: message.address,
    amount: message.amount,
    payload: message.payload,
    stateInit: message.stateInit,
    extraCurrency: message.extraCurrency,
    mode: message.mode ? SendModeToValue(message.mode) : void 0
  };
}
function toTransactionRequest(params) {
  return {
    messages: params.messages.map(toTransactionRequestMessage),
    network: params.network ? { chainId: params.network } : void 0,
    validUntil: params.valid_until,
    fromAddress: params.from
  };
}
function toConnectTransactionParamContent(request) {
  return {
    messages: request.messages.map(toConnectTransactionParamMessage),
    network: request.network?.chainId,
    valid_until: request.validUntil,
    from: request.fromAddress
  };
}
function ot(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var T = { exports: {} }, A, v;
function nt() {
  if (v) return A;
  v = 1;
  var t = 1e3, e = t * 60, o4 = e * 60, n = o4 * 24, a2 = n * 7, r = n * 365.25;
  A = function(u, s2) {
    s2 = s2 || {};
    var p2 = typeof u;
    if (p2 === "string" && u.length > 0)
      return d(u);
    if (p2 === "number" && isFinite(u))
      return s2.long ? l(u) : i(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function d(u) {
    if (u = String(u), !(u.length > 100)) {
      var s2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (s2) {
        var p2 = parseFloat(s2[1]), _ = (s2[2] || "ms").toLowerCase();
        switch (_) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p2 * r;
          case "weeks":
          case "week":
          case "w":
            return p2 * a2;
          case "days":
          case "day":
          case "d":
            return p2 * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p2 * o4;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p2 * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p2 * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p2;
          default:
            return;
        }
      }
    }
  }
  function i(u) {
    var s2 = Math.abs(u);
    return s2 >= n ? Math.round(u / n) + "d" : s2 >= o4 ? Math.round(u / o4) + "h" : s2 >= e ? Math.round(u / e) + "m" : s2 >= t ? Math.round(u / t) + "s" : u + "ms";
  }
  function l(u) {
    var s2 = Math.abs(u);
    return s2 >= n ? f2(u, s2, n, "day") : s2 >= o4 ? f2(u, s2, o4, "hour") : s2 >= e ? f2(u, s2, e, "minute") : s2 >= t ? f2(u, s2, t, "second") : u + " ms";
  }
  function f2(u, s2, p2, _) {
    var U2 = s2 >= p2 * 1.5;
    return Math.round(u / p2) + " " + _ + (U2 ? "s" : "");
  }
  return A;
}
function at(t) {
  o4.debug = o4, o4.default = o4, o4.coerce = l, o4.disable = d, o4.enable = a2, o4.enabled = i, o4.humanize = nt(), o4.destroy = f2, Object.keys(t).forEach((u) => {
    o4[u] = t[u];
  }), o4.names = [], o4.skips = [], o4.formatters = {};
  function e(u) {
    let s2 = 0;
    for (let p2 = 0; p2 < u.length; p2++)
      s2 = (s2 << 5) - s2 + u.charCodeAt(p2), s2 |= 0;
    return o4.colors[Math.abs(s2) % o4.colors.length];
  }
  o4.selectColor = e;
  function o4(u) {
    let s2, p2 = null, _, U2;
    function y2(...h2) {
      if (!y2.enabled)
        return;
      const c = y2, B2 = Number(/* @__PURE__ */ new Date()), P2 = B2 - (s2 || B2);
      c.diff = P2, c.prev = s2, c.curr = B2, s2 = B2, h2[0] = o4.coerce(h2[0]), typeof h2[0] != "string" && h2.unshift("%O");
      let k2 = 0;
      h2[0] = h2[0].replace(/%([a-zA-Z%])/g, (E2, tt) => {
        if (E2 === "%%")
          return "%";
        k2++;
        const L = o4.formatters[tt];
        if (typeof L == "function") {
          const et = h2[k2];
          E2 = L.call(c, et), h2.splice(k2, 1), k2--;
        }
        return E2;
      }), o4.formatArgs.call(c, h2), (c.log || o4.log).apply(c, h2);
    }
    return y2.namespace = u, y2.useColors = o4.useColors(), y2.color = o4.selectColor(u), y2.extend = n, y2.destroy = o4.destroy, Object.defineProperty(y2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => p2 !== null ? p2 : (_ !== o4.namespaces && (_ = o4.namespaces, U2 = o4.enabled(u)), U2),
      set: (h2) => {
        p2 = h2;
      }
    }), typeof o4.init == "function" && o4.init(y2), y2;
  }
  function n(u, s2) {
    const p2 = o4(this.namespace + (typeof s2 > "u" ? ":" : s2) + u);
    return p2.log = this.log, p2;
  }
  function a2(u) {
    o4.save(u), o4.namespaces = u, o4.names = [], o4.skips = [];
    const s2 = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const p2 of s2)
      p2[0] === "-" ? o4.skips.push(p2.slice(1)) : o4.names.push(p2);
  }
  function r(u, s2) {
    let p2 = 0, _ = 0, U2 = -1, y2 = 0;
    for (; p2 < u.length; )
      if (_ < s2.length && (s2[_] === u[p2] || s2[_] === "*"))
        s2[_] === "*" ? (U2 = _, y2 = p2, _++) : (p2++, _++);
      else if (U2 !== -1)
        _ = U2 + 1, y2++, p2 = y2;
      else
        return false;
    for (; _ < s2.length && s2[_] === "*"; )
      _++;
    return _ === s2.length;
  }
  function d() {
    const u = [
      ...o4.names,
      ...o4.skips.map((s2) => "-" + s2)
    ].join(",");
    return o4.enable(""), u;
  }
  function i(u) {
    for (const s2 of o4.skips)
      if (r(u, s2))
        return false;
    for (const s2 of o4.names)
      if (r(u, s2))
        return true;
    return false;
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function f2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return o4.enable(o4.load()), o4;
}
var rt = at;
(function(t, e) {
  e.formatArgs = n, e.save = a2, e.load = r, e.useColors = o4, e.storage = d(), e.destroy = /* @__PURE__ */ (() => {
    let l = false;
    return () => {
      l || (l = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function o4() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const f2 = "color: " + this.color;
    l.splice(1, 0, f2, "color: inherit");
    let u = 0, s2 = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p2) => {
      p2 !== "%%" && (u++, p2 === "%c" && (s2 = u));
    }), l.splice(s2, 0, f2);
  }
  e.log = console.debug || console.log || (() => {
  });
  function a2(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function r() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function d() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = rt(e);
  const { formatters: i } = t.exports;
  i.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (f2) {
      return "[UnexpectedJSONParseError]: " + f2.message;
    }
  };
})(T, T.exports);
var dt = T.exports;
const $ = /* @__PURE__ */ ot(dt);
function g(t) {
  return t.toString(2).length;
}
function C(t) {
  if (t.remainingBits >= 1)
    return {
      kind: "Bool",
      value: t.loadUint(1) == 1
    };
  throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}
function b(t) {
  let e = t.loadUint(8), o4 = Array.from(Array(e).keys()).map((n) => t.loadUint(8));
  return {
    kind: "FixedLengthText",
    n: e,
    value: o4
  };
}
function m(t, e) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "Maybe_nothing"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "Maybe_just",
      value: e(t)
    };
  throw new Error('Expected one of "Maybe_nothing", "Maybe_just" in loading "Maybe", but data does not satisfy any constructor');
}
function S(t, e, o4) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "Either_left",
      value: e(t)
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "Either_right",
      value: o4(t)
    };
  throw new Error('Expected one of "Either_left", "Either_right" in loading "Either", but data does not satisfy any constructor');
}
function w(t) {
  return {
    kind: "JettonPayload",
    data: t.asCell()
  };
}
function N(t) {
  return {
    kind: "NFTPayload",
    data: t.asCell()
  };
}
function H(t) {
  return {
    kind: "Bytes",
    data: t.asCell()
  };
}
function R(t) {
  return {
    kind: "Text"
  };
}
function it(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 18516)
    return t.loadUint(16), {
      kind: "Protocol"
    };
  throw new Error('Expected one of "Protocol" in loading "Protocol", but data does not satisfy any constructor');
}
function K(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "ProtoList_proto_list_nil"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1) {
    t.loadUint(1);
    let e = it(t), o4 = K(t);
    return {
      kind: "ProtoList_proto_list_next",
      head: e,
      tail: o4
    };
  }
  throw new Error('Expected one of "ProtoList_proto_list_nil", "ProtoList_proto_list_next" in loading "ProtoList", but data does not satisfy any constructor');
}
function lt(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 8567)
    return t.loadUint(16), {
      kind: "SmcCapability"
    };
  throw new Error('Expected one of "SmcCapability" in loading "SmcCapability", but data does not satisfy any constructor');
}
function z(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "SmcCapList_cap_list_nil"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1) {
    t.loadUint(1);
    let e = lt(t), o4 = z(t);
    return {
      kind: "SmcCapList_cap_list_next",
      head: e,
      tail: o4
    };
  }
  throw new Error('Expected one of "SmcCapList_cap_list_nil", "SmcCapList_cap_list_next" in loading "SmcCapList", but data does not satisfy any constructor');
}
function st(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 40915) {
    t.loadUint(16);
    let e = t.loadAddress(), o4 = t.loadUint(8), n = o4 & 1 ? z(t) : void 0;
    if (!(o4 <= 1))
      throw new Error('Condition (flags <= 1) is not satisfied while loading "DNSRecord_dns_smc_address" for type "DNSRecord"');
    return {
      kind: "DNSRecord_dns_smc_address",
      smc_addr: e,
      flags: o4,
      cap_list: n
    };
  }
  if (t.remainingBits >= 16 && t.preloadUint(16) == 47763)
    return t.loadUint(16), {
      kind: "DNSRecord_dns_next_resolver",
      resolver: t.loadAddress()
    };
  if (t.remainingBits >= 16 && t.preloadUint(16) == 44289) {
    t.loadUint(16);
    let e = t.loadBuffer(256 / 8), o4 = t.loadUint(8), n = o4 & 1 ? K(t) : void 0;
    if (!(o4 <= 1))
      throw new Error('Condition (flags <= 1) is not satisfied while loading "DNSRecord_dns_adnl_address" for type "DNSRecord"');
    return {
      kind: "DNSRecord_dns_adnl_address",
      adnl_addr: e,
      flags: o4,
      proto_list: n
    };
  }
  if (t.remainingBits >= 16 && t.preloadUint(16) == 29811)
    return t.loadUint(16), {
      kind: "DNSRecord_dns_storage_address",
      bag_id: t.loadBuffer(256 / 8)
    };
  throw new Error('Expected one of "DNSRecord_dns_smc_address", "DNSRecord_dns_next_resolver", "DNSRecord_dns_adnl_address", "DNSRecord_dns_storage_address" in loading "DNSRecord", but data does not satisfy any constructor');
}
function ut(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1112786133) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = m(t, (a2) => a2.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoStake",
      query_id: e,
      forward_ton_amount: o4,
      forward_payload: n
    };
  }
  throw new Error('Expected one of "BemoStake" in loading "BemoStake", but data does not satisfy any constructor');
}
function ft(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1227534771) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a2 = t.loadVarUintBig(g(15)), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoUnstake",
      index: e,
      owner: o4,
      ton_amount: n,
      jetton_amount: a2,
      forward_payload: r
    };
  }
  throw new Error('Expected one of "BemoUnstake" in loading "BemoUnstake", but data does not satisfy any constructor');
}
function pt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 279039605) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a2 = t.loadVarUintBig(g(15)), r = m(t, (i) => i.loadRef().beginParse(true).asCell()), d = t.loadUint(32);
    return {
      kind: "BemoDeployUnstakeRequest",
      query_id: e,
      owner_address: o4,
      withdraw_ton_amount: n,
      withdraw_jetton_amount: a2,
      forward_payload: r,
      lockup_timestamp: d
    };
  }
  throw new Error('Expected one of "BemoDeployUnstakeRequest" in loading "BemoDeployUnstakeRequest", but data does not satisfy any constructor');
}
function mt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2429028871) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoUnstakeNotification",
      query_id: e,
      forward_payload: o4
    };
  }
  throw new Error('Expected one of "BemoUnstakeNotification" in loading "BemoUnstakeNotification", but data does not satisfy any constructor');
}
function gt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 946025784)
    return t.loadUint(32), {
      kind: "BemoReturnUnstakeRequest",
      lockup_timestamp: t.loadUint(32)
    };
  throw new Error('Expected one of "BemoReturnUnstakeRequest" in loading "BemoReturnUnstakeRequest", but data does not satisfy any constructor');
}
function _t(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1544662441)
    return t.loadUint(32), {
      kind: "DaolamaVaultSupply",
      amount: t.loadCoins()
    };
  throw new Error('Expected one of "DaolamaVaultSupply" in loading "DaolamaVaultSupply", but data does not satisfy any constructor');
}
function yt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2078119902) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "DaolamaVaultWithdraw",
      jetton_amount: e,
      user_address: o4
    };
  }
  throw new Error('Expected one of "DaolamaVaultWithdraw" in loading "DaolamaVaultWithdraw", but data does not satisfy any constructor');
}
function V(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function Ut(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3043726744) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = t.loadAddressAny(), r = t.loadVarUintBig(g(15)), d = t.loadRef().beginParse(true), i = V(d), l = d.loadVarUintBig(g(15)), f2 = V(d), u = d.loadVarUintBig(g(15)), s2 = m(t, (_) => _.loadRef().beginParse(true).asCell()), p2 = m(t, (_) => _.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustDepositLiquidityAll",
      query_id: e,
      proof: n,
      owner_addr: a2,
      min_lp_amount: r,
      asset0: i,
      asset0_amount: l,
      asset1: f2,
      asset1_amount: u,
      fulfill_payload: s2,
      reject_payload: p2
    };
  }
  throw new Error('Expected one of "DedustDepositLiquidityAll" in loading "DedustDepositLiquidityAll", but data does not satisfy any constructor');
}
function ht(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o4,
    referral_addr: n,
    fulfill_payload: a2,
    reject_payload: r
  };
}
function Q(t) {
  let e = C(t), o4 = t.loadVarUintBig(g(15)), n = m(t, (a2) => {
    let r = a2.loadRef().beginParse(true);
    return Ct(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o4,
    next: n
  };
}
function Ct(t) {
  let e = t.loadAddressAny(), o4 = Q(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o4
  };
}
function ct(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1643009069) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = t.loadVarUintBig(g(15)), r = t.loadAddressAny(), d = Q(t), i = t.loadRef().beginParse(true), l = ht(i);
    return {
      kind: "DedustSwapExternal",
      query_id: e,
      proof: n,
      amount: a2,
      sender_addr: r,
      current: d,
      swap_params: l
    };
  }
  throw new Error('Expected one of "DedustSwapExternal" in loading "DedustSwapExternal", but data does not satisfy any constructor');
}
function wt(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function kt(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o4,
    referral_addr: n,
    fulfill_payload: a2,
    reject_payload: r
  };
}
function Z(t) {
  let e = C(t), o4 = t.loadVarUintBig(g(15)), n = m(t, (a2) => {
    let r = a2.loadRef().beginParse(true);
    return St(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o4,
    next: n
  };
}
function St(t) {
  let e = t.loadAddressAny(), o4 = Z(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o4
  };
}
function Bt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1923917994) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = wt(t), r = t.loadVarUintBig(g(15)), d = t.loadAddressAny(), i = Z(t), l = t.loadRef().beginParse(true), f2 = kt(l);
    return {
      kind: "DedustSwapPeer",
      query_id: e,
      proof: n,
      asset: a2,
      amount: r,
      sender_addr: d,
      current: i,
      swap_params: f2
    };
  }
  throw new Error('Expected one of "DedustSwapPeer" in loading "DedustSwapPeer", but data does not satisfy any constructor');
}
function xt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2907617013) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = t.loadVarUintBig(g(15)), r = t.loadAddressAny(), d = m(t, (i) => i.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustPayoutFromPool",
      query_id: e,
      proof: n,
      amount: a2,
      recipient_addr: r,
      payload: d
    };
  }
  throw new Error('Expected one of "DedustPayoutFromPool" in loading "DedustPayoutFromPool", but data does not satisfy any constructor');
}
function bt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1196394191) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustPayout",
      query_id: e,
      payload: o4
    };
  }
  throw new Error('Expected one of "DedustPayout" in loading "DedustPayout", but data does not satisfy any constructor');
}
function Nt(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o4,
    referral_addr: n,
    fulfill_payload: a2,
    reject_payload: r
  };
}
function Pt(t) {
  let e = C(t), o4 = t.loadVarUintBig(g(15)), n = m(t, (a2) => {
    let r = a2.loadRef().beginParse(true);
    return X(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o4,
    next: n
  };
}
function X(t) {
  let e = t.loadAddressAny(), o4 = Pt(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o4
  };
}
function Et(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3926267997) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = X(t), a2 = t.loadRef().beginParse(true), r = Nt(a2);
    return {
      kind: "DedustSwap",
      query_id: e,
      amount: o4,
      step: n,
      swap_params: r
    };
  }
  throw new Error('Expected one of "DedustSwap" in loading "DedustSwap", but data does not satisfy any constructor');
}
function F(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function At(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "DedustPoolType_volatile"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "DedustPoolType_stable"
    };
  throw new Error('Expected one of "DedustPoolType_volatile", "DedustPoolType_stable" in loading "DedustPoolType", but data does not satisfy any constructor');
}
function Tt(t) {
  let e = At(t), o4 = F(t), n = F(t);
  return {
    kind: "DedustPoolParams",
    pool_type: e,
    asset0: o4,
    asset1: n
  };
}
function Dt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3579725446) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = Tt(t), a2 = t.loadRef().beginParse(true), r = a2.loadCoins(), d = a2.loadCoins(), i = a2.loadCoins(), l = m(t, (u) => u.loadRef().beginParse(true).asCell()), f2 = m(t, (u) => u.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustDepositLiquidity",
      query_id: e,
      amount: o4,
      pool_params: n,
      min_lp_amount: r,
      asset0_target_balance: d,
      asset1_target_balance: i,
      fulfill_payload: l,
      reject_payload: f2
    };
  }
  throw new Error('Expected one of "DedustDepositLiquidity" in loading "DedustDepositLiquidity", but data does not satisfy any constructor');
}
function Rt(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function qt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 567271467) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = Rt(t);
    return {
      kind: "DedustCreateVault",
      query_id: e,
      asset: o4
    };
  }
  throw new Error('Expected one of "DedustCreateVault" in loading "DedustCreateVault", but data does not satisfy any constructor');
}
function W(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function Lt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2547326767) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = W(t), n = W(t);
    return {
      kind: "DedustCreateVolatilePool",
      query_id: e,
      asset0: o4,
      asset1: n
    };
  }
  throw new Error('Expected one of "DedustCreateVolatilePool" in loading "DedustCreateVolatilePool", but data does not satisfy any constructor');
}
function vt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 376237550) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustCancelDeposit",
      query_id: e,
      payload: o4
    };
  }
  throw new Error('Expected one of "DedustCancelDeposit" in loading "DedustCancelDeposit", but data does not satisfy any constructor');
}
function Vt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1322339173)
    return t.loadUint(32), {
      kind: "DnsBalanceRelease",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "DnsBalanceRelease" in loading "DnsBalanceRelease", but data does not satisfy any constructor');
}
function Ft(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1320284409) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DeleteDnsRecord",
      query_id: e,
      key: o4
    };
  }
  throw new Error('Expected one of "DeleteDnsRecord" in loading "DeleteDnsRecord", but data does not satisfy any constructor');
}
function Wt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1320284409) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8), n = t.loadRef().beginParse(true), a2 = st(n);
    return {
      kind: "ChangeDnsRecord",
      query_id: e,
      key: o4,
      value: a2
    };
  }
  throw new Error('Expected one of "ChangeDnsRecord" in loading "ChangeDnsRecord", but data does not satisfy any constructor');
}
function Jt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1153347137)
    return t.loadUint(32), {
      kind: "ProcessGovernanceDecision",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ProcessGovernanceDecision" in loading "ProcessGovernanceDecision", but data does not satisfy any constructor');
}
function It(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 923790417)
    return t.loadUint(32), {
      kind: "AuctionFillUp",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "AuctionFillUp" in loading "AuctionFillUp", but data does not satisfy any constructor');
}
function Ot(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1434249760)
    return t.loadUint(32), {
      kind: "OutbidNotification",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "OutbidNotification" in loading "OutbidNotification", but data does not satisfy any constructor');
}
function Mt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1298755173) {
    t.loadUint(32);
    let e = t.loadUint(8), o4 = t.loadUint(32), n = t.loadBuffer(256 / 8), a2 = t.loadBuffer(256 / 8), r = t.loadUintBig(128), d = t.loadBuffer(256 / 8);
    return {
      kind: "GramSubmitProofOfWork",
      flags: e,
      expire: o4,
      whom: n,
      rdata1: a2,
      rseed: r,
      rdata2: d
    };
  }
  throw new Error('Expected one of "GramSubmitProofOfWork" in loading "GramSubmitProofOfWork", but data does not satisfy any constructor');
}
function jt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1027039654) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a2 = t.loadVarUintBig(g(15)), r = t.loadAddressAny();
    return {
      kind: "HipoFinanceDepositCoins",
      query_id: e,
      owner: o4,
      coins: n,
      ownership_assigned_amount: a2,
      referrer: r
    };
  }
  throw new Error('Expected one of "HipoFinanceDepositCoins" in loading "HipoFinanceDepositCoins", but data does not satisfy any constructor');
}
function Gt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1541764646) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a2 = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "HipoFinanceProxyTokensMinted",
      query_id: e,
      tokens: o4,
      coins: n,
      owner: a2,
      round_since: r
    };
  }
  throw new Error('Expected one of "HipoFinanceProxyTokensMinted" in loading "HipoFinanceProxyTokensMinted", but data does not satisfy any constructor');
}
function $t(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1413869550) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a2 = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "HipoFinanceTokensMinted",
      query_id: e,
      tokens: o4,
      coins: n,
      owner: a2,
      round_since: r
    };
  }
  throw new Error('Expected one of "HipoFinanceTokensMinted" in loading "HipoFinanceTokensMinted", but data does not satisfy any constructor');
}
function Ht(t) {
  if (t.remainingBits >= 8 && t.preloadUint(8) == 0)
    return t.loadUint(8), {
      kind: "PaymentProviderUrl_none"
    };
  if (t.remainingBits >= 8 && t.preloadUint(8) == 1)
    return t.loadUint(8), {
      kind: "PaymentProviderUrl_tonsite",
      address: t.loadBuffer(256 / 8)
    };
  throw new Error('Expected one of "PaymentProviderUrl_none", "PaymentProviderUrl_tonsite" in loading "PaymentProviderUrl", but data does not satisfy any constructor');
}
function Kt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2057453237) {
    t.loadUint(32);
    let e = t.loadBuffer(128 / 8), o4 = Ht(t);
    return {
      kind: "InvoicePayload",
      id: e,
      url: o4
    };
  }
  throw new Error('Expected one of "InvoicePayload" in loading "InvoicePayload", but data does not satisfy any constructor');
}
function zt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 260734629) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = m(t, (l) => l.loadRef().beginParse(true).asCell()), d = t.loadVarUintBig(g(15)), i = S(t, w, (l) => {
      let f2 = l.loadRef().beginParse(true);
      return w(f2);
    });
    return {
      kind: "JettonTransfer",
      query_id: e,
      amount: o4,
      destination: n,
      response_destination: a2,
      custom_payload: r,
      forward_ton_amount: d,
      forward_payload: i
    };
  }
  throw new Error('Expected one of "JettonTransfer" in loading "JettonTransfer", but data does not satisfy any constructor');
}
function Qt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 395134233) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = t.loadVarUintBig(g(15)), d = S(t, w, (i) => {
      let l = i.loadRef().beginParse(true);
      return w(l);
    });
    return {
      kind: "JettonInternalTransfer",
      query_id: e,
      amount: o4,
      from: n,
      response_address: a2,
      forward_ton_amount: r,
      forward_payload: d
    };
  }
  throw new Error('Expected one of "JettonInternalTransfer" in loading "JettonInternalTransfer", but data does not satisfy any constructor');
}
function Zt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1499400124) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = m(t, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonBurn",
      query_id: e,
      amount: o4,
      response_destination: n,
      custom_payload: a2
    };
  }
  throw new Error('Expected one of "JettonBurn" in loading "JettonBurn", but data does not satisfy any constructor');
}
function Xt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2078119902) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny();
    return {
      kind: "JettonBurnNotification",
      query_id: e,
      amount: o4,
      sender: n,
      response_destination: a2
    };
  }
  throw new Error('Expected one of "JettonBurnNotification" in loading "JettonBurnNotification", but data does not satisfy any constructor');
}
function Yt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1935855772) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = S(t, w, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonNotify",
      query_id: e,
      amount: o4,
      sender: n,
      forward_payload: a2
    };
  }
  throw new Error('Expected one of "JettonNotify" in loading "JettonNotify", but data does not satisfy any constructor');
}
function te(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4006754003) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(4);
    return {
      kind: "JettonSetStatus",
      query_id: e,
      status: o4
    };
  }
  throw new Error('Expected one of "JettonSetStatus" in loading "JettonSetStatus", but data does not satisfy any constructor');
}
function ee(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1680571655) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddress(), n = t.loadCoins();
    return {
      kind: "JettonMint",
      query_id: e,
      to_address: o4,
      ton_amount: n
    };
  }
  throw new Error('Expected one of "JettonMint" in loading "JettonMint", but data does not satisfy any constructor');
}
function oe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1694626644) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny();
    return {
      kind: "JettonChangeAdmin",
      query_id: e,
      new_admin_address: o4
    };
  }
  throw new Error('Expected one of "JettonChangeAdmin" in loading "JettonChangeAdmin", but data does not satisfy any constructor');
}
function ne(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4220051737)
    return t.loadUint(32), {
      kind: "JettonClaimAdmin",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "JettonClaimAdmin" in loading "JettonClaimAdmin", but data does not satisfy any constructor');
}
function ae(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4006754003) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(4);
    return {
      kind: "JettonForceAction_set_status",
      query_id: e,
      status: o4
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1499400124) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = m(t, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonForceAction_burn",
      query_id: e,
      amount: o4,
      response_destination: n,
      custom_payload: a2
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 260734629) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = m(t, (l) => l.loadRef().beginParse(true).asCell()), d = t.loadVarUintBig(g(15)), i = S(t, w, (l) => {
      let f2 = l.loadRef().beginParse(true);
      return w(f2);
    });
    return {
      kind: "JettonForceAction_transfer",
      query_id: e,
      amount: o4,
      destination: n,
      response_destination: a2,
      custom_payload: r,
      forward_ton_amount: d,
      forward_payload: i
    };
  }
  throw new Error('Expected one of "JettonForceAction_set_status", "JettonForceAction_burn", "JettonForceAction_transfer" in loading "JettonForceAction", but data does not satisfy any constructor');
}
function re(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 593276754) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddress(), n = t.loadCoins(), a2 = t.loadRef().beginParse(true), r = ae(a2);
    return {
      kind: "JettonCallTo",
      query_id: e,
      to_address: o4,
      ton_amount: n,
      master_msg: r
    };
  }
  throw new Error('Expected one of "JettonCallTo" in loading "JettonCallTo", but data does not satisfy any constructor');
}
function de(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 621336170) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), r = t.loadRef().beginParse(true).asCell();
    return {
      kind: "JettonUpgrade",
      query_id: e,
      new_data: n,
      new_code: r
    };
  }
  throw new Error('Expected one of "JettonUpgrade" in loading "JettonUpgrade", but data does not satisfy any constructor');
}
function ie(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3414567170) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "JettonChangeMetadata",
      query_id: e,
      metadata: o4
    };
  }
  throw new Error('Expected one of "JettonChangeMetadata" in loading "JettonChangeMetadata", but data does not satisfy any constructor');
}
function le(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4294967295)
    return t.loadUint(32), {
      kind: "Bounce",
      payload: t.asCell()
    };
  throw new Error('Expected one of "Bounce" in loading "Bounce", but data does not satisfy any constructor');
}
function se(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 0)
    return t.loadUint(32), {
      kind: "TextComment",
      text: R()
    };
  throw new Error('Expected one of "TextComment" in loading "TextComment", but data does not satisfy any constructor');
}
function ue(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 560454219)
    return t.loadUint(32), {
      kind: "EncryptedTextComment",
      cipher_text: H(t)
    };
  throw new Error('Expected one of "EncryptedTextComment" in loading "EncryptedTextComment", but data does not satisfy any constructor');
}
function fe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3576854235)
    return t.loadUint(32), {
      kind: "Excess",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Excess" in loading "Excess", but data does not satisfy any constructor');
}
function pe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3547469196)
    return t.loadUint(32), {
      kind: "TopUp",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TopUp" in loading "TopUp", but data does not satisfy any constructor');
}
function me(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 378586628) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "Credit",
      query_id: e,
      amount: o4
    };
  }
  throw new Error('Expected one of "Credit" in loading "Credit", but data does not satisfy any constructor');
}
function ge(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2068529894)
    return t.loadUint(32), {
      kind: "Approve",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Approve" in loading "Approve", but data does not satisfy any constructor');
}
function _e(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3902843902)
    return t.loadUint(32), {
      kind: "Disapprove",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Disapprove" in loading "Disapprove", but data does not satisfy any constructor');
}
function ye(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1316189259) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8), n = t.loadUint(32), a2 = t.loadUint(32), r = t.loadBuffer(256 / 8), i = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "ElectorNewStake",
      query_id: e,
      validator_pubkey: o4,
      stake_at: n,
      max_factor: a2,
      adnl_addr: r,
      signature: i
    };
  }
  throw new Error('Expected one of "ElectorNewStake" in loading "ElectorNewStake", but data does not satisfy any constructor');
}
function Ue(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4084484172)
    return t.loadUint(32), {
      kind: "ElectorNewStakeConfirmation",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorNewStakeConfirmation" in loading "ElectorNewStakeConfirmation", but data does not satisfy any constructor');
}
function he(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1197831204)
    return t.loadUint(32), {
      kind: "ElectorRecoverStakeRequest",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorRecoverStakeRequest" in loading "ElectorRecoverStakeRequest", but data does not satisfy any constructor');
}
function Ce(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4184830756)
    return t.loadUint(32), {
      kind: "ElectorRecoverStakeResponse",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorRecoverStakeResponse" in loading "ElectorRecoverStakeResponse", but data does not satisfy any constructor');
}
function ce(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3946265093)
    return t.loadUint(32), {
      kind: "TonstakeControllerRecoverStake",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerRecoverStake" in loading "TonstakeControllerRecoverStake", but data does not satisfy any constructor');
}
function we(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4043121232)
    return t.loadUint(32), {
      kind: "TonstakeControllerUpdateValidatorHash",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerUpdateValidatorHash" in loading "TonstakeControllerUpdateValidatorHash", but data does not satisfy any constructor');
}
function ke(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2399065977) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "TonstakeControllerWithdrawValidator",
      query_id: e,
      value: o4
    };
  }
  throw new Error('Expected one of "TonstakeControllerWithdrawValidator" in loading "TonstakeControllerWithdrawValidator", but data does not satisfy any constructor');
}
function Se(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 805462823) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "TonstakeControllerValidatorWithdrawal",
      query_id: e,
      amount: o4
    };
  }
  throw new Error('Expected one of "TonstakeControllerValidatorWithdrawal" in loading "TonstakeControllerValidatorWithdrawal", but data does not satisfy any constructor');
}
function Be(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3763363086) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadUintBig(256), a2 = t.loadUint(32), r = t.loadUint(32), d = t.loadUintBig(256), l = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "TonstakeControllerNewStake",
      query_id: e,
      value: o4,
      validator_pubkey: n,
      stake_at: a2,
      max_factor: r,
      adnl_addr: d,
      signature: l
    };
  }
  throw new Error('Expected one of "TonstakeControllerNewStake" in loading "TonstakeControllerNewStake", but data does not satisfy any constructor');
}
function xe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1664463130) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(24);
    return {
      kind: "TonstakeControllerSendRequestLoan",
      query_id: e,
      min_loan: o4,
      max_loan: n,
      max_interst: a2
    };
  }
  throw new Error('Expected one of "TonstakeControllerSendRequestLoan" in loading "TonstakeControllerSendRequestLoan", but data does not satisfy any constructor');
}
function be(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3983767718)
    return t.loadUint(32), {
      kind: "TonstakeControllerReturnUnusedLoan",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerReturnUnusedLoan" in loading "TonstakeControllerReturnUnusedLoan", but data does not satisfy any constructor');
}
function Ne(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1438805205)
    return t.loadUint(32), {
      kind: "TonstakeControllerReturnAvailableFunds",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerReturnAvailableFunds" in loading "TonstakeControllerReturnAvailableFunds", but data does not satisfy any constructor');
}
function Pe(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = t.loadRef().beginParse(true), d = r.loadAddressAny(), i = r.loadAddressAny();
  return {
    kind: "TonstakersControllerData",
    controller_id: e,
    validator: o4,
    pool: n,
    governor: a2,
    approver: d,
    halter: i
  };
}
function Ee(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3863136613) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(24), r = t.loadRef().beginParse(true), d = Pe(r);
    return {
      kind: "TonstakePoolRequestLoan",
      query_id: e,
      min_loan: o4,
      max_loan: n,
      max_interest: a2,
      controller_data: d
    };
  }
  throw new Error('Expected one of "TonstakePoolRequestLoan" in loading "TonstakePoolRequestLoan", but data does not satisfy any constructor');
}
function Ae(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3755778683)
    return t.loadUint(32), {
      kind: "TonstakePoolLoanRepayment",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolLoanRepayment" in loading "TonstakePoolLoanRepayment", but data does not satisfy any constructor');
}
function Te$1(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1205158801) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "TonstakePoolDeposit",
      query_id: e,
      referral: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolDeposit" in loading "TonstakePoolDeposit", but data does not satisfy any constructor');
}
function De(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1271382751)
    return t.loadUint(32), {
      kind: "TonstakePoolTouch",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolTouch" in loading "TonstakePoolTouch", but data does not satisfy any constructor');
}
function Re(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 715822752) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(16);
    return {
      kind: "TonstakePoolSetGovernanceFee",
      query_id: e,
      governance_fee: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolSetGovernanceFee" in loading "TonstakePoolSetGovernanceFee", but data does not satisfy any constructor');
}
function qe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 832244956) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny(), a2 = t.loadAddressAny();
    return {
      kind: "TonstakePoolWithdraw",
      query_id: e,
      jetton_amount: o4,
      from_address: n,
      response_address: a2
    };
  }
  throw new Error('Expected one of "TonstakePoolWithdraw" in loading "TonstakePoolWithdraw", but data does not satisfy any constructor');
}
function Le(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 175592284)
    return t.loadUint(32), {
      kind: "TonstakePoolWithdrawal",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolWithdrawal" in loading "TonstakePoolWithdrawal", but data does not satisfy any constructor');
}
function ve(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1582399286) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (r) => r.loadAddressAny()), n = m(t, (r) => r.loadAddressAny()), a2 = m(t, (r) => r.loadAddressAny());
    return {
      kind: "TonstakePoolSetRoles",
      query_id: e,
      governor: o4,
      interest_manager: n,
      halter: a2
    };
  }
  throw new Error('Expected one of "TonstakePoolSetRoles" in loading "TonstakePoolSetRoles", but data does not satisfy any constructor');
}
function Ve(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2616546844) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = C(t), n = C(t);
    return {
      kind: "TonstakePoolSetDepositSettings",
      query_id: e,
      optimistic_deposit_withdrawals: o4,
      deposits_open: n
    };
  }
  throw new Error('Expected one of "TonstakePoolSetDepositSettings" in loading "TonstakePoolSetDepositSettings", but data does not satisfy any constructor');
}
function Fe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2994658477) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64);
    return {
      kind: "TonstakePoolDeployController",
      controller_id: e,
      query_id: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolDeployController" in loading "TonstakePoolDeployController", but data does not satisfy any constructor');
}
function We(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2574354460) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(48);
    return {
      kind: "TonstakePoolPrepareGovernanceMigration",
      query_id: e,
      governor_update_after: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolPrepareGovernanceMigration" in loading "TonstakePoolPrepareGovernanceMigration", but data does not satisfy any constructor');
}
function Je(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 654743035) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(8), a2 = t.loadRef().beginParse(true).asCell();
    return {
      kind: "TonstakeControllerPoolSendMessage",
      query_id: e,
      mode: o4,
      msg: a2
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolSendMessage" in loading "TonstakeControllerPoolSendMessage", but data does not satisfy any constructor');
}
function Ie(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2531783976) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (r) => r.loadRef().beginParse(true).asCell()), n = m(t, (r) => r.loadRef().beginParse(true).asCell()), a2 = m(t, (r) => r.loadRef().beginParse(true).asCell());
    return {
      kind: "TonstakeControllerPoolUpgrade",
      query_id: e,
      data: o4,
      code: n,
      after_upgrade: a2
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolUpgrade" in loading "TonstakeControllerPoolUpgrade", but data does not satisfy any constructor');
}
function Oe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2045231126) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny();
    return {
      kind: "TonstakeControllerPoolSetSudoer",
      query_id: e,
      sudoer: o4
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolSetSudoer" in loading "TonstakeControllerPoolSetSudoer", but data does not satisfy any constructor');
}
function Me(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1917314981)
    return t.loadUint(32), {
      kind: "TonstakeControllerPoolUnhalt",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerPoolUnhalt" in loading "TonstakeControllerPoolUnhalt", but data does not satisfy any constructor');
}
function je(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 328866638)
    return t.loadUint(32), {
      kind: "TonstakeControllerPoolHalt",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerPoolHalt" in loading "TonstakeControllerPoolHalt", but data does not satisfy any constructor');
}
function Ge(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3387966597) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(16);
    return {
      kind: "TonstakeImanagerSetInterest",
      query_id: e,
      interest_rate: o4
    };
  }
  throw new Error('Expected one of "TonstakeImanagerSetInterest" in loading "TonstakeImanagerSetInterest", but data does not satisfy any constructor');
}
function $e(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1423144071)
    return t.loadUint(32), {
      kind: "TonstakeImanagerOperationFee",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeImanagerOperationFee" in loading "TonstakeImanagerOperationFee", but data does not satisfy any constructor');
}
function He(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2985012742) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(16);
    return {
      kind: "TonstakeImanagerRequestNotification",
      query_id: e,
      min_loan: o4,
      max_loan: n,
      max_interest: a2
    };
  }
  throw new Error('Expected one of "TonstakeImanagerRequestNotification" in loading "TonstakeImanagerRequestNotification", but data does not satisfy any constructor');
}
function Ke(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3241429248) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadInt(1), d = t.loadCoins(), i = t.loadCoins();
    return {
      kind: "TonstakeImanagerStats",
      query_id: e,
      borrowed: o4,
      expected: n,
      returned: a2,
      profit_sign: r,
      profit: d,
      total_balance: i
    };
  }
  throw new Error('Expected one of "TonstakeImanagerStats" in loading "TonstakeImanagerStats", but data does not satisfy any constructor');
}
function ze(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4045930062)
    return t.loadUint(32), {
      kind: "TonstakeNftBurn",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeNftBurn" in loading "TonstakeNftBurn", but data does not satisfy any constructor');
}
function Qe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3982012594) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny(), a2 = t.loadUintBig(64);
    return {
      kind: "TonstakeNftBurnNotification",
      query_id: e,
      amount: o4,
      owner: n,
      index: a2
    };
  }
  throw new Error('Expected one of "TonstakeNftBurnNotification" in loading "TonstakeNftBurnNotification", but data does not satisfy any constructor');
}
function Ze(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 321886789) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadCoins(), a2 = t.loadAddressAny(), r = t.loadAddressAny();
    return {
      kind: "TonstakeNftInit",
      query_id: e,
      owner: o4,
      amount: n,
      prev: a2,
      next: r
    };
  }
  throw new Error('Expected one of "TonstakeNftInit" in loading "TonstakeNftInit", but data does not satisfy any constructor');
}
function Xe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3678112445)
    return t.loadUint(32), {
      kind: "TonstakeNftPayout",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeNftPayout" in loading "TonstakeNftPayout", but data does not satisfy any constructor');
}
function Ye(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 376746144) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins();
    return {
      kind: "TonstakePayoutMintJettons",
      query_id: e,
      destination: o4,
      amount: n,
      notification: a2,
      forward: r
    };
  }
  throw new Error('Expected one of "TonstakePayoutMintJettons" in loading "TonstakePayoutMintJettons", but data does not satisfy any constructor');
}
function to(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2007184673) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "MegatonWtonMint",
      query_id: e,
      amount: o4
    };
  }
  throw new Error('Expected one of "MegatonWtonMint" in loading "MegatonWtonMint", but data does not satisfy any constructor');
}
function eo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1607220500) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (i) => i.loadRef().beginParse(true).asCell()), r = t.loadVarUintBig(g(15)), d = S(t, N, (i) => {
      let l = i.loadRef().beginParse(true);
      return N(l);
    });
    return {
      kind: "NftTransfer",
      query_id: e,
      new_owner: o4,
      response_destination: n,
      custom_payload: a2,
      forward_amount: r,
      forward_payload: d
    };
  }
  throw new Error('Expected one of "NftTransfer" in loading "NftTransfer", but data does not satisfy any constructor');
}
function oo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 85167505) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = S(t, N, (a2) => {
      let r = a2.loadRef().beginParse(true);
      return N(r);
    });
    return {
      kind: "NftOwnershipAssigned",
      query_id: e,
      prev_owner: o4,
      forward_payload: n
    };
  }
  throw new Error('Expected one of "NftOwnershipAssigned" in loading "NftOwnershipAssigned", but data does not satisfy any constructor');
}
function no(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 801842850)
    return t.loadUint(32), {
      kind: "GetStaticData",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "GetStaticData" in loading "GetStaticData", but data does not satisfy any constructor');
}
function ao(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2339837749) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(256), n = t.loadAddressAny();
    return {
      kind: "ReportStaticData",
      query_id: e,
      index: o4,
      collection: n
    };
  }
  throw new Error('Expected one of "ReportStaticData" in loading "ReportStaticData", but data does not satisfy any constructor');
}
function ro(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1765620048)
    return t.loadUint(32), {
      kind: "GetRoyaltyParams",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "GetRoyaltyParams" in loading "GetRoyaltyParams", but data does not satisfy any constructor');
}
function io(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2831876269) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(16), n = t.loadUint(16), a2 = t.loadAddressAny();
    return {
      kind: "ReportRoyaltyParams",
      query_id: e,
      numerator: o4,
      denominator: n,
      destination: a2
    };
  }
  throw new Error('Expected one of "ReportRoyaltyParams" in loading "ReportRoyaltyParams", but data does not satisfy any constructor');
}
function lo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 81711432) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), a2 = t.loadRef().beginParse(true).asCell(), r = C(t);
    return {
      kind: "ProveOwnership",
      query_id: e,
      dest: o4,
      forward_payload: a2,
      with_content: r
    };
  }
  throw new Error('Expected one of "ProveOwnership" in loading "ProveOwnership", but data does not satisfy any constructor');
}
function so(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 86296494) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(256), n = t.loadAddressAny(), r = t.loadRef().beginParse(true).asCell(), d = t.loadUintBig(64), i = m(t, (l) => l.loadRef().beginParse(true).asCell());
    return {
      kind: "OwnershipProof",
      query_id: e,
      item_id: o4,
      owner: n,
      data: r,
      revoked_at: d,
      content: i
    };
  }
  throw new Error('Expected one of "OwnershipProof" in loading "OwnershipProof", but data does not satisfy any constructor');
}
function uo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3502489578) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), a2 = t.loadRef().beginParse(true).asCell(), r = C(t);
    return {
      kind: "SbtRequestOwner",
      query_id: e,
      dest: o4,
      forward_payload: a2,
      with_content: r
    };
  }
  throw new Error('Expected one of "SbtRequestOwner" in loading "SbtRequestOwner", but data does not satisfy any constructor');
}
function fo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 232130531) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(256), n = t.loadAddressAny(), a2 = t.loadAddressAny(), d = t.loadRef().beginParse(true).asCell(), i = t.loadUintBig(64), l = m(t, (f2) => f2.loadRef().beginParse(true).asCell());
    return {
      kind: "SbtOwnerInfo",
      query_id: e,
      item_id: o4,
      initiator: n,
      owner: a2,
      data: d,
      revoked_at: i,
      content: l
    };
  }
  throw new Error('Expected one of "SbtOwnerInfo" in loading "SbtOwnerInfo", but data does not satisfy any constructor');
}
function po(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 520377210)
    return t.loadUint(32), {
      kind: "SbtDestroy",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SbtDestroy" in loading "SbtDestroy", but data does not satisfy any constructor');
}
function mo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1871312355)
    return t.loadUint(32), {
      kind: "SbtRevoke",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SbtRevoke" in loading "SbtRevoke", but data does not satisfy any constructor');
}
function go(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1741148801) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadCoins();
    return {
      kind: "TopUpChannelBalance",
      add_A: e,
      add_B: o4
    };
  }
  throw new Error('Expected one of "TopUpChannelBalance" in loading "TopUpChannelBalance", but data does not satisfy any constructor');
}
function _o(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 235282626) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = t.loadCoins(), d = t.loadCoins();
    return {
      kind: "InitPaymentChannel",
      is_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      balance_A: r,
      balance_B: d
    };
  }
  throw new Error('Expected one of "InitPaymentChannel" in loading "InitPaymentChannel", but data does not satisfy any constructor');
}
function yo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1433884798) {
    t.loadUint(32);
    let o4 = t.loadRef().beginParse(true).loadBuffer(512 / 8), a2 = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = t.loadUint(32), d = t.loadUintBig(128), i = t.loadCoins(), l = t.loadCoins(), f2 = t.loadUintBig(64), u = t.loadUintBig(64);
    return {
      kind: "ChannelCooperativeClose",
      sig_A: o4,
      sig_B: a2,
      tag: r,
      channel_id: d,
      balance_A: i,
      balance_B: l,
      seqno_A: f2,
      seqno_B: u
    };
  }
  throw new Error('Expected one of "ChannelCooperativeClose" in loading "ChannelCooperativeClose", but data does not satisfy any constructor');
}
function Uo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2040604399) {
    t.loadUint(32);
    let o4 = t.loadRef().beginParse(true).loadBuffer(512 / 8), a2 = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = t.loadUint(32), d = t.loadUintBig(128), i = t.loadUintBig(64), l = t.loadUintBig(64);
    return {
      kind: "ChannelCooperativeCommit",
      sig_A: o4,
      sig_B: a2,
      tag: r,
      channel_id: d,
      seqno_A: i,
      seqno_B: l
    };
  }
  throw new Error('Expected one of "ChannelCooperativeCommit" in loading "ChannelCooperativeCommit", but data does not satisfy any constructor');
}
function ho(t) {
  let e = t.loadCoins(), o4 = t.asCell();
  return {
    kind: "ConditionalPayment",
    amount: e,
    condition: o4
  };
}
function J(t) {
  let e = t.loadUintBig(64), o4 = t.loadCoins(), n = distExports$2.Dictionary.load(distExports$2.Dictionary.Keys.Uint(32), {
    serialize: () => {
      throw new Error("Not implemented");
    },
    parse: ho
  }, t);
  return {
    kind: "SemiChannelBody",
    seqno: e,
    sent: o4,
    conditionals: n
  };
}
function Co(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1130910580) {
    t.loadUint(32);
    let e = t.loadUintBig(128), o4 = J(t), n = m(t, (a2) => {
      let r = a2.loadRef().beginParse(true);
      return J(r);
    });
    return {
      kind: "SemiChannel",
      channel_id: e,
      data: o4,
      counterparty_data: n
    };
  }
  throw new Error('Expected one of "SemiChannel" in loading "SemiChannel", but data does not satisfy any constructor');
}
function I(t) {
  let e = t.loadBuffer(64), o4 = Co(t);
  return {
    kind: "SignedSemiChannel",
    signature: e,
    state: o4
  };
}
function co(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 521476815) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = t.loadRef().beginParse(true), d = I(r), i = t.loadRef().beginParse(true), l = I(i);
    return {
      kind: "StartUncooperativeChannelClose",
      signed_by_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      sch_A: d,
      sch_B: l
    };
  }
  throw new Error('Expected one of "StartUncooperativeChannelClose" in loading "StartUncooperativeChannelClose", but data does not satisfy any constructor');
}
function wo(t) {
  let e = t.loadCoins(), o4 = t.asCell();
  return {
    kind: "ConditionalPayment",
    amount: e,
    condition: o4
  };
}
function O(t) {
  let e = t.loadUintBig(64), o4 = t.loadCoins(), n = distExports$2.Dictionary.load(distExports$2.Dictionary.Keys.Uint(32), {
    serialize: () => {
      throw new Error("Not implemented");
    },
    parse: wo
  }, t);
  return {
    kind: "SemiChannelBody",
    seqno: e,
    sent: o4,
    conditionals: n
  };
}
function ko(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1130910580) {
    t.loadUint(32);
    let e = t.loadUintBig(128), o4 = O(t), n = m(t, (a2) => {
      let r = a2.loadRef().beginParse(true);
      return O(r);
    });
    return {
      kind: "SemiChannel",
      channel_id: e,
      data: o4,
      counterparty_data: n
    };
  }
  throw new Error('Expected one of "SemiChannel" in loading "SemiChannel", but data does not satisfy any constructor');
}
function M(t) {
  let e = t.loadBuffer(64), o4 = ko(t);
  return {
    kind: "SignedSemiChannel",
    signature: e,
    state: o4
  };
}
function So(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 143567410) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = t.loadRef().beginParse(true), d = M(r), i = t.loadRef().beginParse(true), l = M(i);
    return {
      kind: "ChallengeQuarantinedChannelState",
      challenged_by_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      sch_A: d,
      sch_B: l
    };
  }
  throw new Error('Expected one of "ChallengeQuarantinedChannelState" in loading "ChallengeQuarantinedChannelState", but data does not satisfy any constructor');
}
function Bo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1727459433) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = distExports$2.Dictionary.load(distExports$2.Dictionary.Keys.Uint(32), {
      serialize: () => {
        throw new Error("Not implemented");
      },
      parse: (d) => d.asCell()
    }, t);
    return {
      kind: "SettleChannelConditionals",
      from_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      conditionals_to_settle: r
    };
  }
  throw new Error('Expected one of "SettleChannelConditionals" in loading "SettleChannelConditionals", but data does not satisfy any constructor');
}
function xo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 625158801)
    return t.loadUint(32), {
      kind: "FinishUncooperativeChannelClose"
    };
  throw new Error('Expected one of "FinishUncooperativeChannelClose" in loading "FinishUncooperativeChannelClose", but data does not satisfy any constructor');
}
function bo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3722217658)
    return t.loadUint(32), {
      kind: "ChannelClosed",
      channel_id: t.loadUintBig(128)
    };
  throw new Error('Expected one of "ChannelClosed" in loading "ChannelClosed", but data does not satisfy any constructor');
}
function No(t) {
  return {
    kind: "StonfiSwapAddrs",
    from_user: t.loadAddressAny()
  };
}
function Po(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 630424929) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadVarUintBig(g(15)), r = t.loadVarUintBig(g(15)), d = C(t), i = t.loadRef().beginParse(true), l = No(i);
    return {
      kind: "StonfiSwap",
      query_id: e,
      to_address: o4,
      sender_address: n,
      jetton_amount: a2,
      min_out: r,
      has_ref_address: d,
      addrs: l
    };
  }
  throw new Error('Expected one of "StonfiSwap" in loading "StonfiSwap", but data does not satisfy any constructor');
}
function j(t) {
  let e = t.loadVarUintBig(g(15)), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a2 = t.loadAddressAny();
  return {
    kind: "StonfiPayToParams",
    amount0_out: e,
    token0_address: o4,
    amount1_out: n,
    token1_address: a2
  };
}
function Eo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4181439551) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadUint(32), a2 = S(t, j, (r) => {
      let d = r.loadRef().beginParse(true);
      return j(d);
    });
    return {
      kind: "StonfiPaymentRequest",
      query_id: e,
      owner: o4,
      exit_code: n,
      params: a2
    };
  }
  throw new Error('Expected one of "StonfiPaymentRequest" in loading "StonfiPaymentRequest", but data does not satisfy any constructor');
}
function Ao(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 32736093) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny(), a2 = S(t, (r) => r.asCell(), (r) => r.loadRef().beginParse(true).asCell());
    return {
      kind: "PtonTonTransfer",
      query_id: e,
      ton_amount: o4,
      refund_address: n,
      forward_payload: a2
    };
  }
  throw new Error('Expected one of "PtonTonTransfer" in loading "PtonTonTransfer", but data does not satisfy any constructor');
}
function To(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2921715614)
    return t.loadUint(32), {
      kind: "PtonTonRefund",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "PtonTonRefund" in loading "PtonTonRefund", but data does not satisfy any constructor');
}
function Do(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 701638965)
    return t.loadUint(32), {
      kind: "PtonResetGas",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "PtonResetGas" in loading "PtonResetGas", but data does not satisfy any constructor');
}
function Ro(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1331643155) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny();
    return {
      kind: "PtonDeployWallet",
      query_id: e,
      owner_address: o4,
      excesses_address: n
    };
  }
  throw new Error('Expected one of "PtonDeployWallet" in loading "PtonDeployWallet", but data does not satisfy any constructor');
}
function qo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1698746245) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny();
    return {
      kind: "PtonInternalDeploy",
      query_id: e,
      excesses_address: o4
    };
  }
  throw new Error('Expected one of "PtonInternalDeploy" in loading "PtonInternalDeploy", but data does not satisfy any constructor');
}
function Lo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 116184359) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a2 = t.loadAddressAny(), r = t.loadVarUintBig(g(15)), d = t.loadCoins(), i = m(t, (p2) => p2.loadRef().beginParse(true).asCell()), l = t.loadRef().beginParse(true), f2 = l.loadAddressAny(), u = l.loadAddressAny(), s2 = l.loadAddressAny();
    return {
      kind: "StonfiCbAddLiquidityV2",
      query_id: e,
      tot_am0: o4,
      tot_am1: n,
      user_address: a2,
      min_lp_out: r,
      fwd_amount: d,
      custom_payload_cs: i,
      to_user_address: f2,
      refund_address: u,
      excess_address: s2
    };
  }
  throw new Error('Expected one of "StonfiCbAddLiquidityV2" in loading "StonfiCbAddLiquidityV2", but data does not satisfy any constructor');
}
function vo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 935368415) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a2 = t.loadVarUintBig(g(15)), r = t.loadRef().beginParse(true), d = r.loadUint(32), i = r.loadAddressAny(), l = r.loadAddressAny(), f2 = r.loadAddressAny(), u = r.loadUintBig(64), s2 = r.loadRef().beginParse(true), p2 = s2.loadVarUintBig(g(15)), _ = s2.loadAddressAny(), U2 = s2.loadUint(1), y2 = s2.loadCoins(), h2 = m(s2, (c) => c.loadRef().beginParse(true).asCell());
    return {
      kind: "StonfiProvideLpV2",
      query_id: e,
      from_user: o4,
      left_amount: n,
      right_amount: a2,
      transferred_op: d,
      token_wallet1: i,
      refund_address: l,
      excesses_address: f2,
      tx_deadline: u,
      min_lp_out: p2,
      to_address: _,
      both_positive: U2,
      fwd_amount: y2,
      custom_payload: h2
    };
  }
  throw new Error('Expected one of "StonfiProvideLpV2" in loading "StonfiProvideLpV2", but data does not satisfy any constructor');
}
function Vo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1355195988) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a2 = t.loadVarUintBig(g(15)), r = t.loadCoins(), d = t.loadUint(1), i = t.loadAddressAny(), l = m(t, (p2) => p2.loadRef().beginParse(true).asCell()), f2 = t.loadRef().beginParse(true), u = f2.loadAddressAny(), s2 = f2.loadAddressAny();
    return {
      kind: "StonfiAddLiquidityV2",
      query_id: e,
      new_amount0: o4,
      new_amount1: n,
      min_lp_out: a2,
      fwd_amount: r,
      both_positive: d,
      to_user: i,
      custom_payload_cs: l,
      refund_address: u,
      excess_address: s2
    };
  }
  throw new Error('Expected one of "StonfiAddLiquidityV2" in loading "StonfiAddLiquidityV2", but data does not satisfy any constructor');
}
function Fo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1702581493) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = t.loadUint(32), d = m(t, (_) => _.loadRef().beginParse(true).asCell()), i = t.loadRef().beginParse(true), l = i.loadCoins(), f2 = i.loadVarUintBig(g(15)), u = i.loadAddressAny(), s2 = i.loadVarUintBig(g(15)), p2 = i.loadAddressAny();
    return {
      kind: "StonfiPayToV2",
      query_id: e,
      to_address: o4,
      excesses_address: n,
      original_caller: a2,
      exit_code: r,
      custom_payload: d,
      fwd_ton_amount: l,
      amount0_out: f2,
      token0_address: u,
      amount1_out: s2,
      token1_address: p2
    };
  }
  throw new Error('Expected one of "StonfiPayToV2" in loading "StonfiPayToV2", but data does not satisfy any constructor');
}
function Wo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1717886506) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a2 = t.loadVarUintBig(g(15)), r = t.loadRef().beginParse(true), d = r.loadUint(32), i = r.loadAddressAny(), l = r.loadAddressAny(), f2 = r.loadAddressAny(), u = r.loadUintBig(64), s2 = r.loadRef().beginParse(true), p2 = s2.loadVarUintBig(g(15)), _ = s2.loadAddressAny(), U2 = s2.loadCoins(), y2 = m(s2, (k2) => k2.loadRef().beginParse(true).asCell()), h2 = s2.loadCoins(), c = m(s2, (k2) => k2.loadRef().beginParse(true).asCell()), B2 = s2.loadUint(16), P2 = s2.loadAddressAny();
    return {
      kind: "StonfiSwapV2",
      query_id: e,
      from_user: o4,
      left_amount: n,
      right_amount: a2,
      transferred_op: d,
      token_wallet1: i,
      refund_address: l,
      excesses_address: f2,
      tx_deadline: u,
      min_out: p2,
      receiver: _,
      fwd_gas: U2,
      custom_payload: y2,
      refund_fwd_gas: h2,
      refund_payload: c,
      ref_fee: B2,
      ref_address: P2
    };
  }
  throw new Error('Expected one of "StonfiSwapV2" in loading "StonfiSwapV2", but data does not satisfy any constructor');
}
function Jo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 894160372)
    return t.loadUint(32), {
      kind: "StonfiWithdrawFeeV2",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StonfiWithdrawFeeV2" in loading "StonfiWithdrawFeeV2", but data does not satisfy any constructor');
}
function Io(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 76607643) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny();
    return {
      kind: "StonfiDepositRefFeeV2",
      query_id: e,
      jetton_amount: o4,
      excesses_address: n
    };
  }
  throw new Error('Expected one of "StonfiDepositRefFeeV2" in loading "StonfiDepositRefFeeV2", but data does not satisfy any constructor');
}
function Oo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 553699618) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny();
    return {
      kind: "StonfiVaultPayToV2",
      query_id: e,
      amount_out: o4,
      token_address: n,
      to_address: a2
    };
  }
  throw new Error('Expected one of "StonfiVaultPayToV2" in loading "StonfiVaultPayToV2", but data does not satisfy any constructor');
}
function Mo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1664620082) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadRef().beginParse(true), r = a2.loadVarUintBig(g(15)), d = a2.loadAddressAny(), i = a2.loadVarUintBig(g(15)), l = a2.loadAddressAny();
    return {
      kind: "StonfiPayVaultV2",
      query_id: e,
      owner: o4,
      excesses_address: n,
      amount0_out: r,
      token0_address: d,
      amount1_out: i,
      token1_address: l
    };
  }
  throw new Error('Expected one of "StonfiPayVaultV2" in loading "StonfiPayVaultV2", but data does not satisfy any constructor');
}
function jo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 695482319) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
    return {
      kind: "StonfiBurnNotificationExtV2",
      query_id: e,
      jetton_amount: o4,
      from_address: n,
      response_address: a2,
      maybe_custom_payload: r
    };
  }
  throw new Error('Expected one of "StonfiBurnNotificationExtV2" in loading "StonfiBurnNotificationExtV2", but data does not satisfy any constructor');
}
function Go(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 5358900) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64), n = t.loadUintBig(256), a2 = t.loadUintBig(64), r = t.loadUintBig(256), d = m(t, (l) => l.loadUintBig(256)), i = R();
    return {
      kind: "TorrentInfo",
      piece_size: e,
      file_size: o4,
      root_hash: n,
      header_size: a2,
      header_hash: r,
      microchunk_hash: d,
      description: i
    };
  }
  throw new Error('Expected one of "TorrentInfo" in loading "TorrentInfo", but data does not satisfy any constructor');
}
function $o(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3832843761) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadRef().beginParse(true), n = Go(o4), a2 = t.loadBuffer(256 / 8), r = t.loadCoins(), d = t.loadUint(32);
    return {
      kind: "DeployStorageContract",
      query_id: e,
      info: n,
      merkle_hash: a2,
      expected_rate: r,
      expected_max_span: d
    };
  }
  throw new Error('Expected one of "DeployStorageContract" in loading "DeployStorageContract", but data does not satisfy any constructor');
}
function Ho(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1408453846) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "UpdatePubkey",
      query_id: e,
      new_pubkey: o4
    };
  }
  throw new Error('Expected one of "UpdatePubkey" in loading "UpdatePubkey", but data does not satisfy any constructor');
}
function Ko(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1422651803) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = C(t), n = t.loadCoins(), a2 = t.loadUint(32), r = t.loadUintBig(64), d = t.loadUintBig(64);
    return {
      kind: "UpdateStorageParams",
      query_id: e,
      accept_new_contracts: o4,
      rate_per_mb_day: n,
      max_span: a2,
      minimal_file_size: r,
      maximal_file_size: d
    };
  }
  throw new Error('Expected one of "UpdateStorageParams" in loading "UpdateStorageParams", but data does not satisfy any constructor');
}
function zo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 276580847)
    return t.loadUint(32), {
      kind: "OfferStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "OfferStorageContract" in loading "OfferStorageContract", but data does not satisfy any constructor');
}
function Qo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2050365064)
    return t.loadUint(32), {
      kind: "AcceptStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "AcceptStorageContract" in loading "AcceptStorageContract", but data does not satisfy any constructor');
}
function Zo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3570068941) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "StorageContractConfirmed",
      cur_lt: e,
      torrent_hash: o4
    };
  }
  throw new Error('Expected one of "StorageContractConfirmed" in loading "StorageContractConfirmed", but data does not satisfy any constructor');
}
function Xo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2046375914)
    return t.loadUint(32), {
      kind: "CloseStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "CloseStorageContract" in loading "CloseStorageContract", but data does not satisfy any constructor');
}
function Yo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3055775075) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "StorageContractTerminated",
      cur_lt: e,
      torrent_hash: o4
    };
  }
  throw new Error('Expected one of "StorageContractTerminated" in loading "StorageContractTerminated", but data does not satisfy any constructor');
}
function tn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1189949076)
    return t.loadUint(32), {
      kind: "StorageWithdraw",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StorageWithdraw" in loading "StorageWithdraw", but data does not satisfy any constructor');
}
function en(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2837163862)
    return t.loadUint(32), {
      kind: "StorageRewardWithdrawal",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StorageRewardWithdrawal" in loading "StorageRewardWithdrawal", but data does not satisfy any constructor');
}
function on(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1100832077) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell();
    return {
      kind: "ProofStorage",
      query_id: e,
      file_dict_proof: n
    };
  }
  throw new Error('Expected one of "ProofStorage" in loading "ProofStorage", but data does not satisfy any constructor');
}
function nn(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32), n = t.loadUint(32), a2 = t.loadUint(32), r = t.loadUint(32), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32), u = t.loadUint(32), s2 = t.loadUint(32), p2 = t.loadUint(32), _ = t.loadUint(2), U2 = t.loadCoins(), y2 = t.loadUint(32);
  return {
    kind: "AmmSettings",
    fee: e,
    rollover_fee: o4,
    funding_period: n,
    init_margin_ratio: a2,
    maintenance_margin_ratio: r,
    liquidation_fee_ratio: d,
    partial_liquidation_ratio: i,
    spread_limit: l,
    max_price_impact: f2,
    max_price_spread: u,
    max_open_notional: s2,
    fee_to_stakers_percent: p2,
    funding_mode: _,
    min_partial_liquidation_notional: U2,
    min_leverage: y2
  };
}
function an(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3989649062) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadRef().beginParse(true), n = nn(o4);
    return {
      kind: "StormChangeSettings",
      redirect_addr: e,
      settings: n
    };
  }
  throw new Error('Expected one of "StormChangeSettings" in loading "StormChangeSettings", but data does not satisfy any constructor');
}
function rn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadUint(32), a2 = t.loadUint(16);
  return {
    kind: "UpdateMsg",
    price: e,
    spread: o4,
    timestamp: n,
    asset_index: a2
  };
}
function dn(t) {
  let e = t.loadRef().beginParse(true), o4 = rn(e), a2 = t.loadRef().beginParse(true).asCell();
  return {
    kind: "OracleData",
    update_msg: o4,
    signatures: a2
  };
}
function ln(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3058877505) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormPayFunding",
      oracle_ref: dn(e)
    };
  }
  throw new Error('Expected one of "StormPayFunding" in loading "StormPayFunding", but data does not satisfy any constructor');
}
function sn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 700515025) {
    t.loadUint(32);
    let e = t.loadAddressAny(), n = t.loadRef().beginParse(true).asCell(), r = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormVammInit",
      redirect_addr: e,
      code: n,
      data: r
    };
  }
  throw new Error('Expected one of "StormVammInit" in loading "StormVammInit", but data does not satisfy any constructor');
}
function un(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32);
  return {
    kind: "Parameters",
    discount: e,
    rebate: o4
  };
}
function fn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3410877500) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadUint(2), n = t.loadAddressAny(), a2 = t.loadRef().beginParse(true), r = un(a2), i = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormMintReferral",
      nft_owner: e,
      ref_type: o4,
      redirect_address: n,
      parameters: r,
      balances_dict: i
    };
  }
  throw new Error('Expected one of "StormMintReferral" in loading "StormMintReferral", but data does not satisfy any constructor');
}
function pn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2229071226) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "StormAddReferralAmount",
      referral_amount: e,
      origin_addr: o4
    };
  }
  throw new Error('Expected one of "StormAddReferralAmount" in loading "StormAddReferralAmount", but data does not satisfy any constructor');
}
function mn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4124371794) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny();
    return {
      kind: "StormWithdrawReferralAmount",
      index: e,
      referral_amount: o4,
      owner_addr: n
    };
  }
  throw new Error('Expected one of "StormWithdrawReferralAmount" in loading "StormWithdrawReferralAmount", but data does not satisfy any constructor');
}
function gn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1329122024) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadAddressAny(), a2 = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormMintExecutor",
      nft_owner: e,
      redirect_address: o4,
      balances_dict: a2
    };
  }
  throw new Error('Expected one of "StormMintExecutor" in loading "StormMintExecutor", but data does not satisfy any constructor');
}
function _n(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1574331769) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "StormAddExecutorAmount",
      referral_amount: e,
      origin_addr: o4
    };
  }
  throw new Error('Expected one of "StormAddExecutorAmount" in loading "StormAddExecutorAmount", but data does not satisfy any constructor');
}
function yn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 752771921) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny();
    return {
      kind: "StormWithdrawExecutorAmount",
      index: e,
      executor_amount: o4,
      owner_addr: n
    };
  }
  throw new Error('Expected one of "StormWithdrawExecutorAmount" in loading "StormWithdrawExecutorAmount", but data does not satisfy any constructor');
}
function Un(t) {
  let e = t.loadCoins(), o4 = t.loadUint(32);
  return {
    kind: "ReferralData",
    amount: e,
    index: o4
  };
}
function hn(t) {
  let e = t.loadUint(8), o4 = t.loadCoins(), n = t.loadUint(32);
  return {
    kind: "ExecutorData",
    split_executor_rewards: e,
    amount: o4,
    index: n
  };
}
function Cn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 880147922) {
    t.loadUint(32);
    let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadIntBig(64), a2 = t.loadIntBig(64), r = t.loadIntBig(64), d = t.loadIntBig(64), i = t.loadIntBig(64), l = t.loadAddressAny(), f2 = m(t, (s2) => {
      let p2 = s2.loadRef().beginParse(true);
      return Un(p2);
    }), u = m(t, (s2) => {
      let p2 = s2.loadRef().beginParse(true);
      return hn(p2);
    });
    return {
      kind: "StormVaultTradeNotification",
      amm_index: e,
      free_amount: o4,
      locked_amount: n,
      exchange_amount: a2,
      withdraw_locked_amount: r,
      fee_to_stakers: d,
      withdraw_amount: i,
      trader_addr: l,
      referral_params: f2,
      executor_params: u
    };
  }
  throw new Error('Expected one of "StormVaultTradeNotification" in loading "StormVaultTradeNotification", but data does not satisfy any constructor');
}
function cn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3365551844)
    return t.loadUint(32), {
      kind: "StormVaultStake",
      amount: t.loadCoins()
    };
  throw new Error('Expected one of "StormVaultStake" in loading "StormVaultStake", but data does not satisfy any constructor');
}
function wn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3585468845) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "StormVaultUnstake",
      jetton_amount: e,
      user_address: o4
    };
  }
  throw new Error('Expected one of "StormVaultUnstake" in loading "StormVaultUnstake", but data does not satisfy any constructor');
}
function kn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 700515025)
    return t.loadUint(32), {
      kind: "StormVaultInit",
      jetton_address: t.loadAddressAny()
    };
  throw new Error('Expected one of "StormVaultInit" in loading "StormVaultInit", but data does not satisfy any constructor');
}
function Sn(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32);
  return {
    kind: "Parameters",
    discount: e,
    rebate: o4
  };
}
function Bn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 316235805) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormTakeReferralFees",
      referral_fees: Sn(e)
    };
  }
  throw new Error('Expected one of "StormTakeReferralFees" in loading "StormTakeReferralFees", but data does not satisfy any constructor');
}
function xn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1729316393) {
    t.loadUint(32);
    let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1), a2 = t.loadAddressAny();
    return {
      kind: "StormCancelOrder",
      order_type: e,
      order_index: o4,
      direction: n,
      gas_to_address: a2
    };
  }
  throw new Error('Expected one of "StormCancelOrder" in loading "StormCancelOrder", but data does not satisfy any constructor');
}
function bn(t) {
  let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1);
  return {
    kind: "OrderPayload",
    order_type: e,
    order_index: o4,
    direction: n
  };
}
function Nn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2744665076) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormCreateOrder",
      order_payload: bn(e)
    };
  }
  throw new Error('Expected one of "StormCreateOrder" in loading "StormCreateOrder", but data does not satisfy any constructor');
}
function Pn(t) {
  let e = t.loadUintBig(128), o4 = t.loadUint(1), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o4,
    margin: n,
    open_notional: a2,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f2
  };
}
function En(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o4,
    base_asset_reserve: n,
    total_long_position_size: a2,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function An(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3482375704) {
    t.loadUint(32);
    let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1), a2 = t.loadUint(32), r = t.loadCoins(), d = m(t, (s2) => s2.loadCoins()), i = t.loadRef().beginParse(true), l = Pn(i), f2 = t.loadRef().beginParse(true), u = En(f2);
    return {
      kind: "StormCompleteOrder",
      order_type: e,
      order_index: o4,
      direction: n,
      origin_opcode: a2,
      index_price: r,
      settlement_oracle_price: d,
      position: l,
      amm: u
    };
  }
  throw new Error('Expected one of "StormCompleteOrder" in loading "StormCompleteOrder", but data does not satisfy any constructor');
}
function Tn(t) {
  let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1);
  return {
    kind: "OrderPayload",
    order_type: e,
    order_index: o4,
    direction: n
  };
}
function Dn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2637088320) {
    t.loadUint(32);
    let e = t.loadUint(3), o4 = t.loadRef().beginParse(true), n = Tn(o4);
    return {
      kind: "StormActivateOrder",
      order_index: e,
      activated_order: n
    };
  }
  throw new Error('Expected one of "StormActivateOrder" in loading "StormActivateOrder", but data does not satisfy any constructor');
}
function Rn(t) {
  let e = t.loadUintBig(128), o4 = t.loadUint(1), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o4,
    margin: n,
    open_notional: a2,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f2
  };
}
function qn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o4,
    base_asset_reserve: n,
    total_long_position_size: a2,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function Ln(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1625278071) {
    t.loadUint(32);
    let e = t.loadUint(1), o4 = t.loadUint(32), n = t.loadCoins(), a2 = m(t, (f2) => f2.loadCoins()), r = t.loadRef().beginParse(true), d = Rn(r), i = t.loadRef().beginParse(true), l = qn(i);
    return {
      kind: "StormUpdatePosition",
      direction: e,
      origin_opcode: o4,
      index_price: n,
      settlement_oracle_price: a2,
      position: d,
      amm: l
    };
  }
  throw new Error('Expected one of "StormUpdatePosition" in loading "StormUpdatePosition", but data does not satisfy any constructor');
}
function vn(t) {
  let e = t.loadUintBig(128), o4 = t.loadUint(1), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o4,
    margin: n,
    open_notional: a2,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f2
  };
}
function Vn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o4,
    base_asset_reserve: n,
    total_long_position_size: a2,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function Fn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1562056632) {
    t.loadUint(32);
    let e = t.loadUint(1), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(32), r = t.loadCoins(), d = m(t, (s2) => s2.loadCoins()), i = t.loadRef().beginParse(true), l = vn(i), f2 = t.loadRef().beginParse(true), u = Vn(f2);
    return {
      kind: "StormUpdatePositionWithStopLoss",
      direction: e,
      stop_trigger_price: o4,
      take_trigger_price: n,
      origin_opcode: a2,
      index_price: r,
      settlement_oracle_price: d,
      position: l,
      amm: u
    };
  }
  throw new Error('Expected one of "StormUpdatePositionWithStopLoss" in loading "StormUpdatePositionWithStopLoss", but data does not satisfy any constructor');
}
function Wn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 982793446)
    return t.loadUint(32), {
      kind: "StormOrderCreated"
    };
  throw new Error('Expected one of "StormOrderCreated" in loading "StormOrderCreated", but data does not satisfy any constructor');
}
function Jn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1775273593)
    return t.loadUint(32), {
      kind: "StormOrderCanceled"
    };
  throw new Error('Expected one of "StormOrderCanceled" in loading "StormOrderCanceled", but data does not satisfy any constructor');
}
function In(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 36101990) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadAddressAny(), n = t.loadCoins(), a2 = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "StormVaultRequestWithdrawPosition",
      trader_addr: e,
      vamm_addr: o4,
      amount: n,
      gas_to_addr: a2,
      withdraw_reason: r
    };
  }
  throw new Error('Expected one of "StormVaultRequestWithdrawPosition" in loading "StormVaultRequestWithdrawPosition", but data does not satisfy any constructor');
}
function On(t) {
  return {
    kind: "Signatures",
    data: t.asCell()
  };
}
function Mn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadUint(32), a2 = t.loadUint(16);
  return {
    kind: "OraclePriceData",
    price: e,
    spread: o4,
    another_spread: n,
    asset_id: a2
  };
}
function jn(t) {
  let e = t.loadRef().beginParse(true), o4 = Mn(e), n = t.loadRef().beginParse(true), a2 = On(n);
  return {
    kind: "OraclePayload",
    price_data: o4,
    signatures: a2
  };
}
function Gn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2288366594) {
    t.loadUint(32);
    let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1), a2 = t.loadUint(32), r = t.loadRef().beginParse(true), d = jn(r);
    return {
      kind: "StormProvidePosition",
      order_type: e,
      order_index: o4,
      direction: n,
      executor_index: a2,
      oracle_payload: d
    };
  }
  throw new Error('Expected one of "StormProvidePosition" in loading "StormProvidePosition", but data does not satisfy any constructor');
}
function $n(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4145513419) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(32), n = t.loadCoins(), a2 = t.loadUint(32), r = t.loadUint(32), d = t.loadCoins(), l = t.loadRef().beginParse(true).asCell();
    return {
      kind: "SubscriptionV2Deploy",
      query_id: e,
      first_charging_date: o4,
      payment_per_period: n,
      period: a2,
      grace_period: r,
      caller_fee: d,
      metadata: l
    };
  }
  throw new Error('Expected one of "SubscriptionV2Deploy" in loading "SubscriptionV2Deploy", but data does not satisfy any constructor');
}
function Hn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1685288050)
    return t.loadUint(32), {
      kind: "SubscriptionV2Destruct",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SubscriptionV2Destruct" in loading "SubscriptionV2Destruct", but data does not satisfy any constructor');
}
function Kn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1350711532) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "SubscriptionV2ReducePayment",
      query_id: e,
      new_payment: o4
    };
  }
  throw new Error('Expected one of "SubscriptionV2ReducePayment" in loading "SubscriptionV2ReducePayment", but data does not satisfy any constructor');
}
function zn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4033639783)
    return t.loadUint(32), {
      kind: "SubscriptionV2PaymentConfirmed"
    };
  throw new Error('Expected one of "SubscriptionV2PaymentConfirmed" in loading "SubscriptionV2PaymentConfirmed", but data does not satisfy any constructor');
}
function Qn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4166133070)
    return t.loadUint(32), {
      kind: "SubscriptionV2WithdrawToBeneficiary",
      subscription_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SubscriptionV2WithdrawToBeneficiary" in loading "SubscriptionV2WithdrawToBeneficiary", but data does not satisfy any constructor');
}
function Zn(t) {
  let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o4,
    destination: n
  };
}
function Xn(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function Yn(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32), n = t.loadUint(32), a2 = b(t), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = Xn(i), f2 = m(t, (u) => {
    let s2 = u.loadRef().beginParse(true);
    return Zn(s2);
  });
  return {
    kind: "TelemintUnsignedDeploy",
    subwallet_id: e,
    valid_since: o4,
    valid_till: n,
    username: a2,
    content: d,
    auction_config: l,
    royalty_params: f2
  };
}
function ta(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1178019994) {
    t.loadUint(32);
    let e = t.loadBuffer(512 / 8), o4 = Yn(t);
    return {
      kind: "TelemintDeploy",
      sig: e,
      msg: o4
    };
  }
  throw new Error('Expected one of "TelemintDeploy" in loading "TelemintDeploy", but data does not satisfy any constructor');
}
function ea(t) {
  let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o4,
    destination: n
  };
}
function oa(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function na(t) {
  let e = m(t, (n) => n.loadAddressAny()), o4 = m(t, (n) => n.loadAddressAny());
  return {
    kind: "TelemintRestrictions",
    force_sender_address: e,
    rewrite_sender_address: o4
  };
}
function aa(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32), n = t.loadUint(32), a2 = b(t), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = oa(i), f2 = m(t, (s2) => {
    let p2 = s2.loadRef().beginParse(true);
    return ea(p2);
  }), u = m(t, (s2) => {
    let p2 = s2.loadRef().beginParse(true);
    return na(p2);
  });
  return {
    kind: "TelemintUnsignedDeployV2",
    subwallet_id: e,
    valid_since: o4,
    valid_till: n,
    token_name: a2,
    content: d,
    auction_config: l,
    royalty_params: f2,
    restrictions: u
  };
}
function ra(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1178019995) {
    t.loadUint(32);
    let e = t.loadBuffer(512 / 8), o4 = aa(t);
    return {
      kind: "TelemintDeployV2",
      sig: e,
      msg: o4
    };
  }
  throw new Error('Expected one of "TelemintDeployV2" in loading "TelemintDeployV2", but data does not satisfy any constructor');
}
function da(t) {
  let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o4,
    destination: n
  };
}
function ia(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function la(t) {
  let e = b(t), o4 = b(t);
  return {
    kind: "TelemintTokenInfo",
    name: e,
    domain: o4
  };
}
function sa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 697974293) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadRef().beginParse(true), a2 = la(n), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = ia(i), f2 = t.loadRef().beginParse(true), u = da(f2);
    return {
      kind: "TeleitemDeploy",
      sender_address: e,
      bid: o4,
      token_info: a2,
      nft_content: d,
      auction_config: l,
      royalty_params: u
    };
  }
  throw new Error('Expected one of "TeleitemDeploy" in loading "TeleitemDeploy", but data does not satisfy any constructor');
}
function ua(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function fa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1215991425) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o4 = t.loadRef().beginParse(true), n = ua(o4);
    return {
      kind: "TeleitemStartAuction",
      query_id: e,
      auction_config: n
    };
  }
  throw new Error('Expected one of "TeleitemStartAuction" in loading "TeleitemStartAuction", but data does not satisfy any constructor');
}
function pa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 924203182)
    return t.loadUint(32), {
      kind: "TeleitemCancelAuction",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemCancelAuction" in loading "TeleitemCancelAuction", but data does not satisfy any constructor');
}
function ma(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2742684035)
    return t.loadUint(32), {
      kind: "TeleitemOk",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemOk" in loading "TeleitemOk", but data does not satisfy any constructor');
}
function ga(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2754750433)
    return t.loadUint(32), {
      kind: "TeleitemReturnBid",
      cur_lt: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemReturnBid" in loading "TeleitemReturnBid", but data does not satisfy any constructor');
}
function _a(t) {
  let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
  return {
    kind: "CertificateData2Fa",
    valid_until: e,
    pubkey: o4
  };
}
function ya(t) {
  let e = _a(t), o4 = t.loadBuffer(512 / 8);
  return {
    kind: "Certificate2Fa",
    data: e,
    signature: o4
  };
}
function Ua(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2975804556) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64), a2 = t.loadRef().beginParse(true).asCell(), r = t.loadUint(8);
    return {
      kind: "Payload2Fa_send_actions",
      seqno: e,
      valid_until: o4,
      msg: a2,
      mode: r
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2642445526) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64);
    return {
      kind: "Payload2Fa_remove_extension",
      seqno: e,
      valid_until: o4
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 601473372) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64), a2 = t.loadRef().beginParse(true).asCell(), r = t.loadCoins();
    return {
      kind: "Payload2Fa_delegation",
      seqno: e,
      valid_until: o4,
      new_state_init: a2,
      forward_amount: r
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3733107969) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64);
    return {
      kind: "Payload2Fa_cancel_delegation",
      seqno: e,
      valid_until: o4
    };
  }
  throw new Error('Expected one of "Payload2Fa_send_actions", "Payload2Fa_remove_extension", "Payload2Fa_delegation", "Payload2Fa_cancel_delegation" in loading "Payload2Fa", but data does not satisfy any constructor');
}
function ha(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1399341111) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true), o4 = ya(e), a2 = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = Ua(t), d = t.loadBuffer(512 / 8);
    return {
      kind: "Tonkeeper2faSigned",
      ref_with_certificate: o4,
      seed_signature: a2,
      payload: r,
      certificate_signature: d
    };
  }
  throw new Error('Expected one of "Tonkeeper2faSigned" in loading "Tonkeeper2faSigned", but data does not satisfy any constructor');
}
function Ca(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3665837821) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o4 = t.loadCoins(), n = t.loadCoins();
    return {
      kind: "WhalesNominatorsWithdraw",
      query_id: e,
      gas: o4,
      amount: n
    };
  }
  throw new Error('Expected one of "WhalesNominatorsWithdraw" in loading "WhalesNominatorsWithdraw", but data does not satisfy any constructor');
}
function ca(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2077040623) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o4 = t.loadCoins();
    return {
      kind: "WhalesNominatorsDeposit",
      query_id: e,
      gas: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsDeposit" in loading "WhalesNominatorsDeposit", but data does not satisfy any constructor');
}
function wa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 362189324)
    return t.loadUint(32), {
      kind: "WhalesNominatorsForceKick",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsForceKick" in loading "WhalesNominatorsForceKick", but data does not satisfy any constructor');
}
function ka(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1958425639)
    return t.loadUint(32), {
      kind: "WhalesNominatorsStakeWithdrawDelayed",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsStakeWithdrawDelayed" in loading "WhalesNominatorsStakeWithdrawDelayed", but data does not satisfy any constructor');
}
function Sa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 601104865)
    return t.loadUint(32), {
      kind: "WhalesNominatorsStakeWithdrawCompleted",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsStakeWithdrawCompleted" in loading "WhalesNominatorsStakeWithdrawCompleted", but data does not satisfy any constructor');
}
function Ba(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2718326572) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadBuffer(256 / 8), r = t.loadUint(32), d = t.loadUint(32), i = t.loadBuffer(256 / 8), f2 = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "WhalesNominatorsSendStake",
      query_id: e,
      gas_limit: o4,
      stake: n,
      validator_pubkey: a2,
      stake_at: r,
      max_factor: d,
      adnl_addr: i,
      signature: f2
    };
  }
  throw new Error('Expected one of "WhalesNominatorsSendStake" in loading "WhalesNominatorsSendStake", but data does not satisfy any constructor');
}
function xa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 622684824) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "WhalesNominatorsWithdrawUnowned",
      query_id: e,
      gas_limit: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsWithdrawUnowned" in loading "WhalesNominatorsWithdrawUnowned", but data does not satisfy any constructor');
}
function ba(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 488052159)
    return t.loadUint(32), {
      kind: "WhalesNominatorsWithdrawUnownedResponse",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsWithdrawUnownedResponse" in loading "WhalesNominatorsWithdrawUnownedResponse", but data does not satisfy any constructor');
}
function Na(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2577928699) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "WhalesNominatorsAcceptStake",
      query_id: e,
      members: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsAcceptStake" in loading "WhalesNominatorsAcceptStake", but data does not satisfy any constructor');
}
function Pa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2711607604) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "WhalesNominatorsAcceptWithdraws",
      query_id: e,
      members: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsAcceptWithdraws" in loading "WhalesNominatorsAcceptWithdraws", but data does not satisfy any constructor');
}
const Ga = [
  {
    opCode: 1112786133,
    parse: ut,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_stake"
  },
  {
    opCode: 1227534771,
    parse: ft,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_unstake"
  },
  {
    opCode: 279039605,
    parse: pt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_deploy_unstake_request"
  },
  {
    opCode: 2429028871,
    parse: mt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_unstake_notification"
  },
  {
    opCode: 946025784,
    parse: gt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_return_unstake_request"
  },
  {
    opCode: 1544662441,
    parse: _t,
    fixedLength: false,
    folderName: "daolama",
    internalName: "daolama_vault_supply"
  },
  {
    opCode: 2078119902,
    parse: yt,
    fixedLength: false,
    folderName: "daolama",
    internalName: "daolama_vault_withdraw"
  },
  {
    opCode: 3043726744,
    parse: Ut,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_deposit_liquidity_all"
  },
  {
    opCode: 1643009069,
    parse: ct,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap_external"
  },
  {
    opCode: 1923917994,
    parse: Bt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap_peer"
  },
  {
    opCode: 2907617013,
    parse: xt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_payout_from_pool"
  },
  {
    opCode: 1196394191,
    parse: bt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_payout"
  },
  {
    opCode: 3926267997,
    parse: Et,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap"
  },
  {
    opCode: 3579725446,
    parse: Dt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_deposit_liquidity"
  },
  {
    opCode: 567271467,
    parse: qt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_create_vault"
  },
  {
    opCode: 2547326767,
    parse: Lt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_create_volatile_pool"
  },
  {
    opCode: 376237550,
    parse: vt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_cancel_deposit"
  },
  {
    opCode: 1322339173,
    parse: Vt,
    fixedLength: false,
    folderName: "dns",
    internalName: "dns_balance_release"
  },
  {
    opCode: 1320284409,
    parse: Ft,
    fixedLength: true,
    folderName: "dns",
    internalName: "delete_dns_record"
  },
  {
    opCode: 1320284409,
    parse: Wt,
    fixedLength: false,
    folderName: "dns",
    internalName: "change_dns_record"
  },
  {
    opCode: 1153347137,
    parse: Jt,
    fixedLength: false,
    folderName: "dns",
    internalName: "process_governance_decision"
  },
  {
    opCode: 923790417,
    parse: It,
    fixedLength: false,
    folderName: "dns",
    internalName: "auction_fill_up"
  },
  {
    opCode: 1434249760,
    parse: Ot,
    fixedLength: false,
    folderName: "dns",
    internalName: "outbid_notification"
  },
  {
    opCode: 1298755173,
    parse: Mt,
    fixedLength: false,
    folderName: "gram",
    internalName: "gram_submit_proof_of_work"
  },
  {
    opCode: 1027039654,
    parse: jt,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_deposit_coins"
  },
  {
    opCode: 1541764646,
    parse: Gt,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_proxy_tokens_minted"
  },
  {
    opCode: 1413869550,
    parse: $t,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_tokens_minted"
  },
  {
    opCode: 2057453237,
    parse: Kt,
    fixedLength: false,
    folderName: "invoices",
    internalName: "invoice_payload"
  },
  {
    opCode: 260734629,
    parse: zt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_transfer"
  },
  {
    opCode: 395134233,
    parse: Qt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_internal_transfer"
  },
  {
    opCode: 1499400124,
    parse: Zt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_burn"
  },
  {
    opCode: 2078119902,
    parse: Xt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_burn_notification"
  },
  {
    opCode: 1935855772,
    parse: Yt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_notify"
  },
  {
    opCode: 4006754003,
    parse: te,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_set_status"
  },
  {
    opCode: 1680571655,
    parse: ee,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_mint"
  },
  {
    opCode: 1694626644,
    parse: oe,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_change_admin"
  },
  {
    opCode: 4220051737,
    parse: ne,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_claim_admin"
  },
  {
    opCode: 593276754,
    parse: re,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_call_to"
  },
  {
    opCode: 621336170,
    parse: de,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_upgrade"
  },
  {
    opCode: 3414567170,
    parse: ie,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_change_metadata"
  },
  {
    opCode: 4294967295,
    parse: le,
    fixedLength: false,
    folderName: "known",
    internalName: "bounce"
  },
  {
    opCode: 0,
    parse: se,
    fixedLength: false,
    folderName: "known",
    internalName: "text_comment"
  },
  {
    opCode: 560454219,
    parse: ue,
    fixedLength: false,
    folderName: "known",
    internalName: "encrypted_text_comment"
  },
  {
    opCode: 3576854235,
    parse: fe,
    fixedLength: false,
    folderName: "known",
    internalName: "excess"
  },
  {
    opCode: 3547469196,
    parse: pe,
    fixedLength: true,
    folderName: "known",
    internalName: "top_up"
  },
  {
    opCode: 378586628,
    parse: me,
    fixedLength: true,
    folderName: "known",
    internalName: "credit"
  },
  {
    opCode: 2068529894,
    parse: ge,
    fixedLength: true,
    folderName: "known",
    internalName: "approve"
  },
  {
    opCode: 3902843902,
    parse: _e,
    fixedLength: true,
    folderName: "known",
    internalName: "disapprove"
  },
  {
    opCode: 1316189259,
    parse: ye,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_new_stake"
  },
  {
    opCode: 4084484172,
    parse: Ue,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_new_stake_confirmation"
  },
  {
    opCode: 1197831204,
    parse: he,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_recover_stake_request"
  },
  {
    opCode: 4184830756,
    parse: Ce,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_recover_stake_response"
  },
  {
    opCode: 3946265093,
    parse: ce,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_recover_stake"
  },
  {
    opCode: 4043121232,
    parse: we,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_update_validator_hash"
  },
  {
    opCode: 2399065977,
    parse: ke,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_withdraw_validator"
  },
  {
    opCode: 805462823,
    parse: Se,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_validator_withdrawal"
  },
  {
    opCode: 3763363086,
    parse: Be,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_new_stake"
  },
  {
    opCode: 1664463130,
    parse: xe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_send_request_loan"
  },
  {
    opCode: 3983767718,
    parse: be,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_return_unused_loan"
  },
  {
    opCode: 1438805205,
    parse: Ne,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_return_available_funds"
  },
  {
    opCode: 3863136613,
    parse: Ee,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_request_loan"
  },
  {
    opCode: 3755778683,
    parse: Ae,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_loan_repayment"
  },
  {
    opCode: 1205158801,
    parse: Te$1,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_deposit"
  },
  {
    opCode: 1271382751,
    parse: De,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_touch"
  },
  {
    opCode: 715822752,
    parse: Re,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_governance_fee"
  },
  {
    opCode: 832244956,
    parse: qe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_withdraw"
  },
  {
    opCode: 175592284,
    parse: Le,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_withdrawal"
  },
  {
    opCode: 1582399286,
    parse: ve,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_roles"
  },
  {
    opCode: 2616546844,
    parse: Ve,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_deposit_settings"
  },
  {
    opCode: 2994658477,
    parse: Fe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_deploy_controller"
  },
  {
    opCode: 2574354460,
    parse: We,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_prepare_governance_migration"
  },
  {
    opCode: 654743035,
    parse: Je,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_send_message"
  },
  {
    opCode: 2531783976,
    parse: Ie,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_upgrade"
  },
  {
    opCode: 2045231126,
    parse: Oe,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_set_sudoer"
  },
  {
    opCode: 1917314981,
    parse: Me,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_unhalt"
  },
  {
    opCode: 328866638,
    parse: je,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_halt"
  },
  {
    opCode: 3387966597,
    parse: Ge,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_set_interest"
  },
  {
    opCode: 1423144071,
    parse: $e,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_operation_fee"
  },
  {
    opCode: 2985012742,
    parse: He,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_request_notification"
  },
  {
    opCode: 3241429248,
    parse: Ke,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_stats"
  },
  {
    opCode: 4045930062,
    parse: ze,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_burn"
  },
  {
    opCode: 3982012594,
    parse: Qe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_burn_notification"
  },
  {
    opCode: 321886789,
    parse: Ze,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_init"
  },
  {
    opCode: 3678112445,
    parse: Xe,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_payout"
  },
  {
    opCode: 376746144,
    parse: Ye,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_payout_mint_jettons"
  },
  {
    opCode: 2007184673,
    parse: to,
    fixedLength: false,
    folderName: "megaton_fi",
    internalName: "megaton_wton_mint"
  },
  {
    opCode: 1607220500,
    parse: eo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "nft_transfer"
  },
  {
    opCode: 85167505,
    parse: oo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "nft_ownership_assigned"
  },
  {
    opCode: 801842850,
    parse: no,
    fixedLength: false,
    folderName: "nfts",
    internalName: "get_static_data"
  },
  {
    opCode: 2339837749,
    parse: ao,
    fixedLength: false,
    folderName: "nfts",
    internalName: "report_static_data"
  },
  {
    opCode: 1765620048,
    parse: ro,
    fixedLength: false,
    folderName: "nfts",
    internalName: "get_royalty_params"
  },
  {
    opCode: 2831876269,
    parse: io,
    fixedLength: false,
    folderName: "nfts",
    internalName: "report_royalty_params"
  },
  {
    opCode: 81711432,
    parse: lo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "prove_ownership"
  },
  {
    opCode: 86296494,
    parse: so,
    fixedLength: false,
    folderName: "nfts",
    internalName: "ownership_proof"
  },
  {
    opCode: 3502489578,
    parse: uo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_request_owner"
  },
  {
    opCode: 232130531,
    parse: fo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_owner_info"
  },
  {
    opCode: 520377210,
    parse: po,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_destroy"
  },
  {
    opCode: 1871312355,
    parse: mo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_revoke"
  },
  {
    opCode: 1741148801,
    parse: go,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "top_up_channel_balance"
  },
  {
    opCode: 235282626,
    parse: _o,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "init_payment_channel"
  },
  {
    opCode: 1433884798,
    parse: yo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_cooperative_close"
  },
  {
    opCode: 2040604399,
    parse: Uo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_cooperative_commit"
  },
  {
    opCode: 521476815,
    parse: co,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "start_uncooperative_channel_close"
  },
  {
    opCode: 143567410,
    parse: So,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "challenge_quarantined_channel_state"
  },
  {
    opCode: 1727459433,
    parse: Bo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "settle_channel_conditionals"
  },
  {
    opCode: 625158801,
    parse: xo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "finish_uncooperative_channel_close"
  },
  {
    opCode: 3722217658,
    parse: bo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_closed"
  },
  {
    opCode: 630424929,
    parse: Po,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_swap"
  },
  {
    opCode: 4181439551,
    parse: Eo,
    fixedLength: true,
    folderName: "ston_fi",
    internalName: "stonfi_payment_request"
  },
  {
    opCode: 32736093,
    parse: Ao,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_ton_transfer"
  },
  {
    opCode: 2921715614,
    parse: To,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_ton_refund"
  },
  {
    opCode: 701638965,
    parse: Do,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_reset_gas"
  },
  {
    opCode: 1331643155,
    parse: Ro,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_deploy_wallet"
  },
  {
    opCode: 1698746245,
    parse: qo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_internal_deploy"
  },
  {
    opCode: 116184359,
    parse: Lo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_cb_add_liquidity_v2"
  },
  {
    opCode: 935368415,
    parse: vo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_provide_lp_v2"
  },
  {
    opCode: 1355195988,
    parse: Vo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_add_liquidity_v2"
  },
  {
    opCode: 1702581493,
    parse: Fo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_pay_to_v2"
  },
  {
    opCode: 1717886506,
    parse: Wo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_swap_v2"
  },
  {
    opCode: 894160372,
    parse: Jo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_withdraw_fee_v2"
  },
  {
    opCode: 76607643,
    parse: Io,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_deposit_ref_fee_v2"
  },
  {
    opCode: 553699618,
    parse: Oo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_vault_pay_to_v2"
  },
  {
    opCode: 1664620082,
    parse: Mo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_pay_vault_v2"
  },
  {
    opCode: 695482319,
    parse: jo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_burn_notification_ext_v2"
  },
  {
    opCode: 3832843761,
    parse: $o,
    fixedLength: false,
    folderName: "storages",
    internalName: "deploy_storage_contract"
  },
  {
    opCode: 1408453846,
    parse: Ho,
    fixedLength: false,
    folderName: "storages",
    internalName: "update_pubkey"
  },
  {
    opCode: 1422651803,
    parse: Ko,
    fixedLength: false,
    folderName: "storages",
    internalName: "update_storage_params"
  },
  {
    opCode: 276580847,
    parse: zo,
    fixedLength: false,
    folderName: "storages",
    internalName: "offer_storage_contract"
  },
  {
    opCode: 2050365064,
    parse: Qo,
    fixedLength: false,
    folderName: "storages",
    internalName: "accept_storage_contract"
  },
  {
    opCode: 3570068941,
    parse: Zo,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_contract_confirmed"
  },
  {
    opCode: 2046375914,
    parse: Xo,
    fixedLength: false,
    folderName: "storages",
    internalName: "close_storage_contract"
  },
  {
    opCode: 3055775075,
    parse: Yo,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_contract_terminated"
  },
  {
    opCode: 1189949076,
    parse: tn,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_withdraw"
  },
  {
    opCode: 2837163862,
    parse: en,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_reward_withdrawal"
  },
  {
    opCode: 1100832077,
    parse: on,
    fixedLength: false,
    folderName: "storages",
    internalName: "proof_storage"
  },
  {
    opCode: 3989649062,
    parse: an,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_change_settings"
  },
  {
    opCode: 3058877505,
    parse: ln,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_pay_funding"
  },
  {
    opCode: 700515025,
    parse: sn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vamm_init"
  },
  {
    opCode: 3410877500,
    parse: fn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_mint_referral"
  },
  {
    opCode: 2229071226,
    parse: pn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_add_referral_amount"
  },
  {
    opCode: 4124371794,
    parse: mn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_withdraw_referral_amount"
  },
  {
    opCode: 1329122024,
    parse: gn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_mint_executor"
  },
  {
    opCode: 1574331769,
    parse: _n,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_add_executor_amount"
  },
  {
    opCode: 752771921,
    parse: yn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_withdraw_executor_amount"
  },
  {
    opCode: 880147922,
    parse: Cn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_trade_notification"
  },
  {
    opCode: 3365551844,
    parse: cn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_stake"
  },
  {
    opCode: 3585468845,
    parse: wn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_unstake"
  },
  {
    opCode: 700515025,
    parse: kn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_init"
  },
  {
    opCode: 316235805,
    parse: Bn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_take_referral_fees"
  },
  {
    opCode: 1729316393,
    parse: xn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_cancel_order"
  },
  {
    opCode: 2744665076,
    parse: Nn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_create_order"
  },
  {
    opCode: 3482375704,
    parse: An,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_complete_order"
  },
  {
    opCode: 2637088320,
    parse: Dn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_activate_order"
  },
  {
    opCode: 1625278071,
    parse: Ln,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_update_position"
  },
  {
    opCode: 1562056632,
    parse: Fn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_update_position_with_stop_loss"
  },
  {
    opCode: 982793446,
    parse: Wn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_order_created"
  },
  {
    opCode: 1775273593,
    parse: Jn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_order_canceled"
  },
  {
    opCode: 36101990,
    parse: In,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_request_withdraw_position"
  },
  {
    opCode: 2288366594,
    parse: Gn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_provide_position"
  },
  {
    opCode: 4145513419,
    parse: $n,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_deploy"
  },
  {
    opCode: 1685288050,
    parse: Hn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_destruct"
  },
  {
    opCode: 1350711532,
    parse: Kn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_reduce_payment"
  },
  {
    opCode: 4033639783,
    parse: zn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_payment_confirmed"
  },
  {
    opCode: 4166133070,
    parse: Qn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_withdraw_to_beneficiary"
  },
  {
    opCode: 1178019994,
    parse: ta,
    fixedLength: false,
    folderName: "telegram",
    internalName: "telemint_deploy"
  },
  {
    opCode: 1178019995,
    parse: ra,
    fixedLength: false,
    folderName: "telegram",
    internalName: "telemint_deploy_v2"
  },
  {
    opCode: 697974293,
    parse: sa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_deploy"
  },
  {
    opCode: 1215991425,
    parse: fa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_start_auction"
  },
  {
    opCode: 924203182,
    parse: pa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_cancel_auction"
  },
  {
    opCode: 2742684035,
    parse: ma,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_ok"
  },
  {
    opCode: 2754750433,
    parse: ga,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_return_bid"
  },
  {
    opCode: 1399341111,
    parse: ha,
    fixedLength: false,
    folderName: "tonkeeper_2fa",
    internalName: "tonkeeper_2fa_signed"
  },
  {
    opCode: 3665837821,
    parse: Ca,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_withdraw"
  },
  {
    opCode: 2077040623,
    parse: ca,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_deposit"
  },
  {
    opCode: 362189324,
    parse: wa,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_force_kick"
  },
  {
    opCode: 1958425639,
    parse: ka,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_stake_withdraw_delayed"
  },
  {
    opCode: 601104865,
    parse: Sa,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_stake_withdraw_completed"
  },
  {
    opCode: 2718326572,
    parse: Ba,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_send_stake"
  },
  {
    opCode: 622684824,
    parse: xa,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_withdraw_unowned"
  },
  {
    opCode: 488052159,
    parse: ba,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_withdraw_unowned_response"
  },
  {
    opCode: 2577928699,
    parse: Na,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_accept_stake"
  },
  {
    opCode: 2711607604,
    parse: Pa,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_accept_withdraws"
  }
], Ha = $("tlb-abi:internal");
$("tlb-abi:jetton");
const za = {
  1112786133: [0],
  1227534771: [1],
  279039605: [2],
  2429028871: [3],
  946025784: [4],
  1544662441: [5],
  2078119902: [6, 31],
  3043726744: [7],
  1643009069: [8],
  1923917994: [9],
  2907617013: [10],
  1196394191: [11],
  3926267997: [12],
  3579725446: [13],
  567271467: [14],
  2547326767: [15],
  376237550: [16],
  1322339173: [17],
  1320284409: [18, 19],
  1153347137: [20],
  923790417: [21],
  1434249760: [22],
  1298755173: [23],
  1027039654: [24],
  1541764646: [25],
  1413869550: [26],
  2057453237: [27],
  260734629: [28],
  395134233: [29],
  1499400124: [30],
  1935855772: [32],
  4006754003: [33],
  1680571655: [34],
  1694626644: [35],
  4220051737: [36],
  593276754: [37],
  621336170: [38],
  3414567170: [39],
  4294967295: [40],
  0: [41],
  560454219: [42],
  3576854235: [43],
  3547469196: [44],
  378586628: [45],
  2068529894: [46],
  3902843902: [47],
  1316189259: [48],
  4084484172: [49],
  1197831204: [50],
  4184830756: [51],
  3946265093: [52],
  4043121232: [53],
  2399065977: [54],
  805462823: [55],
  3763363086: [56],
  1664463130: [57],
  3983767718: [58],
  1438805205: [59],
  3863136613: [60],
  3755778683: [61],
  1205158801: [62],
  1271382751: [63],
  715822752: [64],
  832244956: [65],
  175592284: [66],
  1582399286: [67],
  2616546844: [68],
  2994658477: [69],
  2574354460: [70],
  654743035: [71],
  2531783976: [72],
  2045231126: [73],
  1917314981: [74],
  328866638: [75],
  3387966597: [76],
  1423144071: [77],
  2985012742: [78],
  3241429248: [79],
  4045930062: [80],
  3982012594: [81],
  321886789: [82],
  3678112445: [83],
  376746144: [84],
  2007184673: [85],
  1607220500: [86],
  85167505: [87],
  801842850: [88],
  2339837749: [89],
  1765620048: [90],
  2831876269: [91],
  81711432: [92],
  86296494: [93],
  3502489578: [94],
  232130531: [95],
  520377210: [96],
  1871312355: [97],
  1741148801: [98],
  235282626: [99],
  1433884798: [100],
  2040604399: [101],
  521476815: [102],
  143567410: [103],
  1727459433: [104],
  625158801: [105],
  3722217658: [106],
  630424929: [107],
  4181439551: [108],
  32736093: [109],
  2921715614: [110],
  701638965: [111],
  1331643155: [112],
  1698746245: [113],
  116184359: [114],
  935368415: [115],
  1355195988: [116],
  1702581493: [117],
  1717886506: [118],
  894160372: [119],
  76607643: [120],
  553699618: [121],
  1664620082: [122],
  695482319: [123],
  3832843761: [124],
  1408453846: [125],
  1422651803: [126],
  276580847: [127],
  2050365064: [128],
  3570068941: [129],
  2046375914: [130],
  3055775075: [131],
  1189949076: [132],
  2837163862: [133],
  1100832077: [134],
  3989649062: [135],
  3058877505: [136],
  700515025: [137, 147],
  3410877500: [138],
  2229071226: [139],
  4124371794: [140],
  1329122024: [141],
  1574331769: [142],
  752771921: [143],
  880147922: [144],
  3365551844: [145],
  3585468845: [146],
  316235805: [148],
  1729316393: [149],
  2744665076: [150],
  3482375704: [151],
  2637088320: [152],
  1625278071: [153],
  1562056632: [154],
  982793446: [155],
  1775273593: [156],
  36101990: [157],
  2288366594: [158],
  4145513419: [159],
  1685288050: [160],
  1350711532: [161],
  4033639783: [162],
  4166133070: [163],
  1178019994: [164],
  1178019995: [165],
  697974293: [166],
  1215991425: [167],
  924203182: [168],
  2742684035: [169],
  2754750433: [170],
  1399341111: [171],
  3665837821: [172],
  2077040623: [173],
  362189324: [174],
  1958425639: [175],
  601104865: [176],
  2718326572: [177],
  622684824: [178],
  488052159: [179],
  2577928699: [180],
  2711607604: [181]
};
function Za(t) {
  if (t.remainingBits < 32)
    return;
  const e = t.preloadUint(32), o4 = za[e];
  if (o4)
    for (const n of o4) {
      const a2 = Ga[n];
      try {
        const r = t.asCell().toBoc(), d = a2.parse(t);
        if (a2.fixedLength && (t.remainingBits !== 0 || t.remainingRefs !== 0))
          throw new Error("Invalid data length");
        return {
          opCode: a2.opCode,
          schema: a2.folderName,
          internal: a2.internalName,
          boc: r,
          data: d
        };
      } catch (r) {
        Ha("Failed to parse internal: %s", r);
      }
    }
}
function toAddressBookEntry(row) {
  return {
    domain: row.domain ?? void 0,
    address: asAddressFriendly(row.user_friendly),
    interfaces: row.interfaces
  };
}
function toAddressBook(addressBookV3) {
  const addressBook = {};
  for (const [_, row] of Object.entries(addressBookV3)) {
    const userFriendlyAddress = asAddressFriendly(row.user_friendly);
    addressBook[userFriendlyAddress] = toAddressBookEntry(row);
  }
  return addressBook;
}
function toTransactionEmulatedTrace(response) {
  return {
    mcBlockSeqno: response.mc_block_seqno,
    trace: toTransactionTraceNode(response.trace),
    transactions: Object.fromEntries(Object.entries(response.transactions ?? {}).map(([hash, tx]) => [Base64ToHex(hash), toTransaction(tx)])),
    actions: response.actions.map(toTransactionTraceAction),
    randSeed: Base64ToHex(response.rand_seed),
    isIncomplete: response.is_incomplete,
    codeCells: Object.fromEntries(Object.entries(response.code_cells ?? {}).map(([hash, cell]) => [Base64ToHex(hash), cell])),
    dataCells: Object.fromEntries(Object.entries(response.data_cells ?? {}).map(([hash, cell]) => [Base64ToHex(hash), cell])),
    metadata: {},
    // to be filled later
    addressBook: {}
    // to be filled later
  };
}
function toTransactionTraceNode(node) {
  return {
    txHash: node.tx_hash ? Base64ToHex(node.tx_hash) : void 0,
    inMsgHash: node.in_msg_hash ? Base64ToHex(node.in_msg_hash) : void 0,
    children: node.children?.map(toTransactionTraceNode) ?? []
  };
}
function toTransactionsResponse(response) {
  return {
    transactions: response.transactions?.map(toTransaction) ?? [],
    addressBook: toAddressBook(response.address_book)
  };
}
function toTransaction(tx) {
  return {
    account: asAddressFriendly(tx.account),
    accountStateBefore: toAccountState(tx.account_state_before),
    accountStateAfter: toAccountState(tx.account_state_after),
    description: toTransactionDescription(tx.description),
    hash: Base64ToHex(tx.hash),
    logicalTime: tx.lt,
    now: tx.now,
    mcBlockSeqno: tx.mc_block_seqno,
    traceExternalHash: Base64ToHex(tx.trace_external_hash),
    traceId: tx.trace_id ?? void 0,
    previousTransactionHash: tx.prev_trans_hash ? Base64ToHex(tx.prev_trans_hash) : void 0,
    previousTransactionLogicalTime: tx.prev_trans_lt ?? void 0,
    origStatus: toAccountStatus(tx.orig_status),
    endStatus: toAccountStatus(tx.end_status),
    totalFees: tx.total_fees,
    totalFeesExtraCurrencies: tx.total_fees_extra_currencies,
    blockRef: toTransactionBlockRef(tx.block_ref),
    inMessage: tx.in_msg ? toTransactionMessage(tx.in_msg) : void 0,
    outMessages: tx.out_msgs?.map(toTransactionMessage) ?? [],
    isEmulated: tx.emulated
  };
}
function toAccountStatus(status) {
  if (status === "active") {
    return { type: "active" };
  } else if (status === "frozen") {
    return { type: "frozen" };
  } else if (status === "uninit") {
    return { type: "uninit" };
  } else {
    return { type: "unknown", value: status };
  }
}
function toTransactionBlockRef(ref) {
  return {
    workchain: ref.workchain,
    shard: ref.shard,
    seqno: ref.seqno
  };
}
function toTransactionDescription(desc) {
  return {
    type: desc.type,
    isAborted: desc.aborted,
    isDestroyed: desc.destroyed,
    isCreditFirst: desc.credit_first,
    isTock: desc.is_tock,
    isInstalled: desc.installed,
    storagePhase: {
      storageFeesCollected: desc.storage_ph?.storage_fees_collected,
      statusChange: desc.storage_ph?.status_change
    },
    creditPhase: desc.credit_ph ? {
      credit: desc.credit_ph?.credit
    } : void 0,
    computePhase: {
      isSkipped: desc.compute_ph?.skipped,
      isSuccess: desc.compute_ph?.success,
      isMessageStateUsed: desc.compute_ph?.msg_state_used,
      isAccountActivated: desc.compute_ph?.account_activated,
      gasFees: desc.compute_ph?.gas_fees,
      gasUsed: desc.compute_ph?.gas_used,
      gasLimit: desc.compute_ph?.gas_limit,
      gasCredit: desc.compute_ph?.gas_credit,
      mode: desc.compute_ph?.mode,
      exitCode: desc.compute_ph?.exit_code,
      vmStepsNumber: desc.compute_ph?.vm_steps,
      vmInitStateHash: desc.compute_ph?.vm_init_state_hash ? Base64ToHex(desc.compute_ph.vm_init_state_hash) : void 0,
      vmFinalStateHash: desc.compute_ph?.vm_final_state_hash ? Base64ToHex(desc.compute_ph.vm_final_state_hash) : void 0
    },
    action: {
      isSuccess: desc.action?.success,
      isValid: desc.action?.valid,
      hasNoFunds: desc.action?.no_funds,
      statusChange: desc.action?.status_change,
      totalForwardingFees: desc.action?.total_fwd_fees,
      totalActionFees: desc.action?.total_action_fees,
      resultCode: desc.action?.result_code,
      totalActionsNumber: desc.action?.tot_actions,
      specActionsNumber: desc.action?.spec_actions,
      skippedActionsNumber: desc.action?.skipped_actions,
      messagesCreatedNumber: desc.action?.msgs_created,
      actionListHash: desc.action?.action_list_hash ? Base64ToHex(desc.action.action_list_hash) : void 0,
      totalMessagesSize: {
        cells: desc.action?.tot_msg_size.cells,
        bits: desc.action?.tot_msg_size.bits
      }
    }
  };
}
function toTransactionMessage(msg) {
  return {
    hash: Base64ToHex(msg.hash),
    normalizedHash: msg.hash_norm ? Base64ToHex(msg.hash_norm) : void 0,
    source: asMaybeAddressFriendly(msg.source) ?? void 0,
    destination: asMaybeAddressFriendly(msg.destination) ?? void 0,
    value: msg.value ?? void 0,
    valueExtraCurrencies: msg.value_extra_currencies,
    fwdFee: msg.fwd_fee ?? void 0,
    ihrFee: msg.ihr_fee ?? void 0,
    creationLogicalTime: msg.created_lt ?? void 0,
    createdAt: msg.created_at ? Number(msg.created_at) : void 0,
    ihrDisabled: msg.ihr_disabled ?? void 0,
    isBounce: msg.bounce ?? void 0,
    isBounced: msg.bounced ?? void 0,
    importFee: msg.import_fee ?? void 0,
    opcode: msg.opcode ?? void 0,
    messageContent: {
      hash: msg.message_content?.hash ? Base64ToHex(msg.message_content.hash) : void 0,
      body: msg.message_content?.body ? msg.message_content.body : void 0,
      decoded: msg.message_content?.decoded ?? void 0
    }
  };
}
function toAccountState(state) {
  return {
    hash: Base64ToHex(state.hash),
    balance: state.balance,
    extraCurrencies: state.extra_currencies ?? void 0,
    accountStatus: state.account_status ? toAccountStatus(state.account_status) : void 0,
    frozenHash: state.frozen_hash ? Base64ToHex(state.frozen_hash) : void 0,
    dataHash: state.data_hash ? Base64ToHex(state.data_hash) : void 0,
    codeHash: state.code_hash ? Base64ToHex(state.code_hash) : void 0
  };
}
function toTransactionTraceAction(action) {
  return {
    traceId: action.trace_id ?? void 0,
    actionId: action.action_id,
    startLt: action.start_lt,
    endLt: action.end_lt,
    startUtime: action.start_utime,
    endUtime: action.end_utime,
    traceEndLt: action.trace_end_lt,
    traceEndUtime: action.trace_end_utime,
    traceMcSeqnoEnd: action.trace_mc_seqno_end,
    transactions: action.transactions.map(Base64ToHex),
    isSuccess: action.success,
    traceExternalHash: Base64ToHex(action.trace_external_hash),
    // Filter out invalid addresses
    accounts: (action.accounts ?? []).map(asMaybeAddressFriendly).filter((addr) => addr !== null),
    details: toTransactionTraceActionDetails(action)
  };
}
function toTransactionTraceActionDetails(action) {
  if (action.type === "jetton_swap") {
    return {
      type: "jetton_swap",
      value: toTransactionTraceActionJettonSwapDetails(action.details)
    };
  } else if (action.type === "call_contract") {
    return {
      type: "call_contract",
      value: toTransactionTraceActionCallContractDetails(action.details)
    };
  } else if (action.type === "ton_transfer") {
    return {
      type: "ton_transfer",
      value: toTransactionTraceActionTONTransferDetails(action.details)
    };
  } else {
    return {
      type: "unknown",
      value: action.details
    };
  }
}
function toTransactionTraceActionJettonSwapDetails(details) {
  return {
    dex: details.dex,
    sender: asMaybeAddressFriendly(details.sender) ?? void 0,
    dexIncomingTransfer: {
      asset: asMaybeAddressFriendly(details.dex_incoming_transfer?.asset) ?? void 0,
      source: asMaybeAddressFriendly(details.dex_incoming_transfer?.source) ?? void 0,
      destination: asMaybeAddressFriendly(details.dex_incoming_transfer?.destination) ?? void 0,
      sourceJettonWallet: asMaybeAddressFriendly(details.dex_incoming_transfer?.source_jetton_wallet) ?? void 0,
      destinationJettonWallet: asMaybeAddressFriendly(details.dex_incoming_transfer?.destination_jetton_wallet) ?? void 0,
      amount: details.dex_incoming_transfer?.amount
    },
    dexOutgoingTransfer: {
      asset: asMaybeAddressFriendly(details.dex_outgoing_transfer?.asset) ?? void 0,
      source: asMaybeAddressFriendly(details.dex_outgoing_transfer?.source) ?? void 0,
      destination: asMaybeAddressFriendly(details.dex_outgoing_transfer?.destination) ?? void 0,
      sourceJettonWallet: asMaybeAddressFriendly(details.dex_outgoing_transfer?.source_jetton_wallet) ?? void 0,
      destinationJettonWallet: asMaybeAddressFriendly(details.dex_outgoing_transfer?.destination_jetton_wallet) ?? void 0,
      amount: details.dex_outgoing_transfer?.amount
    },
    peerSwaps: details.peer_swaps
  };
}
function toTransactionTraceActionCallContractDetails(details) {
  return {
    opcode: details.opcode,
    source: asMaybeAddressFriendly(details.source) ?? void 0,
    destination: asMaybeAddressFriendly(details.destination) ?? void 0,
    value: details.value,
    valueExtraCurrencies: details.extra_currencies ?? void 0
  };
}
function toTransactionTraceActionTONTransferDetails(details) {
  return {
    source: asMaybeAddressFriendly(details.source) ?? void 0,
    destination: asMaybeAddressFriendly(details.destination) ?? void 0,
    value: details.value,
    valueExtraCurrencies: details.value_extra_currencies,
    comment: details.comment ?? void 0,
    isEncrypted: details.encrypted
  };
}
var AssetType;
(function(AssetType2) {
  AssetType2["ton"] = "ton";
  AssetType2["jetton"] = "jetton";
  AssetType2["nft"] = "nft";
})(AssetType || (AssetType = {}));
const Network = {
  /**
   * TON Mainnet (chain ID: -239)
   */
  mainnet: () => ({ chainId: "-239" }),
  /**
   * TON Testnet (chain ID: -3)
   */
  testnet: () => ({ chainId: "-3" }),
  /**
   * Custom network with specified chain ID
   */
  custom: (chainId) => ({ chainId })
};
var Result$1;
(function(Result2) {
  Result2["success"] = "success";
  Result2["failure"] = "failure";
})(Result$1 || (Result$1 = {}));
const TON_PROXY_ADDRESSES = [
  "EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez",
  "EQBnGWMCf3-FZZq1W4IWcWiGAc3PHuZ0_H-7sad2oY00o83S"
];
function processToncenterMoneyFlow(emulation) {
  if (!emulation || !emulation.transactions) {
    return {
      outputs: "0",
      inputs: "0",
      allJettonTransfers: [],
      ourTransfers: [],
      ourAddress: void 0
    };
  }
  const firstTx = emulation.transactions[emulation.trace.tx_hash];
  const ourTxes = Object.values(emulation.transactions).filter((t) => t.account === firstTx.account);
  const messagesFrom = ourTxes.flatMap((t) => t.out_msgs);
  const messagesTo = ourTxes.flatMap((t) => t.in_msg).filter((m2) => m2 !== null);
  const outputs = messagesFrom.reduce((acc, m2) => {
    if (m2.value) {
      return acc + BigInt(m2.value);
    }
    return acc + 0n;
  }, 0n).toString();
  const inputs = messagesTo.reduce((acc, m2) => {
    if (m2.value) {
      return acc + BigInt(m2.value);
    }
    return acc + 0n;
  }, 0n).toString();
  const jettonTransfers = [];
  for (const t of Object.values(emulation.transactions)) {
    if (!t.in_msg?.source) {
      continue;
    }
    const parsed = Za(distExports$2.Cell.fromBase64(t.in_msg.message_content.body).beginParse());
    if (parsed?.internal !== "jetton_transfer") {
      continue;
    }
    const from = asMaybeAddressFriendly(t.in_msg.source);
    const to2 = parsed.data.destination instanceof distExports$2.Address ? parsed.data.destination : null;
    if (!to2) {
      continue;
    }
    const jettonAmount = parsed.data.amount;
    const metadata = emulation.metadata[t.account];
    if (!metadata || !metadata?.token_info) {
      continue;
    }
    const tokenInfo = metadata.token_info.find((t2) => t2.valid && t2.type === "jetton_wallets");
    if (!tokenInfo) {
      continue;
    }
    const jettonAddress = asMaybeAddressFriendly(tokenInfo.extra.jetton);
    jettonTransfers.push({
      fromAddress: from ?? void 0,
      toAddress: asMaybeAddressFriendly(to2.toString()) ?? void 0,
      tokenAddress: jettonAddress ?? void 0,
      amount: jettonAmount.toString(),
      assetType: AssetType.jetton
    });
  }
  const ourAddress = distExports$2.Address.parse(firstTx.account);
  const selfTransfers = [];
  const ourJettonTransfersByAddress = jettonTransfers.reduce((acc, transfer) => {
    if (transfer.assetType !== AssetType.jetton) {
      return acc;
    }
    const jettonKey = transfer.tokenAddress?.toString() || "unknown";
    if (TON_PROXY_ADDRESSES.includes(jettonKey)) {
      return acc;
    }
    const rawKey = distExports$2.Address.parse(jettonKey).toRawString().toUpperCase();
    if (!acc[rawKey]) {
      acc[rawKey] = 0n;
    }
    if (ourAddress && transfer.toAddress === ourAddress.toString()) {
      acc[rawKey] += BigInt(transfer.amount);
    }
    if (ourAddress && transfer.fromAddress === ourAddress.toString()) {
      acc[rawKey] -= BigInt(transfer.amount);
    }
    return acc;
  }, {});
  const ourJettonTransfers = Object.entries(ourJettonTransfersByAddress).map(([jettonKey, amount]) => ({
    assetType: AssetType.jetton,
    tokenAddress: asMaybeAddressFriendly(jettonKey) ?? void 0,
    amount: amount.toString()
  }));
  selfTransfers.push({
    assetType: AssetType.ton,
    amount: (BigInt(inputs) - BigInt(outputs)).toString()
  });
  selfTransfers.push(...ourJettonTransfers);
  return {
    outputs,
    inputs,
    allJettonTransfers: jettonTransfers,
    ourTransfers: selfTransfers,
    ourAddress: asAddressFriendly(ourAddress)
  };
}
async function createTransactionPreview(client, request, wallet) {
  const txData = await wallet?.getSignedSendTransaction(request, { fakeSignature: true });
  if (!txData) {
    return {
      result: Result$1.failure,
      error: {
        code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
        message: "Unknown emulation error"
      }
    };
  }
  let emulationResult;
  try {
    const emulatedResult = await CallForSuccess(() => client.fetchEmulation(txData, true));
    if (emulatedResult.result === "success") {
      emulationResult = emulatedResult.emulationResult;
    } else {
      return {
        result: Result$1.failure,
        error: {
          code: emulatedResult.emulationError.code,
          message: emulatedResult.emulationError.message
        }
      };
    }
  } catch (_error) {
    return {
      result: Result$1.failure,
      error: {
        code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
        message: "Unknown emulation error"
      }
    };
  }
  const moneyFlow = processToncenterMoneyFlow(emulationResult);
  return {
    result: Result$1.success,
    trace: toTransactionEmulatedTrace(emulationResult),
    moneyFlow
  };
}
const log$f = globalLogger.createChild("TransactionHandler");
class TransactionHandler extends BasicHandler {
  config;
  walletManager;
  sessionManager;
  eventEmitter;
  analytics;
  constructor(notify, config, eventEmitter, walletManager, sessionManager, analyticsManager) {
    super(notify);
    this.config = config;
    this.walletManager = walletManager;
    this.sessionManager = sessionManager;
    this.eventEmitter = eventEmitter;
    this.sessionManager = sessionManager;
    this.analytics = analyticsManager?.scoped();
  }
  canHandle(event) {
    return event.method === "sendTransaction";
  }
  async handle(event) {
    const walletId = event.walletId;
    const walletAddress = event.walletAddress;
    if (!walletId && !walletAddress) {
      log$f.error("Wallet ID not found", { event });
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
          message: "Wallet ID not found"
        },
        id: event.id
      };
    }
    const wallet = walletId ? this.walletManager.getWallet(walletId) : void 0;
    if (!wallet) {
      log$f.error("Wallet not found", { event, walletId, walletAddress });
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
          message: "Wallet not found"
        },
        id: event.id
      };
    }
    const requestValidation = this.parseTonConnectTransactionRequest(event, wallet);
    if (!requestValidation.result || !requestValidation?.validation?.isValid) {
      log$f.error("Failed to parse transaction request", { event, requestValidation });
      this.eventEmitter.emit("event:error", event);
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR,
          message: "Failed to parse transaction request"
        },
        id: event.id
      };
    }
    const request = requestValidation.result;
    let preview;
    if (!this.config.eventProcessor?.disableTransactionEmulation) {
      try {
        preview = await CallForSuccess(() => createTransactionPreview(wallet.client, request, wallet));
        if (preview.result === Result$1.success && preview.trace) {
          try {
            this.eventEmitter.emit("emulation:result", preview.trace);
          } catch (error2) {
            log$f.warn("Error emitting emulation result event", { error: error2 });
          }
        }
      } catch (error2) {
        log$f.error("Failed to create transaction preview", { error: error2 });
        preview = {
          error: {
            code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
            message: "Unknown emulation error"
          },
          result: Result$1.failure
        };
      }
    }
    const txEvent = {
      ...event,
      request,
      preview: {
        data: preview
      },
      dAppInfo: event.dAppInfo ?? {},
      walletId: walletId ?? this.walletManager.getWalletId(wallet),
      walletAddress: walletAddress ?? wallet.getAddress()
    };
    if (this.analytics) {
      const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
      this.analytics?.emitWalletTransactionRequestReceived({
        trace_id: event.traceId,
        client_id: event.from,
        wallet_id: sessionData?.publicKey,
        dapp_name: event.dAppInfo?.name,
        network_id: wallet.getNetwork().chainId,
        // manifest_json_url: event.dAppInfo?.url, // todo
        origin_url: event.dAppInfo?.url
      });
    }
    return txEvent;
  }
  /**
   * Parse raw transaction request from bridge event
   */
  parseTonConnectTransactionRequest(event, wallet) {
    let errors2 = [];
    try {
      if (event.params.length !== 1) {
        throw new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "Invalid transaction request - expected exactly 1 parameter", void 0, { paramCount: event.params.length, eventId: event.id });
      }
      const params = JSON.parse(event.params[0]);
      const validUntilValidation = this.validateValidUntil(params.valid_until);
      if (!validUntilValidation.isValid) {
        errors2 = errors2.concat(validUntilValidation.errors);
      } else {
        params.valid_until = validUntilValidation.result;
      }
      const networkValidation = this.validateNetwork(params.network, wallet);
      if (!networkValidation.isValid) {
        errors2 = errors2.concat(networkValidation.errors);
      } else {
        params.network = networkValidation.result;
      }
      const fromValidation = this.validateFrom(params.from, wallet);
      if (!fromValidation.isValid) {
        errors2 = errors2.concat(fromValidation.errors);
      } else {
        params.from = fromValidation.result;
      }
      const isTonConnect = !event.isLocal;
      const messagesValidation = validateTransactionMessages(params.messages, isTonConnect);
      if (!messagesValidation.isValid) {
        errors2 = errors2.concat(messagesValidation.errors);
      }
      return {
        result: toTransactionRequest(params),
        validation: { isValid: errors2.length === 0, errors: errors2 }
      };
    } catch (error2) {
      log$f.error("Failed to parse transaction request", { error: error2 });
      errors2.push("Failed to parse transaction request");
      return {
        result: void 0,
        validation: { isValid: errors2.length === 0, errors: errors2 }
      };
    }
  }
  /**
   * Parse network from various possible formats
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateNetwork(network, wallet) {
    let errors2 = [];
    if (typeof network === "string") {
      if (network === "-3" || network === "-239") {
        const chain = network === "-3" ? CHAIN.TESTNET : CHAIN.MAINNET;
        const walletNetwork = wallet.getNetwork();
        if (chain !== walletNetwork.chainId) {
          errors2.push("Invalid network not equal to wallet network");
        } else {
          return { result: chain, isValid: errors2.length === 0, errors: errors2 };
        }
      } else {
        errors2.push("Invalid network not a valid network");
      }
    } else {
      errors2.push("Invalid network not a string");
    }
    return { result: void 0, isValid: errors2.length === 0, errors: errors2 };
  }
  validateFrom(from, wallet) {
    let errors2 = [];
    if (typeof from !== "string") {
      errors2.push("Invalid from address not a string");
      return { result: "", isValid: errors2.length === 0, errors: errors2 };
    }
    if (!isValidAddress(from)) {
      errors2.push("Invalid from address");
      return { result: "", isValid: errors2.length === 0, errors: errors2 };
    }
    const fromAddress = distExports$2.Address.parse(from);
    const walletAddress = distExports$2.Address.parse(wallet.getAddress());
    if (!fromAddress.equals(walletAddress)) {
      errors2.push("Invalid from address not equal to wallet address");
      return { result: "", isValid: errors2.length === 0, errors: errors2 };
    }
    return { result: from, isValid: errors2.length === 0, errors: errors2 };
  }
  /**
   * Parse validUntil timestamp
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateValidUntil(validUntil) {
    let errors2 = [];
    if (typeof validUntil === "undefined") {
      return { result: 0, isValid: errors2.length === 0, errors: errors2 };
    }
    if (typeof validUntil !== "number" || isNaN(validUntil)) {
      errors2.push("Invalid validUntil timestamp not a number");
      return { result: 0, isValid: errors2.length === 0, errors: errors2 };
    }
    const now = Math.floor(Date.now() / 1e3);
    if (validUntil < now) {
      errors2.push("Invalid validUntil timestamp");
      return { result: 0, isValid: errors2.length === 0, errors: errors2 };
    }
    return { result: validUntil, isValid: errors2.length === 0, errors: errors2 };
  }
}
var dist$2 = {};
var parser = {};
var dist$1 = {};
var Address = {};
var crc16 = {};
var hasRequiredCrc16;
function requireCrc16() {
  if (hasRequiredCrc16) return crc16;
  hasRequiredCrc16 = 1;
  Object.defineProperty(crc16, "__esModule", { value: true });
  crc16.crc16 = void 0;
  function crc16$12(data) {
    const poly = 4129;
    let reg = 0;
    const message = Buffer.alloc(data.length + 2);
    message.set(data);
    for (let byte of message) {
      let mask = 128;
      while (mask > 0) {
        reg <<= 1;
        if (byte & mask) {
          reg += 1;
        }
        mask >>= 1;
        if (reg > 65535) {
          reg &= 65535;
          reg ^= poly;
        }
      }
    }
    return Buffer.from([Math.floor(reg / 256), reg % 256]);
  }
  crc16.crc16 = crc16$12;
  return crc16;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return Address;
  hasRequiredAddress = 1;
  var __importDefault = Address && Address.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Address, "__esModule", { value: true });
  Address.address = Address.Address = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const crc16_1 = requireCrc16();
  const bounceable_tag = 17;
  const non_bounceable_tag = 81;
  const test_flag = 128;
  function parseFriendlyAddress(src) {
    if (typeof src === "string" && !Address$12.isFriendly(src)) {
      throw new Error("Unknown address type");
    }
    const data = Buffer.isBuffer(src) ? src : Buffer.from(src, "base64");
    if (data.length !== 36) {
      throw new Error("Unknown address type: byte length is not equal to 36");
    }
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
      throw new Error("Invalid checksum: " + src);
    }
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
      isTestOnly = true;
      tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag)
      throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 255) {
      workchain = -1;
    } else {
      workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return { isTestOnly, isBounceable, workchain, hashPart };
  }
  let Address$12 = class Address2 {
    static isAddress(src) {
      return src instanceof Address2;
    }
    static isFriendly(source) {
      if (source.length !== 48) {
        return false;
      }
      if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
        return false;
      }
      return true;
    }
    static isRaw(source) {
      if (source.indexOf(":") === -1) {
        return false;
      }
      let [wc, hash] = source.split(":");
      if (!Number.isInteger(parseFloat(wc))) {
        return false;
      }
      if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
        return false;
      }
      if (hash.length !== 64) {
        return false;
      }
      return true;
    }
    static normalize(source) {
      if (typeof source === "string") {
        return Address2.parse(source).toString();
      } else {
        return source.toString();
      }
    }
    static parse(source) {
      if (Address2.isFriendly(source)) {
        return this.parseFriendly(source).address;
      } else if (Address2.isRaw(source)) {
        return this.parseRaw(source);
      } else {
        throw new Error("Unknown address type: " + source);
      }
    }
    static parseRaw(source) {
      let workChain = parseInt(source.split(":")[0]);
      let hash = Buffer.from(source.split(":")[1], "hex");
      return new Address2(workChain, hash);
    }
    static parseFriendly(source) {
      if (Buffer.isBuffer(source)) {
        let r = parseFriendlyAddress(source);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      } else {
        let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
        let r = parseFriendlyAddress(addr);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      }
    }
    constructor(workChain, hash) {
      this.toRawString = () => {
        return this.workChain + ":" + this.hash.toString("hex");
      };
      this.toRaw = () => {
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(this.hash);
        addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
        return addressWithChecksum;
      };
      this.toStringBuffer = (args) => {
        let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
        let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
        let tag = bounceable ? bounceable_tag : non_bounceable_tag;
        if (testOnly) {
          tag |= test_flag;
        }
        const addr = Buffer.alloc(34);
        addr[0] = tag;
        addr[1] = this.workChain;
        addr.set(this.hash, 2);
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(addr);
        addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
        return addressWithChecksum;
      };
      this.toString = (args) => {
        let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
        let buffer2 = this.toStringBuffer(args);
        if (urlSafe) {
          return buffer2.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
        } else {
          return buffer2.toString("base64");
        }
      };
      this[_a2] = () => this.toString();
      if (hash.length !== 32) {
        throw new Error("Invalid address hash length: " + hash.length);
      }
      this.workChain = workChain;
      this.hash = hash;
      Object.freeze(this);
    }
    equals(src) {
      if (src.workChain !== this.workChain) {
        return false;
      }
      return src.hash.equals(this.hash);
    }
  };
  Address.Address = Address$12;
  _a2 = symbol_inspect_1.default;
  function address(src) {
    return Address$12.parse(src);
  }
  Address.address = address;
  return Address;
}
var ExternalAddress = {};
var hasRequiredExternalAddress;
function requireExternalAddress() {
  if (hasRequiredExternalAddress) return ExternalAddress;
  hasRequiredExternalAddress = 1;
  var __importDefault = ExternalAddress && ExternalAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(ExternalAddress, "__esModule", { value: true });
  ExternalAddress.ExternalAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let ExternalAddress$12 = class ExternalAddress2 {
    static isAddress(src) {
      return src instanceof ExternalAddress2;
    }
    constructor(value, bits) {
      this[_a2] = () => this.toString();
      this.value = value;
      this.bits = bits;
    }
    toString() {
      return `External<${this.bits}:${this.value}>`;
    }
  };
  ExternalAddress.ExternalAddress = ExternalAddress$12;
  _a2 = symbol_inspect_1.default;
  return ExternalAddress;
}
var ADNLAddress = {};
var base32 = {};
var hasRequiredBase32;
function requireBase32() {
  if (hasRequiredBase32) return base32;
  hasRequiredBase32 = 1;
  Object.defineProperty(base32, "__esModule", { value: true });
  base32.base32Decode = base32.base32Encode = void 0;
  const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  function base32Encode(buffer2) {
    const length = buffer2.byteLength;
    let bits = 0;
    let value = 0;
    let output = "";
    for (let i = 0; i < length; i++) {
      value = value << 8 | buffer2[i];
      bits += 8;
      while (bits >= 5) {
        output += alphabet[value >>> bits - 5 & 31];
        bits -= 5;
      }
    }
    if (bits > 0) {
      output += alphabet[value << 5 - bits & 31];
    }
    return output;
  }
  base32.base32Encode = base32Encode;
  function readChar(alphabet2, char) {
    const idx = alphabet2.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index2 = 0;
    const output = Buffer.alloc(length * 5 / 8 | 0);
    for (let i = 0; i < length; i++) {
      value = value << 5 | readChar(alphabet, cleanedInput[i]);
      bits += 5;
      if (bits >= 8) {
        output[index2++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output;
  }
  base32.base32Decode = base32Decode;
  return base32;
}
var hasRequiredADNLAddress;
function requireADNLAddress() {
  if (hasRequiredADNLAddress) return ADNLAddress;
  hasRequiredADNLAddress = 1;
  var __importDefault = ADNLAddress && ADNLAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(ADNLAddress, "__esModule", { value: true });
  ADNLAddress.ADNLAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const base32_1 = requireBase32();
  const crc16_1 = requireCrc16();
  let ADNLAddress$12 = class ADNLAddress2 {
    static parseFriendly(src) {
      if (src.length !== 55) {
        throw Error("Invalid address");
      }
      src = "f" + src;
      let decoded = (0, base32_1.base32Decode)(src);
      if (decoded[0] !== 45) {
        throw Error("Invalid address");
      }
      let gotHash = decoded.slice(33);
      let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
      if (!hash.equals(gotHash)) {
        throw Error("Invalid address");
      }
      return new ADNLAddress2(decoded.slice(1, 33));
    }
    static parseRaw(src) {
      const data = Buffer.from(src, "base64");
      return new ADNLAddress2(data);
    }
    constructor(address) {
      this.toRaw = () => {
        return this.address.toString("hex").toUpperCase();
      };
      this.toString = () => {
        let data = Buffer.concat([Buffer.from([45]), this.address]);
        let hash = (0, crc16_1.crc16)(data);
        data = Buffer.concat([data, hash]);
        return (0, base32_1.base32Encode)(data).slice(1);
      };
      this[_a2] = () => this.toString();
      if (address.length !== 32) {
        throw Error("Invalid address");
      }
      this.address = address;
    }
    equals(b2) {
      return this.address.equals(b2.address);
    }
  };
  ADNLAddress.ADNLAddress = ADNLAddress$12;
  _a2 = symbol_inspect_1.default;
  return ADNLAddress;
}
var contractAddress = {};
var Builder$3 = {};
var BitBuilder = {};
var BitString = {};
var paddedBits = {};
var hasRequiredPaddedBits;
function requirePaddedBits() {
  if (hasRequiredPaddedBits) return paddedBits;
  hasRequiredPaddedBits = 1;
  Object.defineProperty(paddedBits, "__esModule", { value: true });
  paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const BitString_1 = requireBitString();
  function bitsToPaddedBuffer(bits) {
    let builder2 = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder2.writeBits(bits);
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for (let i = 0; i < padding; i++) {
      if (i === 0) {
        builder2.writeBit(1);
      } else {
        builder2.writeBit(0);
      }
    }
    return builder2.buffer();
  }
  paddedBits.bitsToPaddedBuffer = bitsToPaddedBuffer;
  function paddedBufferToBits(buff) {
    let bitLen = 0;
    for (let i = buff.length - 1; i >= 0; i--) {
      if (buff[i] !== 0) {
        const testByte = buff[i];
        let bitPos = testByte & -testByte;
        if ((bitPos & 1) == 0) {
          bitPos = Math.log2(bitPos) + 1;
        }
        if (i > 0) {
          bitLen = i << 3;
        }
        bitLen += 8 - bitPos;
        break;
      }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
  }
  paddedBits.paddedBufferToBits = paddedBufferToBits;
  return paddedBits;
}
var hasRequiredBitString;
function requireBitString() {
  if (hasRequiredBitString) return BitString;
  hasRequiredBitString = 1;
  var __importDefault = BitString && BitString.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(BitString, "__esModule", { value: true });
  BitString.BitString = void 0;
  const paddedBits_1 = requirePaddedBits();
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let BitString$12 = class BitString2 {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/
    static isBitString(src) {
      return src instanceof BitString2;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */
    constructor(data, offset, length) {
      this[_a2] = () => this.toString();
      if (length < 0) {
        throw new Error(`Length ${length} is out of bounds`);
      }
      this._length = length;
      this._data = data;
      this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */
    at(index2) {
      if (index2 >= this._length) {
        throw new Error(`Index ${index2} > ${this._length} is out of bounds`);
      }
      if (index2 < 0) {
        throw new Error(`Index ${index2} < 0 is out of bounds`);
      }
      let byteIndex = this._offset + index2 >> 3;
      let bitIndex = 7 - (this._offset + index2) % 8;
      return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */
    substring(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset(${offset}) < 0 is out of bounds`);
      }
      if (length === 0) {
        return BitString2.EMPTY;
      }
      if (offset + length > this._length) {
        throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
      }
      return new BitString2(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */
    subbuffer(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset + length > this._length) {
        throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
      }
      if (length % 8 !== 0) {
        return null;
      }
      if ((this._offset + offset) % 8 !== 0) {
        return null;
      }
      let start = this._offset + offset >> 3;
      let end2 = start + (length >> 3);
      return this._data.subarray(start, end2);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */
    equals(b2) {
      if (this._length !== b2._length) {
        return false;
      }
      for (let i = 0; i < this._length; i++) {
        if (this.at(i) !== b2.at(i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */
    toString() {
      const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
      if (this._length % 4 === 0) {
        const s2 = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
        if (this._length % 8 === 0) {
          return s2;
        } else {
          return s2.substring(0, s2.length - 1);
        }
      } else {
        const hex = padded.toString("hex").toUpperCase();
        if (this._length % 8 <= 4) {
          return hex.substring(0, hex.length - 1) + "_";
        } else {
          return hex + "_";
        }
      }
    }
  };
  BitString.BitString = BitString$12;
  _a2 = symbol_inspect_1.default;
  BitString$12.EMPTY = new BitString$12(Buffer.alloc(0), 0, 0);
  return BitString;
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
  if (hasRequiredBitBuilder) return BitBuilder;
  hasRequiredBitBuilder = 1;
  Object.defineProperty(BitBuilder, "__esModule", { value: true });
  BitBuilder.BitBuilder = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  const BitString_1 = requireBitString();
  let BitBuilder$12 = class BitBuilder {
    constructor(size = 1023) {
      this._buffer = Buffer.alloc(Math.ceil(size / 8));
      this._length = 0;
    }
    /**
     * Current number of bits written
     */
    get length() {
      return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */
    writeBit(value) {
      let n = this._length;
      if (n > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
        this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
      }
      this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */
    writeBits(src) {
      for (let i = 0; i < src.length; i++) {
        this.writeBit(src.at(i));
      }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */
    writeBuffer(src) {
      if (this._length % 8 === 0) {
        if (this._length + src.length * 8 > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        src.copy(this._buffer, this._length / 8);
        this._length += src.length * 8;
      } else {
        for (let i = 0; i < src.length; i++) {
          this.writeUint(src[i], 8);
        }
      }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeUint(value, bits) {
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      const v2 = BigInt(value);
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      const vBits = 1n << BigInt(bits);
      if (v2 < 0 || v2 >= vBits) {
        throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
      }
      if (this._length + bits > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      const tillByte = 8 - this._length % 8;
      if (tillByte > 0) {
        const bidx = Math.floor(this._length / 8);
        if (bits < tillByte) {
          const wb = Number(v2);
          this._buffer[bidx] |= wb << tillByte - bits;
          this._length += bits;
        } else {
          const wb = Number(v2 >> BigInt(bits - tillByte));
          this._buffer[bidx] |= wb;
          this._length += tillByte;
        }
      }
      bits -= tillByte;
      while (bits > 0) {
        if (bits >= 8) {
          this._buffer[this._length / 8] = Number(v2 >> BigInt(bits - 8) & 0xffn);
          this._length += 8;
          bits -= 8;
        } else {
          this._buffer[this._length / 8] = Number(v2 << BigInt(8 - bits) & 0xffn);
          this._length += bits;
          bits = 0;
        }
      }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      if (bits === 1) {
        if (v2 !== -1n && v2 !== 0n) {
          throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
        } else {
          this.writeBit(value === -1n);
          return;
        }
      }
      let vBits = 1n << BigInt(bits) - 1n;
      if (v2 < -vBits || v2 >= vBits) {
        throw Error(`value is out of range for ${bits} bits. Got ${value}`);
      }
      if (v2 < 0) {
        this.writeBit(true);
        v2 = vBits + v2;
      } else {
        this.writeBit(false);
      }
      this.writeUint(v2, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarUint(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 < 0) {
        throw Error(`value is negative. Got ${value}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      const sizeBytes = Math.ceil(v2.toString(2).length / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeUint(v2, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      const sizeBytes = Math.ceil((v22.toString(2).length + 1) / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeInt(v2, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */
    writeCoins(amount) {
      this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */
    writeAddress(address) {
      if (address === null || address === void 0) {
        this.writeUint(0, 2);
        return;
      }
      if (Address_1.Address.isAddress(address)) {
        this.writeUint(2, 2);
        this.writeUint(0, 1);
        this.writeInt(address.workChain, 8);
        this.writeBuffer(address.hash);
        return;
      }
      if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
        this.writeUint(1, 2);
        this.writeUint(address.bits, 9);
        this.writeUint(address.value, address.bits);
        return;
      }
      throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */
    build() {
      return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */
    buffer() {
      if (this._length % 8 !== 0) {
        throw new Error("BitBuilder buffer is not byte aligned");
      }
      return this._buffer.subarray(0, this._length / 8);
    }
  };
  BitBuilder.BitBuilder = BitBuilder$12;
  return BitBuilder;
}
var Cell = {};
var CellType = {};
var hasRequiredCellType;
function requireCellType() {
  if (hasRequiredCellType) return CellType;
  hasRequiredCellType = 1;
  Object.defineProperty(CellType, "__esModule", { value: true });
  CellType.CellType = void 0;
  var CellType$12;
  (function(CellType2) {
    CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
    CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
    CellType2[CellType2["Library"] = 2] = "Library";
    CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
    CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
  })(CellType$12 || (CellType.CellType = CellType$12 = {}));
  return CellType;
}
var Slice = {};
var Dictionary = {};
var generateMerkleProof = {};
var readUnaryLength = {};
var hasRequiredReadUnaryLength;
function requireReadUnaryLength() {
  if (hasRequiredReadUnaryLength) return readUnaryLength;
  hasRequiredReadUnaryLength = 1;
  Object.defineProperty(readUnaryLength, "__esModule", { value: true });
  readUnaryLength.readUnaryLength = void 0;
  function readUnaryLength$12(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  readUnaryLength.readUnaryLength = readUnaryLength$12;
  return readUnaryLength;
}
var exoticMerkleProof = {};
var BitReader = {};
var hasRequiredBitReader;
function requireBitReader() {
  if (hasRequiredBitReader) return BitReader;
  hasRequiredBitReader = 1;
  Object.defineProperty(BitReader, "__esModule", { value: true });
  BitReader.BitReader = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  let BitReader$12 = class BitReader2 {
    constructor(bits, offset = 0) {
      this._checkpoints = [];
      this._bits = bits;
      this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
      return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
      return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
      if (bits < 0 || this._offset + bits > this._bits.length) {
        throw new Error(`Index ${this._offset + bits} is out of bounds`);
      }
      this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
      if (this._checkpoints.length > 0) {
        this._offset = this._checkpoints.pop();
      } else {
        this._offset = 0;
      }
    }
    /**
     * Save checkpoint
     */
    save() {
      this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
      let r = this._bits.at(this._offset);
      this._offset++;
      return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
      return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
      let r = this._bits.substring(this._offset, bits);
      this._offset += bits;
      return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
      return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
      let buf2 = this._preloadBuffer(bytes, this._offset);
      this._offset += bytes * 8;
      return buf2;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
      return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
      return this._toSafeInteger(this.loadUintBig(bits), "loadUintBig");
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
      let loaded = this.preloadUintBig(bits);
      this._offset += bits;
      return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
      return this._toSafeInteger(this._preloadUint(bits, this._offset), "preloadUintBig");
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
      return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return this._toSafeInteger(res, "loadUintBig");
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
      return this._toSafeInteger(this._preloadInt(bits, this._offset), "preloadIntBig");
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
      return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadUintBig(size * 8), "loadVarUintBig");
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), "preloadVarUintBig");
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadIntBig(size * 8), "loadVarIntBig");
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), "preloadVarIntBig");
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
      return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
      return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address: " + type);
      }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else if (type === 3) {
        throw Error("Unsupported");
      } else {
        throw Error("Unreachable");
      }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
      if (bits % 8 !== 0) {
        throw new Error("Invalid number of bits");
      }
      let length = bits;
      while (true) {
        if (this._bits.at(this._offset + length - 1)) {
          length--;
          break;
        } else {
          length--;
        }
      }
      let r = this._bits.substring(this._offset, length);
      this._offset += bits;
      return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
      return new BitReader2(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let sign2 = this._bits.at(offset);
      let res = 0n;
      for (let i = 0; i < bits - 1; i++) {
        if (this._bits.at(offset + 1 + i)) {
          res += 1n << BigInt(bits - i - 1 - 1);
        }
      }
      if (sign2) {
        res = res - (1n << BigInt(bits - 1));
      }
      return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let res = 0n;
      for (let i = 0; i < bits; i++) {
        if (this._bits.at(offset + i)) {
          res += 1n << BigInt(bits - i - 1);
        }
      }
      return res;
    }
    _preloadBuffer(bytes, offset) {
      let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
      if (fastBuffer) {
        return fastBuffer;
      }
      let buf2 = Buffer.alloc(bytes);
      for (let i = 0; i < bytes; i++) {
        buf2[i] = Number(this._preloadUint(8, offset + i * 8));
      }
      return buf2;
    }
    _loadInternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 2) {
        throw Error("Invalid address");
      }
      let rewrite_pfx = void 0;
      let rewrite_depth = void 0;
      if (this._preloadUint(1, this._offset + 2) !== 0n) {
        rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
        rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
        this._offset += 5 + rewrite_depth;
      }
      let wc = Number(this._preloadInt(8, this._offset + 3));
      let hash = this._preloadBuffer(32, this._offset + 11);
      if (rewrite_depth !== void 0 && rewrite_pfx !== void 0) {
        let pfx = Number(rewrite_pfx);
        let byteIndex = 0;
        let bitIndex = 0;
        let bitsRemaining = rewrite_depth;
        while (bitsRemaining > 0) {
          let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
          let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
          let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
          hash[byteIndex] = hash[byteIndex] & ~mask | bits;
          bitsRemaining -= bitsInThisByte;
          bitIndex += bitsInThisByte;
          if (bitIndex === 8) {
            byteIndex++;
            bitIndex = 0;
          }
        }
      }
      this._offset += 267;
      return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 1) {
        throw Error("Invalid address");
      }
      let bits = Number(this._preloadUint(9, this._offset + 2));
      let value = this._preloadUint(bits, this._offset + 11);
      this._offset += 11 + bits;
      return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src, alt) {
      if (BigInt(Number.MAX_SAFE_INTEGER) < src || src < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new TypeError(`${src} is out of safe integer range. Use ${alt} instead`);
      }
      return Number(src);
    }
  };
  BitReader.BitReader = BitReader$12;
  return BitReader;
}
var hasRequiredExoticMerkleProof;
function requireExoticMerkleProof() {
  if (hasRequiredExoticMerkleProof) return exoticMerkleProof;
  hasRequiredExoticMerkleProof = 1;
  Object.defineProperty(exoticMerkleProof, "__esModule", { value: true });
  exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
  const BitReader_1 = requireBitReader();
  const Builder_12 = requireBuilder$1();
  function exoticMerkleProof$12(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
      throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
      throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 3) {
      throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    const proofHash = reader2.loadBuffer(32);
    const proofDepth = reader2.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
      throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
      throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
    }
    return {
      proofDepth,
      proofHash
    };
  }
  exoticMerkleProof.exoticMerkleProof = exoticMerkleProof$12;
  function convertToMerkleProof(c) {
    return (0, Builder_12.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
  }
  exoticMerkleProof.convertToMerkleProof = convertToMerkleProof;
  return exoticMerkleProof;
}
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
  if (hasRequiredGenerateMerkleProof) return generateMerkleProof;
  hasRequiredGenerateMerkleProof = 1;
  Object.defineProperty(generateMerkleProof, "__esModule", { value: true });
  generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
  const Builder_12 = requireBuilder$1();
  const readUnaryLength_1 = requireReadUnaryLength();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  function convertToPrunedBranch(c) {
    return (0, Builder_12.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
  }
  function doGenerateMerkleProof(prefix, slice, n, keys) {
    const originalCell = slice.asCell();
    if (keys.length == 0) {
      return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      return originalCell;
    } else {
      let sl = originalCell.beginParse();
      let left = sl.loadRef();
      let right = sl.loadRef();
      if (!left.isExotic) {
        const leftKeys = keys.filter((key) => {
          return pp + "0" === key.slice(0, pp.length + 1);
        });
        left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, leftKeys);
      }
      if (!right.isExotic) {
        const rightKeys = keys.filter((key) => {
          return pp + "1" === key.slice(0, pp.length + 1);
        });
        right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, rightKeys);
      }
      return (0, Builder_12.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
  }
  function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key) => {
      if (!dict.has(key)) {
        throw new Error(`Trying to generate merkle proof for a missing key "${key}"`);
      }
    });
    const s2 = (0, Builder_12.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof("", s2, keyObject.bits, keys.map((key) => keyObject.serialize(key).toString(2).padStart(keyObject.bits, "0")));
  }
  generateMerkleProof.generateMerkleProofDirect = generateMerkleProofDirect;
  function generateMerkleProof$12(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
  }
  generateMerkleProof.generateMerkleProof = generateMerkleProof$12;
  return generateMerkleProof;
}
var generateMerkleUpdate = {};
var hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
  if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate;
  hasRequiredGenerateMerkleUpdate = 1;
  Object.defineProperty(generateMerkleUpdate, "__esModule", { value: true });
  generateMerkleUpdate.generateMerkleUpdate = void 0;
  const Builder_12 = requireBuilder$1();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_12.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
  }
  function generateMerkleUpdate$12(dict, key, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
    dict.set(key, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
  }
  generateMerkleUpdate.generateMerkleUpdate = generateMerkleUpdate$12;
  return generateMerkleUpdate;
}
var parseDict = {};
var hasRequiredParseDict;
function requireParseDict() {
  if (hasRequiredParseDict) return parseDict;
  hasRequiredParseDict = 1;
  Object.defineProperty(parseDict, "__esModule", { value: true });
  parseDict.parseDict = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  function doParse(prefix, slice, n, res, extractor) {
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = readUnaryLength2(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      res.set(BigInt("0b" + pp), extractor(slice));
    } else {
      let left = slice.loadRef();
      let right = slice.loadRef();
      if (!left.isExotic) {
        doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
      }
      if (!right.isExotic) {
        doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
      }
    }
  }
  function parseDict$12(sc, keySize, extractor) {
    let res = /* @__PURE__ */ new Map();
    if (sc) {
      doParse("", sc, keySize, res, extractor);
    }
    return res;
  }
  parseDict.parseDict = parseDict$12;
  return parseDict;
}
var serializeDict = {};
var findCommonPrefix = {};
var hasRequiredFindCommonPrefix;
function requireFindCommonPrefix() {
  if (hasRequiredFindCommonPrefix) return findCommonPrefix;
  hasRequiredFindCommonPrefix = 1;
  Object.defineProperty(findCommonPrefix, "__esModule", { value: true });
  findCommonPrefix.findCommonPrefix = void 0;
  function findCommonPrefix$12(src, startPos = 0) {
    if (src.length === 0) {
      return "";
    }
    let r = src[0].slice(startPos);
    for (let i = 1; i < src.length; i++) {
      const s2 = src[i];
      while (s2.indexOf(r, startPos) !== startPos) {
        r = r.substring(0, r.length - 1);
        if (r === "") {
          return r;
        }
      }
    }
    return r;
  }
  findCommonPrefix.findCommonPrefix = findCommonPrefix$12;
  return findCommonPrefix;
}
var hasRequiredSerializeDict;
function requireSerializeDict() {
  if (hasRequiredSerializeDict) return serializeDict;
  hasRequiredSerializeDict = 1;
  Object.defineProperty(serializeDict, "__esModule", { value: true });
  serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
  const Builder_12 = requireBuilder$1();
  const findCommonPrefix_1 = requireFindCommonPrefix();
  function pad(src, size) {
    while (src.length < size) {
      src = "0" + src;
    }
    return src;
  }
  function forkMap(src, prefixLen) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    let left = /* @__PURE__ */ new Map();
    let right = /* @__PURE__ */ new Map();
    for (let [k2, d] of src.entries()) {
      if (k2[prefixLen] === "0") {
        left.set(k2, d);
      } else {
        right.set(k2, d);
      }
    }
    if (left.size === 0) {
      throw Error("Internal inconsistency. Left emtpy.");
    }
    if (right.size === 0) {
      throw Error("Internal inconsistency. Right emtpy.");
    }
    return { left, right };
  }
  function buildNode(src, prefixLen) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    if (src.size === 1) {
      return { type: "leaf", value: Array.from(src.values())[0] };
    }
    let { left, right } = forkMap(src, prefixLen);
    return {
      type: "fork",
      left: buildEdge(left, prefixLen + 1),
      right: buildEdge(right, prefixLen + 1)
    };
  }
  function buildEdge(src, prefixLen = 0) {
    if (src.size === 0) {
      throw Error("Internal inconsistency");
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);
    return { label, node: buildNode(src, label.length + prefixLen) };
  }
  function buildTree(src, keyLength) {
    let converted = /* @__PURE__ */ new Map();
    for (let k2 of Array.from(src.keys())) {
      const padded = pad(k2.toString(2), keyLength);
      converted.set(padded, src.get(k2));
    }
    return buildEdge(converted);
  }
  serializeDict.buildTree = buildTree;
  function writeLabelShort(src, to2) {
    to2.storeBit(0);
    for (let i = 0; i < src.length; i++) {
      to2.storeBit(1);
    }
    to2.storeBit(0);
    if (src.length > 0) {
      to2.storeUint(BigInt("0b" + src), src.length);
    }
    return to2;
  }
  serializeDict.writeLabelShort = writeLabelShort;
  function labelShortLength(src) {
    return 1 + src.length + 1 + src.length;
  }
  function writeLabelLong(src, keyLength, to2) {
    to2.storeBit(1);
    to2.storeBit(0);
    let length = Math.ceil(Math.log2(keyLength + 1));
    to2.storeUint(src.length, length);
    if (src.length > 0) {
      to2.storeUint(BigInt("0b" + src), src.length);
    }
    return to2;
  }
  serializeDict.writeLabelLong = writeLabelLong;
  function labelLongLength(src, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
  }
  function writeLabelSame(value, length, keyLength, to2) {
    to2.storeBit(1);
    to2.storeBit(1);
    to2.storeBit(value);
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to2.storeUint(length, lenLen);
  }
  serializeDict.writeLabelSame = writeLabelSame;
  function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
  }
  function isSame(src) {
    if (src.length === 0 || src.length === 1) {
      return true;
    }
    for (let i = 1; i < src.length; i++) {
      if (src[i] !== src[0]) {
        return false;
      }
    }
    return true;
  }
  function detectLabelType(src, keyLength) {
    let kind = "short";
    let kindLength = labelShortLength(src);
    let longLength = labelLongLength(src, keyLength);
    if (longLength < kindLength) {
      kindLength = longLength;
      kind = "long";
    }
    if (isSame(src)) {
      let sameLength = labelSameLength(keyLength);
      if (sameLength < kindLength) {
        kindLength = sameLength;
        kind = "same";
      }
    }
    return kind;
  }
  serializeDict.detectLabelType = detectLabelType;
  function writeLabel(src, keyLength, to2) {
    let type = detectLabelType(src, keyLength);
    if (type === "short") {
      writeLabelShort(src, to2);
    } else if (type === "long") {
      writeLabelLong(src, keyLength, to2);
    } else if (type === "same") {
      writeLabelSame(src[0] === "1", src.length, keyLength, to2);
    }
  }
  function writeNode(src, keyLength, serializer, to2) {
    if (src.type === "leaf") {
      serializer(src.value, to2);
    }
    if (src.type === "fork") {
      const leftCell = (0, Builder_12.beginCell)();
      const rightCell = (0, Builder_12.beginCell)();
      writeEdge(src.left, keyLength - 1, serializer, leftCell);
      writeEdge(src.right, keyLength - 1, serializer, rightCell);
      to2.storeRef(leftCell);
      to2.storeRef(rightCell);
    }
  }
  function writeEdge(src, keyLength, serializer, to2) {
    writeLabel(src.label, keyLength, to2);
    writeNode(src.node, keyLength - src.label.length, serializer, to2);
  }
  function serializeDict$12(src, keyLength, serializer, to2) {
    const tree = buildTree(src, keyLength);
    writeEdge(tree, keyLength, serializer, to2);
  }
  serializeDict.serializeDict = serializeDict$12;
  return serializeDict;
}
var internalKeySerializer = {};
var hasRequiredInternalKeySerializer;
function requireInternalKeySerializer() {
  if (hasRequiredInternalKeySerializer) return internalKeySerializer;
  hasRequiredInternalKeySerializer = 1;
  Object.defineProperty(internalKeySerializer, "__esModule", { value: true });
  internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
  const Address_1 = requireAddress();
  const BitString_1 = requireBitString();
  const paddedBits_1 = requirePaddedBits();
  function serializeInternalKey(value) {
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw Error("Invalid key type: not a safe integer: " + value);
      }
      return "n:" + value.toString(10);
    } else if (typeof value === "bigint") {
      return "b:" + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
      return "a:" + value.toString();
    } else if (Buffer.isBuffer(value)) {
      return "f:" + value.toString("hex");
    } else if (BitString_1.BitString.isBitString(value)) {
      return "B:" + value.toString();
    } else {
      throw Error("Invalid key type");
    }
  }
  internalKeySerializer.serializeInternalKey = serializeInternalKey;
  function deserializeInternalKey(value) {
    let k2 = value.slice(0, 2);
    let v2 = value.slice(2);
    if (k2 === "n:") {
      return parseInt(v2, 10);
    } else if (k2 === "b:") {
      return BigInt(v2);
    } else if (k2 === "a:") {
      return Address_1.Address.parse(v2);
    } else if (k2 === "f:") {
      return Buffer.from(v2, "hex");
    } else if (k2 === "B:") {
      const lastDash = v2.slice(-1) == "_";
      const isPadded = lastDash || v2.length % 2 != 0;
      if (isPadded) {
        let charLen = lastDash ? v2.length - 1 : v2.length;
        const padded = v2.substr(0, charLen) + "0";
        if (!lastDash && (charLen & 1) !== 0) {
          return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
        } else {
          return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
        }
      } else {
        return new BitString_1.BitString(Buffer.from(v2, "hex"), 0, v2.length << 2);
      }
    }
    throw Error("Invalid key type: " + k2);
  }
  internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
  return internalKeySerializer;
}
var hasRequiredDictionary;
function requireDictionary() {
  if (hasRequiredDictionary) return Dictionary;
  hasRequiredDictionary = 1;
  Object.defineProperty(Dictionary, "__esModule", { value: true });
  Dictionary.Dictionary = void 0;
  const Address_1 = requireAddress();
  const Builder_12 = requireBuilder$1();
  const Cell_1 = requireCell();
  const BitString_1 = requireBitString();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  const generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
  const parseDict_1 = requireParseDict();
  const serializeDict_1 = requireSerializeDict();
  const internalKeySerializer_1 = requireInternalKeySerializer();
  let Dictionary$12 = class Dictionary2 {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key, value) {
      if (key && value) {
        return new Dictionary2(/* @__PURE__ */ new Map(), key, value);
      } else {
        return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
      }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key, value, sc) {
      let slice;
      if (sc instanceof Cell_1.Cell) {
        if (sc.isExotic) {
          return Dictionary2.empty(key, value);
        }
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let cell = slice.loadMaybeRef();
      if (cell && !cell.isExotic) {
        return Dictionary2.loadDirect(key, value, cell.beginParse());
      } else {
        return Dictionary2.empty(key, value);
      }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key, value, sc) {
      if (!sc) {
        return Dictionary2.empty(key, value);
      }
      let slice;
      if (sc instanceof Cell_1.Cell) {
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
      let prepare = /* @__PURE__ */ new Map();
      for (let [k2, v2] of values) {
        prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k2)), v2);
      }
      return new Dictionary2(prepare, key, value);
    }
    constructor(values, key, value) {
      this._key = key;
      this._value = value;
      this._map = values;
    }
    get size() {
      return this._map.size;
    }
    get(key) {
      return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    has(key) {
      return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    set(key, value) {
      this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
      return this;
    }
    delete(key) {
      const k2 = (0, internalKeySerializer_1.serializeInternalKey)(key);
      return this._map.delete(k2);
    }
    clear() {
      this._map.clear();
    }
    *[Symbol.iterator]() {
      for (const [k2, v2] of this._map) {
        const key = (0, internalKeySerializer_1.deserializeInternalKey)(k2);
        yield [key, v2];
      }
    }
    keys() {
      return Array.from(this._map.keys()).map((v2) => (0, internalKeySerializer_1.deserializeInternalKey)(v2));
    }
    values() {
      return Array.from(this._map.values());
    }
    store(builder2, key, value) {
      if (this._map.size === 0) {
        builder2.storeBit(0);
      } else {
        let resolvedKey = this._key;
        if (key !== null && key !== void 0) {
          resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k2, v2] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
        }
        builder2.storeBit(1);
        let dd = (0, Builder_12.beginCell)();
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
        builder2.storeRef(dd.endCell());
      }
    }
    storeDirect(builder2, key, value) {
      if (this._map.size === 0) {
        throw Error("Cannot store empty dictionary directly");
      }
      let resolvedKey = this._key;
      if (key !== null && key !== void 0) {
        resolvedKey = key;
      }
      let resolvedValue = this._value;
      if (value !== null && value !== void 0) {
        resolvedValue = value;
      }
      if (!resolvedKey) {
        throw Error("Key serializer is not defined");
      }
      if (!resolvedValue) {
        throw Error("Value serializer is not defined");
      }
      let prepared = /* @__PURE__ */ new Map();
      for (const [k2, v2] of this._map) {
        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
      }
      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder2);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */
    generateMerkleProof(keys) {
      return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */
    generateMerkleProofDirect(keys) {
      return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key, newValue) {
      return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
    }
  };
  Dictionary.Dictionary = Dictionary$12;
  Dictionary$12.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
      return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
      return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
      return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
      return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
      return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
      return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
      return createBitStringKey(bits);
    }
  };
  Dictionary$12.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
      return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
      return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
      return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
      return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
      return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
      return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
      return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
      return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
      return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
      return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
      return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key, value) => {
      return createDictionaryValue(key, value);
    }
  };
  function createAddressKey() {
    return {
      bits: 267,
      serialize: (src) => {
        if (!Address_1.Address.isAddress(src)) {
          throw Error("Key is not an address");
        }
        return (0, Builder_12.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
      }
    };
  }
  function createBigIntKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "bigint") {
          throw Error("Key is not a bigint");
        }
        return (0, Builder_12.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
      }
    };
  }
  function createIntKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src)) {
          throw Error("Key is not a safe integer: " + src);
        }
        return (0, Builder_12.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
      }
    };
  }
  function createBigUintKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "bigint") {
          throw Error("Key is not a bigint");
        }
        if (src < 0) {
          throw Error("Key is negative: " + src);
        }
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      }
    };
  }
  function createUintKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (typeof src !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src)) {
          throw Error("Key is not a safe integer: " + src);
        }
        if (src < 0) {
          throw Error("Key is negative: " + src);
        }
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return Number((0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
      }
    };
  }
  function createBufferKey(bytes) {
    return {
      bits: bytes * 8,
      serialize: (src) => {
        if (!Buffer.isBuffer(src)) {
          throw Error("Key is not a buffer");
        }
        return (0, Builder_12.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
      }
    };
  }
  function createBitStringKey(bits) {
    return {
      bits,
      serialize: (src) => {
        if (!BitString_1.BitString.isBitString(src))
          throw Error("Key is not a BitString");
        return (0, Builder_12.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src) => {
        return (0, Builder_12.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
      }
    };
  }
  function createIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadInt(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadIntBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigVarIntValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeVarInt(src, bits);
      },
      parse: (src) => {
        let value = src.loadVarIntBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigVarUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeVarUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadVarUintBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadUint(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBigUintValue(bits) {
    return {
      serialize: (src, buidler) => {
        buidler.storeUint(src, bits);
      },
      parse: (src) => {
        let value = src.loadUintBig(bits);
        src.endParse();
        return value;
      }
    };
  }
  function createBooleanValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeBit(src);
      },
      parse: (src) => {
        let value = src.loadBit();
        src.endParse();
        return value;
      }
    };
  }
  function createAddressValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeAddress(src);
      },
      parse: (src) => {
        let addr = src.loadAddress();
        src.endParse();
        return addr;
      }
    };
  }
  function createCellValue() {
    return {
      serialize: (src, buidler) => {
        buidler.storeRef(src);
      },
      parse: (src) => {
        let value = src.loadRef();
        src.endParse();
        return value;
      }
    };
  }
  function createDictionaryValue(key, value) {
    return {
      serialize: (src, buidler) => {
        src.store(buidler);
      },
      parse: (src) => {
        let dict = Dictionary$12.load(key, value, src);
        src.endParse();
        return dict;
      }
    };
  }
  function createBufferValue(size) {
    return {
      serialize: (src, buidler) => {
        if (src.length !== size) {
          throw Error("Invalid buffer size");
        }
        buidler.storeBuffer(src);
      },
      parse: (src) => {
        let value = src.loadBuffer(size);
        src.endParse();
        return value;
      }
    };
  }
  function createBitStringValue(bits) {
    return {
      serialize: (src, builder2) => {
        if (src.length !== bits) {
          throw Error("Invalid BitString size");
        }
        builder2.storeBits(src);
      },
      parse: (src) => {
        let value = src.loadBits(bits);
        src.endParse();
        return value;
      }
    };
  }
  return Dictionary;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  Object.defineProperty(strings, "__esModule", { value: true });
  strings.writeString = strings.stringToCell = strings.readString = void 0;
  const Builder_12 = requireBuilder$1();
  function readBuffer(slice) {
    if (slice.remainingBits % 8 !== 0) {
      throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
      throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    let res;
    if (slice.remainingBits === 0) {
      res = Buffer.alloc(0);
    } else {
      res = slice.loadBuffer(slice.remainingBits / 8);
    }
    if (slice.remainingRefs === 1) {
      res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
    }
    return res;
  }
  function readString(slice) {
    return readBuffer(slice).toString();
  }
  strings.readString = readString;
  function writeBuffer(src, builder2) {
    if (src.length > 0) {
      let bytes = Math.floor(builder2.availableBits / 8);
      if (src.length > bytes) {
        let a2 = src.subarray(0, bytes);
        let t = src.subarray(bytes);
        builder2 = builder2.storeBuffer(a2);
        let bb = (0, Builder_12.beginCell)();
        writeBuffer(t, bb);
        builder2 = builder2.storeRef(bb.endCell());
      } else {
        builder2 = builder2.storeBuffer(src);
      }
    }
  }
  function stringToCell(src) {
    let builder2 = (0, Builder_12.beginCell)();
    writeBuffer(Buffer.from(src), builder2);
    return builder2.endCell();
  }
  strings.stringToCell = stringToCell;
  function writeString(src, builder2) {
    writeBuffer(Buffer.from(src), builder2);
  }
  strings.writeString = writeString;
  return strings;
}
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice) return Slice;
  hasRequiredSlice = 1;
  var __importDefault = Slice && Slice.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Slice, "__esModule", { value: true });
  Slice.Slice = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const Dictionary_1 = requireDictionary();
  const Builder_12 = requireBuilder$1();
  const strings_1 = requireStrings();
  let Slice$12 = class Slice2 {
    constructor(reader2, refs) {
      this[_a2] = () => this.toString();
      this._reader = reader2.clone();
      this._refs = [...refs];
      this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */
    get remainingBits() {
      return this._reader.remaining;
    }
    /**
     * Get offset bits
     */
    get offsetBits() {
      return this._reader.offset;
    }
    /**
     * Get remaining refs
     */
    get remainingRefs() {
      return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */
    get offsetRefs() {
      return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */
    skip(bits) {
      this._reader.skip(bits);
      return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */
    loadBit() {
      return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */
    preloadBit() {
      return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */
    loadBoolean() {
      return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */
    loadMaybeBoolean() {
      if (this.loadBit()) {
        return this.loadBoolean();
      } else {
        return null;
      }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    loadBits(bits) {
      return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    preloadBits(bits) {
      return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUint(bits) {
      return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUintBig(bits) {
      return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUint(bits) {
      return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUintBig(bits) {
      return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUint(bits) {
      if (this.loadBit()) {
        return this.loadUint(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUintBig(bits) {
      if (this.loadBit()) {
        return this.loadUintBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadInt(bits) {
      return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadIntBig(bits) {
      return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadInt(bits) {
      return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadIntBig(bits) {
      return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeInt(bits) {
      if (this.loadBit()) {
        return this.loadInt(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeIntBig(bits) {
      if (this.loadBit()) {
        return this.loadIntBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUint(bits) {
      return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUintBig(bits) {
      return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUint(bits) {
      return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUintBig(bits) {
      return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarInt(bits) {
      return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarIntBig(bits) {
      return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarInt(bits) {
      return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarIntBig(bits) {
      return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */
    loadCoins() {
      return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */
    preloadCoins() {
      return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */
    loadMaybeCoins() {
      if (this._reader.loadBit()) {
        return this._reader.loadCoins();
      } else {
        return null;
      }
    }
    /**
     * Load internal Address
     * @returns Address
     */
    loadAddress() {
      return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */
    loadMaybeAddress() {
      return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */
    loadAddressAny() {
      return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */
    loadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */
    preloadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */
    loadMaybeRef() {
      if (this.loadBit()) {
        return this.loadRef();
      } else {
        return null;
      }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */
    preloadMaybeRef() {
      if (this.preloadBit()) {
        return this.preloadRef();
      } else {
        return null;
      }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    loadBuffer(bytes) {
      return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    preloadBuffer(bytes) {
      return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */
    loadStringTail() {
      return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */
    loadMaybeStringTail() {
      if (this.loadBit()) {
        return (0, strings_1.readString)(this);
      } else {
        return null;
      }
    }
    /**
     * Load string tail from ref
     * @returns string
     */
    loadStringRefTail() {
      return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */
    loadMaybeStringRefTail() {
      const ref = this.loadMaybeRef();
      if (ref) {
        return (0, strings_1.readString)(ref.beginParse());
      } else {
        return null;
      }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDict(key, value) {
      return Dictionary_1.Dictionary.load(key, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDictDirect(key, value) {
      return Dictionary_1.Dictionary.loadDirect(key, value, this);
    }
    /**
     * Checks if slice is empty
     */
    endParse() {
      if (this.remainingBits > 0 || this.remainingRefs > 0) {
        throw new Error("Slice is not empty");
      }
    }
    /**
     * Convert slice to cell
     */
    asCell() {
      return (0, Builder_12.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */
    clone(fromStart = false) {
      if (fromStart) {
        let reader2 = this._reader.clone();
        reader2.reset();
        return new Slice2(reader2, this._refs);
      } else {
        let res = new Slice2(this._reader, this._refs);
        res._refsOffset = this._refsOffset;
        return res;
      }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */
    toString() {
      return this.asCell().toString();
    }
  };
  Slice.Slice = Slice$12;
  _a2 = symbol_inspect_1.default;
  return Slice;
}
var resolveExotic = {};
var exoticLibrary = {};
var hasRequiredExoticLibrary;
function requireExoticLibrary() {
  if (hasRequiredExoticLibrary) return exoticLibrary;
  hasRequiredExoticLibrary = 1;
  Object.defineProperty(exoticLibrary, "__esModule", { value: true });
  exoticLibrary.exoticLibrary = void 0;
  const BitReader_1 = requireBitReader();
  function exoticLibrary$12(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256;
    if (bits.length !== size) {
      throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 2) {
      throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
  }
  exoticLibrary.exoticLibrary = exoticLibrary$12;
  return exoticLibrary;
}
var exoticMerkleUpdate = {};
var hasRequiredExoticMerkleUpdate;
function requireExoticMerkleUpdate() {
  if (hasRequiredExoticMerkleUpdate) return exoticMerkleUpdate;
  hasRequiredExoticMerkleUpdate = 1;
  Object.defineProperty(exoticMerkleUpdate, "__esModule", { value: true });
  exoticMerkleUpdate.exoticMerkleUpdate = void 0;
  const BitReader_1 = requireBitReader();
  function exoticMerkleUpdate$12(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
      throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
      throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 4) {
      throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader2.loadBuffer(32);
    const proofHash2 = reader2.loadBuffer(32);
    const proofDepth1 = reader2.loadUint(16);
    const proofDepth2 = reader2.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
    }
    return {
      proofDepth1,
      proofDepth2,
      proofHash1,
      proofHash2
    };
  }
  exoticMerkleUpdate.exoticMerkleUpdate = exoticMerkleUpdate$12;
  return exoticMerkleUpdate;
}
var exoticPruned = {};
var LevelMask = {};
var hasRequiredLevelMask;
function requireLevelMask() {
  if (hasRequiredLevelMask) return LevelMask;
  hasRequiredLevelMask = 1;
  Object.defineProperty(LevelMask, "__esModule", { value: true });
  LevelMask.LevelMask = void 0;
  let LevelMask$12 = class LevelMask2 {
    constructor(mask = 0) {
      this._mask = 0;
      this._mask = mask;
      this._hashIndex = countSetBits(this._mask);
      this._hashCount = this._hashIndex + 1;
    }
    get value() {
      return this._mask;
    }
    get level() {
      return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
      return this._hashIndex;
    }
    get hashCount() {
      return this._hashCount;
    }
    apply(level) {
      return new LevelMask2(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
      let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
      return res;
    }
  };
  LevelMask.LevelMask = LevelMask$12;
  function countSetBits(n) {
    n = n - (n >> 1 & 1431655765);
    n = (n & 858993459) + (n >> 2 & 858993459);
    return (n + (n >> 4) & 252645135) * 16843009 >> 24;
  }
  return LevelMask;
}
var hasRequiredExoticPruned;
function requireExoticPruned() {
  if (hasRequiredExoticPruned) return exoticPruned;
  hasRequiredExoticPruned = 1;
  Object.defineProperty(exoticPruned, "__esModule", { value: true });
  exoticPruned.exoticPruned = void 0;
  const BitReader_1 = requireBitReader();
  const LevelMask_1 = requireLevelMask();
  function exoticPruned$12(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.loadUint(8);
    if (type !== 1) {
      throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    if (refs.length !== 0) {
      throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    let mask;
    if (bits.length === 280) {
      mask = new LevelMask_1.LevelMask(1);
    } else {
      mask = new LevelMask_1.LevelMask(reader2.loadUint(8));
      if (mask.level < 1 || mask.level > 3) {
        throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
      }
      const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
      }
    }
    let pruned = [];
    let hashes = [];
    let depths = [];
    for (let i = 0; i < mask.level; i++) {
      hashes.push(reader2.loadBuffer(32));
    }
    for (let i = 0; i < mask.level; i++) {
      depths.push(reader2.loadUint(16));
    }
    for (let i = 0; i < mask.level; i++) {
      pruned.push({
        depth: depths[i],
        hash: hashes[i]
      });
    }
    return {
      mask: mask.value,
      pruned
    };
  }
  exoticPruned.exoticPruned = exoticPruned$12;
  return exoticPruned;
}
var hasRequiredResolveExotic;
function requireResolveExotic() {
  if (hasRequiredResolveExotic) return resolveExotic;
  hasRequiredResolveExotic = 1;
  Object.defineProperty(resolveExotic, "__esModule", { value: true });
  resolveExotic.resolveExotic = void 0;
  const BitReader_1 = requireBitReader();
  const CellType_1 = requireCellType();
  const exoticLibrary_1 = requireExoticLibrary();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticPruned_1 = requireExoticPruned();
  const LevelMask_1 = requireLevelMask();
  function resolvePruned(bits, refs) {
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for (let i = 0; i < pruned.pruned.length; i++) {
      depths.push(pruned.pruned[i].depth);
      hashes.push(pruned.pruned[i].hash);
    }
    return {
      type: CellType_1.CellType.PrunedBranch,
      depths,
      hashes,
      mask
    };
  }
  function resolveLibrary(bits, refs) {
    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
      type: CellType_1.CellType.Library,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleProof(bits, refs) {
    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
      type: CellType_1.CellType.MerkleProof,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleUpdate(bits, refs) {
    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
      type: CellType_1.CellType.MerkleUpdate,
      depths,
      hashes,
      mask
    };
  }
  function resolveExotic$12(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.preloadUint(8);
    if (type === 1) {
      return resolvePruned(bits, refs);
    }
    if (type === 2) {
      return resolveLibrary(bits, refs);
    }
    if (type === 3) {
      return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
      return resolveMerkleUpdate(bits, refs);
    }
    throw Error("Invalid exotic cell type: " + type);
  }
  resolveExotic.resolveExotic = resolveExotic$12;
  return resolveExotic;
}
var wonderCalculator = {};
var descriptor = {};
var hasRequiredDescriptor;
function requireDescriptor() {
  if (hasRequiredDescriptor) return descriptor;
  hasRequiredDescriptor = 1;
  Object.defineProperty(descriptor, "__esModule", { value: true });
  descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
  const CellType_1 = requireCellType();
  const paddedBits_1 = requirePaddedBits();
  function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
  }
  descriptor.getRefsDescriptor = getRefsDescriptor;
  function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
  }
  descriptor.getBitsDescriptor = getBitsDescriptor;
  function getRepr(originalBits, bits, refs, level, levelMask, type) {
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    for (const c of refs) {
      let childDepth;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childDepth = c.depth(level + 1);
      } else {
        childDepth = c.depth(level);
      }
      repr[reprCursor++] = Math.floor(childDepth / 256);
      repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs) {
      let childHash;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childHash = c.hash(level + 1);
      } else {
        childHash = c.hash(level);
      }
      childHash.copy(repr, reprCursor);
      reprCursor += 32;
    }
    return repr;
  }
  descriptor.getRepr = getRepr;
  return descriptor;
}
var hasRequiredWonderCalculator;
function requireWonderCalculator() {
  if (hasRequiredWonderCalculator) return wonderCalculator;
  hasRequiredWonderCalculator = 1;
  Object.defineProperty(wonderCalculator, "__esModule", { value: true });
  wonderCalculator.wonderCalculator = void 0;
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const LevelMask_1 = requireLevelMask();
  const exoticPruned_1 = requireExoticPruned();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const descriptor_1 = requireDescriptor();
  const crypto_1 = requireDist$4();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticLibrary_1 = requireExoticLibrary();
  function wonderCalculator$12(type, bits, refs) {
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
      let mask = 0;
      for (let r of refs) {
        mask = mask | r.mask.value;
      }
      levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
      pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
      (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
      (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
      (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      levelMask = new LevelMask_1.LevelMask();
    } else {
      throw new Error("Unsupported exotic type");
    }
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
      if (!levelMask.isSignificant(levelI)) {
        continue;
      }
      if (hashI < hashIOffset) {
        hashI++;
        continue;
      }
      let currentBits;
      if (hashI === hashIOffset) {
        if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid");
        }
        currentBits = bits;
      } else {
        if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid: " + levelI + ", " + type);
        }
        currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
      }
      let currentDepth = 0;
      for (let c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(levelI + 1);
        } else {
          childDepth = c.depth(levelI);
        }
        currentDepth = Math.max(currentDepth, childDepth);
      }
      if (refs.length > 0) {
        currentDepth++;
      }
      let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
      let hash = (0, crypto_1.sha256_sync)(repr);
      let destI = hashI - hashIOffset;
      depths[destI] = currentDepth;
      hashes[destI] = hash;
      hashI++;
    }
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
      for (let i = 0; i < 4; i++) {
        const { hashIndex } = levelMask.apply(i);
        const { hashIndex: thisHashIndex } = levelMask;
        if (hashIndex !== thisHashIndex) {
          resolvedHashes.push(pruned.pruned[hashIndex].hash);
          resolvedDepths.push(pruned.pruned[hashIndex].depth);
        } else {
          resolvedHashes.push(hashes[0]);
          resolvedDepths.push(depths[0]);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
        resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
      }
    }
    return {
      mask: levelMask,
      hashes: resolvedHashes,
      depths: resolvedDepths
    };
  }
  wonderCalculator.wonderCalculator = wonderCalculator$12;
  return wonderCalculator;
}
var serialization = {};
var topologicalSort = {};
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort;
  hasRequiredTopologicalSort = 1;
  Object.defineProperty(topologicalSort, "__esModule", { value: true });
  topologicalSort.topologicalSort = void 0;
  function topologicalSort$12(src) {
    let pending = [src];
    let allCells = /* @__PURE__ */ new Map();
    let notPermCells = /* @__PURE__ */ new Set();
    let sorted = [];
    while (pending.length > 0) {
      const cells = [...pending];
      pending = [];
      for (let cell of cells) {
        const hash = cell.hash().toString("hex");
        if (allCells.has(hash)) {
          continue;
        }
        notPermCells.add(hash);
        allCells.set(hash, { cell, refs: cell.refs.map((v2) => v2.hash().toString("hex")) });
        for (let r of cell.refs) {
          pending.push(r);
        }
      }
    }
    let tempMark = /* @__PURE__ */ new Set();
    function visit2(hash) {
      if (!notPermCells.has(hash)) {
        return;
      }
      if (tempMark.has(hash)) {
        throw Error("Not a DAG");
      }
      tempMark.add(hash);
      let refs = allCells.get(hash).refs;
      for (let ci = refs.length - 1; ci >= 0; ci--) {
        visit2(refs[ci]);
      }
      sorted.push(hash);
      tempMark.delete(hash);
      notPermCells.delete(hash);
    }
    while (notPermCells.size > 0) {
      const id = Array.from(notPermCells)[0];
      visit2(id);
    }
    let indexes = /* @__PURE__ */ new Map();
    for (let i = 0; i < sorted.length; i++) {
      indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      let ent = sorted[i];
      const rrr = allCells.get(ent);
      result.push({ cell: rrr.cell, refs: rrr.refs.map((v2) => indexes.get(v2)) });
    }
    return result;
  }
  topologicalSort.topologicalSort = topologicalSort$12;
  return topologicalSort;
}
var bitsForNumber = {};
var hasRequiredBitsForNumber;
function requireBitsForNumber() {
  if (hasRequiredBitsForNumber) return bitsForNumber;
  hasRequiredBitsForNumber = 1;
  Object.defineProperty(bitsForNumber, "__esModule", { value: true });
  bitsForNumber.bitsForNumber = void 0;
  function bitsForNumber$12(src, mode) {
    let v2 = BigInt(src);
    if (mode === "int") {
      if (v2 === 0n || v2 === -1n) {
        return 1;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      return v22.toString(2).length + 1;
    } else if (mode === "uint") {
      if (v2 < 0) {
        throw Error(`value is negative. Got ${src}`);
      }
      return v2.toString(2).length;
    } else {
      throw Error(`invalid mode. Got ${mode}`);
    }
  }
  bitsForNumber.bitsForNumber = bitsForNumber$12;
  return bitsForNumber;
}
var crc32c = {};
var hasRequiredCrc32c;
function requireCrc32c() {
  if (hasRequiredCrc32c) return crc32c;
  hasRequiredCrc32c = 1;
  Object.defineProperty(crc32c, "__esModule", { value: true });
  crc32c.crc32c = void 0;
  const POLY = 2197175160;
  function crc32c$12(source) {
    let crc = 0 ^ 4294967295;
    for (let n = 0; n < source.length; n++) {
      crc ^= source[n];
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 4294967295;
    let res = Buffer.alloc(4);
    res.writeInt32LE(crc);
    return res;
  }
  crc32c.crc32c = crc32c$12;
  return crc32c;
}
var hasRequiredSerialization;
function requireSerialization() {
  if (hasRequiredSerialization) return serialization;
  hasRequiredSerialization = 1;
  Object.defineProperty(serialization, "__esModule", { value: true });
  serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
  const BitReader_1 = requireBitReader();
  const BitString_1 = requireBitString();
  const Cell_1 = requireCell();
  const topologicalSort_1 = requireTopologicalSort();
  const bitsForNumber_1 = requireBitsForNumber();
  const BitBuilder_1 = requireBitBuilder();
  const descriptor_1 = requireDescriptor();
  const paddedBits_1 = requirePaddedBits();
  const crc32c_1 = requireCrc32c();
  function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
  }
  function getHashesCountFromMask(mask) {
    let n = 0;
    for (let i = 0; i < 3; i++) {
      n += mask & 1;
      mask = mask >> 1;
    }
    return n + 1;
  }
  function readCell(reader2, sizeBytes) {
    const d1 = reader2.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    const d2 = reader2.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader2.skip(hashesSize * 8);
    reader2.skip(depthSize * 8);
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
      if (paddingAdded) {
        bits = reader2.loadPaddedBits(dataBytesize * 8);
      } else {
        bits = reader2.loadBits(dataBytesize * 8);
      }
    }
    let refs = [];
    for (let i = 0; i < refsCount; i++) {
      refs.push(reader2.loadUint(sizeBytes * 8));
    }
    return {
      bits,
      refs,
      exotic
    };
  }
  function calcCellSize(cell, sizeBytes) {
    return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
  }
  function parseBoc(src) {
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
    let magic = reader2.loadUint(32);
    if (magic === 1761568243) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index2 = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root: [0]
      };
    } else if (magic === 2898503464) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index2 = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      let crc32 = reader2.loadBuffer(4);
      if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
        throw Error("Invalid CRC32C");
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root: [0]
      };
    } else if (magic === 3052313714) {
      let hasIdx = reader2.loadUint(1);
      let hasCrc32c = reader2.loadUint(1);
      reader2.loadUint(1);
      reader2.loadUint(2);
      let size = reader2.loadUint(3);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let root = [];
      for (let i = 0; i < roots; i++) {
        root.push(reader2.loadUint(size * 8));
      }
      let index2 = null;
      if (hasIdx) {
        index2 = reader2.loadBuffer(cells * offBytes);
      }
      let cellData = reader2.loadBuffer(totalCellSize);
      if (hasCrc32c) {
        let crc32 = reader2.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index: index2,
        cellData,
        root
      };
    } else {
      throw Error("Invalid magic");
    }
  }
  serialization.parseBoc = parseBoc;
  function deserializeBoc(src) {
    let boc = parseBoc(src);
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    let cells = [];
    for (let i = 0; i < boc.cells; i++) {
      let cll = readCell(reader2, boc.size);
      cells.push({ ...cll, result: null });
    }
    for (let i = cells.length - 1; i >= 0; i--) {
      if (cells[i].result) {
        throw Error("Impossible");
      }
      let refs = [];
      for (let r of cells[i].refs) {
        if (!cells[r].result) {
          throw Error("Invalid BOC file");
        }
        refs.push(cells[r].result);
      }
      cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
    }
    let roots = [];
    for (let i = 0; i < boc.root.length; i++) {
      roots.push(cells[boc.root[i]].result);
    }
    return roots;
  }
  serialization.deserializeBoc = deserializeBoc;
  function writeCellToBuilder(cell, refs, sizeBytes, to2) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to2.writeUint(d1, 8);
    to2.writeUint(d2, 8);
    to2.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs) {
      to2.writeUint(r, sizeBytes * 8);
    }
  }
  function serializeBoc(root, opts) {
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
    let totalCellSize = 0;
    let index2 = [];
    for (let c of allCells) {
      let sz = calcCellSize(c.cell, sizeBytes);
      totalCellSize += sz;
      index2.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    let builder2 = new BitBuilder_1.BitBuilder(totalSize);
    builder2.writeUint(3052313714, 32);
    builder2.writeBit(has_idx);
    builder2.writeBit(has_crc32c);
    builder2.writeBit(has_cache_bits);
    builder2.writeUint(flags, 2);
    builder2.writeUint(sizeBytes, 3);
    builder2.writeUint(offsetBytes, 8);
    builder2.writeUint(cellsNum, sizeBytes * 8);
    builder2.writeUint(1, sizeBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    builder2.writeUint(totalCellSize, offsetBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    if (has_idx) {
      for (let i = 0; i < cellsNum; i++) {
        builder2.writeUint(index2[i], offsetBytes * 8);
      }
    }
    for (let i = 0; i < cellsNum; i++) {
      writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder2);
    }
    if (has_crc32c) {
      let crc32 = (0, crc32c_1.crc32c)(builder2.buffer());
      builder2.writeBuffer(crc32);
    }
    let res = builder2.buffer();
    if (res.length !== totalSize / 8) {
      throw Error("Internal error");
    }
    return res;
  }
  serialization.serializeBoc = serializeBoc;
  return serialization;
}
var hasRequiredCell;
function requireCell() {
  if (hasRequiredCell) return Cell;
  hasRequiredCell = 1;
  var __importDefault = Cell && Cell.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Cell, "__esModule", { value: true });
  Cell.Cell = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const Slice_1 = requireSlice();
  const resolveExotic_1 = requireResolveExotic();
  const wonderCalculator_1 = requireWonderCalculator();
  const serialization_1 = requireSerialization();
  const BitReader_1 = requireBitReader();
  const Builder_12 = requireBuilder$1();
  let Cell$12 = class Cell2 {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */
    static fromBoc(src) {
      return (0, serialization_1.deserializeBoc)(src);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */
    static fromBase64(src) {
      let parsed = Cell2.fromBoc(Buffer.from(src, "base64"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */
    static fromHex(src) {
      let parsed = Cell2.fromBoc(Buffer.from(src, "hex"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    constructor(opts) {
      this._hashes = [];
      this._depths = [];
      this.beginParse = (allowExotic = false) => {
        if (this.isExotic && !allowExotic) {
          throw new Error("Exotic cells cannot be parsed");
        }
        return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
      };
      this.hash = (level = 3) => {
        return this._hashes[Math.min(this._hashes.length - 1, level)];
      };
      this.depth = (level = 3) => {
        return this._depths[Math.min(this._depths.length - 1, level)];
      };
      this.level = () => {
        return this.mask.level;
      };
      this.equals = (other) => {
        return this.hash().equals(other.hash());
      };
      this[_a2] = () => this.toString();
      let bits = BitString_1.BitString.EMPTY;
      if (opts && opts.bits) {
        bits = opts.bits;
      }
      let refs = [];
      if (opts && opts.refs) {
        refs = [...opts.refs];
      }
      let hashes;
      let depths;
      let mask;
      let type = CellType_1.CellType.Ordinary;
      if (opts && opts.exotic) {
        let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
        let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = resolved.type;
      } else {
        if (refs.length > 4) {
          throw new Error("Invalid number of references");
        }
        if (bits.length > 1023) {
          throw new Error(`Bits overflow: ${bits.length} > 1023`);
        }
        let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = CellType_1.CellType.Ordinary;
      }
      this.type = type;
      this.bits = bits;
      this.refs = refs;
      this.mask = mask;
      this._depths = depths;
      this._hashes = hashes;
      Object.freeze(this);
      Object.freeze(this.refs);
      Object.freeze(this.bits);
      Object.freeze(this.mask);
      Object.freeze(this._depths);
      Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */
    get isExotic() {
      return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */
    toBoc(opts) {
      let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
      let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
      return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */
    toString(indent) {
      let id = indent || "";
      let t = "x";
      if (this.isExotic) {
        if (this.type === CellType_1.CellType.MerkleProof) {
          t = "p";
        } else if (this.type === CellType_1.CellType.MerkleUpdate) {
          t = "u";
        } else if (this.type === CellType_1.CellType.PrunedBranch) {
          t = "p";
        }
      }
      let s2 = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
      for (let k2 in this.refs) {
        const i = this.refs[k2];
        s2 += "\n" + i.toString(id + " ");
      }
      return s2;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */
    asSlice() {
      return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this.asSlice());
    }
  };
  Cell.Cell = Cell$12;
  _a2 = symbol_inspect_1.default;
  Cell$12.EMPTY = new Cell$12();
  return Cell;
}
var hasRequiredBuilder$1;
function requireBuilder$1() {
  if (hasRequiredBuilder$1) return Builder$3;
  hasRequiredBuilder$1 = 1;
  Object.defineProperty(Builder$3, "__esModule", { value: true });
  Builder$3.Builder = Builder$3.beginCell = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const Cell_1 = requireCell();
  const strings_1 = requireStrings();
  function beginCell() {
    return new Builder2();
  }
  Builder$3.beginCell = beginCell;
  class Builder2 {
    constructor() {
      this._bits = new BitBuilder_1.BitBuilder();
      this._refs = [];
    }
    /**
     * Bits written so far
     */
    get bits() {
      return this._bits.length;
    }
    /**
     * References written so far
     */
    get refs() {
      return this._refs.length;
    }
    /**
     * Available bits
     */
    get availableBits() {
      return 1023 - this.bits;
    }
    /**
     * Available references
     */
    get availableRefs() {
      return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */
    storeBit(value) {
      this._bits.writeBit(value);
      return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */
    storeBits(src) {
      this._bits.writeBits(src);
      return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeBuffer(src, bytes) {
      if (bytes !== void 0 && bytes !== null) {
        if (src.length !== bytes) {
          throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
        }
      }
      this._bits.writeBuffer(src);
      return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeMaybeBuffer(src, bytes) {
      if (src !== null) {
        this.storeBit(1);
        this.storeBuffer(src, bytes);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeUint(value, bits) {
      this._bits.writeUint(value, bits);
      return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeInt(value, bits) {
      this._bits.writeInt(value, bits);
      return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarUint(value, bits) {
      this._bits.writeVarUint(value, bits);
      return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarInt(value, bits) {
      this._bits.writeVarInt(value, bits);
      return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */
    storeCoins(amount) {
      this._bits.writeCoins(amount);
      return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */
    storeMaybeCoins(amount) {
      if (amount !== null && amount !== void 0) {
        this.storeBit(1);
        this.storeCoins(amount);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */
    storeAddress(address) {
      this._bits.writeAddress(address);
      return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeRef(cell) {
      if (this._refs.length >= 4) {
        throw new Error("Too many references");
      }
      if (cell instanceof Cell_1.Cell) {
        this._refs.push(cell);
      } else if (cell instanceof Builder2) {
        this._refs.push(cell.endCell());
      } else {
        throw new Error("Invalid argument");
      }
      return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeMaybeRef(cell) {
      if (cell) {
        this.storeBit(1);
        this.storeRef(cell);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */
    storeSlice(src) {
      let c = src.clone();
      if (c.remainingBits > 0) {
        this.storeBits(c.loadBits(c.remainingBits));
      }
      while (c.remainingRefs > 0) {
        this.storeRef(c.loadRef());
      }
      return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */
    storeMaybeSlice(src) {
      if (src) {
        this.storeBit(1);
        this.storeSlice(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */
    storeBuilder(src) {
      return this.storeSlice(src.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */
    storeMaybeBuilder(src) {
      if (src) {
        this.storeBit(1);
        this.storeBuilder(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeWritable(writer) {
      if (typeof writer === "object") {
        writer.writeTo(this);
      } else {
        writer(this);
      }
      return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeMaybeWritable(writer) {
      if (writer) {
        this.storeBit(1);
        this.storeWritable(writer);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */
    store(writer) {
      this.storeWritable(writer);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeStringTail(src) {
      (0, strings_1.writeString)(src, this);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringTail(src) {
      if (src !== null && src !== void 0) {
        this.storeBit(1);
        (0, strings_1.writeString)(src, this);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeStringRefTail(src) {
      this.storeRef(beginCell().storeStringTail(src));
      return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringRefTail(src) {
      if (src !== null && src !== void 0) {
        this.storeBit(1);
        this.storeStringRefTail(src);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDict(dict, key, value) {
      if (dict) {
        dict.store(this, key, value);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDictDirect(dict, key, value) {
      dict.storeDirect(this, key, value);
      return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */
    endCell(opts) {
      return new Cell_1.Cell({
        bits: this._bits.build(),
        refs: this._refs,
        exotic: opts?.exotic
      });
    }
    /**
     * Convert to cell
     * @returns cell
     */
    asCell() {
      return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */
    asSlice() {
      return this.endCell().beginParse();
    }
  }
  Builder$3.Builder = Builder2;
  return Builder$3;
}
var StateInit = {};
var SimpleLibrary = {};
var hasRequiredSimpleLibrary;
function requireSimpleLibrary() {
  if (hasRequiredSimpleLibrary) return SimpleLibrary;
  hasRequiredSimpleLibrary = 1;
  Object.defineProperty(SimpleLibrary, "__esModule", { value: true });
  SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
  function loadSimpleLibrary(slice) {
    return {
      public: slice.loadBit(),
      root: slice.loadRef()
    };
  }
  SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
  function storeSimpleLibrary(src) {
    return (builder2) => {
      builder2.storeBit(src.public);
      builder2.storeRef(src.root);
    };
  }
  SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
  SimpleLibrary.SimpleLibraryValue = {
    serialize(src, builder2) {
      storeSimpleLibrary(src)(builder2);
    },
    parse(src) {
      return loadSimpleLibrary(src);
    }
  };
  return SimpleLibrary;
}
var TickTock = {};
var hasRequiredTickTock;
function requireTickTock() {
  if (hasRequiredTickTock) return TickTock;
  hasRequiredTickTock = 1;
  Object.defineProperty(TickTock, "__esModule", { value: true });
  TickTock.storeTickTock = TickTock.loadTickTock = void 0;
  function loadTickTock(slice) {
    return {
      tick: slice.loadBit(),
      tock: slice.loadBit()
    };
  }
  TickTock.loadTickTock = loadTickTock;
  function storeTickTock(src) {
    return (builder2) => {
      builder2.storeBit(src.tick);
      builder2.storeBit(src.tock);
    };
  }
  TickTock.storeTickTock = storeTickTock;
  return TickTock;
}
var hasRequiredStateInit;
function requireStateInit() {
  if (hasRequiredStateInit) return StateInit;
  hasRequiredStateInit = 1;
  Object.defineProperty(StateInit, "__esModule", { value: true });
  StateInit.storeStateInit = StateInit.loadStateInit = void 0;
  const Dictionary_1 = requireDictionary();
  const SimpleLibrary_1 = requireSimpleLibrary();
  const TickTock_1 = requireTickTock();
  function loadStateInit(slice) {
    let splitDepth;
    if (slice.loadBit()) {
      splitDepth = slice.loadUint(5);
    }
    let special;
    if (slice.loadBit()) {
      special = (0, TickTock_1.loadTickTock)(slice);
    }
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
      libraries = void 0;
    }
    return {
      splitDepth,
      special,
      code,
      data,
      libraries
    };
  }
  StateInit.loadStateInit = loadStateInit;
  function storeStateInit(src) {
    return (builder2) => {
      if (src.splitDepth !== null && src.splitDepth !== void 0) {
        builder2.storeBit(true);
        builder2.storeUint(src.splitDepth, 5);
      } else {
        builder2.storeBit(false);
      }
      if (src.special !== null && src.special !== void 0) {
        builder2.storeBit(true);
        builder2.store((0, TickTock_1.storeTickTock)(src.special));
      } else {
        builder2.storeBit(false);
      }
      builder2.storeMaybeRef(src.code);
      builder2.storeMaybeRef(src.data);
      builder2.storeDict(src.libraries);
    };
  }
  StateInit.storeStateInit = storeStateInit;
  return StateInit;
}
var hasRequiredContractAddress;
function requireContractAddress() {
  if (hasRequiredContractAddress) return contractAddress;
  hasRequiredContractAddress = 1;
  Object.defineProperty(contractAddress, "__esModule", { value: true });
  contractAddress.contractAddress = void 0;
  const Builder_12 = requireBuilder$1();
  const StateInit_1 = requireStateInit();
  const Address_1 = requireAddress();
  function contractAddress$12(workchain, init2) {
    let hash = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(init2)).endCell().hash();
    return new Address_1.Address(workchain, hash);
  }
  contractAddress.contractAddress = contractAddress$12;
  return contractAddress;
}
var tuple = {};
var hasRequiredTuple;
function requireTuple() {
  if (hasRequiredTuple) return tuple;
  hasRequiredTuple = 1;
  Object.defineProperty(tuple, "__esModule", { value: true });
  tuple.parseTuple = tuple.serializeTuple = void 0;
  const Builder_12 = requireBuilder$1();
  const INT64_MIN = BigInt("-9223372036854775808");
  const INT64_MAX = BigInt("9223372036854775807");
  function serializeTupleItem(src, builder2) {
    if (src.type === "null") {
      builder2.storeUint(0, 8);
    } else if (src.type === "int") {
      if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
        builder2.storeUint(1, 8);
        builder2.storeInt(src.value, 64);
      } else {
        builder2.storeUint(256, 15);
        builder2.storeInt(src.value, 257);
      }
    } else if (src.type === "nan") {
      builder2.storeInt(767, 16);
    } else if (src.type === "cell") {
      builder2.storeUint(3, 8);
      builder2.storeRef(src.cell);
    } else if (src.type === "slice") {
      builder2.storeUint(4, 8);
      builder2.storeUint(0, 10);
      builder2.storeUint(src.cell.bits.length, 10);
      builder2.storeUint(0, 3);
      builder2.storeUint(src.cell.refs.length, 3);
      builder2.storeRef(src.cell);
    } else if (src.type === "builder") {
      builder2.storeUint(5, 8);
      builder2.storeRef(src.cell);
    } else if (src.type === "tuple") {
      let head = null;
      let tail = null;
      for (let i = 0; i < src.items.length; i++) {
        let s2 = head;
        head = tail;
        tail = s2;
        if (i > 1) {
          head = (0, Builder_12.beginCell)().storeRef(tail).storeRef(head).endCell();
        }
        let bc = (0, Builder_12.beginCell)();
        serializeTupleItem(src.items[i], bc);
        tail = bc.endCell();
      }
      builder2.storeUint(7, 8);
      builder2.storeUint(src.items.length, 16);
      if (head) {
        builder2.storeRef(head);
      }
      if (tail) {
        builder2.storeRef(tail);
      }
    } else {
      throw Error("Invalid value");
    }
  }
  function parseStackItem(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
      return { type: "null" };
    } else if (kind === 1) {
      return { type: "int", value: cs.loadIntBig(64) };
    } else if (kind === 2) {
      if (cs.loadUint(7) === 0) {
        return { type: "int", value: cs.loadIntBig(257) };
      } else {
        cs.loadBit();
        return { type: "nan" };
      }
    } else if (kind === 3) {
      return { type: "cell", cell: cs.loadRef() };
    } else if (kind === 4) {
      let startBits = cs.loadUint(10);
      let endBits = cs.loadUint(10);
      let startRefs = cs.loadUint(3);
      let endRefs = cs.loadUint(3);
      let rs = cs.loadRef().beginParse();
      rs.skip(startBits);
      let dt2 = rs.loadBits(endBits - startBits);
      let builder2 = (0, Builder_12.beginCell)().storeBits(dt2);
      if (startRefs < endRefs) {
        for (let i = 0; i < startRefs; i++) {
          rs.loadRef();
        }
        for (let i = 0; i < endRefs - startRefs; i++) {
          builder2.storeRef(rs.loadRef());
        }
      }
      return { type: "slice", cell: builder2.endCell() };
    } else if (kind === 5) {
      return { type: "builder", cell: cs.loadRef() };
    } else if (kind === 7) {
      let length = cs.loadUint(16);
      let items = [];
      if (length > 1) {
        let head = cs.loadRef().beginParse();
        let tail = cs.loadRef().beginParse();
        items.unshift(parseStackItem(tail));
        for (let i = 0; i < length - 2; i++) {
          let ohead = head;
          head = ohead.loadRef().beginParse();
          tail = ohead.loadRef().beginParse();
          items.unshift(parseStackItem(tail));
        }
        items.unshift(parseStackItem(head));
      } else if (length === 1) {
        items.push(parseStackItem(cs.loadRef().beginParse()));
      }
      return { type: "tuple", items };
    } else {
      throw Error("Unsupported stack item");
    }
  }
  function serializeTupleTail(src, builder2) {
    if (src.length > 0) {
      let tail = (0, Builder_12.beginCell)();
      serializeTupleTail(src.slice(0, src.length - 1), tail);
      builder2.storeRef(tail.endCell());
      serializeTupleItem(src[src.length - 1], builder2);
    }
  }
  function serializeTuple(src) {
    let builder2 = (0, Builder_12.beginCell)();
    builder2.storeUint(src.length, 24);
    let r = [...src];
    serializeTupleTail(r, builder2);
    return builder2.endCell();
  }
  tuple.serializeTuple = serializeTuple;
  function parseTuple(src) {
    let res = [];
    let cs = src.beginParse();
    let size = cs.loadUint(24);
    for (let i = 0; i < size; i++) {
      let next = cs.loadRef();
      res.unshift(parseStackItem(cs));
      cs = next.beginParse();
    }
    return res;
  }
  tuple.parseTuple = parseTuple;
  return tuple;
}
var reader = {};
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  Object.defineProperty(reader, "__esModule", { value: true });
  reader.TupleReader = void 0;
  class TupleReader {
    constructor(items) {
      this.items = [...items];
    }
    get remaining() {
      return this.items.length;
    }
    peek() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      return this.items[0];
    }
    pop() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      let res = this.items[0];
      this.items.splice(0, 1);
      return res;
    }
    skip(num = 1) {
      for (let i = 0; i < num; i++) {
        this.pop();
      }
      return this;
    }
    readBigNumber() {
      let popped = this.pop();
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readBigNumberOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readNumber() {
      return Number(this.readBigNumber());
    }
    readNumberOpt() {
      let r = this.readBigNumberOpt();
      if (r !== null) {
        return Number(r);
      } else {
        return null;
      }
    }
    readBoolean() {
      let res = this.readNumber();
      return res === 0 ? false : true;
    }
    readBooleanOpt() {
      let res = this.readNumberOpt();
      if (res !== null) {
        return res === 0 ? false : true;
      } else {
        return null;
      }
    }
    readAddress() {
      let r = this.readCell().beginParse().loadAddress();
      if (r !== null) {
        return r;
      } else {
        throw Error("Not an address");
      }
    }
    readAddressOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        return r.beginParse().loadMaybeAddress();
      } else {
        return null;
      }
    }
    readCell() {
      let popped = this.pop();
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell: " + popped.type);
      }
      return popped.cell;
    }
    readCellOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell");
      }
      return popped.cell;
    }
    readTuple() {
      let popped = this.pop();
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    readTupleOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    static readLispList(reader2) {
      const result = [];
      let tail = reader2;
      while (tail !== null) {
        var head = tail.pop();
        if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
          throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
        }
        tail = tail.readTupleOpt();
        result.push(head);
      }
      return result;
    }
    readLispListDirect() {
      if (this.items.length === 1 && this.items[0].type === "null") {
        return [];
      }
      return TupleReader.readLispList(this);
    }
    readLispList() {
      return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
      let s2 = this.readCell().beginParse();
      if (s2.remainingRefs !== 0) {
        throw Error("Not a buffer");
      }
      if (s2.remainingBits % 8 !== 0) {
        throw Error("Not a buffer");
      }
      return s2.loadBuffer(s2.remainingBits / 8);
    }
    readBufferOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        if (s2.remainingRefs !== 0 || s2.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s2.loadBuffer(s2.remainingBits / 8);
      } else {
        return null;
      }
    }
    readString() {
      let s2 = this.readCell().beginParse();
      return s2.loadStringTail();
    }
    readStringOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        return s2.loadStringTail();
      } else {
        return null;
      }
    }
  }
  reader.TupleReader = TupleReader;
  return reader;
}
var builder = {};
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", { value: true });
  builder.TupleBuilder = void 0;
  const Builder_12 = requireBuilder$1();
  const Cell_1 = requireCell();
  const Slice_1 = requireSlice();
  class TupleBuilder {
    constructor() {
      this._tuple = [];
    }
    writeNumber(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: BigInt(v2) });
      }
    }
    writeBoolean(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: v2 ? -1n : 0n });
      }
    }
    writeBuffer(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeBuffer(v2).endCell() });
      }
    }
    writeString(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeStringTail(v2).endCell() });
      }
    }
    writeCell(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "cell", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "cell", cell: v2.asCell() });
        }
      }
    }
    writeSlice(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "slice", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "slice", cell: v2.asCell() });
        }
      }
    }
    writeBuilder(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "builder", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "builder", cell: v2.asCell() });
        }
      }
    }
    writeTuple(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "tuple", items: v2 });
      }
    }
    writeAddress(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeAddress(v2).endCell() });
      }
    }
    build() {
      return [...this._tuple];
    }
  }
  builder.TupleBuilder = TupleBuilder;
  return builder;
}
var _export = {};
var _helpers = {};
var convert = {};
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromNano = convert.toNano = void 0;
  function toNano(src) {
    if (typeof src === "bigint") {
      return src * 1000000000n;
    } else {
      if (typeof src === "number") {
        if (!Number.isFinite(src)) {
          throw Error("Invalid number");
        }
        if (Math.log10(src) <= 6) {
          src = src.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
        } else if (src - Math.trunc(src) === 0) {
          src = src.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
        } else {
          throw Error("Not enough precision for a number value. Use string value instead");
        }
      }
      let neg = false;
      while (src.startsWith("-")) {
        neg = !neg;
        src = src.slice(1);
      }
      if (src === ".") {
        throw Error("Invalid number");
      }
      let parts = src.split(".");
      if (parts.length > 2) {
        throw Error("Invalid number");
      }
      let whole = parts[0];
      let frac = parts[1];
      if (!whole) {
        whole = "0";
      }
      if (!frac) {
        frac = "0";
      }
      if (frac.length > 9) {
        throw Error("Invalid number");
      }
      while (frac.length < 9) {
        frac += "0";
      }
      let r = BigInt(whole) * 1000000000n + BigInt(frac);
      if (neg) {
        r = -r;
      }
      return r;
    }
  }
  convert.toNano = toNano;
  function fromNano(src) {
    let v2 = BigInt(src);
    let neg = false;
    if (v2 < 0) {
      neg = true;
      v2 = -v2;
    }
    let frac = v2 % 1000000000n;
    let facStr = frac.toString();
    while (facStr.length < 9) {
      facStr = "0" + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let whole = v2 / 1000000000n;
    let wholeStr = whole.toString();
    let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
    if (neg) {
      value = "-" + value;
    }
    return value;
  }
  convert.fromNano = fromNano;
  return convert;
}
var ExtraCurrency = {};
var hasRequiredExtraCurrency;
function requireExtraCurrency() {
  if (hasRequiredExtraCurrency) return ExtraCurrency;
  hasRequiredExtraCurrency = 1;
  Object.defineProperty(ExtraCurrency, "__esModule", { value: true });
  ExtraCurrency.packExtraCurrencyCell = ExtraCurrency.packExtraCurrencyDict = ExtraCurrency.storeExtraCurrency = ExtraCurrency.loadMaybeExtraCurrency = ExtraCurrency.loadExtraCurrency = void 0;
  const Builder_12 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k2, v2] of ecDict) {
      ecMap[k2] = v2;
    }
    return ecMap;
  }
  ExtraCurrency.loadExtraCurrency = loadExtraCurrency;
  function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
  }
  ExtraCurrency.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
  function storeExtraCurrency(extracurrency) {
    return (builder2) => {
      builder2.storeDict(packExtraCurrencyDict(extracurrency));
    };
  }
  ExtraCurrency.storeExtraCurrency = storeExtraCurrency;
  function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k2, v2]) => resEc.set(Number(k2), v2));
    return resEc;
  }
  ExtraCurrency.packExtraCurrencyDict = packExtraCurrencyDict;
  function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_12.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
  }
  ExtraCurrency.packExtraCurrencyCell = packExtraCurrencyCell;
  return ExtraCurrency;
}
var hasRequired_helpers;
function require_helpers() {
  if (hasRequired_helpers) return _helpers;
  hasRequired_helpers = 1;
  Object.defineProperty(_helpers, "__esModule", { value: true });
  _helpers.comment = _helpers.external = _helpers.internal = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  const Builder_12 = requireBuilder$1();
  const convert_1 = requireConvert();
  const ExtraCurrency_1 = requireExtraCurrency();
  function internal(src) {
    let bounce = true;
    if (src.bounce !== null && src.bounce !== void 0) {
      bounce = src.bounce;
    }
    let to2;
    if (typeof src.to === "string") {
      to2 = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
      to2 = src.to;
    } else {
      throw new Error(`Invalid address ${src.to}`);
    }
    let value;
    if (typeof src.value === "string") {
      value = (0, convert_1.toNano)(src.value);
    } else {
      value = src.value;
    }
    let other;
    if (src.extracurrency) {
      other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src.extracurrency);
    }
    let body = Cell_1.Cell.EMPTY;
    if (typeof src.body === "string") {
      body = (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
    } else if (src.body) {
      body = src.body;
    }
    return {
      info: {
        type: "internal",
        dest: to2,
        value: { coins: value, other },
        bounce,
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
      },
      init: src.init ?? void 0,
      body
    };
  }
  _helpers.internal = internal;
  function external(src) {
    let to2;
    if (typeof src.to === "string") {
      to2 = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
      to2 = src.to;
    } else {
      throw new Error(`Invalid address ${src.to}`);
    }
    return {
      info: {
        type: "external-in",
        dest: to2,
        importFee: 0n
      },
      init: src.init ?? void 0,
      body: src.body || Cell_1.Cell.EMPTY
    };
  }
  _helpers.external = external;
  function comment(src) {
    return (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
  }
  _helpers.comment = comment;
  return _helpers;
}
var Account = {};
var AccountStorage = {};
var AccountState = {};
var hasRequiredAccountState;
function requireAccountState() {
  if (hasRequiredAccountState) return AccountState;
  hasRequiredAccountState = 1;
  Object.defineProperty(AccountState, "__esModule", { value: true });
  AccountState.storeAccountState = AccountState.loadAccountState = void 0;
  const StateInit_1 = requireStateInit();
  function loadAccountState(cs) {
    if (cs.loadBit()) {
      return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
    } else if (cs.loadBit()) {
      return { type: "frozen", stateHash: cs.loadUintBig(256) };
    } else {
      return { type: "uninit" };
    }
  }
  AccountState.loadAccountState = loadAccountState;
  function storeAccountState(src) {
    return (builder2) => {
      if (src.type === "active") {
        builder2.storeBit(true);
        builder2.store((0, StateInit_1.storeStateInit)(src.state));
      } else if (src.type === "frozen") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.storeUint(src.stateHash, 256);
      } else if (src.type === "uninit") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      }
    };
  }
  AccountState.storeAccountState = storeAccountState;
  return AccountState;
}
var CurrencyCollection = {};
var hasRequiredCurrencyCollection;
function requireCurrencyCollection() {
  if (hasRequiredCurrencyCollection) return CurrencyCollection;
  hasRequiredCurrencyCollection = 1;
  Object.defineProperty(CurrencyCollection, "__esModule", { value: true });
  CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
  const Dictionary_1 = requireDictionary();
  function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
      5
      /* log2(32) */
    ));
    if (other.size === 0) {
      return { coins };
    } else {
      return { other, coins };
    }
  }
  CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
  function storeCurrencyCollection(collection) {
    return (builder2) => {
      builder2.storeCoins(collection.coins);
      if (collection.other) {
        builder2.storeDict(collection.other);
      } else {
        builder2.storeBit(0);
      }
    };
  }
  CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
  return CurrencyCollection;
}
var hasRequiredAccountStorage;
function requireAccountStorage() {
  if (hasRequiredAccountStorage) return AccountStorage;
  hasRequiredAccountStorage = 1;
  Object.defineProperty(AccountStorage, "__esModule", { value: true });
  AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
  const AccountState_1 = requireAccountState();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadAccountStorage(slice) {
    return {
      lastTransLt: slice.loadUintBig(64),
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
      state: (0, AccountState_1.loadAccountState)(slice)
    };
  }
  AccountStorage.loadAccountStorage = loadAccountStorage;
  function storeAccountStorage(src) {
    return (builder2) => {
      builder2.storeUint(src.lastTransLt, 64);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
      builder2.store((0, AccountState_1.storeAccountState)(src.state));
    };
  }
  AccountStorage.storeAccountStorage = storeAccountStorage;
  return AccountStorage;
}
var StorageInfo = {};
var StorageExtraInfo = {};
var hasRequiredStorageExtraInfo;
function requireStorageExtraInfo() {
  if (hasRequiredStorageExtraInfo) return StorageExtraInfo;
  hasRequiredStorageExtraInfo = 1;
  Object.defineProperty(StorageExtraInfo, "__esModule", { value: true });
  StorageExtraInfo.storeStorageExtraInfo = StorageExtraInfo.loadStorageExtraInfo = void 0;
  function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
      return null;
    }
    if (header === 1) {
      return {
        dictHash: slice.loadUintBig(256)
      };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
  }
  StorageExtraInfo.loadStorageExtraInfo = loadStorageExtraInfo;
  function storeStorageExtraInfo(src) {
    return (builder2) => {
      if (src === null) {
        builder2.storeUint(0, 3);
      } else {
        builder2.storeUint(1, 3);
        builder2.storeUint(src.dictHash, 256);
      }
    };
  }
  StorageExtraInfo.storeStorageExtraInfo = storeStorageExtraInfo;
  return StorageExtraInfo;
}
var StorageUsed = {};
var hasRequiredStorageUsed;
function requireStorageUsed() {
  if (hasRequiredStorageUsed) return StorageUsed;
  hasRequiredStorageUsed = 1;
  Object.defineProperty(StorageUsed, "__esModule", { value: true });
  StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
  function loadStorageUsed(cs) {
    return {
      cells: cs.loadVarUintBig(3),
      bits: cs.loadVarUintBig(3)
    };
  }
  StorageUsed.loadStorageUsed = loadStorageUsed;
  function storeStorageUsed(src) {
    return (builder2) => {
      builder2.storeVarUint(src.cells, 3);
      builder2.storeVarUint(src.bits, 3);
    };
  }
  StorageUsed.storeStorageUsed = storeStorageUsed;
  return StorageUsed;
}
var hasRequiredStorageInfo;
function requireStorageInfo() {
  if (hasRequiredStorageInfo) return StorageInfo;
  hasRequiredStorageInfo = 1;
  Object.defineProperty(StorageInfo, "__esModule", { value: true });
  StorageInfo.storeStorageInfo = StorageInfo.loadStorageInfo = void 0;
  const StorageExtraInfo_1 = requireStorageExtraInfo();
  const StorageUsed_1 = requireStorageUsed();
  function loadStorageInfo(slice) {
    return {
      used: (0, StorageUsed_1.loadStorageUsed)(slice),
      storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
      lastPaid: slice.loadUint(32),
      duePayment: slice.loadMaybeCoins()
    };
  }
  StorageInfo.loadStorageInfo = loadStorageInfo;
  function storeStorageInfo(src) {
    return (builder2) => {
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src.used));
      builder2.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src.storageExtra));
      builder2.storeUint(src.lastPaid, 32);
      builder2.storeMaybeCoins(src.duePayment);
    };
  }
  StorageInfo.storeStorageInfo = storeStorageInfo;
  return StorageInfo;
}
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return Account;
  hasRequiredAccount = 1;
  Object.defineProperty(Account, "__esModule", { value: true });
  Account.storeAccount = Account.loadAccount = void 0;
  const AccountStorage_1 = requireAccountStorage();
  const StorageInfo_1 = requireStorageInfo();
  function loadAccount(slice) {
    return {
      addr: slice.loadAddress(),
      storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
      storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
  }
  Account.loadAccount = loadAccount;
  function storeAccount(src) {
    return (builder2) => {
      builder2.storeAddress(src.addr);
      builder2.store((0, StorageInfo_1.storeStorageInfo)(src.storageStats));
      builder2.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
    };
  }
  Account.storeAccount = storeAccount;
  return Account;
}
var AccountStatus = {};
var hasRequiredAccountStatus;
function requireAccountStatus() {
  if (hasRequiredAccountStatus) return AccountStatus;
  hasRequiredAccountStatus = 1;
  Object.defineProperty(AccountStatus, "__esModule", { value: true });
  AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
  function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0) {
      return "uninitialized";
    }
    if (status === 1) {
      return "frozen";
    }
    if (status === 2) {
      return "active";
    }
    if (status === 3) {
      return "non-existing";
    }
    throw Error("Invalid data");
  }
  AccountStatus.loadAccountStatus = loadAccountStatus;
  function storeAccountStatus(src) {
    return (builder2) => {
      if (src === "uninitialized") {
        builder2.storeUint(0, 2);
      } else if (src === "frozen") {
        builder2.storeUint(1, 2);
      } else if (src === "active") {
        builder2.storeUint(2, 2);
      } else if (src === "non-existing") {
        builder2.storeUint(3, 2);
      } else {
        throw Error("Invalid data");
      }
      return builder2;
    };
  }
  AccountStatus.storeAccountStatus = storeAccountStatus;
  return AccountStatus;
}
var AccountStatusChange = {};
var hasRequiredAccountStatusChange;
function requireAccountStatusChange() {
  if (hasRequiredAccountStatusChange) return AccountStatusChange;
  hasRequiredAccountStatusChange = 1;
  Object.defineProperty(AccountStatusChange, "__esModule", { value: true });
  AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
  function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
      return "unchanged";
    }
    if (slice.loadBit()) {
      return "deleted";
    } else {
      return "frozen";
    }
  }
  AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
  function storeAccountStatusChange(src) {
    return (builder2) => {
      if (src == "unchanged") {
        builder2.storeBit(0);
      } else if (src === "frozen") {
        builder2.storeBit(1);
        builder2.storeBit(0);
      } else if (src === "deleted") {
        builder2.storeBit(1);
        builder2.storeBit(1);
      } else {
        throw Error("Invalid account status change");
      }
    };
  }
  AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
  return AccountStatusChange;
}
var OutList = {};
var MessageRelaxed = {};
var CommonMessageInfoRelaxed = {};
var hasRequiredCommonMessageInfoRelaxed;
function requireCommonMessageInfoRelaxed() {
  if (hasRequiredCommonMessageInfoRelaxed) return CommonMessageInfoRelaxed;
  hasRequiredCommonMessageInfoRelaxed = 1;
  Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", { value: true });
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfoRelaxed(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src2 = slice.loadMaybeAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src2,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    }
    const src = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
  function storeCommonMessageInfoRelaxed(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  return CommonMessageInfoRelaxed;
}
var hasRequiredMessageRelaxed;
function requireMessageRelaxed() {
  if (hasRequiredMessageRelaxed) return MessageRelaxed;
  hasRequiredMessageRelaxed = 1;
  Object.defineProperty(MessageRelaxed, "__esModule", { value: true });
  MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
  const Builder_12 = requireBuilder$1();
  const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
  const StateInit_1 = requireStateInit();
  function loadMessageRelaxed(slice) {
    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init2 = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init2 = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init2 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init: init2,
      body
    };
  }
  MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
  function storeMessageRelaxed(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          if (builder2.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        if (builder2.availableBits - 1 >= message.body.bits.length && builder2.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
          needRef = false;
        } else {
          needRef = true;
        }
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
  return MessageRelaxed;
}
var LibRef = {};
var hasRequiredLibRef;
function requireLibRef() {
  if (hasRequiredLibRef) return LibRef;
  hasRequiredLibRef = 1;
  Object.defineProperty(LibRef, "__esModule", { value: true });
  LibRef.storeLibRef = LibRef.loadLibRef = void 0;
  function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
      return {
        type: "hash",
        libHash: slice.loadBuffer(32)
      };
    } else {
      return {
        type: "ref",
        library: slice.loadRef()
      };
    }
  }
  LibRef.loadLibRef = loadLibRef;
  function storeLibRef(src) {
    return (builder2) => {
      if (src.type === "hash") {
        builder2.storeUint(0, 1);
        builder2.storeBuffer(src.libHash);
      } else {
        builder2.storeUint(1, 1);
        builder2.storeRef(src.library);
      }
    };
  }
  LibRef.storeLibRef = storeLibRef;
  return LibRef;
}
var hasRequiredOutList;
function requireOutList() {
  if (hasRequiredOutList) return OutList;
  hasRequiredOutList = 1;
  Object.defineProperty(OutList, "__esModule", { value: true });
  OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
  const MessageRelaxed_1 = requireMessageRelaxed();
  const Builder_12 = requireBuilder$1();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const LibRef_1 = requireLibRef();
  function storeOutAction(action) {
    switch (action.type) {
      case "sendMsg":
        return storeOutActionSendMsg(action);
      case "setCode":
        return storeOutActionSetCode(action);
      case "reserve":
        return storeOutActionReserve(action);
      case "changeLibrary":
        return storeOutActionChangeLibrary(action);
      default:
        throw new Error(`Unknown action type ${action.type}`);
    }
  }
  OutList.storeOutAction = storeOutAction;
  const outActionSendMsgTag = 247711853;
  function storeOutActionSendMsg(action) {
    return (builder2) => {
      builder2.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_12.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
  }
  const outActionSetCodeTag = 2907562126;
  function storeOutActionSetCode(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
  }
  const outActionReserveTag = 921090057;
  function storeOutActionReserve(action) {
    return (builder2) => {
      builder2.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
  }
  const outActionChangeLibraryTag = 653925844;
  function storeOutActionChangeLibrary(action) {
    return (builder2) => {
      builder2.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
  }
  function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
      const mode = slice.loadUint(8);
      const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
      return {
        type: "sendMsg",
        mode,
        outMsg
      };
    }
    if (tag === outActionSetCodeTag) {
      const newCode = slice.loadRef();
      return {
        type: "setCode",
        newCode
      };
    }
    if (tag === outActionReserveTag) {
      const mode = slice.loadUint(8);
      const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        type: "reserve",
        mode,
        currency
      };
    }
    if (tag === outActionChangeLibraryTag) {
      const mode = slice.loadUint(7);
      const libRef = (0, LibRef_1.loadLibRef)(slice);
      return {
        type: "changeLibrary",
        mode,
        libRef
      };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
  }
  OutList.loadOutAction = loadOutAction;
  function storeOutList(actions) {
    const cell = actions.reduce((cell2, action) => (0, Builder_12.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_12.beginCell)().endCell());
    return (builder2) => {
      builder2.storeSlice(cell.beginParse());
    };
  }
  OutList.storeOutList = storeOutList;
  function loadOutList(slice) {
    const actions = [];
    while (slice.remainingRefs) {
      const nextCell = slice.loadRef();
      actions.push(loadOutAction(slice));
      slice = nextCell.beginParse();
    }
    return actions.reverse();
  }
  OutList.loadOutList = loadOutList;
  return OutList;
}
var CommonMessageInfo = {};
var hasRequiredCommonMessageInfo;
function requireCommonMessageInfo() {
  if (hasRequiredCommonMessageInfo) return CommonMessageInfo;
  hasRequiredCommonMessageInfo = 1;
  Object.defineProperty(CommonMessageInfo, "__esModule", { value: true });
  CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfo(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src2 = slice.loadAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src2,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      const src2 = slice.loadMaybeExternalAddress();
      const dest2 = slice.loadAddress();
      const importFee = slice.loadCoins();
      return {
        type: "external-in",
        src: src2,
        dest: dest2,
        importFee
      };
    }
    const src = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
  function storeCommonMessageInfo(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-in") {
        builder2.storeBit(1);
        builder2.storeBit(0);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeCoins(source.importFee);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
  return CommonMessageInfo;
}
var ComputeSkipReason = {};
var hasRequiredComputeSkipReason;
function requireComputeSkipReason() {
  if (hasRequiredComputeSkipReason) return ComputeSkipReason;
  hasRequiredComputeSkipReason = 1;
  Object.defineProperty(ComputeSkipReason, "__esModule", { value: true });
  ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
  function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0) {
      return "no-state";
    } else if (reason === 1) {
      return "bad-state";
    } else if (reason === 2) {
      return "no-gas";
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
  }
  ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
  function storeComputeSkipReason(src) {
    return (builder2) => {
      if (src === "no-state") {
        builder2.storeUint(0, 2);
      } else if (src === "bad-state") {
        builder2.storeUint(1, 2);
      } else if (src === "no-gas") {
        builder2.storeUint(2, 2);
      } else {
        throw new Error(`Unknown ComputeSkipReason: ${src}`);
      }
    };
  }
  ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
  return ComputeSkipReason;
}
var DepthBalanceInfo = {};
var hasRequiredDepthBalanceInfo;
function requireDepthBalanceInfo() {
  if (hasRequiredDepthBalanceInfo) return DepthBalanceInfo;
  hasRequiredDepthBalanceInfo = 1;
  Object.defineProperty(DepthBalanceInfo, "__esModule", { value: true });
  DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
      splitDepth,
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
  }
  DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
  function storeDepthBalanceInfo(src) {
    return (builder2) => {
      builder2.storeUint(src.splitDepth, 5);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
    };
  }
  DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
  return DepthBalanceInfo;
}
var HashUpdate = {};
var hasRequiredHashUpdate;
function requireHashUpdate() {
  if (hasRequiredHashUpdate) return HashUpdate;
  hasRequiredHashUpdate = 1;
  Object.defineProperty(HashUpdate, "__esModule", { value: true });
  HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
  function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 114) {
      throw Error("Invalid data");
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return { oldHash, newHash };
  }
  HashUpdate.loadHashUpdate = loadHashUpdate;
  function storeHashUpdate(src) {
    return (builder2) => {
      builder2.storeUint(114, 8);
      builder2.storeBuffer(src.oldHash);
      builder2.storeBuffer(src.newHash);
    };
  }
  HashUpdate.storeHashUpdate = storeHashUpdate;
  return HashUpdate;
}
var MasterchainStateExtra = {};
var hasRequiredMasterchainStateExtra;
function requireMasterchainStateExtra() {
  if (hasRequiredMasterchainStateExtra) return MasterchainStateExtra;
  hasRequiredMasterchainStateExtra = 1;
  Object.defineProperty(MasterchainStateExtra, "__esModule", { value: true });
  MasterchainStateExtra.loadMasterchainStateExtra = void 0;
  const Dictionary_1 = requireDictionary();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadMasterchainStateExtra(cs) {
    if (cs.loadUint(16) !== 52262) {
      throw Error("Invalid data");
    }
    if (cs.loadBit()) {
      cs.loadRef();
    }
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
      config,
      configAddress,
      globalBalance
    };
  }
  MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
  return MasterchainStateExtra;
}
var Message = {};
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return Message;
  hasRequiredMessage = 1;
  Object.defineProperty(Message, "__esModule", { value: true });
  Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
  const Builder_12 = requireBuilder$1();
  const CommonMessageInfo_1 = requireCommonMessageInfo();
  const StateInit_1 = requireStateInit();
  function loadMessage(slice) {
    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init2 = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init2 = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init2 = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init: init2,
      body
    };
  }
  Message.loadMessage = loadMessage;
  function storeMessage(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          needRef2 = builder2.availableBits - 2 < initCell.bits + message.body.bits.length;
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        needRef = builder2.availableBits - 1 < message.body.bits.length || builder2.refs + message.body.refs.length > 4;
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  Message.storeMessage = storeMessage;
  Message.MessageValue = {
    serialize(src, builder2) {
      builder2.storeRef((0, Builder_12.beginCell)().store(storeMessage(src)));
    },
    parse(slice) {
      return loadMessage(slice.loadRef().beginParse());
    }
  };
  return Message;
}
var SendMode = {};
var hasRequiredSendMode;
function requireSendMode() {
  if (hasRequiredSendMode) return SendMode;
  hasRequiredSendMode = 1;
  Object.defineProperty(SendMode, "__esModule", { value: true });
  SendMode.SendMode = void 0;
  var SendMode$12;
  (function(SendMode2) {
    SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode2[SendMode2["NONE"] = 0] = "NONE";
  })(SendMode$12 || (SendMode.SendMode = SendMode$12 = {}));
  return SendMode;
}
var ReserveMode = {};
var hasRequiredReserveMode;
function requireReserveMode() {
  if (hasRequiredReserveMode) return ReserveMode;
  hasRequiredReserveMode = 1;
  Object.defineProperty(ReserveMode, "__esModule", { value: true });
  ReserveMode.ReserveMode = void 0;
  var ReserveMode$12;
  (function(ReserveMode2) {
    ReserveMode2[ReserveMode2["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
  })(ReserveMode$12 || (ReserveMode.ReserveMode = ReserveMode$12 = {}));
  return ReserveMode;
}
var ShardAccount = {};
var hasRequiredShardAccount;
function requireShardAccount() {
  if (hasRequiredShardAccount) return ShardAccount;
  hasRequiredShardAccount = 1;
  Object.defineProperty(ShardAccount, "__esModule", { value: true });
  ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
  const Builder_12 = requireBuilder$1();
  const Account_1 = requireAccount();
  function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = void 0;
    if (!accountRef.isExotic) {
      let accountSlice = accountRef.beginParse();
      if (accountSlice.loadBit()) {
        account = (0, Account_1.loadAccount)(accountSlice);
      }
    }
    return {
      account,
      lastTransactionHash: slice.loadUintBig(256),
      lastTransactionLt: slice.loadUintBig(64)
    };
  }
  ShardAccount.loadShardAccount = loadShardAccount;
  function storeShardAccount(src) {
    return (builder2) => {
      if (src.account) {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
      } else {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(false));
      }
      builder2.storeUint(src.lastTransactionHash, 256);
      builder2.storeUint(src.lastTransactionLt, 64);
    };
  }
  ShardAccount.storeShardAccount = storeShardAccount;
  return ShardAccount;
}
var ShardAccounts = {};
var hasRequiredShardAccounts;
function requireShardAccounts() {
  if (hasRequiredShardAccounts) return ShardAccounts;
  hasRequiredShardAccounts = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    const Dictionary_1 = requireDictionary();
    const DepthBalanceInfo_1 = requireDepthBalanceInfo();
    const ShardAccount_1 = requireShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src, builder2) {
        builder2.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder2.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src) {
      return (Builder2) => {
        Builder2.storeDict(src);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  })(ShardAccounts);
  return ShardAccounts;
}
var ShardIdent = {};
var hasRequiredShardIdent;
function requireShardIdent() {
  if (hasRequiredShardIdent) return ShardIdent;
  hasRequiredShardIdent = 1;
  Object.defineProperty(ShardIdent, "__esModule", { value: true });
  ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
  function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
      throw Error("Invalid data");
    }
    return {
      shardPrefixBits: slice.loadUint(6),
      workchainId: slice.loadInt(32),
      shardPrefix: slice.loadUintBig(64)
    };
  }
  ShardIdent.loadShardIdent = loadShardIdent;
  function storeShardIdent(src) {
    return (builder2) => {
      builder2.storeUint(0, 2);
      builder2.storeUint(src.shardPrefixBits, 6);
      builder2.storeInt(src.workchainId, 32);
      builder2.storeUint(src.shardPrefix, 64);
    };
  }
  ShardIdent.storeShardIdent = storeShardIdent;
  return ShardIdent;
}
var ShardStateUnsplit = {};
var hasRequiredShardStateUnsplit;
function requireShardStateUnsplit() {
  if (hasRequiredShardStateUnsplit) return ShardStateUnsplit;
  hasRequiredShardStateUnsplit = 1;
  Object.defineProperty(ShardStateUnsplit, "__esModule", { value: true });
  ShardStateUnsplit.loadShardStateUnsplit = void 0;
  const MasterchainStateExtra_1 = requireMasterchainStateExtra();
  const ShardAccounts_1 = requireShardAccounts();
  const ShardIdent_1 = requireShardIdent();
  function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 2418257890) {
      throw Error("Invalid data");
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    let shardAccountsRef = cs.loadRef();
    let accounts = void 0;
    if (!shardAccountsRef.isExotic) {
      accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    cs.loadRef();
    let mcStateExtra = cs.loadBit();
    let extras2 = null;
    if (mcStateExtra) {
      let cell = cs.loadRef();
      if (!cell.isExotic) {
        extras2 = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
      }
    }
    return {
      globalId,
      shardId,
      seqno,
      vertSeqNo,
      genUtime,
      genLt,
      minRefMcSeqno,
      beforeSplit,
      accounts,
      extras: extras2
    };
  }
  ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
  return ShardStateUnsplit;
}
var SplitMergeInfo = {};
var hasRequiredSplitMergeInfo;
function requireSplitMergeInfo() {
  if (hasRequiredSplitMergeInfo) return SplitMergeInfo;
  hasRequiredSplitMergeInfo = 1;
  Object.defineProperty(SplitMergeInfo, "__esModule", { value: true });
  SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
  function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
      currentShardPrefixLength,
      accountSplitDepth,
      thisAddress,
      siblingAddress
    };
  }
  SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
  function storeSplitMergeInfo(src) {
    return (builder2) => {
      builder2.storeUint(src.currentShardPrefixLength, 6);
      builder2.storeUint(src.accountSplitDepth, 6);
      builder2.storeUint(src.thisAddress, 256);
      builder2.storeUint(src.siblingAddress, 256);
    };
  }
  SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
  return SplitMergeInfo;
}
var Transaction = {};
var TransactionDescription = {};
var TransactionActionPhase = {};
var hasRequiredTransactionActionPhase;
function requireTransactionActionPhase() {
  if (hasRequiredTransactionActionPhase) return TransactionActionPhase;
  hasRequiredTransactionActionPhase = 1;
  Object.defineProperty(TransactionActionPhase, "__esModule", { value: true });
  TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
      success,
      valid,
      noFunds,
      statusChange,
      totalFwdFees,
      totalActionFees,
      resultCode,
      resultArg,
      totalActions,
      specActions,
      skippedActions,
      messagesCreated,
      actionListHash,
      totalMessageSize
    };
  }
  TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
  function storeTransactionActionPhase(src) {
    return (builder2) => {
      builder2.storeBit(src.success);
      builder2.storeBit(src.valid);
      builder2.storeBit(src.noFunds);
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
      builder2.storeMaybeCoins(src.totalFwdFees);
      builder2.storeMaybeCoins(src.totalActionFees);
      builder2.storeInt(src.resultCode, 32);
      builder2.storeMaybeInt(src.resultArg, 32);
      builder2.storeUint(src.totalActions, 16);
      builder2.storeUint(src.specActions, 16);
      builder2.storeUint(src.skippedActions, 16);
      builder2.storeUint(src.messagesCreated, 16);
      builder2.storeUint(src.actionListHash, 256);
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src.totalMessageSize));
    };
  }
  TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
  return TransactionActionPhase;
}
var TransactionBouncePhase = {};
var hasRequiredTransactionBouncePhase;
function requireTransactionBouncePhase() {
  if (hasRequiredTransactionBouncePhase) return TransactionBouncePhase;
  hasRequiredTransactionBouncePhase = 1;
  Object.defineProperty(TransactionBouncePhase, "__esModule", { value: true });
  TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionBouncePhase(slice) {
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let messageFees = slice.loadCoins();
      let forwardFees = slice.loadCoins();
      return {
        type: "ok",
        messageSize,
        messageFees,
        forwardFees
      };
    }
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let requiredForwardFees = slice.loadCoins();
      return {
        type: "no-funds",
        messageSize,
        requiredForwardFees
      };
    }
    return {
      type: "negative-funds"
    };
  }
  TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
  function storeTransactionBouncePhase(src) {
    return (builder2) => {
      if (src.type === "ok") {
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
        builder2.storeCoins(src.messageFees);
        builder2.storeCoins(src.forwardFees);
      } else if (src.type === "negative-funds") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      } else if (src.type === "no-funds") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
        builder2.storeCoins(src.requiredForwardFees);
      } else {
        throw new Error("Invalid TransactionBouncePhase type");
      }
    };
  }
  TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
  return TransactionBouncePhase;
}
var TransactionComputePhase = {};
var hasRequiredTransactionComputePhase;
function requireTransactionComputePhase() {
  if (hasRequiredTransactionComputePhase) return TransactionComputePhase;
  hasRequiredTransactionComputePhase = 1;
  Object.defineProperty(TransactionComputePhase, "__esModule", { value: true });
  TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
  const Builder_12 = requireBuilder$1();
  const ComputeSkipReason_1 = requireComputeSkipReason();
  function loadTransactionComputePhase(slice) {
    if (!slice.loadBit()) {
      let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
      return {
        type: "skipped",
        reason
      };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
      type: "vm",
      success,
      messageStateUsed,
      accountActivated,
      gasFees,
      gasUsed,
      gasLimit,
      gasCredit,
      mode,
      exitCode,
      exitArg,
      vmSteps,
      vmInitStateHash,
      vmFinalStateHash
    };
  }
  TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
  function storeTransactionComputePhase(src) {
    return (builder2) => {
      if (src.type === "skipped") {
        builder2.storeBit(0);
        builder2.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
        return;
      }
      builder2.storeBit(1);
      builder2.storeBit(src.success);
      builder2.storeBit(src.messageStateUsed);
      builder2.storeBit(src.accountActivated);
      builder2.storeCoins(src.gasFees);
      builder2.storeRef((0, Builder_12.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b2) => src.gasCredit !== void 0 && src.gasCredit !== null ? b2.storeBit(1).storeVarUint(src.gasCredit, 2) : b2.storeBit(0)).storeUint(src.mode, 8).storeInt(src.exitCode, 32).store((b2) => src.exitArg !== void 0 && src.exitArg !== null ? b2.storeBit(1).storeInt(src.exitArg, 32) : b2.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
    };
  }
  TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
  return TransactionComputePhase;
}
var TransactionCreditPhase = {};
var hasRequiredTransactionCreditPhase;
function requireTransactionCreditPhase() {
  if (hasRequiredTransactionCreditPhase) return TransactionCreditPhase;
  hasRequiredTransactionCreditPhase = 1;
  Object.defineProperty(TransactionCreditPhase, "__esModule", { value: true });
  TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
      dueFeesColelcted,
      credit
    };
  }
  TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
  function storeTransactionCreditPhase(src) {
    return (builder2) => {
      if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src.dueFeesColelcted);
      }
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
    };
  }
  TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
  return TransactionCreditPhase;
}
var TransactionStoragePhase = {};
var hasRequiredTransactionStoragePhase;
function requireTransactionStoragePhase() {
  if (hasRequiredTransactionStoragePhase) return TransactionStoragePhase;
  hasRequiredTransactionStoragePhase = 1;
  Object.defineProperty(TransactionStoragePhase, "__esModule", { value: true });
  TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = void 0;
    if (slice.loadBit()) {
      storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
      storageFeesCollected,
      storageFeesDue,
      statusChange
    };
  }
  TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
  function storeTransactionsStoragePhase(src) {
    return (builder2) => {
      builder2.storeCoins(src.storageFeesCollected);
      if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src.storageFeesDue);
      }
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
    };
  }
  TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  return TransactionStoragePhase;
}
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
  if (hasRequiredTransactionDescription) return TransactionDescription;
  hasRequiredTransactionDescription = 1;
  Object.defineProperty(TransactionDescription, "__esModule", { value: true });
  TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
  const Builder_12 = requireBuilder$1();
  const SplitMergeInfo_1 = requireSplitMergeInfo();
  const Transaction_1 = requireTransaction();
  const TransactionActionPhase_1 = requireTransactionActionPhase();
  const TransactionBouncePhase_1 = requireTransactionBouncePhase();
  const TransactionComputePhase_1 = requireTransactionComputePhase();
  const TransactionCreditPhase_1 = requireTransactionCreditPhase();
  const TransactionStoragePhase_1 = requireTransactionStoragePhase();
  function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0) {
      const creditFirst = slice.loadBit();
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let creditPhase = void 0;
      if (slice.loadBit()) {
        creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      let aborted = slice.loadBit();
      let bouncePhase = void 0;
      if (slice.loadBit()) {
        bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
      }
      const destroyed = slice.loadBit();
      return {
        type: "generic",
        creditFirst,
        storagePhase,
        creditPhase,
        computePhase,
        actionPhase,
        bouncePhase,
        aborted,
        destroyed
      };
    }
    if (type === 1) {
      return {
        type: "storage",
        storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
      };
    }
    if (type === 2 || type === 3) {
      const isTock = type === 3;
      let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "tick-tock",
        isTock,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 4) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "split-prepare",
        splitInfo,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 5) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
      const installed = slice.loadBit();
      return {
        type: "split-install",
        splitInfo,
        prepareTransaction,
        installed
      };
    }
    throw Error(`Unsupported transaction description type ${type}`);
  }
  TransactionDescription.loadTransactionDescription = loadTransactionDescription;
  function storeTransactionDescription(src) {
    return (builder2) => {
      if (src.type === "generic") {
        builder2.storeUint(0, 4);
        builder2.storeBit(src.creditFirst);
        if (src.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        if (src.creditPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        if (src.bouncePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.destroyed);
      } else if (src.type === "storage") {
        builder2.storeUint(1, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
      } else if (src.type === "tick-tock") {
        builder2.storeUint(src.isTock ? 3 : 2, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        builder2.storeBit(src.destroyed);
      } else if (src.type === "split-prepare") {
        builder2.storeUint(4, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
        if (src.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
        if (src.actionPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src.aborted);
        builder2.storeBit(src.destroyed);
      } else if (src.type === "split-install") {
        builder2.storeUint(5, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
        builder2.storeRef((0, Builder_12.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
        builder2.storeBit(src.installed);
      } else {
        throw Error(`Unsupported transaction description type ${src.type}`);
      }
    };
  }
  TransactionDescription.storeTransactionDescription = storeTransactionDescription;
  return TransactionDescription;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction) return Transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(Transaction, "__esModule", { value: true });
  Transaction.storeTransaction = Transaction.loadTransaction = void 0;
  const Builder_12 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  const AccountStatus_1 = requireAccountStatus();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const HashUpdate_1 = requireHashUpdate();
  const Message_1 = requireMessage();
  const TransactionDescription_1 = requireTransactionDescription();
  function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 7) {
      throw Error("Invalid data");
    }
    let address = slice.loadUintBig(256);
    let lt2 = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
      address,
      lt: lt2,
      prevTransactionHash,
      prevTransactionLt,
      now,
      outMessagesCount,
      oldStatus,
      endStatus,
      inMessage,
      outMessages,
      totalFees,
      stateUpdate,
      description,
      raw,
      hash: () => raw.hash()
    };
  }
  Transaction.loadTransaction = loadTransaction;
  function storeTransaction(src) {
    return (builder2) => {
      builder2.storeUint(7, 4);
      builder2.storeUint(src.address, 256);
      builder2.storeUint(src.lt, 64);
      builder2.storeUint(src.prevTransactionHash, 256);
      builder2.storeUint(src.prevTransactionLt, 64);
      builder2.storeUint(src.now, 32);
      builder2.storeUint(src.outMessagesCount, 15);
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
      let msgBuilder = (0, Builder_12.beginCell)();
      if (src.inMessage) {
        msgBuilder.storeBit(true);
        msgBuilder.storeRef((0, Builder_12.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
      } else {
        msgBuilder.storeBit(false);
      }
      msgBuilder.storeDict(src.outMessages);
      builder2.storeRef(msgBuilder);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
    };
  }
  Transaction.storeTransaction = storeTransaction;
  return Transaction;
}
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = requireAccount();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = requireAccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = requireAccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = requireAccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = requireAccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = requireOutList();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = requireCommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = requireComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = requireCurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = requireDepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var ExtraCurrency_1 = requireExtraCurrency();
    Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyCell;
    } });
    Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyDict;
    } });
    Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadExtraCurrency;
    } });
    Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadMaybeExtraCurrency;
    } });
    Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.storeExtraCurrency;
    } });
    var HashUpdate_1 = requireHashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = requireMasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = requireMessage();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = requireMessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = requireSendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ReserveMode_1 = requireReserveMode();
    Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function() {
      return ReserveMode_1.ReserveMode;
    } });
    var ShardAccount_1 = requireShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = requireShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = requireShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = requireShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = requireSimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var LibRef_1 = requireLibRef();
    Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function() {
      return LibRef_1.loadLibRef;
    } });
    Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function() {
      return LibRef_1.storeLibRef;
    } });
    var SplitMergeInfo_1 = requireSplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = requireStateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInfo_1 = requireStorageInfo();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.storeStorageInfo;
    } });
    var StorageUsed_1 = requireStorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var TickTock_1 = requireTickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = requireTransaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = requireTransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = requireTransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = requireTransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = requireTransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = requireTransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = requireTransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  })(_export);
  return _export;
}
var openContract = {};
var hasRequiredOpenContract;
function requireOpenContract() {
  if (hasRequiredOpenContract) return openContract;
  hasRequiredOpenContract = 1;
  Object.defineProperty(openContract, "__esModule", { value: true });
  openContract.openContract = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  function openContract$12(src, factory) {
    let address;
    let init2 = null;
    if (!Address_1.Address.isAddress(src.address)) {
      throw Error("Invalid address");
    }
    address = src.address;
    if (src.init) {
      if (!(src.init.code instanceof Cell_1.Cell)) {
        throw Error("Invalid init.code");
      }
      if (!(src.init.data instanceof Cell_1.Cell)) {
        throw Error("Invalid init.data");
      }
      init2 = src.init;
    }
    let executor = factory({ address, init: init2 });
    return new Proxy(src, {
      get(target, prop) {
        const value = target[prop];
        if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send") || prop.startsWith("is"))) {
          if (typeof value === "function") {
            return (...args) => value.apply(target, [executor, ...args]);
          }
        }
        return value;
      }
    });
  }
  openContract.openContract = openContract$12;
  return openContract;
}
var ComputeError = {};
var hasRequiredComputeError;
function requireComputeError() {
  if (hasRequiredComputeError) return ComputeError;
  hasRequiredComputeError = 1;
  Object.defineProperty(ComputeError, "__esModule", { value: true });
  ComputeError.ComputeError = void 0;
  let ComputeError$12 = class ComputeError2 extends Error {
    constructor(message, exitCode, opts) {
      super(message);
      this.exitCode = exitCode;
      this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
      this.logs = opts && opts.logs ? opts.logs : null;
      Object.setPrototypeOf(this, ComputeError2.prototype);
    }
  };
  ComputeError.ComputeError = ComputeError$12;
  return ComputeError;
}
var getMethodId = {};
var hasRequiredGetMethodId;
function requireGetMethodId() {
  if (hasRequiredGetMethodId) return getMethodId;
  hasRequiredGetMethodId = 1;
  Object.defineProperty(getMethodId, "__esModule", { value: true });
  getMethodId.getMethodId = void 0;
  const TABLE = new Int16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ]);
  function crc162(data) {
    if (!(data instanceof Buffer)) {
      data = Buffer.from(data);
    }
    let crc = 0;
    for (let index2 = 0; index2 < data.length; index2++) {
      const byte = data[index2];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  }
  function getMethodId$12(name) {
    return crc162(name) & 65535 | 65536;
  }
  getMethodId.getMethodId = getMethodId$12;
  return getMethodId;
}
var safeSign = {};
var hasRequiredSafeSign;
function requireSafeSign() {
  if (hasRequiredSafeSign) return safeSign;
  hasRequiredSafeSign = 1;
  Object.defineProperty(safeSign, "__esModule", { value: true });
  safeSign.safeSignVerify = safeSign.safeSign = void 0;
  const crypto_1 = requireDist$4();
  const MIN_SEED_LENGTH = 8;
  const MAX_SEED_LENGTH = 64;
  function createSafeSignHash(cell, seed) {
    let seedData = Buffer.from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
      throw Error("Seed can	 be longer than 64 bytes");
    }
    if (seedData.length < MIN_SEED_LENGTH) {
      throw Error("Seed must be at least 8 bytes");
    }
    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
  }
  function safeSign$12(cell, secretKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
  }
  safeSign.safeSign = safeSign$12;
  function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
  }
  safeSign.safeSignVerify = safeSignVerify;
  return safeSign;
}
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2) return dist$1;
  hasRequiredDist$2 = 1;
  (function(exports) {
    var __createBinding = dist$1 && dist$1.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = dist$1 && dist$1.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = requireAddress();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = requireExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = requireADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = requireContractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = requireBitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = requireBitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = requireBitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_12 = requireBuilder$1();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_12.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_12.beginCell;
    } });
    var Slice_1 = requireSlice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = requireCellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = requireCell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = requireDictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = requireExoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.convertToMerkleProof;
    } });
    var exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = requireExoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = requireGenerateMerkleProof();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProofDirect;
    } });
    var generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = requireTuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    var reader_1 = requireReader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = requireBuilder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = requireOpenContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = requireComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = requireConvert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = requireCrc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = requireCrc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = requireBase32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = requireGetMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = requireSafeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  })(dist$1);
  return dist$1;
}
var TLBRuntime = {};
var build = {};
var ast = {};
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast;
  hasRequiredAst = 1;
  Object.defineProperty(ast, "__esModule", { value: true });
  ast.TLBCode = ast.TLBType = ast.TLBConstructor = ast.TLBParameter = ast.TLBVariable = ast.TLBVarExpr = ast.TLBUnaryOp = ast.TLBNumberExpr = ast.TLBBinaryOp = void 0;
  class TLBBinaryOp {
    constructor(left, right, operation, variables = /* @__PURE__ */ new Set([...left.variables, ...right.variables]), hasNeg = left.hasNeg || right.hasNeg) {
      this.left = left;
      this.right = right;
      this.operation = operation;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBBinaryOp = TLBBinaryOp;
  class TLBNumberExpr {
    constructor(n, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
      this.n = n;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBNumberExpr = TLBNumberExpr;
  class TLBUnaryOp {
    constructor(value, operation, variables = value.variables, hasNeg = value.hasNeg) {
      this.value = value;
      this.operation = operation;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBUnaryOp = TLBUnaryOp;
  class TLBVarExpr {
    constructor(x2, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
      this.x = x2;
      this.variables = variables;
      this.hasNeg = hasNeg;
      if (variables.size == 0) {
        variables.add(x2);
      }
    }
  }
  ast.TLBVarExpr = TLBVarExpr;
  class TLBVariable {
    constructor(isConst, negated, type, name, isField, deriveExpr, initialExpr) {
      this.isConst = isConst;
      this.negated = negated;
      this.type = type;
      this.name = name;
      this.isField = isField;
      this.deriveExpr = deriveExpr;
      this.initialExpr = initialExpr;
    }
  }
  ast.TLBVariable = TLBVariable;
  class TLBParameter {
    constructor(variable, paramExpr, argName) {
      this.variable = variable;
      this.paramExpr = paramExpr;
      this.argName = argName;
    }
  }
  ast.TLBParameter = TLBParameter;
  class TLBConstructor {
    constructor(parameters, variables, variablesMap, parametersMap, name, fields, tag, constraints, declaration, tlbType) {
      this.parameters = parameters;
      this.variables = variables;
      this.variablesMap = variablesMap;
      this.parametersMap = parametersMap;
      this.name = name;
      this.fields = fields;
      this.tag = tag;
      this.constraints = constraints;
      this.declaration = declaration;
      this.tlbType = tlbType;
    }
  }
  ast.TLBConstructor = TLBConstructor;
  class TLBType {
    constructor(name, constructors) {
      this.name = name;
      this.constructors = constructors;
    }
  }
  ast.TLBType = TLBType;
  class TLBCode {
    constructor(types) {
      this.types = types;
    }
  }
  ast.TLBCode = TLBCode;
  return ast;
}
var main = {};
var dist = {};
var intermediate = {};
var main$1 = { exports: {} };
function isValidType(type) {
  return type === "description" || type === "string" || type === "code";
}
function Failure$2(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error("invalid Failure type: " + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}
Failure$2.prototype.getPExpr = function() {
  return this.pexpr;
};
Failure$2.prototype.getText = function() {
  return this.text;
};
Failure$2.prototype.getType = function() {
  return this.type;
};
Failure$2.prototype.isDescription = function() {
  return this.type === "description";
};
Failure$2.prototype.isStringTerminal = function() {
  return this.type === "string";
};
Failure$2.prototype.isCode = function() {
  return this.type === "code";
};
Failure$2.prototype.isFluffy = function() {
  return this.fluffy;
};
Failure$2.prototype.makeFluffy = function() {
  this.fluffy = true;
};
Failure$2.prototype.clearFluffy = function() {
  this.fluffy = false;
};
Failure$2.prototype.subsumes = function(that) {
  return this.getText() === that.getText() && this.type === that.type && (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};
Failure$2.prototype.toString = function() {
  return this.type === "string" ? JSON.stringify(this.getText()) : this.getText();
};
Failure$2.prototype.clone = function() {
  const failure = new Failure$2(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};
Failure$2.prototype.toKey = function() {
  return this.toString() + "#" + this.type;
};
var Failure_1 = Failure$2;
var common$l = {};
(function(exports) {
  exports.abstract = function(optMethodName) {
    const methodName = optMethodName || "";
    return function() {
      throw new Error(
        "this method " + methodName + " is abstract! (it has no implementation in class " + this.constructor.name + ")"
      );
    };
  };
  exports.assert = function(cond, message) {
    if (!cond) {
      throw new Error(message || "Assertion failed");
    }
  };
  exports.defineLazyProperty = function(obj, propName, getterFn) {
    let memo;
    Object.defineProperty(obj, propName, {
      get() {
        if (!memo) {
          memo = getterFn.call(this);
        }
        return memo;
      }
    });
  };
  exports.clone = function(obj) {
    if (obj) {
      return Object.assign({}, obj);
    }
    return obj;
  };
  exports.repeatFn = function(fn2, n) {
    const arr = [];
    while (n-- > 0) {
      arr.push(fn2());
    }
    return arr;
  };
  exports.repeatStr = function(str, n) {
    return new Array(n + 1).join(str);
  };
  exports.repeat = function(x2, n) {
    return exports.repeatFn(() => x2, n);
  };
  exports.getDuplicates = function(array) {
    const duplicates = [];
    for (let idx = 0; idx < array.length; idx++) {
      const x2 = array[idx];
      if (array.lastIndexOf(x2) !== idx && duplicates.indexOf(x2) < 0) {
        duplicates.push(x2);
      }
    }
    return duplicates;
  };
  exports.copyWithoutDuplicates = function(array) {
    const noDuplicates = [];
    array.forEach((entry) => {
      if (noDuplicates.indexOf(entry) < 0) {
        noDuplicates.push(entry);
      }
    });
    return noDuplicates;
  };
  exports.isSyntactic = function(ruleName) {
    const firstChar = ruleName[0];
    return firstChar === firstChar.toUpperCase();
  };
  exports.isLexical = function(ruleName) {
    return !exports.isSyntactic(ruleName);
  };
  exports.padLeft = function(str, len, optChar) {
    const ch = optChar || " ";
    if (str.length < len) {
      return exports.repeatStr(ch, len - str.length) + str;
    }
    return str;
  };
  exports.StringBuffer = function() {
    this.strings = [];
  };
  exports.StringBuffer.prototype.append = function(str) {
    this.strings.push(str);
  };
  exports.StringBuffer.prototype.contents = function() {
    return this.strings.join("");
  };
  const escapeUnicode = (str) => String.fromCodePoint(parseInt(str, 16));
  exports.unescapeCodePoint = function(s2) {
    if (s2.charAt(0) === "\\") {
      switch (s2.charAt(1)) {
        case "b":
          return "\b";
        case "f":
          return "\f";
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "v":
          return "\v";
        case "x":
          return escapeUnicode(s2.slice(2, 4));
        case "u":
          return s2.charAt(2) === "{" ? escapeUnicode(s2.slice(3, -1)) : escapeUnicode(s2.slice(2, 6));
        default:
          return s2.charAt(1);
      }
    } else {
      return s2;
    }
  };
  exports.unexpectedObjToString = function(obj) {
    if (obj == null) {
      return String(obj);
    }
    const baseToString = Object.prototype.toString.call(obj);
    try {
      let typeName;
      if (obj.constructor && obj.constructor.name) {
        typeName = obj.constructor.name;
      } else if (baseToString.indexOf("[object ") === 0) {
        typeName = baseToString.slice(8, -1);
      } else {
        typeName = typeof obj;
      }
      return typeName + ": " + JSON.stringify(String(obj));
    } catch (e) {
      return baseToString;
    }
  };
})(common$l);
const common$k = common$l;
class Node {
  constructor(matchLength) {
    this.matchLength = matchLength;
  }
  get ctorName() {
    throw new Error("subclass responsibility");
  }
  numChildren() {
    return this.children ? this.children.length : 0;
  }
  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }
  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }
  hasChildren() {
    return this.numChildren() > 0;
  }
  hasNoChildren() {
    return !this.hasChildren();
  }
  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
        "cannot get only child of a node of type " + this.ctorName + " (it has " + this.numChildren() + " children)"
      );
    } else {
      return this.firstChild();
    }
  }
  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get first child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(0);
    }
  }
  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get last child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }
  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childBefore() called w/ an argument that is not a child");
    } else if (childIdx === 0) {
      throw new Error("cannot get child before first child");
    } else {
      return this.childAt(childIdx - 1);
    }
  }
  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childAfter() called w/ an argument that is not a child");
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error("cannot get child after last child");
    } else {
      return this.childAt(childIdx + 1);
    }
  }
  isTerminal() {
    return false;
  }
  isNonterminal() {
    return false;
  }
  isIteration() {
    return false;
  }
  isOptional() {
    return false;
  }
}
class TerminalNode$2 extends Node {
  get ctorName() {
    return "_terminal";
  }
  isTerminal() {
    return true;
  }
  get primitiveValue() {
    throw new Error("The `primitiveValue` property was removed in Ohm v17.");
  }
}
class NonterminalNode$1 extends Node {
  constructor(ruleName, children, childOffsets, matchLength) {
    super(matchLength);
    this.ruleName = ruleName;
    this.children = children;
    this.childOffsets = childOffsets;
  }
  get ctorName() {
    return this.ruleName;
  }
  isNonterminal() {
    return true;
  }
  isLexical() {
    return common$k.isLexical(this.ctorName);
  }
  isSyntactic() {
    return common$k.isSyntactic(this.ctorName);
  }
}
class IterationNode$2 extends Node {
  constructor(children, childOffsets, matchLength, isOptional) {
    super(matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }
  get ctorName() {
    return "_iter";
  }
  isIteration() {
    return true;
  }
  isOptional() {
    return this.optional;
  }
}
var nodes$1 = {
  TerminalNode: TerminalNode$2,
  NonterminalNode: NonterminalNode$1,
  IterationNode: IterationNode$2
};
var pexprsMain = {};
var UnicodeCategories$1 = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,
  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,
  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,
  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};
const UnicodeCategories = UnicodeCategories$1;
const common$j = common$l;
class PExpr$1 {
  constructor() {
    if (this.constructor === PExpr$1) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }
  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}
const any = Object.create(PExpr$1.prototype);
const end = Object.create(PExpr$1.prototype);
class Terminal$1 extends PExpr$1 {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}
class Range extends PExpr$1 {
  constructor(from, to2) {
    super();
    this.from = from;
    this.to = to2;
    this.matchCodePoint = from.length > 1 || to2.length > 1;
  }
}
class Param extends PExpr$1 {
  constructor(index2) {
    super();
    this.index = index2;
  }
}
class Alt extends PExpr$1 {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}
class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);
    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);
    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}
class Seq extends PExpr$1 {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}
class Iter extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Star extends Iter {
}
class Plus extends Iter {
}
class Opt extends Iter {
}
Star.prototype.operator = "*";
Plus.prototype.operator = "+";
Opt.prototype.operator = "?";
Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;
Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;
class Not extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lookahead extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lex extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Apply extends PExpr$1 {
  constructor(ruleName, args = []) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }
  isSyntactic() {
    return common$j.isSyntactic(this.ruleName);
  }
  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, "_memoKey", { value: this.toString() });
    }
    return this._memoKey;
  }
}
class UnicodeChar extends PExpr$1 {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}
pexprsMain.PExpr = PExpr$1;
pexprsMain.any = any;
pexprsMain.end = end;
pexprsMain.Terminal = Terminal$1;
pexprsMain.Range = Range;
pexprsMain.Param = Param;
pexprsMain.Alt = Alt;
pexprsMain.Extend = Extend;
pexprsMain.Splice = Splice;
pexprsMain.Seq = Seq;
pexprsMain.Iter = Iter;
pexprsMain.Star = Star;
pexprsMain.Plus = Plus;
pexprsMain.Opt = Opt;
pexprsMain.Not = Not;
pexprsMain.Lookahead = Lookahead;
pexprsMain.Lex = Lex;
pexprsMain.Apply = Apply;
pexprsMain.UnicodeChar = UnicodeChar;
const common$i = common$l;
const pexprs$l = pexprsMain;
pexprs$l.PExpr.prototype.allowsSkippingPrecedingSpace = common$i.abstract(
  "allowsSkippingPrecedingSpace"
);
pexprs$l.any.allowsSkippingPrecedingSpace = pexprs$l.end.allowsSkippingPrecedingSpace = pexprs$l.Apply.prototype.allowsSkippingPrecedingSpace = pexprs$l.Terminal.prototype.allowsSkippingPrecedingSpace = pexprs$l.Range.prototype.allowsSkippingPrecedingSpace = pexprs$l.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};
pexprs$l.Alt.prototype.allowsSkippingPrecedingSpace = pexprs$l.Iter.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lex.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lookahead.prototype.allowsSkippingPrecedingSpace = pexprs$l.Not.prototype.allowsSkippingPrecedingSpace = pexprs$l.Param.prototype.allowsSkippingPrecedingSpace = pexprs$l.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};
function Namespace$2() {
}
Namespace$2.prototype = /* @__PURE__ */ Object.create(null);
Namespace$2.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace$2) {
    return objOrNamespace;
  }
  return Namespace$2.createNamespace(objOrNamespace);
};
Namespace$2.createNamespace = function(optProps) {
  return Namespace$2.extend(Namespace$2.prototype, optProps);
};
Namespace$2.extend = function(namespace, optProps) {
  if (namespace !== Namespace$2.prototype && !(namespace instanceof Namespace$2)) {
    throw new TypeError("not a Namespace object: " + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace$2,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return Object.assign(ns, optProps);
};
Namespace$2.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};
var Namespace_1 = Namespace$2;
const { assert: assert$3 } = common$l;
const Namespace$1 = Namespace_1;
const pexprs$k = pexprsMain;
function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}
function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}
function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, "message", {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, "shortMessage", {
    enumerable: true,
    get() {
      return "Expected " + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}
function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ? "Grammar " + grammarName + " is not declared in namespace " + Namespace$1.toString(namespace) : "Undeclared grammar " + grammarName;
  return createError(message, interval);
}
function duplicateGrammarDeclaration(grammar2, namespace) {
  return createError("Grammar " + grammar2.name + " is already declared in this namespace");
}
function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
    "Rule " + ruleName + " is not declared in grammar " + grammarName,
    optInterval
  );
}
function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot override rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot extend rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName + "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}
function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
    "Wrong number of parameters for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    source
  );
}
function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
    "Wrong number of arguments for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    expr
  );
}
function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
    "Duplicate parameter names in rule " + ruleName + ": " + duplicates.join(", "),
    source
  );
}
function invalidParameter(ruleName, expr) {
  return createError(
    "Invalid parameter to rule " + ruleName + ": " + expr + " has arity " + expr.getArity() + ", but parameter expressions must have arity 1",
    expr.source
  );
}
const syntacticVsLexicalNote = "NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. See https://ohmjs.org/d/svl for more details.";
function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
    "Cannot apply syntactic rule " + ruleName + " from here (inside a lexical context)",
    applyExpr.source
  );
}
function applySyntacticWithLexicalRuleApplication(applyExpr) {
  const { ruleName } = applyExpr;
  return createError(
    `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` + syntacticVsLexicalNote,
    applyExpr.source
  );
}
function unnecessaryExperimentalApplySyntactic(applyExpr) {
  return createError(
    "applySyntactic is not required here (in a syntactic context)",
    applyExpr.source
  );
}
function incorrectArgumentType(expectedType, expr) {
  return createError("Incorrect argument type: expected " + expectedType, expr.source);
}
function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}
function invalidCodePoint(applyWrapper) {
  const node = applyWrapper._node;
  assert$3(node && node.isNonterminal() && node.ctorName === "escapeChar_unicodeCodePoint");
  const digitIntervals = applyWrapper.children.slice(1, -1).map((d) => d.source);
  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));
  return createError(
    `U+${fullInterval.contents} is not a valid Unicode code point`,
    fullInterval
  );
}
function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message = "Nullable expression " + expr + " is not allowed inside '" + kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack.map((app) => new pexprs$k.Apply(app.ruleName, app.args)).join("\n");
    message += "\nApplication stack (most recent application last):\n" + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}
function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
    "Rule " + ruleName + " involves an alternation which has inconsistent arity (expected " + expected + ", got " + actual + ")",
    expr.source
  );
}
function duplicatePropertyNames(duplicates) {
  return createError("Object pattern has duplicate property names: " + duplicates.join(", "));
}
function invalidConstructorCall(grammar2, ctorName, children) {
  return createError(
    "Attempt to invoke constructor " + ctorName + " with invalid or unexpected arguments"
  );
}
function multipleErrors(errors2) {
  const messages = errors2.map((e) => e.message);
  return createError(["Errors:"].concat(messages).join("\n- "), errors2[0].interval);
}
function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map((info) => {
    const ans = "  " + info[0].name + " > " + info[1];
    return info.length === 3 ? ans + " for '" + info[2] + "'" : ans;
  }).join("\n");
  stackTrace += "\n  " + name + " > " + ctorName;
  let moreInfo = "";
  if (ctorName === "_iter") {
    moreInfo = [
      "\nNOTE: as of Ohm v16, there is no default action for iteration nodes  see ",
      "  https://ohmjs.org/d/dsa for details."
    ].join("\n");
  }
  const message = [
    `Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,
    "Action stack (most recent call last):",
    stackTrace
  ].join("\n");
  const e = createError(message);
  e.name = "missingSemanticAction";
  return e;
}
var errors$9 = {
  applicationOfSyntacticRuleFromLexicalContext,
  applySyntacticWithLexicalRuleApplication,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidCodePoint,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  unnecessaryExperimentalApplySyntactic,
  wrongNumberOfArguments,
  wrongNumberOfParameters,
  throwErrors(errors2) {
    if (errors2.length === 1) {
      throw errors2[0];
    }
    if (errors2.length > 1) {
      throw multipleErrors(errors2);
    }
  }
};
var util$7 = {};
(function(exports) {
  const common2 = common$l;
  function padNumbersToEqualLength(arr) {
    let maxLen = 0;
    const strings2 = arr.map((n) => {
      const str = n.toString();
      maxLen = Math.max(maxLen, str.length);
      return str;
    });
    return strings2.map((s2) => common2.padLeft(s2, maxLen));
  }
  function strcpy(dest, src, offset) {
    const origDestLen = dest.length;
    const start = dest.slice(0, offset);
    const end2 = dest.slice(offset + src.length);
    return (start + src + end2).substr(0, origDestLen);
  }
  function lineAndColumnToMessage(...ranges) {
    const lineAndCol = this;
    const { offset } = lineAndCol;
    const { repeatStr } = common2;
    const sb = new common2.StringBuffer();
    sb.append("Line " + lineAndCol.lineNum + ", col " + lineAndCol.colNum + ":\n");
    const lineNumbers = padNumbersToEqualLength([
      lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
      lineAndCol.lineNum,
      lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
    ]);
    const appendLine = (num, content, prefix) => {
      sb.append(prefix + lineNumbers[num] + " | " + content + "\n");
    };
    if (lineAndCol.prevLine != null) {
      appendLine(0, lineAndCol.prevLine, "  ");
    }
    appendLine(1, lineAndCol.line, "> ");
    const lineLen = lineAndCol.line.length;
    let indicationLine = repeatStr(" ", lineLen + 1);
    for (let i = 0; i < ranges.length; ++i) {
      let startIdx = ranges[i][0];
      let endIdx = ranges[i][1];
      common2.assert(startIdx >= 0 && startIdx <= endIdx, "range start must be >= 0 and <= end");
      const lineStartOffset = offset - lineAndCol.colNum + 1;
      startIdx = Math.max(0, startIdx - lineStartOffset);
      endIdx = Math.min(endIdx - lineStartOffset, lineLen);
      indicationLine = strcpy(indicationLine, repeatStr("~", endIdx - startIdx), startIdx);
    }
    const gutterWidth = 2 + lineNumbers[1].length + 3;
    sb.append(repeatStr(" ", gutterWidth));
    indicationLine = strcpy(indicationLine, "^", lineAndCol.colNum - 1);
    sb.append(indicationLine.replace(/ +$/, "") + "\n");
    if (lineAndCol.nextLine != null) {
      appendLine(2, lineAndCol.nextLine, "  ");
    }
    return sb.contents();
  }
  let builtInRulesCallbacks = [];
  exports.awaitBuiltInRules = (cb) => {
    builtInRulesCallbacks.push(cb);
  };
  exports.announceBuiltInRules = (grammar2) => {
    builtInRulesCallbacks.forEach((cb) => {
      cb(grammar2);
    });
    builtInRulesCallbacks = null;
  };
  exports.getLineAndColumn = (str, offset) => {
    let lineNum = 1;
    let colNum = 1;
    let currOffset = 0;
    let lineStartOffset = 0;
    let nextLine = null;
    let prevLine = null;
    let prevLineStartOffset = -1;
    while (currOffset < offset) {
      const c = str.charAt(currOffset++);
      if (c === "\n") {
        lineNum++;
        colNum = 1;
        prevLineStartOffset = lineStartOffset;
        lineStartOffset = currOffset;
      } else if (c !== "\r") {
        colNum++;
      }
    }
    let lineEndOffset = str.indexOf("\n", lineStartOffset);
    if (lineEndOffset === -1) {
      lineEndOffset = str.length;
    } else {
      const nextLineEndOffset = str.indexOf("\n", lineEndOffset + 1);
      nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset) : str.slice(lineEndOffset, nextLineEndOffset);
      nextLine = nextLine.replace(/^\r?\n/, "").replace(/\r$/, "");
    }
    if (prevLineStartOffset >= 0) {
      prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\r?\n$/, "");
    }
    const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, "");
    return {
      offset,
      lineNum,
      colNum,
      line,
      prevLine,
      nextLine,
      toString: lineAndColumnToMessage
    };
  };
  exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
    return exports.getLineAndColumn(str, offset).toString(...ranges);
  };
  exports.uniqueId = /* @__PURE__ */ (() => {
    let idCounter = 0;
    return (prefix) => "" + prefix + idCounter++;
  })();
})(util$7);
const { abstract, isSyntactic } = common$l;
const errors$8 = errors$9;
const pexprs$j = pexprsMain;
const util$6 = util$7;
let BuiltInRules;
util$6.awaitBuiltInRules((g2) => {
  BuiltInRules = g2;
});
let lexifyCount;
pexprs$j.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.PExpr.prototype._assertAllApplicationsAreValid = abstract(
  "_assertAllApplicationsAreValid"
);
pexprs$j.any._assertAllApplicationsAreValid = pexprs$j.end._assertAllApplicationsAreValid = pexprs$j.Terminal.prototype._assertAllApplicationsAreValid = pexprs$j.Range.prototype._assertAllApplicationsAreValid = pexprs$j.Param.prototype._assertAllApplicationsAreValid = pexprs$j.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
};
pexprs$j.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
  lexifyCount--;
};
pexprs$j.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Iter.prototype._assertAllApplicationsAreValid = pexprs$j.Not.prototype._assertAllApplicationsAreValid = pexprs$j.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2, skipSyntacticCheck = false) {
  const ruleInfo = grammar2.rules[this.ruleName];
  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;
  if (!ruleInfo) {
    throw errors$8.undeclaredRule(this.ruleName, grammar2.name, this.source);
  }
  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {
    throw errors$8.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors$8.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }
  const isBuiltInApplySyntactic = BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;
  const isBuiltInCaseInsensitive = BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;
  if (isBuiltInCaseInsensitive) {
    if (!(this.args[0] instanceof pexprs$j.Terminal)) {
      throw errors$8.incorrectArgumentType('a Terminal (e.g. "abc")', this.args[0]);
    }
  }
  if (isBuiltInApplySyntactic) {
    const arg = this.args[0];
    if (!(arg instanceof pexprs$j.Apply)) {
      throw errors$8.incorrectArgumentType("a syntactic rule application", arg);
    }
    if (!isSyntactic(arg.ruleName)) {
      throw errors$8.applySyntacticWithLexicalRuleApplication(arg);
    }
    if (isContextSyntactic) {
      throw errors$8.unnecessaryExperimentalApplySyntactic(this);
    }
  }
  this.args.forEach((arg) => {
    arg._assertAllApplicationsAreValid(ruleName, grammar2, isBuiltInApplySyntactic);
    if (arg.getArity() !== 1) {
      throw errors$8.invalidParameter(this.ruleName, arg);
    }
  });
};
const common$h = common$l;
const errors$7 = errors$9;
const pexprs$i = pexprsMain;
pexprs$i.PExpr.prototype.assertChoicesHaveUniformArity = common$h.abstract(
  "assertChoicesHaveUniformArity"
);
pexprs$i.any.assertChoicesHaveUniformArity = pexprs$i.end.assertChoicesHaveUniformArity = pexprs$i.Terminal.prototype.assertChoicesHaveUniformArity = pexprs$i.Range.prototype.assertChoicesHaveUniformArity = pexprs$i.Param.prototype.assertChoicesHaveUniformArity = pexprs$i.Lex.prototype.assertChoicesHaveUniformArity = pexprs$i.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors$7.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};
pexprs$i.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors$7.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};
pexprs$i.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};
pexprs$i.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
const common$g = common$l;
const errors$6 = errors$9;
const pexprs$h = pexprsMain;
pexprs$h.PExpr.prototype.assertIteratedExprsAreNotNullable = common$g.abstract(
  "assertIteratedExprsAreNotNullable"
);
pexprs$h.any.assertIteratedExprsAreNotNullable = pexprs$h.end.assertIteratedExprsAreNotNullable = pexprs$h.Terminal.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Range.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Param.prototype.assertIteratedExprsAreNotNullable = pexprs$h.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
};
pexprs$h.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
  if (this.expr.isNullable(grammar2)) {
    throw errors$6.kleeneExprHasNullableOperand(this, []);
  }
};
pexprs$h.Opt.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Not.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lookahead.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
};
pexprs$h.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.args.forEach((arg) => {
    arg.assertIteratedExprsAreNotNullable(grammar2);
  });
};
const { assert: assert$2 } = common$l;
const errors$5 = errors$9;
const util$5 = util$7;
function Interval$3(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}
Interval$3.coverage = function(firstInterval, ...intervals) {
  let { startIdx, endIdx } = firstInterval;
  for (const interval of intervals) {
    if (interval.sourceString !== firstInterval.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, interval.startIdx);
      endIdx = Math.max(endIdx, interval.endIdx);
    }
  }
  return new Interval$3(firstInterval.sourceString, startIdx, endIdx);
};
Interval$3.prototype = {
  coverageWith(...intervals) {
    return Interval$3.coverage(...intervals, this);
  },
  collapsedLeft() {
    return new Interval$3(this.sourceString, this.startIdx, this.startIdx);
  },
  collapsedRight() {
    return new Interval$3(this.sourceString, this.endIdx, this.endIdx);
  },
  getLineAndColumn() {
    return util$5.getLineAndColumn(this.sourceString, this.startIdx);
  },
  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util$5.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },
  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      return [];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      return [
        new Interval$3(this.sourceString, this.startIdx, that.startIdx),
        new Interval$3(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, that.endIdx, this.endIdx)];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, this.startIdx, that.startIdx)];
    } else {
      return [this];
    }
  },
  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    }
    assert$2(
      this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
      "other interval does not cover this one"
    );
    return new Interval$3(
      this.sourceString,
      this.startIdx - that.startIdx,
      this.endIdx - that.startIdx
    );
  },
  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends.
  trimmed() {
    const { contents } = this;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval$3(this.sourceString, startIdx, endIdx);
  },
  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval$3(this.sourceString, newStartIdx, newStartIdx + len);
  }
};
Object.defineProperties(Interval$3.prototype, {
  contents: {
    get() {
      if (this._contents === void 0) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() {
      return this.endIdx - this.startIdx;
    },
    enumerable: true
  }
});
var Interval_1 = Interval$3;
const Interval$2 = Interval_1;
const common$f = common$l;
const BALLOT_X = "";
const CHECK_MARK = "";
const DOT_OPERATOR = "";
const RIGHTWARDS_DOUBLE_ARROW = "";
const SYMBOL_FOR_HORIZONTAL_TABULATION = "";
const SYMBOL_FOR_LINE_FEED = "";
const SYMBOL_FOR_CARRIAGE_RETURN = "";
const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};
function spaces(n) {
  return common$f.repeat(" ", n).join("");
}
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));
  if (excerpt.length < len) {
    return excerpt + common$f.repeat(" ", len - excerpt.length).join("");
  }
  return excerpt;
}
function asEscapedString(obj) {
  if (typeof obj === "string") {
    return obj.replace(/ /g, DOT_OPERATOR).replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION).replace(/\n/g, SYMBOL_FOR_LINE_FEED).replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}
function Trace$2(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval$2(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;
  this._flags = succeeded ? Flags.succeeded : 0;
}
Trace$2.prototype.SKIP = {};
Object.defineProperty(Trace$2.prototype, "displayString", {
  get() {
    return this.expr.toDisplayString();
  }
});
Object.keys(Flags).forEach((name) => {
  const mask = Flags[name];
  Object.defineProperty(Trace$2.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});
Trace$2.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};
Trace$2.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    expr,
    this.succeeded,
    this.bindings,
    this.children
  );
  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};
Trace$2.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    this.expr,
    false,
    [value],
    [ruleBodyTrace]
  );
  this.terminatingLREntry.terminatesLR = true;
};
Trace$2.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === "function") {
    visitor = { enter: visitor };
  }
  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace$2.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach((child) => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    this.children.forEach((c) => {
      _walk(c, null, 0);
    });
  } else {
    _walk(this, null, 0);
  }
};
Trace$2.prototype.toString = function() {
  const sb = new common$f.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    if (ctorName === "Alt") {
      return;
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + " " + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(" (LR)");
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(" " + RIGHTWARDS_DOUBLE_ARROW + "  ");
      sb.append(typeof contents === "string" ? '"' + contents + '"' : contents);
    }
    sb.append("\n");
  });
  return sb.contents();
};
var Trace_1 = Trace$2;
const Trace$1 = Trace_1;
const common$e = common$l;
const errors$4 = errors$9;
const nodes$2 = nodes$1;
const pexprs$g = pexprsMain;
const { TerminalNode: TerminalNode$1 } = nodes$2;
const { NonterminalNode } = nodes$2;
const { IterationNode: IterationNode$1 } = nodes$2;
pexprs$g.PExpr.prototype.eval = common$e.abstract("eval");
pexprs$g.any.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.end.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode$1(0), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Terminal.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode$1(this.obj.length), origPos);
    return true;
  }
};
pexprs$g.Range.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();
  if (cp !== void 0 && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {
    state.pushBinding(new TerminalNode$1(String.fromCodePoint(cp).length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};
pexprs$g.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};
pexprs$g.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};
pexprs$g.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};
pexprs$g.Iter.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }
  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors$4.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(
      state._bindingOffsets.length - arity,
      arity
    );
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];
    const endOffset = lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs$g.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
      new IterationNode$1(cols[idx], colOffsets[idx], matchLength, isOptional)
    );
    state._bindingOffsets.push(offset);
  }
  return true;
};
pexprs$g.Not.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();
  const ans = state.eval(this.expr);
  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }
  inputStream.pos = origPos;
  return true;
};
pexprs$g.Lookahead.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);
  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    return app.handleCycle(state);
  }
  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];
  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};
pexprs$g.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const { currentLeftRecursion } = posInfo;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];
  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    memoRec = posInfo.memoize(memoKey, {
      matchLength: 0,
      examinedLength: 0,
      value: false,
      rightmostFailureOffset: -1
    });
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};
pexprs$g.Apply.prototype.reallyEval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const { body } = ruleInfo;
  const { description } = ruleInfo;
  state.enterApplication(origPosInfo, this);
  if (description) {
    state.pushFailuresInfo();
  }
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;
  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;
  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec);
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;
  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common$e.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }
  inputStream.examinedLength = Math.max(
    inputStream.examinedLength,
    origInputStreamExaminedLength
  );
  state.exitApplication(origPosInfo, value);
  return succeeded;
};
pexprs$g.Apply.prototype.evalOnce = function(expr, state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    const matchLength = inputStream.pos - origPos;
    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }
  const { inputStream } = state;
  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    if (state.isTracing()) {
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace$1(
        state.input,
        origPos,
        inputStream.pos,
        this,
        true,
        [newValue],
        [seedTrace.clone()]
      );
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1);
    }
  }
  if (state.isTracing()) {
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};
pexprs$g.UnicodeChar.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
const common$d = common$l;
const pexprs$f = pexprsMain;
pexprs$f.PExpr.prototype.getArity = common$d.abstract("getArity");
pexprs$f.any.getArity = pexprs$f.end.getArity = pexprs$f.Terminal.prototype.getArity = pexprs$f.Range.prototype.getArity = pexprs$f.Param.prototype.getArity = pexprs$f.Apply.prototype.getArity = pexprs$f.UnicodeChar.prototype.getArity = function() {
  return 1;
};
pexprs$f.Alt.prototype.getArity = function() {
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};
pexprs$f.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};
pexprs$f.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};
pexprs$f.Not.prototype.getArity = function() {
  return 0;
};
pexprs$f.Lookahead.prototype.getArity = pexprs$f.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};
const common$c = common$l;
const pexprs$e = pexprsMain;
function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}
pexprs$e.PExpr.prototype.outputRecipe = common$c.abstract("outputRecipe");
pexprs$e.any.outputRecipe = function(formals, grammarInterval) {
  return ["any", getMetaInfo(this, grammarInterval)];
};
pexprs$e.end.outputRecipe = function(formals, grammarInterval) {
  return ["end", getMetaInfo(this, grammarInterval)];
};
pexprs$e.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["terminal", getMetaInfo(this, grammarInterval), this.obj];
};
pexprs$e.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["range", getMetaInfo(this, grammarInterval), this.from, this.to];
};
pexprs$e.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["param", getMetaInfo(this, grammarInterval), this.index];
};
pexprs$e.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["alt", getMetaInfo(this, grammarInterval)].concat(
    this.terms.map((term) => term.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0];
  return extension.outputRecipe(formals, grammarInterval);
};
pexprs$e.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    "splice",
    getMetaInfo(this, grammarInterval),
    beforeTerms.map((term) => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map((term) => term.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["seq", getMetaInfo(this, grammarInterval)].concat(
    this.factors.map((factor) => factor.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Star.prototype.outputRecipe = pexprs$e.Plus.prototype.outputRecipe = pexprs$e.Opt.prototype.outputRecipe = pexprs$e.Not.prototype.outputRecipe = pexprs$e.Lookahead.prototype.outputRecipe = pexprs$e.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};
pexprs$e.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    "app",
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map((arg) => arg.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["unicodeChar", getMetaInfo(this, grammarInterval), this.category];
};
const common$b = common$l;
const pexprs$d = pexprsMain;
pexprs$d.PExpr.prototype.introduceParams = common$b.abstract("introduceParams");
pexprs$d.any.introduceParams = pexprs$d.end.introduceParams = pexprs$d.Terminal.prototype.introduceParams = pexprs$d.Range.prototype.introduceParams = pexprs$d.Param.prototype.introduceParams = pexprs$d.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};
pexprs$d.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};
pexprs$d.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};
pexprs$d.Iter.prototype.introduceParams = pexprs$d.Not.prototype.introduceParams = pexprs$d.Lookahead.prototype.introduceParams = pexprs$d.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};
pexprs$d.Apply.prototype.introduceParams = function(formals) {
  const index2 = formals.indexOf(this.ruleName);
  if (index2 >= 0) {
    if (this.args.length > 0) {
      throw new Error("Parameterized rules cannot be passed as arguments to another rule.");
    }
    return new pexprs$d.Param(index2).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};
const common$a = common$l;
const pexprs$c = pexprsMain;
pexprs$c.PExpr.prototype.isNullable = function(grammar2) {
  return this._isNullable(grammar2, /* @__PURE__ */ Object.create(null));
};
pexprs$c.PExpr.prototype._isNullable = common$a.abstract("_isNullable");
pexprs$c.any._isNullable = pexprs$c.Range.prototype._isNullable = pexprs$c.Param.prototype._isNullable = pexprs$c.Plus.prototype._isNullable = pexprs$c.UnicodeChar.prototype._isNullable = function(grammar2, memo) {
  return false;
};
pexprs$c.end._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Terminal.prototype._isNullable = function(grammar2, memo) {
  if (typeof this.obj === "string") {
    return this.obj === "";
  } else {
    return false;
  }
};
pexprs$c.Alt.prototype._isNullable = function(grammar2, memo) {
  return this.terms.length === 0 || this.terms.some((term) => term._isNullable(grammar2, memo));
};
pexprs$c.Seq.prototype._isNullable = function(grammar2, memo) {
  return this.factors.every((factor) => factor._isNullable(grammar2, memo));
};
pexprs$c.Star.prototype._isNullable = pexprs$c.Opt.prototype._isNullable = pexprs$c.Not.prototype._isNullable = pexprs$c.Lookahead.prototype._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Lex.prototype._isNullable = function(grammar2, memo) {
  return this.expr._isNullable(grammar2, memo);
};
pexprs$c.Apply.prototype._isNullable = function(grammar2, memo) {
  const key = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key)) {
    const { body } = grammar2.rules[this.ruleName];
    const inlined = body.substituteParams(this.args);
    memo[key] = false;
    memo[key] = inlined._isNullable(grammar2, memo);
  }
  return memo[key];
};
const common$9 = common$l;
const pexprs$b = pexprsMain;
pexprs$b.PExpr.prototype.substituteParams = common$9.abstract("substituteParams");
pexprs$b.any.substituteParams = pexprs$b.end.substituteParams = pexprs$b.Terminal.prototype.substituteParams = pexprs$b.Range.prototype.substituteParams = pexprs$b.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};
pexprs$b.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};
pexprs$b.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Alt(this.terms.map((term) => term.substituteParams(actuals)));
};
pexprs$b.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Seq(this.factors.map((factor) => factor.substituteParams(actuals)));
};
pexprs$b.Iter.prototype.substituteParams = pexprs$b.Not.prototype.substituteParams = pexprs$b.Lookahead.prototype.substituteParams = pexprs$b.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};
pexprs$b.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    return this;
  } else {
    const args = this.args.map((arg) => arg.substituteParams(actuals));
    return new pexprs$b.Apply(this.ruleName, args);
  }
};
const common$8 = common$l;
const pexprs$a = pexprsMain;
const { copyWithoutDuplicates } = common$8;
function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}
function resolveDuplicatedNames(argumentNameList) {
  const count = /* @__PURE__ */ Object.create(null);
  argumentNameList.forEach((argName) => {
    count[argName] = (count[argName] || 0) + 1;
  });
  Object.keys(count).forEach((dupArgName) => {
    if (count[dupArgName] <= 1) {
      return;
    }
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + "_" + subscript++;
      }
    });
  });
}
pexprs$a.PExpr.prototype.toArgumentNameList = common$8.abstract("toArgumentNameList");
pexprs$a.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["any"];
};
pexprs$a.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["end"];
};
pexprs$a.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === "string" && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    return ["_" + this.obj];
  } else {
    return ["$" + firstArgIndex];
  }
};
pexprs$a.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + "_to_" + this.to;
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "_" + argName;
  }
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "$" + firstArgIndex;
  }
  return [argName];
};
pexprs$a.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const termArgNameLists = this.terms.map(
    (term) => term.toArgumentNameList(firstArgIndex, true)
  );
  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join("_or_"));
  }
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argumentNameList = [];
  this.factors.forEach((factor) => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(
    (exprArgumentString) => exprArgumentString[exprArgumentString.length - 1] === "s" ? exprArgumentString + "es" : exprArgumentString + "s"
  );
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((argName) => {
    return "opt" + argName[0].toUpperCase() + argName.slice(1);
  });
};
pexprs$a.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};
pexprs$a.Lookahead.prototype.toArgumentNameList = pexprs$a.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};
pexprs$a.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};
pexprs$a.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["$" + firstArgIndex];
};
pexprs$a.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["param" + this.index];
};
const common$7 = common$l;
const pexprs$9 = pexprsMain;
pexprs$9.PExpr.prototype.toDisplayString = common$7.abstract("toDisplayString");
pexprs$9.Alt.prototype.toDisplayString = pexprs$9.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return "[" + this.constructor.name + "]";
};
pexprs$9.any.toDisplayString = pexprs$9.end.toDisplayString = pexprs$9.Iter.prototype.toDisplayString = pexprs$9.Not.prototype.toDisplayString = pexprs$9.Lookahead.prototype.toDisplayString = pexprs$9.Lex.prototype.toDisplayString = pexprs$9.Terminal.prototype.toDisplayString = pexprs$9.Range.prototype.toDisplayString = pexprs$9.Param.prototype.toDisplayString = function() {
  return this.toString();
};
pexprs$9.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toDisplayString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$9.UnicodeChar.prototype.toDisplayString = function() {
  return "Unicode [" + this.category + "] character";
};
const Failure$1 = Failure_1;
const common$6 = common$l;
const pexprs$8 = pexprsMain;
pexprs$8.PExpr.prototype.toFailure = common$6.abstract("toFailure");
pexprs$8.any.toFailure = function(grammar2) {
  return new Failure$1(this, "any object", "description");
};
pexprs$8.end.toFailure = function(grammar2) {
  return new Failure$1(this, "end of input", "description");
};
pexprs$8.Terminal.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, this.obj, "string");
};
pexprs$8.Range.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, JSON.stringify(this.from) + ".." + JSON.stringify(this.to), "code");
};
pexprs$8.Not.prototype.toFailure = function(grammar2) {
  const description = this.expr === pexprs$8.any ? "nothing" : "not " + this.expr.toFailure(grammar2);
  return new Failure$1(this, description, "description");
};
pexprs$8.Lookahead.prototype.toFailure = function(grammar2) {
  return this.expr.toFailure(grammar2);
};
pexprs$8.Apply.prototype.toFailure = function(grammar2) {
  let { description } = grammar2.rules[this.ruleName];
  if (!description) {
    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? "an" : "a";
    description = article + " " + this.ruleName;
  }
  return new Failure$1(this, description, "description");
};
pexprs$8.UnicodeChar.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, "a Unicode [" + this.category + "] character", "description");
};
pexprs$8.Alt.prototype.toFailure = function(grammar2) {
  const fs = this.terms.map((t) => t.toFailure(grammar2));
  const description = "(" + fs.join(" or ") + ")";
  return new Failure$1(this, description, "description");
};
pexprs$8.Seq.prototype.toFailure = function(grammar2) {
  const fs = this.factors.map((f2) => f2.toFailure(grammar2));
  const description = "(" + fs.join(" ") + ")";
  return new Failure$1(this, description, "description");
};
pexprs$8.Iter.prototype.toFailure = function(grammar2) {
  const description = "(" + this.expr.toFailure(grammar2) + this.operator + ")";
  return new Failure$1(this, description, "description");
};
const common$5 = common$l;
const pexprs$7 = pexprsMain;
pexprs$7.PExpr.prototype.toString = common$5.abstract("toString");
pexprs$7.any.toString = function() {
  return "any";
};
pexprs$7.end.toString = function() {
  return "end";
};
pexprs$7.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};
pexprs$7.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + ".." + JSON.stringify(this.to);
};
pexprs$7.Param.prototype.toString = function() {
  return "$" + this.index;
};
pexprs$7.Lex.prototype.toString = function() {
  return "#(" + this.expr.toString() + ")";
};
pexprs$7.Alt.prototype.toString = function() {
  return this.terms.length === 1 ? this.terms[0].toString() : "(" + this.terms.map((term) => term.toString()).join(" | ") + ")";
};
pexprs$7.Seq.prototype.toString = function() {
  return this.factors.length === 1 ? this.factors[0].toString() : "(" + this.factors.map((factor) => factor.toString()).join(" ") + ")";
};
pexprs$7.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};
pexprs$7.Not.prototype.toString = function() {
  return "~" + this.expr;
};
pexprs$7.Lookahead.prototype.toString = function() {
  return "&" + this.expr;
};
pexprs$7.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$7.UnicodeChar.prototype.toString = function() {
  return "\\p{" + this.category + "}";
};
var pexprs$6 = pexprsMain;
const Failure = Failure_1;
const { TerminalNode } = nodes$1;
const { assert: assert$1 } = common$l;
const { PExpr, Terminal } = pexprs$6;
class CaseInsensitiveTerminal$1 extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }
  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert$1(terminal instanceof Terminal, "expected a Terminal expression");
    return terminal.obj;
  }
  // Implementation of the PExpr API
  allowsSkippingPrecedingSpace() {
    return true;
  }
  eval(state) {
    const { inputStream } = state;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(matchStr.length), origPos);
      return true;
    }
  }
  getArity() {
    return 1;
  }
  substituteParams(actuals) {
    return new CaseInsensitiveTerminal$1(this.obj.substituteParams(actuals));
  }
  toDisplayString() {
    return this.obj.toDisplayString() + " (case-insensitive)";
  }
  toFailure(grammar2) {
    return new Failure(
      this,
      this.obj.toFailure(grammar2) + " (case-insensitive)",
      "description"
    );
  }
  _isNullable(grammar2, memo) {
    return this.obj._isNullable(grammar2, memo);
  }
}
var CaseInsensitiveTerminal_1 = CaseInsensitiveTerminal$1;
const Interval$1 = Interval_1;
function InputStream$3(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}
InputStream$3.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },
  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },
  nextCharCode() {
    const nextChar = this.next();
    return nextChar && nextChar.charCodeAt(0);
  },
  nextCodePoint() {
    const cp = this.source.slice(this.pos++).codePointAt(0);
    if (cp > 65535) {
      this.pos += 1;
    }
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return cp;
  },
  matchString(s2, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      for (idx = 0; idx < s2.length; idx++) {
        const actual = this.next();
        const expected = s2[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    for (idx = 0; idx < s2.length; idx++) {
      if (this.next() !== s2[idx]) {
        return false;
      }
    }
    return true;
  },
  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },
  interval(startIdx, optEndIdx) {
    return new Interval$1(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};
var InputStream_1 = InputStream$3;
const common$4 = common$l;
const util$4 = util$7;
const Interval = Interval_1;
function MatchResult$2(matcher, input, startExpr, cst, cstOffset, rightmostFailurePosition, optRecordedFailures) {
  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;
  if (this.failed()) {
    common$4.defineLazyProperty(this, "message", function() {
      const detail = "Expected " + this.getExpectedText();
      return util$4.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common$4.defineLazyProperty(this, "shortMessage", function() {
      const detail = "expected " + this.getExpectedText();
      const errorInfo = util$4.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return "Line " + errorInfo.lineNum + ", col " + errorInfo.colNum + ": " + detail;
    });
  }
}
MatchResult$2.prototype.succeeded = function() {
  return !!this._cst;
};
MatchResult$2.prototype.failed = function() {
  return !this.succeeded();
};
MatchResult$2.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};
MatchResult$2.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures = this.matcher._match(
      this.startExpr,
      false,
      this.getRightmostFailurePosition()
    );
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};
MatchResult$2.prototype.toString = function() {
  return this.succeeded() ? "[match succeeded]" : "[match failed at position " + this.getRightmostFailurePosition() + "]";
};
MatchResult$2.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error("cannot get expected text of a successful MatchResult");
  }
  const sb = new common$4.StringBuffer();
  let failures = this.getRightmostFailures();
  failures = failures.filter((failure) => !failure.isFluffy());
  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ", or " : " or ");
      } else {
        sb.append(", ");
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};
MatchResult$2.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};
var MatchResult_1 = MatchResult$2;
function PosInfo$1() {
  this.applicationMemoKeyStack = [];
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = void 0;
}
PosInfo$1.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },
  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },
  exit() {
    this.applicationMemoKeyStack.pop();
  },
  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;
    const { applicationMemoKeyStack } = this;
    const indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(
      indexOfFirstInvolvedRule
    );
    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };
    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },
  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },
  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const { applicationMemoKeyStack } = this;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },
  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset = Math.max(
      this.maxRightmostFailureOffset,
      memoRec.rightmostFailureOffset
    );
    return memoRec;
  },
  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      return;
    }
    const { memo } = this;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    Object.keys(memo).forEach((k2) => {
      const memoRec = memo[k2];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k2];
      } else {
        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
        this.maxRightmostFailureOffset = Math.max(
          this.maxRightmostFailureOffset,
          memoRec.rightmostFailureOffset
        );
      }
    });
  }
};
var PosInfo_1 = PosInfo$1;
const InputStream$2 = InputStream_1;
const MatchResult$1 = MatchResult_1;
const PosInfo = PosInfo_1;
const Trace = Trace_1;
const pexprs$5 = pexprs$6;
const util$3 = util$7;
let builtInApplySyntacticBody;
util$3.awaitBuiltInRules((builtInRules2) => {
  builtInApplySyntacticBody = builtInRules2.rules.applySyntactic.body;
});
const applySpaces = new pexprs$5.Apply("spaces");
function MatchState$1(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;
  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream$2(matcher.input);
  this.memoTable = matcher.memoTable;
  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];
  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];
  if (optPositionToRecordFailures !== void 0) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = /* @__PURE__ */ Object.create(null);
  }
}
MatchState$1.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },
  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },
  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      this._rightmostFailurePositionStack.pop()
    );
    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },
  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },
  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },
  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },
  inSyntacticContext() {
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      return this.startExpr.factors[0].isSyntactic();
    }
  },
  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },
  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },
  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;
  },
  maybeSkipSpacesBefore(expr) {
    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },
  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },
  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },
  numBindings() {
    return this._bindings.length;
  },
  truncateBindings(newLength) {
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },
  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },
  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },
  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);
    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        expr = expr.substituteParams(app.args);
      }
      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },
  recordFailure(failure, shouldCloneIfNew) {
    const key = failure.toKey();
    if (!this.recordedFailures[key]) {
      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key].clearFluffy();
    }
  },
  recordFailures(failures, shouldCloneIfNew) {
    Object.keys(failures).forEach((key) => {
      this.recordFailure(failures[key], shouldCloneIfNew);
    });
  },
  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return void 0;
    }
    const ans = /* @__PURE__ */ Object.create(null);
    Object.keys(this.recordedFailures).forEach((key) => {
      ans[key] = this.recordedFailures[key].clone();
    });
    return ans;
  },
  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },
  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ? this.posToOffset(this.rightmostFailurePosition) : -1;
  },
  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr instanceof pexprs$5.Apply) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },
  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs$5.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) || new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },
  isTracing() {
    return !!this.trace;
  },
  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }
    if (this.recordedFailures && this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }
    return true;
  },
  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }
    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      memoRecRightmostFailurePosition
    );
    if (this.recordedFailures && this.positionToRecordFailures === memoRecRightmostFailurePosition && memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }
    this.inputStream.examinedLength = Math.max(
      this.inputStream.examinedLength,
      memoRec.examinedLength + origPos
    );
    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },
  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const { inputStream } = this;
    const origNumBindings = this._bindings.length;
    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = /* @__PURE__ */ Object.create(null);
    }
    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);
    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }
    const ans = expr.eval(this);
    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }
    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        Object.keys(this.recordedFailures).forEach((key) => {
          this.recordedFailures[key].makeFluffy();
        });
      }
    } else {
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }
    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }
    if (expr === builtInApplySyntacticBody) {
      this.skipSpaces();
    }
    return ans;
  },
  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      rightmostFailures = Object.keys(this.recordedFailures).map(
        (key) => this.recordedFailures[key]
      );
    }
    const cst = this._bindings[0];
    if (cst) {
      cst.grammar = this.grammar;
    }
    return new MatchResult$1(
      this.matcher,
      this.input,
      this.startExpr,
      cst,
      this._bindingOffsets[0],
      this.rightmostFailurePosition,
      rightmostFailures
    );
  },
  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },
  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },
  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};
var MatchState_1 = MatchState$1;
const MatchState = MatchState_1;
const pexprs$4 = pexprs$6;
function Matcher$1(grammar2) {
  this.grammar = grammar2;
  this.memoTable = [];
  this.input = "";
}
Matcher$1.prototype.getInput = function() {
  return this.input;
};
Matcher$1.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};
Matcher$1.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length || endIdx < 0 || endIdx > currentInput.length || startIdx > endIdx) {
    throw new Error("Invalid indices: " + startIdx + " and " + endIdx);
  }
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(void 0);
  }
  restOfMemoTable.forEach(function(posInfo) {
    this.memoTable.push(posInfo);
  }, this);
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }
  return this;
};
Matcher$1.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};
Matcher$1.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};
Matcher$1.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};
Matcher$1.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error("Missing start rule argument -- the grammar has no default start rule.");
  }
  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs$4.Seq([startApp, pexprs$4.end]);
};
var Matcher_1 = Matcher$1;
const InputStream$1 = InputStream_1;
const { IterationNode } = nodes$1;
const MatchResult = MatchResult_1;
const common$3 = common$l;
const errors$3 = errors$9;
const util$2 = util$7;
const globalActionStack = [];
const hasOwnProperty = (x2, prop) => Object.prototype.hasOwnProperty.call(x2, prop);
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;
    this._baseInterval = baseInterval;
    if (node.isNonterminal()) {
      common$3.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }
  toString() {
    return "[semantics wrapper for " + this._node.grammar.name + "]";
  }
  _forgetMemoizedResultFor(attributeName) {
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach((child) => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }
  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      return void 0;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];
      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }
  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }
  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }
  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }
  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }
  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];
    const childNodes = childWrappers.map((c) => c._node);
    const iter = new IterationNode(childNodes, [], -1, false);
    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }
  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }
  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }
  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error("The `interval` property is deprecated -- use `source` instead");
  }
  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }
  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}
function Semantics$2(grammar2, superSemantics) {
  const self2 = this;
  this.grammar = grammar2;
  this.checkedActionDicts = false;
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self2.checkActionDictsIfHaventAlready();
      this._semantics = self2;
    }
  };
  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar2.equals(this.super.grammar) || grammar2._inheritsFrom(this.super.grammar))) {
      throw new Error(
        "Cannot extend a semantics for grammar '" + this.super.grammar.name + "' for use with grammar '" + grammar2.name + "' (not a sub-grammar)"
      );
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util$2.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = /* @__PURE__ */ Object.create(null);
    this.attributes = /* @__PURE__ */ Object.create(null);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
  }
}
Semantics$2.prototype.toString = function() {
  return "[semantics for " + this.grammar.name + "]";
};
Semantics$2.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};
Semantics$2.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};
Semantics$2.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s2) {
    return s2.super !== Semantics$2.BuiltInSemantics._getSemantics();
  }
  let str = "(function(g) {\n";
  if (hasSuperSemantics(this)) {
    str += "  var semantics = " + this.super.toRecipe(true) + "(g";
    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += ".superGrammar";
      relatedGrammar = relatedGrammar.superGrammar;
    }
    str += ");\n";
    str += "  return g.extendSemantics(semantics)";
  } else {
    str += "  return g.createSemantics()";
  }
  ["Operation", "Attribute"].forEach((type) => {
    const semanticOperations = this[type.toLowerCase() + "s"];
    Object.keys(semanticOperations).forEach((name) => {
      const { actionDict, formals, builtInDefault } = semanticOperations[name];
      let signature = name;
      if (formals.length > 0) {
        signature += "(" + formals.join(", ") + ")";
      }
      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + "s"][name]) {
        method = "extend" + type;
      } else {
        method = "add" + type;
      }
      str += "\n    ." + method + "(" + JSON.stringify(signature) + ", {";
      const srcArray = [];
      Object.keys(actionDict).forEach((actionName) => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();
          source = source.replace(/^.*\(/, "function(");
          srcArray.push("\n      " + JSON.stringify(actionName) + ": " + source);
        }
      });
      str += srcArray.join(",") + "\n    })";
    });
  });
  str += ";\n  })";
  if (!semanticsOnly) {
    str = "(function() {\n  var grammar = this.fromRecipe(" + this.grammar.toRecipe() + ");\n  var semantics = " + str + "(grammar);\n  return semantics;\n});\n";
  }
  return str;
};
function parseSignature$1(signature, type) {
  if (!Semantics$2.prototypeGrammar) {
    common$3.assert(signature.indexOf("(") === -1);
    return {
      name: signature,
      formals: []
    };
  }
  const r = Semantics$2.prototypeGrammar.match(
    signature,
    type === "operation" ? "OperationSignature" : "AttributeSignature"
  );
  if (r.failed()) {
    throw new Error(r.message);
  }
  return Semantics$2.prototypeGrammarSemantics(r).parse();
}
function newDefaultAction(type, name, doIt) {
  return function(...children) {
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map((formal) => this.args[formal]);
    if (!this.isIteration() && children.length === 1) {
      return doIt.apply(children[0], args);
    } else {
      throw errors$3.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}
Semantics$2.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + "s";
  const parsedNameAndFormalArgs = parseSignature$1(signature, type);
  const { name } = parsedNameAndFormalArgs;
  const { formals } = parsedNameAndFormalArgs;
  this.assertNewName(name, type);
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = { _default: builtInDefault };
  Object.keys(actionDict).forEach((name2) => {
    realActionDict[name2] = actionDict[name2];
  });
  const entry = type === "operation" ? new Operation(name, formals, realActionDict, builtInDefault) : new Attribute(name, realActionDict, builtInDefault);
  entry.checkActionDict(this.grammar);
  this[typePlural][name] = entry;
  function doIt(...args) {
    const thisThing = this._semantics[typePlural][name];
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
        "Invalid number of arguments passed to " + name + " " + type + " (expected " + thisThing.formals.length + ", got " + arguments.length + ")"
      );
    }
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [idx, val] of Object.entries(args)) {
      const formal = thisThing.formals[idx];
      argsObj[formal] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }
  if (type === "operation") {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return "[" + name + " operation]";
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true
      // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util$2.uniqueId(name)
    });
  }
};
Semantics$2.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + "s";
  parseSignature$1(name, "attribute");
  if (!(this.super && name in this.super[typePlural])) {
    throw new Error(
      "Cannot extend " + type + " '" + name + "': did not inherit an " + type + " with that name"
    );
  }
  if (hasOwnProperty(this[typePlural], name)) {
    throw new Error("Cannot extend " + type + " '" + name + "' again");
  }
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach((name2) => {
    newActionDict[name2] = actionDict[name2];
  });
  this[typePlural][name] = type === "operation" ? new Operation(name, inheritedFormals, newActionDict) : new Attribute(name, newActionDict);
  this[typePlural][name].checkActionDict(this.grammar);
};
Semantics$2.prototype.assertNewName = function(name, type) {
  if (hasOwnProperty(Wrapper.prototype, name)) {
    throw new Error("Cannot add " + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
      "Cannot add " + type + " '" + name + "': an operation with that name already exists"
    );
  }
  if (name in this.attributes) {
    throw new Error(
      "Cannot add " + type + " '" + name + "': an attribute with that name already exists"
    );
  }
};
Semantics$2.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};
Semantics$2.createSemantics = function(grammar2, optSuperSemantics) {
  const s2 = new Semantics$2(
    grammar2,
    optSuperSemantics !== void 0 ? optSuperSemantics : Semantics$2.BuiltInSemantics._getSemantics()
  );
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
        "Semantics expected a MatchResult, but got " + common$3.unexpectedObjToString(matchResult)
      );
    }
    if (matchResult.failed()) {
      throw new TypeError("cannot apply Semantics to " + matchResult.toString());
    }
    const cst = matchResult._cst;
    if (cst.grammar !== grammar2) {
      throw new Error(
        "Cannot use a MatchResult from grammar '" + cst.grammar.name + "' with a semantics for '" + grammar2.name + "'"
      );
    }
    const inputStream = new InputStream$1(matchResult.input);
    return s2.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };
  proxy.addOperation = function(signature, actionDict) {
    s2.addOperationOrAttribute("operation", signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s2.extendOperationOrAttribute("operation", name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s2.addOperationOrAttribute("attribute", name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s2.extendOperationOrAttribute("attribute", name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s2.operations[operationOrAttributeName] || s2.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error(
        '"' + operationOrAttributeName + '" is not a valid operation or attribute name in this semantics for "' + grammar2.name + '"'
      );
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s2.operations) {
      semantic = s2.operations[operationOrAttributeName];
      delete s2.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s2.attributes) {
      semantic = s2.attributes[operationOrAttributeName];
      delete s2.attributes[operationOrAttributeName];
    }
    delete s2.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s2.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s2.attributes);
  };
  proxy.getGrammar = function() {
    return s2.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s2.toRecipe(semanticsOnly);
  };
  proxy.toString = s2.toString.bind(s2);
  proxy._getSemantics = function() {
    return s2;
  };
  return proxy;
};
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }
  checkActionDict(grammar2) {
    grammar2._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }
  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      const { ctorName } = nodeWrapper._node;
      let actionFn = this.actionDict[ctorName];
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        return actionFn.apply(nodeWrapper, nodeWrapper._children());
      }
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, "_nonterminal", ctorName]);
          return actionFn.apply(nodeWrapper, nodeWrapper._children());
        }
      }
      globalActionStack.push([this, "default action", ctorName]);
      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());
    } finally {
      globalActionStack.pop();
    }
  }
}
Operation.prototype.typeName = "operation";
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }
  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key = semantics.attributeKeys[this.name];
    if (!hasOwnProperty(node, key)) {
      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key];
  }
}
Attribute.prototype.typeName = "attribute";
var Semantics_1 = Semantics$2;
const CaseInsensitiveTerminal = CaseInsensitiveTerminal_1;
const Matcher = Matcher_1;
const Semantics$1 = Semantics_1;
const common$2 = common$l;
const errors$2 = errors$9;
const pexprs$3 = pexprs$6;
const SPECIAL_ACTION_NAMES = ["_iter", "_terminal", "_nonterminal", "_default"];
function getSortedRuleValues(grammar2) {
  return Object.keys(grammar2.rules).sort().map((name) => grammar2.rules[name]);
}
const jsonToJS = (str) => str.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
function Grammar$4(name, superGrammar, rules, optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error(
        "Invalid start rule: '" + optDefaultStartRule + "' is not a rule in grammar '" + name + "'"
      );
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}
let ohmGrammar$2;
let buildGrammar$1;
Grammar$4.initApplicationParser = function(grammar2, builderFn) {
  ohmGrammar$2 = grammar2;
  buildGrammar$1 = builderFn;
};
Grammar$4.prototype = {
  matcher() {
    return new Matcher(this);
  },
  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar$4.ProtoBuiltInRules || this === Grammar$4.BuiltInRules;
  },
  equals(g2) {
    if (this === g2) {
      return true;
    }
    if (g2 == null || this.name !== g2.name || this.defaultStartRule !== g2.defaultStartRule || !(this.superGrammar === g2.superGrammar || this.superGrammar.equals(g2.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g2);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description && rule.formals.join(",") === otherRules[i].formals.join(",") && rule.body.toString() === otherRules[i].body.toString();
    });
  },
  match(input, optStartApplication) {
    const m2 = this.matcher();
    m2.replaceInputRange(0, 0, input);
    return m2.match(optStartApplication);
  },
  trace(input, optStartApplication) {
    const m2 = this.matcher();
    m2.replaceInputRange(0, 0, input);
    return m2.trace(optStartApplication);
  },
  createSemantics() {
    return Semantics$1.createSemantics(this);
  },
  extendSemantics(superSemantics) {
    return Semantics$1.createSemantics(this, superSemantics._getSemantics());
  },
  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    const problems = [];
    for (const k2 in actionDict) {
      const v2 = actionDict[k2];
      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k2);
      if (!isSpecialAction && !(k2 in this.rules)) {
        problems.push(`'${k2}' is not a valid semantic action for '${this.name}'`);
        continue;
      }
      if (typeof v2 !== "function") {
        problems.push(`'${k2}' must be a function in an action dictionary for '${this.name}'`);
        continue;
      }
      const actual = v2.length;
      const expected = this._topDownActionArity(k2);
      if (actual !== expected) {
        let details;
        if (k2 === "_iter" || k2 === "_nonterminal") {
          details = `it should use a rest parameter, e.g. \`${k2}(...children) {}\`. NOTE: this is new in Ohm v16  see https://ohmjs.org/d/ati for details.`;
        } else {
          details = `expected ${expected}, got ${actual}`;
        }
        problems.push(`Semantic action '${k2}' has the wrong arity: ${details}`);
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map((problem) => "- " + problem);
      const error2 = new Error(
        [
          `Found errors in the action dictionary of the '${name}' ${what}:`,
          ...prettyProblems
        ].join("\n")
      );
      error2.problems = problems;
      throw error2;
    }
  },
  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    return SPECIAL_ACTION_NAMES.includes(actionName) ? 0 : this.rules[actionName].body.getArity();
  },
  _inheritsFrom(grammar2) {
    let g2 = this.superGrammar;
    while (g2) {
      if (g2.equals(grammar2, true)) {
        return true;
      }
      g2 = g2.superGrammar;
    }
    return false;
  },
  toRecipe(superGrammarExpr = void 0) {
    const metaInfo = {};
    if (this.source) {
      metaInfo.source = this.source.contents;
    }
    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }
    const rules = {};
    Object.keys(this.rules).forEach((ruleName) => {
      const ruleInfo = this.rules[ruleName];
      const { body } = ruleInfo;
      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];
      let operation;
      if (isDefinition) {
        operation = "define";
      } else {
        operation = body instanceof pexprs$3.Extend ? "extend" : "override";
      }
      const metaInfo2 = {};
      if (ruleInfo.source && this.source) {
        const adjusted = ruleInfo.source.relativeTo(this.source);
        metaInfo2.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }
      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);
      rules[ruleName] = [
        operation,
        // "define"/"extend"/"override"
        metaInfo2,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });
    let superGrammarOutput = "null";
    if (superGrammarExpr) {
      superGrammarOutput = superGrammarExpr;
    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammarOutput = this.superGrammar.toRecipe();
    }
    const recipeElements = [
      ...["grammar", metaInfo, this.name].map(JSON.stringify),
      superGrammarOutput,
      ...[startRule, rules].map(JSON.stringify)
    ];
    return jsonToJS(`[${recipeElements.join(",")}]`);
  },
  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  _toOperationOrAttributeActionDictionaryTemplate() {
    const sb = new common$2.StringBuffer();
    sb.append("{");
    let first = true;
    for (const ruleName in this.rules) {
      const { body } = this.rules[ruleName];
      if (first) {
        first = false;
      } else {
        sb.append(",");
      }
      sb.append("\n");
      sb.append("  ");
      this.addSemanticActionTemplate(ruleName, body, sb);
    }
    sb.append("\n}");
    return sb.contents();
  },
  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(": function(");
    const arity = this._topDownActionArity(ruleName);
    sb.append(common$2.repeat("_", arity).join(", "));
    sb.append(") {\n");
    sb.append("  }");
  },
  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf("<") === -1) {
      app = new pexprs$3.Apply(str);
    } else {
      const cst = ohmGrammar$2.match(str, "Base_application");
      app = buildGrammar$1(cst, {});
    }
    if (!(app.ruleName in this.rules)) {
      throw errors$2.undeclaredRule(app.ruleName, this.name);
    }
    const { formals } = this.rules[app.ruleName];
    if (formals.length !== app.args.length) {
      const { source } = this.rules[app.ruleName];
      throw errors$2.wrongNumberOfParameters(
        app.ruleName,
        formals.length,
        app.args.length,
        source
      );
    }
    return app;
  }
};
Grammar$4.ProtoBuiltInRules = new Grammar$4(
  "ProtoBuiltInRules",
  // name
  void 0,
  // supergrammar
  {
    any: {
      body: pexprs$3.any,
      formals: [],
      description: "any character",
      primitive: true
    },
    end: {
      body: pexprs$3.end,
      formals: [],
      description: "end of input",
      primitive: true
    },
    caseInsensitive: {
      body: new CaseInsensitiveTerminal(new pexprs$3.Param(0)),
      formals: ["str"],
      primitive: true
    },
    lower: {
      body: new pexprs$3.UnicodeChar("Ll"),
      formals: [],
      description: "a lowercase letter",
      primitive: true
    },
    upper: {
      body: new pexprs$3.UnicodeChar("Lu"),
      formals: [],
      description: "an uppercase letter",
      primitive: true
    },
    // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
    unicodeLtmo: {
      body: new pexprs$3.UnicodeChar("Ltmo"),
      formals: [],
      description: "a Unicode character in Lt, Lm, or Lo",
      primitive: true
    },
    // These rules are not truly primitive (they could be written in userland) but are defined
    // here for bootstrapping purposes.
    spaces: {
      body: new pexprs$3.Star(new pexprs$3.Apply("space")),
      formals: []
    },
    space: {
      body: new pexprs$3.Range("\0", " "),
      formals: [],
      description: "a space"
    }
  }
);
var Grammar_1 = Grammar$4;
const Grammar$3 = Grammar_1;
const InputStream = InputStream_1;
const common$1 = common$l;
const errors$1 = errors$9;
const pexprs$2 = pexprs$6;
function GrammarDecl$1(name) {
  this.name = name;
}
GrammarDecl$1.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};
GrammarDecl$1.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
      // TODO: The conditional expression below is an ugly hack. It's kind of ok because
      // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
      // we should try to find a better way to do this.
      this.name === "BuiltInRules" ? Grammar$3.ProtoBuiltInRules : Grammar$3.BuiltInRules
    );
  }
  return this.superGrammar;
};
GrammarDecl$1.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors$1.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};
GrammarDecl$1.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames2 = common$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name, duplicateParameterNames2, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors$1.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};
GrammarDecl$1.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};
GrammarDecl$1.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error("the super grammar of a GrammarDecl cannot be set more than once");
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};
GrammarDecl$1.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};
GrammarDecl$1.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};
GrammarDecl$1.prototype.build = function() {
  const grammar2 = new Grammar$3(
    this.name,
    this.ensureSuperGrammar(),
    this.rules,
    this.defaultStartRule
  );
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar2.rules).forEach((ruleName) => {
    const { body } = grammar2.rules[ruleName];
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar2);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    Object.keys(grammar2.rules).forEach((ruleName) => {
      const { body } = grammar2.rules[ruleName];
      try {
        body.assertIteratedExprsAreNotNullable(grammar2, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors$1.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar2.source = this.source;
  }
  return grammar2;
};
GrammarDecl$1.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors$1.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors$1.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames2 = common$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name, duplicateParameterNames2, source);
  }
  return this.install(name, formals, body, description, source);
};
GrammarDecl$1.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};
GrammarDecl$1.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors$1.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs$2.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};
var GrammarDecl_1 = GrammarDecl$1;
const Grammar$2 = Grammar_1;
const GrammarDecl = GrammarDecl_1;
const pexprs$1 = pexprs$6;
function Builder$2() {
}
Builder$2.prototype = {
  currentDecl: null,
  currentRuleName: null,
  newGrammar(name) {
    return new GrammarDecl(name);
  },
  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(
        superGrammar instanceof Grammar$2 ? superGrammar : this.fromRecipe(superGrammar)
      );
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }
    this.currentDecl = gDecl;
    Object.keys(rules).forEach((ruleName) => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];
      const action = ruleRecipe[0];
      const metaInfo2 = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);
      let source;
      if (gDecl.source && metaInfo2 && metaInfo2.sourceInterval) {
        source = gDecl.source.subInterval(
          metaInfo2.sourceInterval[0],
          metaInfo2.sourceInterval[1] - metaInfo2.sourceInterval[0]
        );
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },
  terminal(x2) {
    return new pexprs$1.Terminal(x2);
  },
  range(from, to2) {
    return new pexprs$1.Range(from, to2);
  },
  param(index2) {
    return new pexprs$1.Param(index2);
  },
  alt(...termArgs) {
    let terms = [];
    for (let arg of termArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs$1.Alt(terms);
  },
  seq(...factorArgs) {
    let factors = [];
    for (let arg of factorArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs$1.Seq(factors);
  },
  star(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Star(expr);
  },
  plus(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Plus(expr);
  },
  opt(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Opt(expr);
  },
  not(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Not(expr);
  },
  la(expr) {
    return this.lookahead(expr);
  },
  lookahead(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lookahead(expr);
  },
  lex(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lex(expr);
  },
  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs$1.PExpr ? param : this.fromRecipe(param);
      }, this);
    }
    return new pexprs$1.Apply(ruleName, optParams);
  },
  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs$1.Splice(
      this.currentDecl.superGrammar,
      this.currentRuleName,
      beforeTerms.map((term) => this.fromRecipe(term)),
      afterTerms.map((term) => this.fromRecipe(term))
    );
  },
  fromRecipe(recipe) {
    const args = recipe[0] === "grammar" ? recipe.slice(1) : recipe.slice(2);
    const result = this[recipe[0]](...args);
    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));
      }
    }
    return result;
  }
};
var Builder_1 = Builder$2;
var version$2 = "16.6.0";
var require$$0$1 = {
  version: version$2
};
var version$1 = typeof __GLOBAL_OHM_VERSION__ === "string" ? __GLOBAL_OHM_VERSION__ : require$$0$1.version;
var makeRecipe$5 = {};
const Builder$1 = Builder_1;
function makeRecipe$4(recipe) {
  if (typeof recipe === "function") {
    return recipe.call(new Builder$1());
  } else {
    if (typeof recipe === "string") {
      recipe = JSON.parse(recipe);
    }
    return new Builder$1().fromRecipe(recipe);
  }
}
makeRecipe$5.makeRecipe = makeRecipe$4;
var { makeRecipe: makeRecipe$3 } = makeRecipe$5;
var builtInRules = makeRecipe$3(["grammar", { "source": 'BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = "0".."9"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | "a".."f"\n    | "A".."F"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  applySyntactic<app> = app\n}' }, "BuiltInRules", null, null, { "alnum": ["define", { "sourceInterval": [18, 78] }, "an alpha-numeric character", [], ["alt", { "sourceInterval": [60, 78] }, ["app", { "sourceInterval": [60, 66] }, "letter", []], ["app", { "sourceInterval": [73, 78] }, "digit", []]]], "letter": ["define", { "sourceInterval": [82, 142] }, "a letter", [], ["alt", { "sourceInterval": [107, 142] }, ["app", { "sourceInterval": [107, 112] }, "lower", []], ["app", { "sourceInterval": [119, 124] }, "upper", []], ["app", { "sourceInterval": [131, 142] }, "unicodeLtmo", []]]], "digit": ["define", { "sourceInterval": [146, 177] }, "a digit", [], ["range", { "sourceInterval": [169, 177] }, "0", "9"]], "hexDigit": ["define", { "sourceInterval": [181, 254] }, "a hexadecimal digit", [], ["alt", { "sourceInterval": [219, 254] }, ["app", { "sourceInterval": [219, 224] }, "digit", []], ["range", { "sourceInterval": [231, 239] }, "a", "f"], ["range", { "sourceInterval": [246, 254] }, "A", "F"]]], "ListOf": ["define", { "sourceInterval": [258, 336] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [282, 336] }, ["app", { "sourceInterval": [282, 307] }, "NonemptyListOf", [["param", { "sourceInterval": [297, 301] }, 0], ["param", { "sourceInterval": [303, 306] }, 1]]], ["app", { "sourceInterval": [314, 336] }, "EmptyListOf", [["param", { "sourceInterval": [326, 330] }, 0], ["param", { "sourceInterval": [332, 335] }, 1]]]]], "NonemptyListOf": ["define", { "sourceInterval": [340, 388] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [372, 388] }, ["param", { "sourceInterval": [372, 376] }, 0], ["star", { "sourceInterval": [377, 388] }, ["seq", { "sourceInterval": [378, 386] }, ["param", { "sourceInterval": [378, 381] }, 1], ["param", { "sourceInterval": [382, 386] }, 0]]]]], "EmptyListOf": ["define", { "sourceInterval": [392, 434] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [438, 438] }]], "listOf": ["define", { "sourceInterval": [438, 516] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [462, 516] }, ["app", { "sourceInterval": [462, 487] }, "nonemptyListOf", [["param", { "sourceInterval": [477, 481] }, 0], ["param", { "sourceInterval": [483, 486] }, 1]]], ["app", { "sourceInterval": [494, 516] }, "emptyListOf", [["param", { "sourceInterval": [506, 510] }, 0], ["param", { "sourceInterval": [512, 515] }, 1]]]]], "nonemptyListOf": ["define", { "sourceInterval": [520, 568] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [552, 568] }, ["param", { "sourceInterval": [552, 556] }, 0], ["star", { "sourceInterval": [557, 568] }, ["seq", { "sourceInterval": [558, 566] }, ["param", { "sourceInterval": [558, 561] }, 1], ["param", { "sourceInterval": [562, 566] }, 0]]]]], "emptyListOf": ["define", { "sourceInterval": [572, 682] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [685, 685] }]], "applySyntactic": ["define", { "sourceInterval": [685, 710] }, null, ["app"], ["param", { "sourceInterval": [707, 710] }, 0]] }]);
const Grammar$1 = Grammar_1;
Grammar$1.BuiltInRules = builtInRules;
var { makeRecipe: makeRecipe$2 } = makeRecipe$5;
var operationsAndAttributes = makeRecipe$2(["grammar", { "source": 'OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = "(" ListOf<name, ","> ")"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = "_"\n    | letter\n\n  nameRest\n    = "_"\n    | alnum\n\n}' }, "OperationsAndAttributes", null, "AttributeSignature", { "AttributeSignature": ["define", { "sourceInterval": [29, 58] }, null, [], ["app", { "sourceInterval": [54, 58] }, "name", []]], "OperationSignature": ["define", { "sourceInterval": [62, 100] }, null, [], ["seq", { "sourceInterval": [87, 100] }, ["app", { "sourceInterval": [87, 91] }, "name", []], ["opt", { "sourceInterval": [92, 100] }, ["app", { "sourceInterval": [92, 99] }, "Formals", []]]]], "Formals": ["define", { "sourceInterval": [104, 143] }, null, [], ["seq", { "sourceInterval": [118, 143] }, ["terminal", { "sourceInterval": [118, 121] }, "("], ["app", { "sourceInterval": [122, 139] }, "ListOf", [["app", { "sourceInterval": [129, 133] }, "name", []], ["terminal", { "sourceInterval": [135, 138] }, ","]]], ["terminal", { "sourceInterval": [140, 143] }, ")"]]], "name": ["define", { "sourceInterval": [147, 187] }, "a name", [], ["seq", { "sourceInterval": [168, 187] }, ["app", { "sourceInterval": [168, 177] }, "nameFirst", []], ["star", { "sourceInterval": [178, 187] }, ["app", { "sourceInterval": [178, 186] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [191, 223] }, null, [], ["alt", { "sourceInterval": [207, 223] }, ["terminal", { "sourceInterval": [207, 210] }, "_"], ["app", { "sourceInterval": [217, 223] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [227, 257] }, null, [], ["alt", { "sourceInterval": [242, 257] }, ["terminal", { "sourceInterval": [242, 245] }, "_"], ["app", { "sourceInterval": [252, 257] }, "alnum", []]]] }]);
const Semantics = Semantics_1;
const util$1 = util$7;
util$1.awaitBuiltInRules((builtInRules2) => {
  const operationsAndAttributesGrammar = operationsAndAttributes;
  initBuiltInSemantics(builtInRules2);
  initPrototypeParser(operationsAndAttributesGrammar);
});
function initBuiltInSemantics(builtInRules2) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };
  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules2, null).addOperation(
    "asIteration",
    {
      emptyListOf: actions.empty,
      nonemptyListOf: actions.nonEmpty,
      EmptyListOf: actions.empty,
      NonemptyListOf: actions.nonEmpty
    }
  );
}
function initPrototypeParser(grammar2) {
  Semantics.prototypeGrammarSemantics = grammar2.createSemantics().addOperation("parse", {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.children.map((c) => c.parse())[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().children.map((c) => c.parse());
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  Semantics.prototypeGrammar = grammar2;
}
var { makeRecipe: makeRecipe$1 } = makeRecipe$5;
var ohmGrammar$1 = makeRecipe$1(["grammar", { "source": `Ohm {

  Grammars
    = Grammar*

  Grammar
    = ident SuperGrammar? "{" Rule* "}"

  SuperGrammar
    = "<:" ident

  Rule
    = ident Formals? ruleDescr? "="  RuleBody  -- define
    | ident Formals?            ":=" OverrideRuleBody  -- override
    | ident Formals?            "+=" RuleBody  -- extend

  RuleBody
    = "|"? NonemptyListOf<TopLevelTerm, "|">

  TopLevelTerm
    = Seq caseName  -- inline
    | Seq

  OverrideRuleBody
    = "|"? NonemptyListOf<OverrideTopLevelTerm, "|">

  OverrideTopLevelTerm
    = "..."  -- superSplice
    | TopLevelTerm

  Formals
    = "<" ListOf<ident, ","> ">"

  Params
    = "<" ListOf<Seq, ","> ">"

  Alt
    = NonemptyListOf<Seq, "|">

  Seq
    = Iter*

  Iter
    = Pred "*"  -- star
    | Pred "+"  -- plus
    | Pred "?"  -- opt
    | Pred

  Pred
    = "~" Lex  -- not
    | "&" Lex  -- lookahead
    | Lex

  Lex
    = "#" Base  -- lex
    | Base

  Base
    = ident Params? ~(ruleDescr? "=" | ":=" | "+=")  -- application
    | oneCharTerminal ".." oneCharTerminal           -- range
    | terminal                                       -- terminal
    | "(" Alt ")"                                    -- paren

  ruleDescr  (a rule description)
    = "(" ruleDescrText ")"

  ruleDescrText
    = (~")" any)*

  caseName
    = "--" (~"\\n" space)* name (~"\\n" space)* ("\\n" | &"}")

  name  (a name)
    = nameFirst nameRest*

  nameFirst
    = "_"
    | letter

  nameRest
    = "_"
    | alnum

  ident  (an identifier)
    = name

  terminal
    = "\\"" terminalChar* "\\""

  oneCharTerminal
    = "\\"" terminalChar "\\""

  terminalChar
    = escapeChar
      | ~"\\\\" ~"\\"" ~"\\n" "\\u{0}".."\\u{10FFFF}"

  escapeChar  (an escape sequence)
    = "\\\\\\\\"                                     -- backslash
    | "\\\\\\""                                     -- doubleQuote
    | "\\\\\\'"                                     -- singleQuote
    | "\\\\b"                                      -- backspace
    | "\\\\n"                                      -- lineFeed
    | "\\\\r"                                      -- carriageReturn
    | "\\\\t"                                      -- tab
    | "\\\\u{" hexDigit hexDigit? hexDigit?
             hexDigit? hexDigit? hexDigit? "}"   -- unicodeCodePoint
    | "\\\\u" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape
    | "\\\\x" hexDigit hexDigit                    -- hexEscape

  space
   += comment

  comment
    = "//" (~"\\n" any)* &("\\n" | end)  -- singleLine
    | "/*" (~"*/" any)* "*/"  -- multiLine

  tokens = token*

  token = caseName | comment | ident | operator | punctuation | terminal | any

  operator = "<:" | "=" | ":=" | "+=" | "*" | "+" | "?" | "~" | "&"

  punctuation = "<" | ">" | "," | "--"
}` }, "Ohm", null, "Grammars", { "Grammars": ["define", { "sourceInterval": [9, 32] }, null, [], ["star", { "sourceInterval": [24, 32] }, ["app", { "sourceInterval": [24, 31] }, "Grammar", []]]], "Grammar": ["define", { "sourceInterval": [36, 83] }, null, [], ["seq", { "sourceInterval": [50, 83] }, ["app", { "sourceInterval": [50, 55] }, "ident", []], ["opt", { "sourceInterval": [56, 69] }, ["app", { "sourceInterval": [56, 68] }, "SuperGrammar", []]], ["terminal", { "sourceInterval": [70, 73] }, "{"], ["star", { "sourceInterval": [74, 79] }, ["app", { "sourceInterval": [74, 78] }, "Rule", []]], ["terminal", { "sourceInterval": [80, 83] }, "}"]]], "SuperGrammar": ["define", { "sourceInterval": [87, 116] }, null, [], ["seq", { "sourceInterval": [106, 116] }, ["terminal", { "sourceInterval": [106, 110] }, "<:"], ["app", { "sourceInterval": [111, 116] }, "ident", []]]], "Rule_define": ["define", { "sourceInterval": [131, 181] }, null, [], ["seq", { "sourceInterval": [131, 170] }, ["app", { "sourceInterval": [131, 136] }, "ident", []], ["opt", { "sourceInterval": [137, 145] }, ["app", { "sourceInterval": [137, 144] }, "Formals", []]], ["opt", { "sourceInterval": [146, 156] }, ["app", { "sourceInterval": [146, 155] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [157, 160] }, "="], ["app", { "sourceInterval": [162, 170] }, "RuleBody", []]]], "Rule_override": ["define", { "sourceInterval": [188, 248] }, null, [], ["seq", { "sourceInterval": [188, 235] }, ["app", { "sourceInterval": [188, 193] }, "ident", []], ["opt", { "sourceInterval": [194, 202] }, ["app", { "sourceInterval": [194, 201] }, "Formals", []]], ["terminal", { "sourceInterval": [214, 218] }, ":="], ["app", { "sourceInterval": [219, 235] }, "OverrideRuleBody", []]]], "Rule_extend": ["define", { "sourceInterval": [255, 305] }, null, [], ["seq", { "sourceInterval": [255, 294] }, ["app", { "sourceInterval": [255, 260] }, "ident", []], ["opt", { "sourceInterval": [261, 269] }, ["app", { "sourceInterval": [261, 268] }, "Formals", []]], ["terminal", { "sourceInterval": [281, 285] }, "+="], ["app", { "sourceInterval": [286, 294] }, "RuleBody", []]]], "Rule": ["define", { "sourceInterval": [120, 305] }, null, [], ["alt", { "sourceInterval": [131, 305] }, ["app", { "sourceInterval": [131, 170] }, "Rule_define", []], ["app", { "sourceInterval": [188, 235] }, "Rule_override", []], ["app", { "sourceInterval": [255, 294] }, "Rule_extend", []]]], "RuleBody": ["define", { "sourceInterval": [309, 362] }, null, [], ["seq", { "sourceInterval": [324, 362] }, ["opt", { "sourceInterval": [324, 328] }, ["terminal", { "sourceInterval": [324, 327] }, "|"]], ["app", { "sourceInterval": [329, 362] }, "NonemptyListOf", [["app", { "sourceInterval": [344, 356] }, "TopLevelTerm", []], ["terminal", { "sourceInterval": [358, 361] }, "|"]]]]], "TopLevelTerm_inline": ["define", { "sourceInterval": [385, 408] }, null, [], ["seq", { "sourceInterval": [385, 397] }, ["app", { "sourceInterval": [385, 388] }, "Seq", []], ["app", { "sourceInterval": [389, 397] }, "caseName", []]]], "TopLevelTerm": ["define", { "sourceInterval": [366, 418] }, null, [], ["alt", { "sourceInterval": [385, 418] }, ["app", { "sourceInterval": [385, 397] }, "TopLevelTerm_inline", []], ["app", { "sourceInterval": [415, 418] }, "Seq", []]]], "OverrideRuleBody": ["define", { "sourceInterval": [422, 491] }, null, [], ["seq", { "sourceInterval": [445, 491] }, ["opt", { "sourceInterval": [445, 449] }, ["terminal", { "sourceInterval": [445, 448] }, "|"]], ["app", { "sourceInterval": [450, 491] }, "NonemptyListOf", [["app", { "sourceInterval": [465, 485] }, "OverrideTopLevelTerm", []], ["terminal", { "sourceInterval": [487, 490] }, "|"]]]]], "OverrideTopLevelTerm_superSplice": ["define", { "sourceInterval": [522, 543] }, null, [], ["terminal", { "sourceInterval": [522, 527] }, "..."]], "OverrideTopLevelTerm": ["define", { "sourceInterval": [495, 562] }, null, [], ["alt", { "sourceInterval": [522, 562] }, ["app", { "sourceInterval": [522, 527] }, "OverrideTopLevelTerm_superSplice", []], ["app", { "sourceInterval": [550, 562] }, "TopLevelTerm", []]]], "Formals": ["define", { "sourceInterval": [566, 606] }, null, [], ["seq", { "sourceInterval": [580, 606] }, ["terminal", { "sourceInterval": [580, 583] }, "<"], ["app", { "sourceInterval": [584, 602] }, "ListOf", [["app", { "sourceInterval": [591, 596] }, "ident", []], ["terminal", { "sourceInterval": [598, 601] }, ","]]], ["terminal", { "sourceInterval": [603, 606] }, ">"]]], "Params": ["define", { "sourceInterval": [610, 647] }, null, [], ["seq", { "sourceInterval": [623, 647] }, ["terminal", { "sourceInterval": [623, 626] }, "<"], ["app", { "sourceInterval": [627, 643] }, "ListOf", [["app", { "sourceInterval": [634, 637] }, "Seq", []], ["terminal", { "sourceInterval": [639, 642] }, ","]]], ["terminal", { "sourceInterval": [644, 647] }, ">"]]], "Alt": ["define", { "sourceInterval": [651, 685] }, null, [], ["app", { "sourceInterval": [661, 685] }, "NonemptyListOf", [["app", { "sourceInterval": [676, 679] }, "Seq", []], ["terminal", { "sourceInterval": [681, 684] }, "|"]]]], "Seq": ["define", { "sourceInterval": [689, 704] }, null, [], ["star", { "sourceInterval": [699, 704] }, ["app", { "sourceInterval": [699, 703] }, "Iter", []]]], "Iter_star": ["define", { "sourceInterval": [719, 736] }, null, [], ["seq", { "sourceInterval": [719, 727] }, ["app", { "sourceInterval": [719, 723] }, "Pred", []], ["terminal", { "sourceInterval": [724, 727] }, "*"]]], "Iter_plus": ["define", { "sourceInterval": [743, 760] }, null, [], ["seq", { "sourceInterval": [743, 751] }, ["app", { "sourceInterval": [743, 747] }, "Pred", []], ["terminal", { "sourceInterval": [748, 751] }, "+"]]], "Iter_opt": ["define", { "sourceInterval": [767, 783] }, null, [], ["seq", { "sourceInterval": [767, 775] }, ["app", { "sourceInterval": [767, 771] }, "Pred", []], ["terminal", { "sourceInterval": [772, 775] }, "?"]]], "Iter": ["define", { "sourceInterval": [708, 794] }, null, [], ["alt", { "sourceInterval": [719, 794] }, ["app", { "sourceInterval": [719, 727] }, "Iter_star", []], ["app", { "sourceInterval": [743, 751] }, "Iter_plus", []], ["app", { "sourceInterval": [767, 775] }, "Iter_opt", []], ["app", { "sourceInterval": [790, 794] }, "Pred", []]]], "Pred_not": ["define", { "sourceInterval": [809, 824] }, null, [], ["seq", { "sourceInterval": [809, 816] }, ["terminal", { "sourceInterval": [809, 812] }, "~"], ["app", { "sourceInterval": [813, 816] }, "Lex", []]]], "Pred_lookahead": ["define", { "sourceInterval": [831, 852] }, null, [], ["seq", { "sourceInterval": [831, 838] }, ["terminal", { "sourceInterval": [831, 834] }, "&"], ["app", { "sourceInterval": [835, 838] }, "Lex", []]]], "Pred": ["define", { "sourceInterval": [798, 862] }, null, [], ["alt", { "sourceInterval": [809, 862] }, ["app", { "sourceInterval": [809, 816] }, "Pred_not", []], ["app", { "sourceInterval": [831, 838] }, "Pred_lookahead", []], ["app", { "sourceInterval": [859, 862] }, "Lex", []]]], "Lex_lex": ["define", { "sourceInterval": [876, 892] }, null, [], ["seq", { "sourceInterval": [876, 884] }, ["terminal", { "sourceInterval": [876, 879] }, "#"], ["app", { "sourceInterval": [880, 884] }, "Base", []]]], "Lex": ["define", { "sourceInterval": [866, 903] }, null, [], ["alt", { "sourceInterval": [876, 903] }, ["app", { "sourceInterval": [876, 884] }, "Lex_lex", []], ["app", { "sourceInterval": [899, 903] }, "Base", []]]], "Base_application": ["define", { "sourceInterval": [918, 979] }, null, [], ["seq", { "sourceInterval": [918, 963] }, ["app", { "sourceInterval": [918, 923] }, "ident", []], ["opt", { "sourceInterval": [924, 931] }, ["app", { "sourceInterval": [924, 930] }, "Params", []]], ["not", { "sourceInterval": [932, 963] }, ["alt", { "sourceInterval": [934, 962] }, ["seq", { "sourceInterval": [934, 948] }, ["opt", { "sourceInterval": [934, 944] }, ["app", { "sourceInterval": [934, 943] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [945, 948] }, "="]], ["terminal", { "sourceInterval": [951, 955] }, ":="], ["terminal", { "sourceInterval": [958, 962] }, "+="]]]]], "Base_range": ["define", { "sourceInterval": [986, 1041] }, null, [], ["seq", { "sourceInterval": [986, 1022] }, ["app", { "sourceInterval": [986, 1001] }, "oneCharTerminal", []], ["terminal", { "sourceInterval": [1002, 1006] }, ".."], ["app", { "sourceInterval": [1007, 1022] }, "oneCharTerminal", []]]], "Base_terminal": ["define", { "sourceInterval": [1048, 1106] }, null, [], ["app", { "sourceInterval": [1048, 1056] }, "terminal", []]], "Base_paren": ["define", { "sourceInterval": [1113, 1168] }, null, [], ["seq", { "sourceInterval": [1113, 1124] }, ["terminal", { "sourceInterval": [1113, 1116] }, "("], ["app", { "sourceInterval": [1117, 1120] }, "Alt", []], ["terminal", { "sourceInterval": [1121, 1124] }, ")"]]], "Base": ["define", { "sourceInterval": [907, 1168] }, null, [], ["alt", { "sourceInterval": [918, 1168] }, ["app", { "sourceInterval": [918, 963] }, "Base_application", []], ["app", { "sourceInterval": [986, 1022] }, "Base_range", []], ["app", { "sourceInterval": [1048, 1056] }, "Base_terminal", []], ["app", { "sourceInterval": [1113, 1124] }, "Base_paren", []]]], "ruleDescr": ["define", { "sourceInterval": [1172, 1231] }, "a rule description", [], ["seq", { "sourceInterval": [1210, 1231] }, ["terminal", { "sourceInterval": [1210, 1213] }, "("], ["app", { "sourceInterval": [1214, 1227] }, "ruleDescrText", []], ["terminal", { "sourceInterval": [1228, 1231] }, ")"]]], "ruleDescrText": ["define", { "sourceInterval": [1235, 1266] }, null, [], ["star", { "sourceInterval": [1255, 1266] }, ["seq", { "sourceInterval": [1256, 1264] }, ["not", { "sourceInterval": [1256, 1260] }, ["terminal", { "sourceInterval": [1257, 1260] }, ")"]], ["app", { "sourceInterval": [1261, 1264] }, "any", []]]]], "caseName": ["define", { "sourceInterval": [1270, 1338] }, null, [], ["seq", { "sourceInterval": [1285, 1338] }, ["terminal", { "sourceInterval": [1285, 1289] }, "--"], ["star", { "sourceInterval": [1290, 1304] }, ["seq", { "sourceInterval": [1291, 1302] }, ["not", { "sourceInterval": [1291, 1296] }, ["terminal", { "sourceInterval": [1292, 1296] }, "\n"]], ["app", { "sourceInterval": [1297, 1302] }, "space", []]]], ["app", { "sourceInterval": [1305, 1309] }, "name", []], ["star", { "sourceInterval": [1310, 1324] }, ["seq", { "sourceInterval": [1311, 1322] }, ["not", { "sourceInterval": [1311, 1316] }, ["terminal", { "sourceInterval": [1312, 1316] }, "\n"]], ["app", { "sourceInterval": [1317, 1322] }, "space", []]]], ["alt", { "sourceInterval": [1326, 1337] }, ["terminal", { "sourceInterval": [1326, 1330] }, "\n"], ["lookahead", { "sourceInterval": [1333, 1337] }, ["terminal", { "sourceInterval": [1334, 1337] }, "}"]]]]], "name": ["define", { "sourceInterval": [1342, 1382] }, "a name", [], ["seq", { "sourceInterval": [1363, 1382] }, ["app", { "sourceInterval": [1363, 1372] }, "nameFirst", []], ["star", { "sourceInterval": [1373, 1382] }, ["app", { "sourceInterval": [1373, 1381] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [1386, 1418] }, null, [], ["alt", { "sourceInterval": [1402, 1418] }, ["terminal", { "sourceInterval": [1402, 1405] }, "_"], ["app", { "sourceInterval": [1412, 1418] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [1422, 1452] }, null, [], ["alt", { "sourceInterval": [1437, 1452] }, ["terminal", { "sourceInterval": [1437, 1440] }, "_"], ["app", { "sourceInterval": [1447, 1452] }, "alnum", []]]], "ident": ["define", { "sourceInterval": [1456, 1489] }, "an identifier", [], ["app", { "sourceInterval": [1485, 1489] }, "name", []]], "terminal": ["define", { "sourceInterval": [1493, 1531] }, null, [], ["seq", { "sourceInterval": [1508, 1531] }, ["terminal", { "sourceInterval": [1508, 1512] }, '"'], ["star", { "sourceInterval": [1513, 1526] }, ["app", { "sourceInterval": [1513, 1525] }, "terminalChar", []]], ["terminal", { "sourceInterval": [1527, 1531] }, '"']]], "oneCharTerminal": ["define", { "sourceInterval": [1535, 1579] }, null, [], ["seq", { "sourceInterval": [1557, 1579] }, ["terminal", { "sourceInterval": [1557, 1561] }, '"'], ["app", { "sourceInterval": [1562, 1574] }, "terminalChar", []], ["terminal", { "sourceInterval": [1575, 1579] }, '"']]], "terminalChar": ["define", { "sourceInterval": [1583, 1660] }, null, [], ["alt", { "sourceInterval": [1602, 1660] }, ["app", { "sourceInterval": [1602, 1612] }, "escapeChar", []], ["seq", { "sourceInterval": [1621, 1660] }, ["not", { "sourceInterval": [1621, 1626] }, ["terminal", { "sourceInterval": [1622, 1626] }, "\\"]], ["not", { "sourceInterval": [1627, 1632] }, ["terminal", { "sourceInterval": [1628, 1632] }, '"']], ["not", { "sourceInterval": [1633, 1638] }, ["terminal", { "sourceInterval": [1634, 1638] }, "\n"]], ["range", { "sourceInterval": [1639, 1660] }, "\0", ""]]]], "escapeChar_backslash": ["define", { "sourceInterval": [1703, 1758] }, null, [], ["terminal", { "sourceInterval": [1703, 1709] }, "\\\\"]], "escapeChar_doubleQuote": ["define", { "sourceInterval": [1765, 1822] }, null, [], ["terminal", { "sourceInterval": [1765, 1771] }, '\\"']], "escapeChar_singleQuote": ["define", { "sourceInterval": [1829, 1886] }, null, [], ["terminal", { "sourceInterval": [1829, 1835] }, "\\'"]], "escapeChar_backspace": ["define", { "sourceInterval": [1893, 1948] }, null, [], ["terminal", { "sourceInterval": [1893, 1898] }, "\\b"]], "escapeChar_lineFeed": ["define", { "sourceInterval": [1955, 2009] }, null, [], ["terminal", { "sourceInterval": [1955, 1960] }, "\\n"]], "escapeChar_carriageReturn": ["define", { "sourceInterval": [2016, 2076] }, null, [], ["terminal", { "sourceInterval": [2016, 2021] }, "\\r"]], "escapeChar_tab": ["define", { "sourceInterval": [2083, 2132] }, null, [], ["terminal", { "sourceInterval": [2083, 2088] }, "\\t"]], "escapeChar_unicodeCodePoint": ["define", { "sourceInterval": [2139, 2243] }, null, [], ["seq", { "sourceInterval": [2139, 2221] }, ["terminal", { "sourceInterval": [2139, 2145] }, "\\u{"], ["app", { "sourceInterval": [2146, 2154] }, "hexDigit", []], ["opt", { "sourceInterval": [2155, 2164] }, ["app", { "sourceInterval": [2155, 2163] }, "hexDigit", []]], ["opt", { "sourceInterval": [2165, 2174] }, ["app", { "sourceInterval": [2165, 2173] }, "hexDigit", []]], ["opt", { "sourceInterval": [2188, 2197] }, ["app", { "sourceInterval": [2188, 2196] }, "hexDigit", []]], ["opt", { "sourceInterval": [2198, 2207] }, ["app", { "sourceInterval": [2198, 2206] }, "hexDigit", []]], ["opt", { "sourceInterval": [2208, 2217] }, ["app", { "sourceInterval": [2208, 2216] }, "hexDigit", []]], ["terminal", { "sourceInterval": [2218, 2221] }, "}"]]], "escapeChar_unicodeEscape": ["define", { "sourceInterval": [2250, 2309] }, null, [], ["seq", { "sourceInterval": [2250, 2291] }, ["terminal", { "sourceInterval": [2250, 2255] }, "\\u"], ["app", { "sourceInterval": [2256, 2264] }, "hexDigit", []], ["app", { "sourceInterval": [2265, 2273] }, "hexDigit", []], ["app", { "sourceInterval": [2274, 2282] }, "hexDigit", []], ["app", { "sourceInterval": [2283, 2291] }, "hexDigit", []]]], "escapeChar_hexEscape": ["define", { "sourceInterval": [2316, 2371] }, null, [], ["seq", { "sourceInterval": [2316, 2339] }, ["terminal", { "sourceInterval": [2316, 2321] }, "\\x"], ["app", { "sourceInterval": [2322, 2330] }, "hexDigit", []], ["app", { "sourceInterval": [2331, 2339] }, "hexDigit", []]]], "escapeChar": ["define", { "sourceInterval": [1664, 2371] }, "an escape sequence", [], ["alt", { "sourceInterval": [1703, 2371] }, ["app", { "sourceInterval": [1703, 1709] }, "escapeChar_backslash", []], ["app", { "sourceInterval": [1765, 1771] }, "escapeChar_doubleQuote", []], ["app", { "sourceInterval": [1829, 1835] }, "escapeChar_singleQuote", []], ["app", { "sourceInterval": [1893, 1898] }, "escapeChar_backspace", []], ["app", { "sourceInterval": [1955, 1960] }, "escapeChar_lineFeed", []], ["app", { "sourceInterval": [2016, 2021] }, "escapeChar_carriageReturn", []], ["app", { "sourceInterval": [2083, 2088] }, "escapeChar_tab", []], ["app", { "sourceInterval": [2139, 2221] }, "escapeChar_unicodeCodePoint", []], ["app", { "sourceInterval": [2250, 2291] }, "escapeChar_unicodeEscape", []], ["app", { "sourceInterval": [2316, 2339] }, "escapeChar_hexEscape", []]]], "space": ["extend", { "sourceInterval": [2375, 2394] }, null, [], ["app", { "sourceInterval": [2387, 2394] }, "comment", []]], "comment_singleLine": ["define", { "sourceInterval": [2412, 2458] }, null, [], ["seq", { "sourceInterval": [2412, 2443] }, ["terminal", { "sourceInterval": [2412, 2416] }, "//"], ["star", { "sourceInterval": [2417, 2429] }, ["seq", { "sourceInterval": [2418, 2427] }, ["not", { "sourceInterval": [2418, 2423] }, ["terminal", { "sourceInterval": [2419, 2423] }, "\n"]], ["app", { "sourceInterval": [2424, 2427] }, "any", []]]], ["lookahead", { "sourceInterval": [2430, 2443] }, ["alt", { "sourceInterval": [2432, 2442] }, ["terminal", { "sourceInterval": [2432, 2436] }, "\n"], ["app", { "sourceInterval": [2439, 2442] }, "end", []]]]]], "comment_multiLine": ["define", { "sourceInterval": [2465, 2501] }, null, [], ["seq", { "sourceInterval": [2465, 2487] }, ["terminal", { "sourceInterval": [2465, 2469] }, "/*"], ["star", { "sourceInterval": [2470, 2482] }, ["seq", { "sourceInterval": [2471, 2480] }, ["not", { "sourceInterval": [2471, 2476] }, ["terminal", { "sourceInterval": [2472, 2476] }, "*/"]], ["app", { "sourceInterval": [2477, 2480] }, "any", []]]], ["terminal", { "sourceInterval": [2483, 2487] }, "*/"]]], "comment": ["define", { "sourceInterval": [2398, 2501] }, null, [], ["alt", { "sourceInterval": [2412, 2501] }, ["app", { "sourceInterval": [2412, 2443] }, "comment_singleLine", []], ["app", { "sourceInterval": [2465, 2487] }, "comment_multiLine", []]]], "tokens": ["define", { "sourceInterval": [2505, 2520] }, null, [], ["star", { "sourceInterval": [2514, 2520] }, ["app", { "sourceInterval": [2514, 2519] }, "token", []]]], "token": ["define", { "sourceInterval": [2524, 2600] }, null, [], ["alt", { "sourceInterval": [2532, 2600] }, ["app", { "sourceInterval": [2532, 2540] }, "caseName", []], ["app", { "sourceInterval": [2543, 2550] }, "comment", []], ["app", { "sourceInterval": [2553, 2558] }, "ident", []], ["app", { "sourceInterval": [2561, 2569] }, "operator", []], ["app", { "sourceInterval": [2572, 2583] }, "punctuation", []], ["app", { "sourceInterval": [2586, 2594] }, "terminal", []], ["app", { "sourceInterval": [2597, 2600] }, "any", []]]], "operator": ["define", { "sourceInterval": [2604, 2669] }, null, [], ["alt", { "sourceInterval": [2615, 2669] }, ["terminal", { "sourceInterval": [2615, 2619] }, "<:"], ["terminal", { "sourceInterval": [2622, 2625] }, "="], ["terminal", { "sourceInterval": [2628, 2632] }, ":="], ["terminal", { "sourceInterval": [2635, 2639] }, "+="], ["terminal", { "sourceInterval": [2642, 2645] }, "*"], ["terminal", { "sourceInterval": [2648, 2651] }, "+"], ["terminal", { "sourceInterval": [2654, 2657] }, "?"], ["terminal", { "sourceInterval": [2660, 2663] }, "~"], ["terminal", { "sourceInterval": [2666, 2669] }, "&"]]], "punctuation": ["define", { "sourceInterval": [2673, 2709] }, null, [], ["alt", { "sourceInterval": [2687, 2709] }, ["terminal", { "sourceInterval": [2687, 2690] }, "<"], ["terminal", { "sourceInterval": [2693, 2696] }, ">"], ["terminal", { "sourceInterval": [2699, 2702] }, ","], ["terminal", { "sourceInterval": [2705, 2709] }, "--"]]] }]);
const Builder = Builder_1;
const Grammar = Grammar_1;
const Namespace = Namespace_1;
const common$m = common$l;
const errors = errors$9;
const pexprs = pexprs$6;
const util = util$7;
const version = version$1;
const { makeRecipe } = makeRecipe$5;
let ohmGrammar;
const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);
const isBuffer = (obj) => !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder2 = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;
  const helpers = metaGrammar.createSemantics().addOperation("visit", {
    Grammars(grammarIter) {
      return grammarIter.children.map((c) => c.visit());
    },
    Grammar(id, s2, _open, rules, _close) {
      const grammarName = id.visit();
      decl = builder2.newGrammar(grammarName, namespace);
      s2.child(0) && s2.child(0).visit();
      rules.children.map((c) => c.visit());
      const g2 = decl.build();
      g2.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors.duplicateGrammarDeclaration(g2, namespace);
      }
      namespace[grammarName] = g2;
      return g2;
    },
    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === "null") {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },
    Rule_define(n, fs, d, _, b2) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b2.visit();
      const description = d.children.map((c) => c.visit())[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b2) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);
      overriding = true;
      const body = b2.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b2) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const body = b2.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      return builder2.alt(...terms.visit()).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);
        afterTerms.forEach((t) => {
          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);
        });
        return new pexprs.Splice(
          decl.superGrammar,
          currentRuleName,
          beforeTerms,
          afterTerms
        ).withSource(this.source);
      } else {
        return builder2.alt(...args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },
    Params(opointy, ps, cpointy) {
      return ps.visit();
    },
    Alt(seqs) {
      return builder2.alt(...seqs.visit()).withSource(this.source);
    },
    TopLevelTerm_inline(b2, n) {
      const inlineRuleName = currentRuleName + "_" + n.visit();
      const body = b2.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration = !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map((formal) => builder2.app(formal));
      return builder2.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },
    Seq(expr) {
      return builder2.seq(...expr.children.map((c) => c.visit())).withSource(this.source);
    },
    Iter_star(x2, _) {
      return builder2.star(x2.visit()).withSource(this.source);
    },
    Iter_plus(x2, _) {
      return builder2.plus(x2.visit()).withSource(this.source);
    },
    Iter_opt(x2, _) {
      return builder2.opt(x2.visit()).withSource(this.source);
    },
    Pred_not(_, x2) {
      return builder2.not(x2.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x2) {
      return builder2.lookahead(x2.visit()).withSource(this.source);
    },
    Lex_lex(_, x2) {
      return builder2.lex(x2.visit()).withSource(this.source);
    },
    Base_application(rule, ps) {
      const params = ps.children.map((c) => c.visit())[0] || [];
      return builder2.app(rule.visit(), params).withSource(this.source);
    },
    Base_range(from, _, to2) {
      return builder2.range(from.visit(), to2.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder2.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x2, close) {
      return x2.visit();
    },
    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },
    caseName(_, space1, n, space2, end2) {
      return n.visit();
    },
    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {
    },
    nameRest(expr) {
    },
    terminal(open, cs, close) {
      return cs.children.map((c) => c.visit()).join("");
    },
    oneCharTerminal(open, c, close) {
      return c.visit();
    },
    escapeChar(c) {
      try {
        return common$m.unescapeCodePoint(this.sourceString);
      } catch (err) {
        if (err instanceof RangeError && err.message.startsWith("Invalid code point ")) {
          throw errors.invalidCodePoint(c);
        }
        throw err;
      }
    },
    NonemptyListOf(x2, _, xs) {
      return [x2.visit()].concat(xs.children.map((c) => c.visit()));
    },
    EmptyListOf() {
      return [];
    },
    _terminal() {
      return this.sourceString;
    }
  });
  return helpers(match).visit();
}
function compileAndLoad(source, namespace) {
  const m2 = ohmGrammar.match(source, "Grammars");
  if (m2.failed()) {
    throw errors.grammarSyntaxError(m2);
  }
  return buildGrammar(m2, namespace);
}
function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error("Missing grammar definition");
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
      util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) + "Found more than one grammar definition -- use ohm.grammars() instead."
    );
  }
  return ns[grammarNames[0]];
}
function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== "string") {
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
        "Expected string as first argument, got " + common$m.unexpectedObjToString(source)
      );
    }
  }
  compileAndLoad(source, ns);
  return ns;
}
function grammarFromScriptElement(optNode) {
  throw new Error(
    "grammarFromScriptElement was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
function grammarsFromScriptElements(optNodeOrNodeList) {
  throw new Error(
    "grammarsFromScriptElements was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
main$1.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null,
  // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util,
  version
};
main$1.exports._buildGrammar = buildGrammar;
util.announceBuiltInRules(Grammar.BuiltInRules);
main$1.exports.ohmGrammar = ohmGrammar = ohmGrammar$1;
Grammar.initApplicationParser(ohmGrammar, buildGrammar);
var ohm = main$1.exports;
const { assert } = common$l;
function getProp(name, thing, fn2) {
  return fn2(thing[name]);
}
function mapProp(name, thing, fn2) {
  return thing[name].map(fn2);
}
function getPropWalkFn(descriptor2) {
  const parts = descriptor2.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor2);
}
function getProps(walkFns, thing, fn2) {
  return walkFns.map((walkFn) => walkFn(thing, fn2));
}
function getWalkFn(shape) {
  if (typeof shape === "string") {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === "function", "Expected a string, Array, or function");
    assert(shape.length === 2, "Expected a function of arity 2, got " + shape.length);
    return shape;
  }
}
function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}
function trim(s2) {
  return s2.trim();
}
function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === "") {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(",").map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return { name, formals: params };
    }
  }
  throw new Error("Invalid operation signature: " + sig);
}
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;
  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error("heeey!");
  };
  this.operations = {};
  this._arities = /* @__PURE__ */ Object.create(null);
  this._getChildren = /* @__PURE__ */ Object.create(null);
  Object.keys(this._shapes).forEach((k2) => {
    const shape = this._shapes[k2];
    this._getChildren[k2] = getWalkFn(shape);
    if (typeof shape !== "function") {
      this._arities[k2] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = (thing) => new this.Adapter(thing, this);
}
VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};
VisitorFamily.prototype._checkActionDict = function(dict) {
  Object.keys(dict).forEach((k2) => {
    assert(k2 in this._getChildren, "Unrecognized action name '" + k2 + "'");
    const action = dict[k2];
    assert(typeof action === "function", "Key '" + k2 + "': expected function, got " + action);
    if (k2 in this._arities) {
      const expected = this._arities[k2];
      const actual = dict[k2].length;
      assert(
        actual === expected,
        "Action '" + k2 + "' has the wrong arity: expected " + expected + ", got " + actual
      );
    }
  });
};
VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const { name } = sig;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };
  const family = this;
  this.Adapter.prototype[name] = function(...args) {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [i, val] of Object.entries(args)) {
      argsObj[sig.formals[i]] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = actions[tag].apply(
      this,
      family._getChildren[tag](this._adaptee, family._wrap)
    );
    this.args = oldArgs;
    return ans;
  };
  return this;
};
var VisitorFamily_1 = VisitorFamily;
const defaultOperation = {
  _terminal() {
    return this.sourceString;
  },
  _nonterminal(...children) {
    const { ctorName } = this._node;
    const { mapping } = this.args;
    if (!Object.prototype.hasOwnProperty.call(mapping, ctorName)) {
      if (this.isLexical()) {
        return this.sourceString;
      }
      const realChildren = children.filter((child) => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }
    }
    if (typeof mapping[ctorName] === "number") {
      return children[mapping[ctorName]].toAST(mapping);
    }
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === "number") {
        node[prop] = children[mappedProp].toAST(mapping);
      } else if (typeof mappedProp === "string" || typeof mappedProp === "boolean" || mappedProp === null) {
        node[prop] = mappedProp;
      } else if (typeof mappedProp === "object" && mappedProp instanceof Number) {
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === "function") {
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === void 0) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          delete node[prop];
        }
      }
    }
    return node;
  },
  _iter(...children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }
    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },
  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },
  EmptyListOf() {
    return [];
  }
};
function toAST(res, mapping) {
  if (typeof res.failed !== "function" || res.failed()) {
    throw new Error("toAST() expects a succesful MatchResult as first parameter");
  }
  mapping = Object.assign({}, mapping);
  const operation = Object.assign({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === "function") {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g2 = res._cst.grammar;
  const s2 = g2.createSemantics().addOperation("toAST(mapping)", operation);
  return s2(res).toAST(mapping);
}
function semanticsForToAST(g2) {
  if (typeof g2.createSemantics !== "function") {
    throw new Error("semanticsToAST() expects a Grammar as parameter");
  }
  return g2.createSemantics().addOperation("toAST(mapping)", defaultOperation);
}
var semanticsToAST = {
  helper: toAST,
  semantics: semanticsForToAST
};
var extras = {
  VisitorFamily: VisitorFamily_1,
  semanticsForToAST: semanticsToAST.semantics,
  toAST: semanticsToAST.helper
};
const ohm_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ohm,
  extras
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(ohm_esm);
var parents = {};
var visit = {};
var nodes = {};
var hasRequiredNodes;
function requireNodes() {
  if (hasRequiredNodes) return nodes;
  hasRequiredNodes = 1;
  Object.defineProperty(nodes, "__esModule", { value: true });
  nodes.NumberExpr = nodes.NameExpr = nodes.RefExpr = nodes.NegateExpr = nodes.MathExpr = nodes.MathOperator = nodes.CombinatorExpr = nodes.BuiltinZeroArgs = nodes.BuiltinZeroArgsOperators = nodes.BuiltinOneArgExpr = nodes.BuiltinOneArgOperators = nodes.BuiltinExpr = nodes.CellRefExpr = nodes.CompareExpr = nodes.CompareOperator = nodes.CondExpr = nodes.Expression = nodes.Combinator = nodes.FieldExprDef = nodes.FieldNamedDef = nodes.FieldAnonymousDef = nodes.FieldCurlyExprDef = nodes.FieldBuiltinDef = nodes.FieldBuiltinType = nodes.Field = nodes.Constructor = nodes.Declaration = nodes.Program = nodes.ASTBase = nodes.ASTRootBase = void 0;
  class ASTRootBase {
  }
  nodes.ASTRootBase = ASTRootBase;
  ASTRootBase._attributes = [];
  class ASTBase extends ASTRootBase {
  }
  nodes.ASTBase = ASTBase;
  class Program extends ASTRootBase {
    constructor(declarations) {
      super();
      this.declarations = declarations;
      this.parent = null;
    }
  }
  nodes.Program = Program;
  Program._attributes = ["declarations"];
  class Declaration extends ASTBase {
    constructor(constructorDef, fields, combinator) {
      super();
      this.constructorDef = constructorDef;
      this.fields = fields;
      this.combinator = combinator;
    }
  }
  nodes.Declaration = Declaration;
  Declaration._attributes = ["constructorDef", "fields", "combinator"];
  class Constructor extends ASTBase {
    constructor(name, tag) {
      super();
      this.name = name;
      this.tag = tag;
    }
    getTagType() {
      if (this.tag === null) {
        return null;
      }
      return this.tag.startsWith("$") ? "binary" : "hex";
    }
  }
  nodes.Constructor = Constructor;
  class Field extends ASTBase {
  }
  nodes.Field = Field;
  nodes.FieldBuiltinType = ["#", "Type"];
  class FieldBuiltinDef extends Field {
    constructor(name, type) {
      super();
      this.name = name;
      this.type = type;
    }
  }
  nodes.FieldBuiltinDef = FieldBuiltinDef;
  class FieldCurlyExprDef extends Field {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes.FieldCurlyExprDef = FieldCurlyExprDef;
  FieldCurlyExprDef._attributes = ["expr"];
  class FieldAnonymousDef extends Field {
    constructor(name, isRef, fields) {
      super();
      this.name = name;
      this.isRef = isRef;
      this.fields = fields;
    }
  }
  nodes.FieldAnonymousDef = FieldAnonymousDef;
  FieldAnonymousDef._attributes = ["fields"];
  class FieldNamedDef extends Field {
    constructor(name, expr) {
      super();
      this.name = name;
      this.expr = expr;
    }
  }
  nodes.FieldNamedDef = FieldNamedDef;
  FieldNamedDef._attributes = ["expr"];
  class FieldExprDef extends Field {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes.FieldExprDef = FieldExprDef;
  FieldExprDef._attributes = ["expr"];
  class Combinator extends ASTBase {
    constructor(name, args) {
      super();
      this.name = name;
      this.args = args;
    }
  }
  nodes.Combinator = Combinator;
  Combinator._attributes = ["args"];
  class Expression extends ASTBase {
  }
  nodes.Expression = Expression;
  class CondExpr extends Expression {
    constructor(left, dotExpr, condExpr) {
      super();
      this.left = left;
      this.dotExpr = dotExpr;
      this.condExpr = condExpr;
    }
  }
  nodes.CondExpr = CondExpr;
  CondExpr._attributes = ["left", "condExpr"];
  nodes.CompareOperator = ["<=", ">=", "!=", "=", "<", ">"];
  class CompareExpr extends Expression {
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
    }
  }
  nodes.CompareExpr = CompareExpr;
  CompareExpr._attributes = ["left", "right"];
  class CellRefExpr extends Expression {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes.CellRefExpr = CellRefExpr;
  CellRefExpr._attributes = ["expr"];
  class BuiltinExpr extends Expression {
  }
  nodes.BuiltinExpr = BuiltinExpr;
  nodes.BuiltinOneArgOperators = ["#<=", "#<", "##"];
  class BuiltinOneArgExpr extends BuiltinExpr {
    constructor(name, arg) {
      super();
      this.name = name;
      this.arg = arg;
    }
  }
  nodes.BuiltinOneArgExpr = BuiltinOneArgExpr;
  BuiltinOneArgExpr._attributes = ["arg"];
  nodes.BuiltinZeroArgsOperators = ["#"];
  class BuiltinZeroArgs extends BuiltinExpr {
    constructor(name) {
      super();
      this.name = name;
    }
  }
  nodes.BuiltinZeroArgs = BuiltinZeroArgs;
  class CombinatorExpr extends Expression {
    constructor(name, args) {
      super();
      this.name = name;
      this.args = args;
    }
  }
  nodes.CombinatorExpr = CombinatorExpr;
  CombinatorExpr._attributes = ["args"];
  nodes.MathOperator = ["*", "+"];
  class MathExpr extends Expression {
    // TODO: narrower type for `left` and `right`?
    // TODO: use `SimpleExpr` and `number`?
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
    }
  }
  nodes.MathExpr = MathExpr;
  MathExpr._attributes = ["left", "right"];
  class NegateExpr extends Expression {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes.NegateExpr = NegateExpr;
  NegateExpr._attributes = ["expr"];
  class RefExpr extends Expression {
  }
  nodes.RefExpr = RefExpr;
  class NameExpr extends RefExpr {
    constructor(name) {
      super();
      this.name = name;
    }
  }
  nodes.NameExpr = NameExpr;
  class NumberExpr extends RefExpr {
    constructor(num) {
      super();
      this.num = num;
    }
  }
  nodes.NumberExpr = NumberExpr;
  return nodes;
}
var hasRequiredVisit;
function requireVisit() {
  if (hasRequiredVisit) return visit;
  hasRequiredVisit = 1;
  Object.defineProperty(visit, "__esModule", { value: true });
  visit.NodeVisitor = void 0;
  visit.iterChildNodes = iterChildNodes;
  visit.walk = walk;
  const nodes_1 = requireNodes();
  function* iterChildNodes(node) {
    const item = Object.getPrototypeOf(node).constructor;
    for (const attributeName of item._attributes) {
      const raw = node[attributeName];
      if (Array.isArray(raw)) {
        for (const child of raw) {
          yield child;
        }
      } else if (raw instanceof nodes_1.ASTRootBase) {
        yield raw;
      }
    }
  }
  function* walk(node) {
    const todo = [node];
    while (todo.length > 0) {
      const current = todo.shift();
      todo.push(...iterChildNodes(current));
      yield current;
    }
  }
  class NodeVisitor {
    visit(node) {
      const constructorName = node.constructor.name;
      const handlerName = `visit${constructorName}`;
      const handler = this[handlerName];
      if (typeof handler === "function") {
        return handler.call(this, node);
      } else {
        return this.genericVisit(node);
      }
    }
    genericVisit(node) {
      for (let attribute of iterChildNodes(node)) {
        this.visit(attribute);
      }
    }
  }
  visit.NodeVisitor = NodeVisitor;
  return visit;
}
var hasRequiredParents;
function requireParents() {
  if (hasRequiredParents) return parents;
  hasRequiredParents = 1;
  Object.defineProperty(parents, "__esModule", { value: true });
  parents.withParents = withParents;
  const visit_1 = requireVisit();
  function withParents(tree) {
    for (let parent of (0, visit_1.walk)(tree)) {
      for (let child of (0, visit_1.iterChildNodes)(parent)) {
        if (parent) {
          child.parent = parent;
        } else {
          child.parent = parent;
        }
      }
    }
    return tree;
  }
  return parents;
}
var tlb = {};
var hasRequiredTlb;
function requireTlb() {
  if (hasRequiredTlb) return tlb;
  hasRequiredTlb = 1;
  Object.defineProperty(tlb, "__esModule", { value: true });
  const grammar2 = String.raw`
TLB {
  // See:
  // https://github.com/andreypfau/TL-B-docs

  // Root definition
  Program = SourceElement*

  // Utilities
  // Override Ohm's built-in definition of space.
  space := whitespace | lineTerminator | comment

  whitespace =
    | "\t"
    | "\x0B"    -- verticalTab
    | "\x0C"    -- formFeed
    | " "
    | "\u00A0"  -- noBreakSpace
    | "\uFEFF"  -- byteOrderMark
    | "\u2000".."\u200B"
    | "\u3000"

  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"

  // Comments
  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
  singleLineComment = "//" (~lineTerminator sourceCharacter)*

  // Data types
  binaryDigit = "0" | "1"
  decimalDigit = "0".."9"
  hex = hexChar* "_"?
  hexChar = decimalDigit | letter

  // Identifiers
  identifier = identifierStart identifierPart*
  identifierStart = "_" | letter
  identifierPart = identifierStart | digit

  // Primitives
  number = digit+

  // Builtins
  builtins_one_arg = "#<=" | "#<" | "##"
  builtins_zero_args = "#"
  builtins_field = "#" | "Type"


  // ----------
  // Base rules
  // ----------
  SourceElement = Declaration | comment
  Declaration = Constructor Fields "=" Combinator ";"


  // Constructors
  // ~~~~~~~~~~~~
  Constructor = ConstructorStart ConstructorTag?
  ConstructorStart = "!"? ("_" | identifier)
  ConstructorTag =
  	| "$" ("_" | binaryDigit+)  -- binary
    | "#" ("_" | hex)           -- hex


  // Fields
  // ~~~~~~
  Fields = FieldDefinition*
  FieldDefinition =
    | FieldBuiltinDef
    | FieldCurlyExprDef
    | FieldAnonymousDef
    | FieldNamedDef
    | FieldExprDef

  FieldBuiltinDef = "{" identifier ":" builtins_field "}"
  FieldCurlyExprDef = "{" CurlyExpression "}"
  FieldAnonymousDef = FieldAnonRef | FieldNamedAnonRef
  FieldNamedDef = identifier ":" CondExpr
  FieldExprDef = CondExpr

  FieldAnonRef = "^"? "[" FieldDefinition* "]"
  FieldNamedAnonRef = identifier ":" FieldAnonRef


  // Combinators
  // ~~~~~~~~~~~

  Combinator = identifier SimpleExpr*


  // Expressions
  // ~~~~~~~~~~~

  // First come the complex rules we only use to define fields.
  // The line between fields definition and expressions is blury at this point.
  CurlyExpression = CompareExpr
  CondExpr =
    | CondDotAndQuestionExpr
    | CondQuestionExpr
    | CondTypeExpr

  CondDotted = TypeExpr "." number
  CondDotAndQuestionExpr = ( CondDotted | Parens<CondDotted> ) "?" TypeExpr
  CondQuestionExpr = TypeExpr "?" TypeExpr
  CondTypeExpr = TypeExpr

  // Compares:
  CompareExpr =
    | CompareOperatorExpr
    | Parens<CompareExpr>
    | MathExpr

  CompareOperatorExpr =
    | MathExpr "<=" MathExpr
    | MathExpr ">=" MathExpr
    | MathExpr "!=" MathExpr
    | MathExpr "=" MathExpr
    | MathExpr "<" MathExpr
    | MathExpr ">" MathExpr

  // Base rule for field defining expressions:
  TypeExpr =
    | CellRefExpr
    | BuiltinExpr
    | CombinatorExpr
    | SimpleExpr
    | Parens<TypeExpr>

  // Math:
  MathExpr = MulExpr ("+" MulExpr)*
  // You can multiply by constant values only: 'Bit' and numbers, basically
  MulExpr = SimpleExpr ("*" RefExpr)*

  // TypeExpr's items:
  CellRefExpr = "^" ( CellRefInner | Parens<CellRefInner> )
  CellRefInner = TypeExpr

  BuiltinExpr = BuiltinOneArg | BuiltinZeroArgs
  // This needs extra 'Parens' because of '(##)' expr:
  BuiltinOneArg = "(" ( builtins_one_arg | Parens<builtins_one_arg> ) RefExpr ")"
  BuiltinZeroArgs = builtins_zero_args

  // It is different from 'Combinator' only in the quantity part:
  // we always need at least one argument here and it can be complex.
  CombinatorExpr = "(" identifier TypeExpr+ ")"

  SimpleExpr =
    | NegateExpr
    | MathExpr
    | RefExpr
    | Parens<SimpleExpr>

  NegateExpr = "~" SimpleExpr
  RefExpr = RefInner | Parens<RefInner>
  RefInner = identifier | number


  // Helpers
  // ~~~~~~~

  // Generic rule to allow parens around some expressions:
  Parens<expr> = "(" expr ")"
}
`;
  tlb.default = grammar2;
  return tlb;
}
var parsing = {};
var locations = {};
var hasRequiredLocations;
function requireLocations() {
  if (hasRequiredLocations) return locations;
  hasRequiredLocations = 1;
  Object.defineProperty(locations, "__esModule", { value: true });
  locations.withLocations = withLocations;
  function withLocations(astNode, intermediateNode) {
    const lineAndColumn = intermediateNode.source.getLineAndColumn();
    astNode.locations = {
      line: lineAndColumn.lineNum,
      column: lineAndColumn.colNum
    };
    return astNode;
  }
  return locations;
}
var hasRequiredParsing;
function requireParsing() {
  if (hasRequiredParsing) return parsing;
  hasRequiredParsing = 1;
  var __createBinding = parsing && parsing.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o4, k22, desc);
  }) : (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o4[k22] = m2[k2];
  }));
  var __setModuleDefault = parsing && parsing.__setModuleDefault || (Object.create ? (function(o4, v2) {
    Object.defineProperty(o4, "default", { enumerable: true, value: v2 });
  }) : function(o4, v2) {
    o4["default"] = v2;
  });
  var __importStar = parsing && parsing.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o4) {
      ownKeys = Object.getOwnPropertyNames || function(o5) {
        var ar = [];
        for (var k2 in o5) if (Object.prototype.hasOwnProperty.call(o5, k2)) ar[ar.length] = k2;
        return ar;
      };
      return ownKeys(o4);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 = ownKeys(mod), i = 0; i < k2.length; i++) if (k2[i] !== "default") __createBinding(result, mod, k2[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(parsing, "__esModule", { value: true });
  parsing.exprNodes = parsing.combinatorNodes = parsing.fieldNodes = parsing.constructorNodes = parsing.rootNodes = void 0;
  const ast2 = __importStar(requireNodes());
  const locations_1 = requireLocations();
  parsing.rootNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Program(node) {
      return (0, locations_1.withLocations)(new ast2.Program(node.children.map((child) => child["root"]())), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SourceElement(node) {
      return (0, locations_1.withLocations)(new ast2.Declaration(node.child(0)["Constructor"](), node.child(1)["Field"](), node.child(3)["Combinator"]()), node);
    }
  };
  parsing.constructorNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Constructor(name, tag) {
      const nameValue = name.sourceString;
      let tagValue = null;
      if (tag.numChildren !== 0) {
        tagValue = tag.child(0)["Constructor"]();
      }
      return (0, locations_1.withLocations)(new ast2.Constructor(nameValue, tagValue), name);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ConstructorTag(node) {
      return node.sourceString;
    }
  };
  parsing.fieldNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Fields(node) {
      return node.children.map((child) => child["Field"]());
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldDefinition(node) {
      return node["Field"]();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldBuiltinDef(lpar, name, _sep, type, _rpar) {
      return (0, locations_1.withLocations)(new ast2.FieldBuiltinDef(name.sourceString, type.sourceString), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldCurlyExprDef(lpar, expr, _rpar) {
      return (0, locations_1.withLocations)(new ast2.FieldCurlyExprDef(expr["expr"]()), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldAnonymousDef(node) {
      const { name, isRef, fields } = node["Field"]();
      return (0, locations_1.withLocations)(new ast2.FieldAnonymousDef(name, isRef, fields), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldNamedDef(name, _sep, expr) {
      return (0, locations_1.withLocations)(new ast2.FieldNamedDef(name.sourceString, expr["expr"]()), name);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldExprDef(node) {
      return (0, locations_1.withLocations)(new ast2.FieldExprDef(node["expr"]()), node);
    },
    // Helpers to parse complex anonymous fields:
    // TODO: move out of this semantics
    FieldAnonRef(ref, _lpar, fields, _rpar) {
      return {
        name: null,
        isRef: ref.numChildren !== 0,
        fields: fields.children.map((field) => field["Field"]())
      };
    },
    FieldNamedAnonRef(name, _sep, fields) {
      return Object.assign(Object.assign({}, fields["Field"]()), { name: name.sourceString });
    }
  };
  parsing.combinatorNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Combinator(name, exprs) {
      return (0, locations_1.withLocations)(new ast2.Combinator(name.sourceString, exprs.children.map((typeExpr) => typeExpr["expr"]())), name);
    }
  };
  parsing.exprNodes = {
    // Math
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MathExpr(left, ops, rights) {
      return parseMath(left, ops, rights);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MulExpr(left, ops, rights) {
      return parseMath(left, ops, rights);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CompareExpr(node) {
      return node["expr"]();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CompareOperatorExpr(left, op, right) {
      return (0, locations_1.withLocations)(new ast2.CompareExpr(left["expr"](), op.sourceString, right["expr"]()), op);
    },
    // Conditional types
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondExpr(expr) {
      const { leftExpr, dotExpr, condExpr } = expr["expr"]();
      if (dotExpr === void 0 && condExpr === void 0) {
        return leftExpr;
      }
      return (0, locations_1.withLocations)(new ast2.CondExpr(leftExpr, dotExpr, condExpr), expr);
    },
    // TODO: move out of this semantics
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondDotAndQuestionExpr(dotNode, _sep, condNode) {
      return Object.assign(Object.assign({}, dotNode["expr"]()), { condExpr: condNode["expr"]() });
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondQuestionExpr(left, _sep, condNode) {
      return {
        leftExpr: left["expr"](),
        dotExpr: null,
        condExpr: condNode["expr"]()
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondTypeExpr(node) {
      return {
        leftExpr: node["expr"]()
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondDotted(left, _sep, number) {
      return {
        leftExpr: left["expr"](),
        dotExpr: new Number(number.sourceString)
      };
    },
    // TypeExpr
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CombinatorExpr(lpar, name, args, _rpar) {
      return (0, locations_1.withLocations)(new ast2.CombinatorExpr(name.sourceString, args.children.map((arg) => arg["expr"]())), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CellRefExpr(ref, node) {
      return (0, locations_1.withLocations)(new ast2.CellRefExpr(node["expr"]()), ref);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinExpr(node) {
      return (0, locations_1.withLocations)(node["expr"](), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NegateExpr(op, node) {
      return (0, locations_1.withLocations)(new ast2.NegateExpr(node["expr"]()), op);
    },
    // Builtins
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinOneArg(lpar, expr, arg, _rpar) {
      return (0, locations_1.withLocations)(new ast2.BuiltinOneArgExpr(expr.sourceString, arg["expr"]()), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinZeroArgs(expr) {
      return (0, locations_1.withLocations)(new ast2.BuiltinZeroArgs(expr.sourceString), expr);
    },
    // Base rules
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    identifier(start, rest) {
      return (0, locations_1.withLocations)(new ast2.NameExpr(start.sourceString + rest.sourceString), start);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    number(node) {
      return (0, locations_1.withLocations)(new ast2.NumberExpr(parseInt(node.sourceString)), node);
    },
    // Helpers
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Parens(lpar, node, _rpar) {
      return (0, locations_1.withLocations)(node["expr"](), lpar);
    }
  };
  function parseMath(left, ops, rights) {
    const leftExpr = left["expr"]();
    const opsSigns = [];
    for (let child of ops.children) {
      opsSigns.push(child.sourceString);
    }
    const rightExprs = [];
    for (let child of rights.children) {
      const rightExpr = child["expr"]();
      if (rightExpr !== void 0) {
        rightExprs.push(rightExpr);
      }
    }
    if (opsSigns.length !== rightExprs.length) {
      throw new Error("Invalid math operation");
    }
    if (opsSigns.length === 0) {
      return (0, locations_1.withLocations)(leftExpr, left);
    }
    let expr = (0, locations_1.withLocations)(new ast2.MathExpr(leftExpr, opsSigns[0], rightExprs[0]), left);
    for (let index2 = 1; index2 < opsSigns.length; index2++) {
      expr = (0, locations_1.withLocations)(new ast2.MathExpr(
        expr,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        opsSigns[index2],
        // validated earlier
        rightExprs[index2]
      ), left);
    }
    return expr;
  }
  return parsing;
}
var hasRequiredIntermediate;
function requireIntermediate() {
  if (hasRequiredIntermediate) return intermediate;
  hasRequiredIntermediate = 1;
  var __importDefault = intermediate && intermediate.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(intermediate, "__esModule", { value: true });
  intermediate.buildGrammar = buildGrammar2;
  intermediate.buildAST = buildAST;
  const ohm_js_1 = __importDefault(require$$0);
  const parents_1 = requireParents();
  const tlb_1 = __importDefault(requireTlb());
  const parsing_1 = requireParsing();
  function buildGrammar2() {
    return ohm_js_1.default.grammar(tlb_1.default);
  }
  function buildAST(input, grammar2) {
    const semantics = grammar2.createSemantics();
    semantics.addOperation("root", parsing_1.rootNodes);
    semantics.addOperation("Constructor", parsing_1.constructorNodes);
    semantics.addOperation("Field", parsing_1.fieldNodes);
    semantics.addOperation("Combinator", parsing_1.combinatorNodes);
    semantics.addOperation("expr", parsing_1.exprNodes);
    const matchResult = grammar2.match(input);
    const ast2 = semantics(matchResult)["root"]();
    return (0, parents_1.withParents)(ast2);
  }
  return intermediate;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist;
  hasRequiredDist$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathOperator = exports.BuiltinZeroArgsOperators = exports.BuiltinOneArgOperators = exports.CompareOperator = exports.FieldBuiltinType = exports.NumberExpr = exports.NameExpr = exports.RefExpr = exports.NegateExpr = exports.MathExpr = exports.CombinatorExpr = exports.BuiltinZeroArgs = exports.BuiltinOneArgExpr = exports.BuiltinExpr = exports.CellRefExpr = exports.CompareExpr = exports.CondExpr = exports.Expression = exports.Combinator = exports.FieldExprDef = exports.FieldNamedDef = exports.FieldAnonymousDef = exports.FieldCurlyExprDef = exports.FieldBuiltinDef = exports.Field = exports.Constructor = exports.Declaration = exports.Program = exports.ASTBase = exports.ASTRootBase = exports.NodeVisitor = void 0;
    exports.parse = parse;
    exports.ast = ast2;
    const intermediate_1 = requireIntermediate();
    function parse(input, grammar2 = void 0) {
      if (grammar2 === void 0) {
        grammar2 = (0, intermediate_1.buildGrammar)();
      }
      return grammar2.match(input);
    }
    function ast2(input) {
      return (0, intermediate_1.buildAST)(input, (0, intermediate_1.buildGrammar)());
    }
    var visit_1 = requireVisit();
    Object.defineProperty(exports, "NodeVisitor", { enumerable: true, get: function() {
      return visit_1.NodeVisitor;
    } });
    var nodes_1 = requireNodes();
    Object.defineProperty(exports, "ASTRootBase", { enumerable: true, get: function() {
      return nodes_1.ASTRootBase;
    } });
    Object.defineProperty(exports, "ASTBase", { enumerable: true, get: function() {
      return nodes_1.ASTBase;
    } });
    Object.defineProperty(exports, "Program", { enumerable: true, get: function() {
      return nodes_1.Program;
    } });
    Object.defineProperty(exports, "Declaration", { enumerable: true, get: function() {
      return nodes_1.Declaration;
    } });
    Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
      return nodes_1.Constructor;
    } });
    Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
      return nodes_1.Field;
    } });
    Object.defineProperty(exports, "FieldBuiltinDef", { enumerable: true, get: function() {
      return nodes_1.FieldBuiltinDef;
    } });
    Object.defineProperty(exports, "FieldCurlyExprDef", { enumerable: true, get: function() {
      return nodes_1.FieldCurlyExprDef;
    } });
    Object.defineProperty(exports, "FieldAnonymousDef", { enumerable: true, get: function() {
      return nodes_1.FieldAnonymousDef;
    } });
    Object.defineProperty(exports, "FieldNamedDef", { enumerable: true, get: function() {
      return nodes_1.FieldNamedDef;
    } });
    Object.defineProperty(exports, "FieldExprDef", { enumerable: true, get: function() {
      return nodes_1.FieldExprDef;
    } });
    Object.defineProperty(exports, "Combinator", { enumerable: true, get: function() {
      return nodes_1.Combinator;
    } });
    Object.defineProperty(exports, "Expression", { enumerable: true, get: function() {
      return nodes_1.Expression;
    } });
    Object.defineProperty(exports, "CondExpr", { enumerable: true, get: function() {
      return nodes_1.CondExpr;
    } });
    Object.defineProperty(exports, "CompareExpr", { enumerable: true, get: function() {
      return nodes_1.CompareExpr;
    } });
    Object.defineProperty(exports, "CellRefExpr", { enumerable: true, get: function() {
      return nodes_1.CellRefExpr;
    } });
    Object.defineProperty(exports, "BuiltinExpr", { enumerable: true, get: function() {
      return nodes_1.BuiltinExpr;
    } });
    Object.defineProperty(exports, "BuiltinOneArgExpr", { enumerable: true, get: function() {
      return nodes_1.BuiltinOneArgExpr;
    } });
    Object.defineProperty(exports, "BuiltinZeroArgs", { enumerable: true, get: function() {
      return nodes_1.BuiltinZeroArgs;
    } });
    Object.defineProperty(exports, "CombinatorExpr", { enumerable: true, get: function() {
      return nodes_1.CombinatorExpr;
    } });
    Object.defineProperty(exports, "MathExpr", { enumerable: true, get: function() {
      return nodes_1.MathExpr;
    } });
    Object.defineProperty(exports, "NegateExpr", { enumerable: true, get: function() {
      return nodes_1.NegateExpr;
    } });
    Object.defineProperty(exports, "RefExpr", { enumerable: true, get: function() {
      return nodes_1.RefExpr;
    } });
    Object.defineProperty(exports, "NameExpr", { enumerable: true, get: function() {
      return nodes_1.NameExpr;
    } });
    Object.defineProperty(exports, "NumberExpr", { enumerable: true, get: function() {
      return nodes_1.NumberExpr;
    } });
    Object.defineProperty(exports, "FieldBuiltinType", { enumerable: true, get: function() {
      return nodes_1.FieldBuiltinType;
    } });
    Object.defineProperty(exports, "CompareOperator", { enumerable: true, get: function() {
      return nodes_1.CompareOperator;
    } });
    Object.defineProperty(exports, "BuiltinOneArgOperators", { enumerable: true, get: function() {
      return nodes_1.BuiltinOneArgOperators;
    } });
    Object.defineProperty(exports, "BuiltinZeroArgsOperators", { enumerable: true, get: function() {
      return nodes_1.BuiltinZeroArgsOperators;
    } });
    Object.defineProperty(exports, "MathOperator", { enumerable: true, get: function() {
      return nodes_1.MathOperator;
    } });
  })(dist);
  return dist;
}
var fill_constructors = {};
var utils$2 = {};
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  Object.defineProperty(utils$2, "__esModule", { value: true });
  utils$2.crc32 = utils$2.getSubStructName = utils$2.findNotReservedName = utils$2.isNameReserved = utils$2.bitLen = utils$2.getCurrentSlice = utils$2.firstLower = void 0;
  function firstLower(structName) {
    return structName.charAt(0).toLowerCase() + structName.slice(1);
  }
  utils$2.firstLower = firstLower;
  function getCurrentSlice(slicePrefix, name) {
    let result = name;
    slicePrefix = slicePrefix.slice(0, slicePrefix.length - 1);
    slicePrefix.forEach((element) => {
      result += element.toString();
    });
    if (result == "cell") {
      return "builder";
    }
    return result;
  }
  utils$2.getCurrentSlice = getCurrentSlice;
  function bitLen(n) {
    return n.toString(2).length;
  }
  utils$2.bitLen = bitLen;
  function isNameReserved(name) {
    let tsReserved = [
      "abstract",
      "arguments",
      "await",
      "boolean",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "double",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "final",
      "finally",
      "float",
      "for",
      "function",
      "goto",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "int",
      "interface",
      "let",
      "long",
      "native",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "short",
      "static",
      "super",
      "switch",
      "synchronized",
      "this",
      "throw",
      "throws",
      "transient",
      "true",
      "try",
      "typeof",
      "var",
      "void",
      "volatile",
      "while",
      "with",
      "yield"
    ];
    if (tsReserved.includes(name)) {
      return true;
    }
    if (name.startsWith("slice")) {
      return true;
    }
    if (name.startsWith("cell")) {
      return true;
    }
    if (name == "builder") {
      return true;
    }
    return false;
  }
  utils$2.isNameReserved = isNameReserved;
  function findNotReservedName(name, possibleSuffix = "0") {
    if (name.startsWith("slice") || name.startsWith("cell")) {
      name = "_" + name;
    }
    while (isNameReserved(name)) {
      name += possibleSuffix;
    }
    return name;
  }
  utils$2.findNotReservedName = findNotReservedName;
  function getSubStructName(tlbType, constructor) {
    if (tlbType.constructors.length > 1) {
      return tlbType.name + "_" + constructor.name;
    } else {
      return tlbType.name;
    }
  }
  utils$2.getSubStructName = getSubStructName;
  const POLYNOMIAL = -306674912;
  function crc32(bytes, crc = 4294967295) {
    let result = crc;
    for (let n = 0; n < bytes.length; n++) {
      result ^= bytes[n];
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
    }
    return (result ^ -1) >>> 0;
  }
  utils$2.crc32 = crc32;
  return utils$2;
}
var handle_field = {};
var handle_type = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.convertToMathExpr = utils$1.getNegatedVariable = utils$1.reorganizeExpression = utils$1.getVariableName = utils$1.deriveMathExpression = utils$1.splitForTypeValue = utils$1.getCalculatedExpression = utils$1.calculateVariable = utils$1.opCodeSetsEqual = void 0;
  const tlb_parser_1 = requireDist$1();
  const ast_1 = requireAst();
  function opCodeSetsEqual(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2 == null || b2 == null)
      return false;
    if (a2.length !== b2.length)
      return false;
    a2 = a2.sort();
    b2 = b2.sort();
    for (var i = 0; i < a2.length; ++i) {
      if (a2[i] !== b2[i])
        return false;
    }
    return true;
  }
  utils$1.opCodeSetsEqual = opCodeSetsEqual;
  function calculateVariable(variable, constructor) {
    if (variable.calculated) {
      return;
    }
    if (!variable.deriveExpr) {
      return;
    }
    variable.calculated = true;
    variable.deriveExpr = getCalculatedExpression(variable.deriveExpr, constructor);
  }
  utils$1.calculateVariable = calculateVariable;
  function getCalculatedExpression(expr, constructor) {
    if (expr instanceof ast_1.TLBVarExpr) {
      let variable = constructor.variablesMap.get(expr.x);
      if (variable) {
        calculateVariable(variable, constructor);
        if (variable.deriveExpr) {
          return variable.deriveExpr;
        }
      }
    }
    if (expr instanceof ast_1.TLBBinaryOp) {
      let left = getCalculatedExpression(expr.left, constructor);
      let right = getCalculatedExpression(expr.right, constructor);
      return new ast_1.TLBBinaryOp(left, right, expr.operation, expr.variables, expr.hasNeg);
    }
    return expr;
  }
  utils$1.getCalculatedExpression = getCalculatedExpression;
  function splitForTypeValue(name, typeName) {
    if (!name.startsWith(typeName)) {
      return void 0;
    }
    let num = parseInt(name.slice(typeName.length));
    if (num == void 0) {
      return void 0;
    }
    if (name != typeName + num.toString()) {
      return void 0;
    }
    return num;
  }
  utils$1.splitForTypeValue = splitForTypeValue;
  function deriveMathExpression(mathExpr) {
    let myMathExpr = convertToMathExpr(mathExpr);
    return {
      name: getVariableName(myMathExpr),
      derived: myMathExpr
    };
  }
  utils$1.deriveMathExpression = deriveMathExpression;
  function getVariableName(myMathExpr) {
    if (myMathExpr instanceof ast_1.TLBVarExpr) {
      return myMathExpr.x;
    }
    if (myMathExpr instanceof ast_1.TLBBinaryOp) {
      if (myMathExpr.left.variables.size) {
        return getVariableName(myMathExpr.left);
      } else {
        return getVariableName(myMathExpr.right);
      }
    }
    return void 0;
  }
  utils$1.getVariableName = getVariableName;
  function reorganizeExpression(mathExpr, variable) {
    if (mathExpr instanceof ast_1.TLBBinaryOp && mathExpr.operation == "=") {
      if (mathExpr.left.variables.has(variable)) {
        mathExpr = new ast_1.TLBBinaryOp(mathExpr.right, mathExpr.left, "=", mathExpr.variables, mathExpr.hasNeg);
      }
      if (mathExpr.right instanceof ast_1.TLBVarExpr) {
        return new ast_1.TLBBinaryOp(mathExpr.right, mathExpr.left, "=", mathExpr.variables, mathExpr.hasNeg);
      }
      let rightSide = mathExpr.right;
      if (rightSide instanceof ast_1.TLBBinaryOp) {
        let op = "";
        if (rightSide.operation == "*") {
          op = "/";
        } else if (rightSide.operation == "+") {
          op = "-";
        } else {
          throw new Error("invalid operation");
        }
        let withVariable = void 0;
        let other = void 0;
        if (rightSide.left.variables.has(variable)) {
          withVariable = rightSide.left;
          other = rightSide.right;
        } else {
          other = rightSide.left;
          withVariable = rightSide.right;
        }
        let leftSide = new ast_1.TLBBinaryOp(mathExpr.left, other, op);
        mathExpr = new ast_1.TLBBinaryOp(leftSide, withVariable, "=", /* @__PURE__ */ new Set([...leftSide.variables, ...withVariable.variables]), leftSide.hasNeg || rightSide.hasNeg);
        return reorganizeExpression(mathExpr, variable);
      }
    }
    throw new Error(`Couldn't reogranize expression: ${mathExpr}`);
  }
  utils$1.reorganizeExpression = reorganizeExpression;
  function getNegatedVariable(mathExpr) {
    if (mathExpr.hasNeg) {
      if (mathExpr instanceof ast_1.TLBBinaryOp) {
        if (mathExpr.left.hasNeg) {
          return getNegatedVariable(mathExpr.left);
        }
        if (mathExpr.right.hasNeg) {
          return getNegatedVariable(mathExpr.right);
        }
      }
      if (mathExpr instanceof ast_1.TLBVarExpr) {
        return mathExpr.x;
      }
    }
    return void 0;
  }
  utils$1.getNegatedVariable = getNegatedVariable;
  function convertToMathExpr(mathExpr, negated = false) {
    if (mathExpr instanceof tlb_parser_1.NameExpr) {
      let variables = /* @__PURE__ */ new Set();
      variables.add(mathExpr.name);
      return new ast_1.TLBVarExpr(mathExpr.name, variables, negated);
    }
    if (mathExpr instanceof tlb_parser_1.NumberExpr) {
      return new ast_1.TLBNumberExpr(mathExpr.num, /* @__PURE__ */ new Set(), false);
    }
    if (mathExpr instanceof tlb_parser_1.MathExpr) {
      let left = convertToMathExpr(mathExpr.left, negated);
      let right = convertToMathExpr(mathExpr.right, negated);
      return new ast_1.TLBBinaryOp(left, right, mathExpr.op);
    }
    if (mathExpr instanceof tlb_parser_1.CompareExpr) {
      let left = convertToMathExpr(mathExpr.left, negated);
      let right = convertToMathExpr(mathExpr.right, negated);
      let operation = mathExpr.op;
      return new ast_1.TLBBinaryOp(left, right, operation);
    }
    if (mathExpr instanceof tlb_parser_1.NegateExpr) {
      if (mathExpr.expr instanceof tlb_parser_1.MathExpr || mathExpr.expr instanceof tlb_parser_1.NameExpr || mathExpr.expr instanceof tlb_parser_1.NumberExpr) {
        let expression = convertToMathExpr(mathExpr.expr, true);
        if (expression instanceof ast_1.TLBBinaryOp) {
          return new ast_1.TLBBinaryOp(expression.left, expression.right, expression.operation, expression.variables, true);
        }
        if (expression instanceof ast_1.TLBVarExpr) {
          return new ast_1.TLBVarExpr(expression.x, expression.variables, true);
        }
        if (expression instanceof ast_1.TLBNumberExpr) {
          return new ast_1.TLBNumberExpr(expression.n, expression.variables, true);
        }
      }
    }
    throw new Error(`Could not convert expression: ${mathExpr}`);
  }
  utils$1.convertToMathExpr = convertToMathExpr;
  return utils$1;
}
var hasRequiredHandle_type;
function requireHandle_type() {
  if (hasRequiredHandle_type) return handle_type;
  hasRequiredHandle_type = 1;
  Object.defineProperty(handle_type, "__esModule", { value: true });
  handle_type.getType = void 0;
  const tlb_parser_1 = requireDist$1();
  const ast_1 = requireAst();
  const utils_1 = requireUtils$1();
  function getType(expr, constructor, fieldTypeName) {
    var _a2;
    if (expr instanceof tlb_parser_1.BuiltinZeroArgs) {
      if (expr.name == "#") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(32),
          storeBits: new ast_1.TLBNumberExpr(32),
          signed: false,
          maxBits: 32
        };
      } else {
        throw new Error("Expression not supported" + expr);
      }
    } else if (expr instanceof tlb_parser_1.BuiltinOneArgExpr) {
      if (expr.name.toString() == "##" || expr.name.toString() == "(##)") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr) {
          return {
            kind: "TLBNumberType",
            bits: new ast_1.TLBNumberExpr(expr.arg.num),
            storeBits: new ast_1.TLBNumberExpr(expr.arg.num),
            signed: false,
            maxBits: expr.arg.num
          };
        }
        if (expr.arg instanceof tlb_parser_1.NameExpr) {
          let parameter = constructor.parametersMap.get(expr.arg.name);
          if (!parameter || !parameter.variable.deriveExpr || !parameter.variable.initialExpr) {
            throw new Error(`Couldn't handle expression ${expr}`);
          }
          return {
            kind: "TLBNumberType",
            bits: (0, utils_1.getCalculatedExpression)(parameter.variable.deriveExpr, constructor),
            storeBits: parameter.variable.initialExpr,
            signed: false,
            maxBits: void 0
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else if (expr.name == "#<") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr || expr.arg instanceof tlb_parser_1.NameExpr) {
          let bits = new ast_1.TLBUnaryOp(new ast_1.TLBBinaryOp((0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.arg), constructor), new ast_1.TLBNumberExpr(1), "-"), ".");
          return {
            kind: "TLBNumberType",
            bits,
            storeBits: bits,
            signed: false,
            maxBits: 32
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else if (expr.name == "#<=") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr || expr.arg instanceof tlb_parser_1.NameExpr) {
          let bits = new ast_1.TLBUnaryOp((0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.arg), constructor), ".");
          return {
            kind: "TLBNumberType",
            bits,
            storeBits: bits,
            signed: false,
            maxBits: 32
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      }
    } else if (expr instanceof tlb_parser_1.CombinatorExpr) {
      if (expr.name == "int" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBNumberType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor),
          storeBits: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: true,
          maxBits: void 0
        };
      } else if (expr.name == "uint" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBNumberType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor),
          storeBits: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: false,
          maxBits: void 0
        };
      } else if (expr.name == "bits" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBBitsType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor)
        };
      } else if (expr.name == "HashmapE") {
        if (expr.args.length != 2) {
          throw new Error("");
        }
        let key = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        if (key.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key, value, directStore: false };
      } else if (expr.name == "HashmapAugE") {
        if (expr.args.length != 3) {
          throw new Error("Not enough arguments for HashmapAugE");
        }
        let key = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        let extra = getType(expr.args[2], constructor, fieldTypeName);
        if (key.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key, value, extra, directStore: false };
      } else if (expr.name == "Hashmap" && constructor.tlbType != "HashmapNode") {
        let key = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        if (key.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key, value, directStore: true };
      } else if (expr.name == "VarUInteger" && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBVarIntegerType",
          n: new ast_1.TLBUnaryOp(new ast_1.TLBBinaryOp((0, utils_1.convertToMathExpr)(expr.args[0]), new ast_1.TLBNumberExpr(1), "-"), "."),
          signed: false
        };
      } else if (expr.name == "VarInteger" && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBVarIntegerType",
          n: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: true
        };
      } else {
        let argumentTypes = [];
        expr.args.forEach((arg) => {
          let thefield = getType(arg, constructor, fieldTypeName);
          argumentTypes.push(thefield);
        });
        return {
          kind: "TLBNamedType",
          name: expr.name,
          arguments: argumentTypes
        };
      }
    } else if (expr instanceof tlb_parser_1.NameExpr) {
      let theNum;
      if (expr.name == "Int") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(257),
          storeBits: new ast_1.TLBNumberExpr(257),
          signed: true,
          maxBits: 257
        };
      } else if (expr.name == "VmStack") {
        return {
          kind: "TLBTupleType"
        };
      } else if (expr.name == "Bits") {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(1023) };
      } else if (expr.name == "Bit") {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(1) };
      } else if (expr.name == "Uint") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(257),
          storeBits: new ast_1.TLBNumberExpr(257),
          signed: false,
          maxBits: 257
        };
      } else if (expr.name == "Any" || expr.name == "Cell") {
        return { kind: "TLBCellType" };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "int")) != void 0) {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(theNum),
          storeBits: new ast_1.TLBNumberExpr(theNum),
          signed: true,
          maxBits: theNum
        };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "uint")) != void 0) {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(theNum),
          storeBits: new ast_1.TLBNumberExpr(theNum),
          signed: false,
          maxBits: theNum
        };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "bits")) != void 0) {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(theNum) };
      } else if (expr.name == "MsgAddressInt") {
        return { kind: "TLBAddressType", addrType: "Internal" };
      } else if (expr.name == "MsgAddressExt") {
        return { kind: "TLBAddressType", addrType: "External" };
      } else if (expr.name == "MsgAddress") {
        return { kind: "TLBAddressType", addrType: "Any" };
      } else if (expr.name == "Grams" || expr.name == "Coins") {
        return { kind: "TLBCoinsType" };
      } else if (expr.name == "Bool") {
        return { kind: "TLBBoolType", value: void 0 };
      } else if (expr.name == "BoolFalse") {
        return { kind: "TLBBoolType", value: false };
      } else if (expr.name == "BoolTrue") {
        return { kind: "TLBBoolType", value: true };
      } else {
        if (((_a2 = constructor.variablesMap.get(expr.name)) === null || _a2 === void 0 ? void 0 : _a2.type) == "#") {
          return {
            kind: "TLBExprMathType",
            expr: (0, utils_1.getCalculatedExpression)(new ast_1.TLBVarExpr(expr.name), constructor),
            initialExpr: new ast_1.TLBVarExpr(expr.name)
          };
        } else {
          return { kind: "TLBNamedType", name: expr.name, arguments: [] };
        }
      }
    } else if (expr instanceof tlb_parser_1.NumberExpr) {
      return { kind: "TLBExprMathType", expr: new ast_1.TLBNumberExpr(expr.num), initialExpr: new ast_1.TLBNumberExpr(expr.num) };
    } else if (expr instanceof tlb_parser_1.NegateExpr && expr.expr instanceof tlb_parser_1.NameExpr) {
      return { kind: "TLBNegatedType", variableName: expr.expr.name };
    } else if (expr instanceof tlb_parser_1.CellRefExpr) {
      let subExprInfo = getType(expr.expr, constructor, fieldTypeName);
      return { kind: "TLBCellInsideType", value: subExprInfo };
    } else if (expr instanceof tlb_parser_1.MathExpr) {
      if (fieldTypeName == "") {
        if (expr.op == "*") {
          let subExprInfo = getType(expr.right, constructor, fieldTypeName);
          return {
            kind: "TLBMultipleType",
            times: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.left), constructor),
            value: subExprInfo
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else {
        return {
          kind: "TLBExprMathType",
          expr: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr), constructor),
          initialExpr: (0, utils_1.convertToMathExpr)(expr)
        };
      }
    } else if (expr instanceof tlb_parser_1.CondExpr) {
      let subExprInfo = getType(expr.condExpr, constructor, fieldTypeName);
      if (expr.left instanceof tlb_parser_1.NameExpr) {
        let condition = (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.left), constructor);
        if (expr.dotExpr != null) {
          condition = new ast_1.TLBBinaryOp(condition, new ast_1.TLBBinaryOp(new ast_1.TLBNumberExpr(1), new ast_1.TLBNumberExpr(expr.dotExpr), "<<"), "&");
        }
        return { kind: "TLBCondType", value: subExprInfo, condition };
      }
    } else {
      throw new Error(`Couldn't handle expression ${expr}`);
    }
    throw new Error(`Couldn't handle expression ${expr}`);
  }
  handle_type.getType = getType;
  return handle_type;
}
var hasRequiredHandle_field;
function requireHandle_field() {
  if (hasRequiredHandle_field) return handle_field;
  hasRequiredHandle_field = 1;
  Object.defineProperty(handle_field, "__esModule", { value: true });
  handle_field.fillFields = void 0;
  const tlb_parser_1 = requireDist$1();
  const handle_type_1 = requireHandle_type();
  function getField(field, constructor, fieldIndex) {
    if (field instanceof tlb_parser_1.FieldAnonymousDef) {
      let result = {
        name: "",
        anonymous: true,
        fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
        subFields: []
      };
      let currentFieldIndex = 0;
      field.fields.forEach((field2) => {
        let subField = getField(field2, constructor, fieldIndex + "_" + currentFieldIndex.toString());
        if (subField) {
          result.subFields.push(subField);
        }
        currentFieldIndex++;
      });
      return result;
    }
    if (field instanceof tlb_parser_1.FieldNamedDef || field instanceof tlb_parser_1.FieldExprDef) {
      let fieldName;
      if (field instanceof tlb_parser_1.FieldNamedDef) {
        fieldName = field.name;
      } else {
        fieldName = "anon" + fieldIndex;
      }
      if (field instanceof tlb_parser_1.FieldExprDef && field.expr instanceof tlb_parser_1.NameExpr && field.expr.name == "_") {
        return void 0;
      }
      if (field.expr instanceof tlb_parser_1.CellRefExpr) {
        if (field.expr.expr instanceof tlb_parser_1.CombinatorExpr && (field.expr.expr.name == "MERKLE_UPDATE" || field.expr.expr.name == "MERKLE_ROOT")) {
          return {
            name: fieldName,
            anonymous: true,
            fieldType: { kind: "TLBExoticType" },
            subFields: []
          };
        } else {
          let subField = getField(new tlb_parser_1.FieldNamedDef(fieldName, field.expr.expr), constructor, fieldIndex + "_0");
          if (subField) {
            let result = {
              name: fieldName,
              anonymous: true,
              fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
              subFields: [subField]
            };
            return result;
          }
          return subField;
        }
      }
      if (field.expr instanceof tlb_parser_1.CombinatorExpr || field.expr instanceof tlb_parser_1.NameExpr || field.expr instanceof tlb_parser_1.BuiltinZeroArgs || field.expr instanceof tlb_parser_1.BuiltinOneArgExpr || field.expr instanceof tlb_parser_1.MathExpr || field.expr instanceof tlb_parser_1.CondExpr) {
        let fieldTypeName;
        if (field.expr instanceof tlb_parser_1.MathExpr || field.expr instanceof tlb_parser_1.CondExpr) {
          fieldTypeName = "";
        } else {
          fieldTypeName = field.expr.name;
        }
        let fieldInfo = (0, handle_type_1.getType)(field.expr, constructor, fieldTypeName);
        return {
          name: fieldName,
          anonymous: !(field instanceof tlb_parser_1.FieldNamedDef),
          fieldType: fieldInfo,
          subFields: []
        };
      }
    }
    return void 0;
  }
  function fillFields(typeItem, _tlbType) {
    let constructor = typeItem.constructor;
    let declaration = typeItem.declaration;
    let fieldIndex = -1;
    declaration.fields.forEach((fieldDecl) => {
      fieldIndex++;
      let field = getField(fieldDecl, constructor, fieldIndex.toString());
      if (field != void 0) {
        constructor.fields.push(field);
      }
    });
  }
  handle_field.fillFields = fillFields;
  return handle_field;
}
var hasRequiredFill_constructors;
function requireFill_constructors() {
  if (hasRequiredFill_constructors) return fill_constructors;
  hasRequiredFill_constructors = 1;
  Object.defineProperty(fill_constructors, "__esModule", { value: true });
  fill_constructors.convertCodeToReadonly = fill_constructors.fillConstructors = void 0;
  const tlb_parser_1 = requireDist$1();
  const ast_1 = requireAst();
  const utils_1 = requireUtils$2();
  const handle_field_1 = requireHandle_field();
  const utils_2 = requireUtils$1();
  function fillConstructors(declarations, tlbCode, input) {
    let typeDeclarations = /* @__PURE__ */ new Map();
    declarations.forEach((declaration) => {
      let tlbType = tlbCode.types.get(declaration.combinator.name);
      if (tlbType == void 0) {
        tlbType = { name: declaration.combinator.name, constructors: [] };
      }
      let constructor = {
        parameters: [],
        parametersMap: /* @__PURE__ */ new Map(),
        name: declaration.constructorDef.name,
        variables: new Array(),
        variablesMap: /* @__PURE__ */ new Map(),
        tag: getConstructorTag(declaration),
        constraints: [],
        fields: [],
        declaration: "",
        tlbType: tlbType.name
      };
      tlbType.constructors.push(constructor);
      tlbCode.types.set(tlbType.name, tlbType);
      let currentDecls = typeDeclarations.get(tlbType.name);
      if (!currentDecls) {
        currentDecls = [];
      }
      currentDecls.push({ declaration, constructor });
      typeDeclarations.set(tlbType.name, currentDecls);
    });
    tlbCode.types.forEach((tlbType) => {
      var _a2;
      (_a2 = typeDeclarations.get(tlbType.name)) === null || _a2 === void 0 ? void 0 : _a2.forEach((typeItem) => {
        let declaration = typeItem.declaration;
        let constructor = typeItem.constructor;
        declaration.fields.forEach((field) => {
          if (field instanceof tlb_parser_1.FieldBuiltinDef) {
            constructor.variables.push({
              name: field.name,
              isConst: false,
              negated: false,
              type: field.type,
              calculated: false,
              isField: false
            });
          }
          if (field instanceof tlb_parser_1.FieldNamedDef) {
            constructor.variables.push({
              name: field.name,
              isConst: false,
              negated: false,
              type: "#",
              calculated: false,
              isField: true
            });
          }
        });
        constructor.variables.forEach((variable) => {
          if (variable.name) {
            constructor.variablesMap.set(variable.name, variable);
          }
        });
        let argumentIndex = -1;
        declaration.combinator.args.forEach((element) => {
          argumentIndex++;
          let parameter = void 0;
          if (element instanceof tlb_parser_1.NameExpr) {
            let variable = constructor.variablesMap.get(element.name);
            if (variable) {
              if (variable.type == "#") {
                variable.deriveExpr = new ast_1.TLBVarExpr(element.name);
                variable.initialExpr = variable.deriveExpr;
              }
              parameter = {
                variable,
                paramExpr: new ast_1.TLBVarExpr(element.name)
              };
            } else {
              throw new Error("Field not known before using (should be tagged as implicit): " + element);
            }
          } else if (element instanceof tlb_parser_1.MathExpr) {
            let derivedExpr = (0, utils_2.deriveMathExpression)(element);
            if (!derivedExpr.name) {
              throw new Error(`Expression should contain variable ${element}`);
            }
            let variable = constructor.variablesMap.get(derivedExpr.name);
            if (variable && variable.name) {
              parameter = { variable, paramExpr: derivedExpr.derived };
              parameter.argName = "arg" + argumentIndex;
              parameter.variable.deriveExpr = reorganizeWithArg((0, utils_2.convertToMathExpr)(element), parameter.argName, variable.name);
              parameter.variable.initialExpr = new ast_1.TLBVarExpr(variable.name);
            } else {
              throw new Error(`Variable should have name ${variable}`);
            }
          } else if (element instanceof tlb_parser_1.NegateExpr && (element.expr instanceof tlb_parser_1.MathExpr || element.expr instanceof tlb_parser_1.NumberExpr || element.expr instanceof tlb_parser_1.NameExpr)) {
            let derivedExpr = (0, utils_2.deriveMathExpression)(element.expr);
            let toBeConst = false;
            if (element.expr instanceof tlb_parser_1.NumberExpr) {
              toBeConst = true;
            }
            if (derivedExpr.name == void 0) {
              if (toBeConst) {
                parameter = {
                  variable: {
                    negated: true,
                    isConst: toBeConst,
                    type: "#",
                    name: void 0,
                    deriveExpr: derivedExpr.derived,
                    initialExpr: derivedExpr.derived,
                    calculated: false,
                    isField: false
                  },
                  paramExpr: derivedExpr.derived
                };
              } else {
                throw new Error("Cannot identify combinator arg " + element);
              }
            } else {
              let variable = constructor.variablesMap.get(derivedExpr.name);
              if (variable) {
                variable.negated = true;
                variable.isConst = toBeConst;
                variable.initialExpr = derivedExpr.derived;
                parameter = {
                  variable,
                  paramExpr: derivedExpr.derived
                };
              } else {
                throw new Error("Cannot identify combinator arg " + element);
              }
            }
          } else if (element instanceof tlb_parser_1.NumberExpr) {
            parameter = {
              variable: {
                negated: false,
                isConst: true,
                type: "#",
                name: void 0,
                deriveExpr: new ast_1.TLBNumberExpr(element.num),
                initialExpr: new ast_1.TLBNumberExpr(element.num),
                calculated: false,
                isField: false
              },
              paramExpr: new ast_1.TLBNumberExpr(element.num)
            };
          } else {
            throw new Error("Cannot identify combinator arg: " + element);
          }
          constructor.parameters.push(parameter);
          if (parameter.variable.name != void 0) {
            constructor.parametersMap.set(parameter.variable.name, parameter);
          }
        });
        constructor.declaration = getStringDeclaration(declaration, input);
        fillConstraintsAndNegationVars(constructor, declaration);
        (0, handle_field_1.fillFields)(typeItem, tlbType);
        calculateVariables(constructor);
      });
      fillParameterNames(tlbType);
      fillArgNames(tlbType);
      findConstructorsNaming(tlbType);
      tlbType.constructors.sort(compareConstructors);
    });
    checkAndRemovePrimitives(tlbCode, input, typeDeclarations);
    findAvailableVarNamesForCode(tlbCode);
  }
  fill_constructors.fillConstructors = fillConstructors;
  function fillConstraintsAndNegationVars(constructor, declaration) {
    declaration.fields.forEach((field) => {
      if (field instanceof tlb_parser_1.FieldCurlyExprDef && field.expr instanceof tlb_parser_1.CompareExpr) {
        if (field.expr.op == "=") {
          let myMathExpr = (0, utils_2.convertToMathExpr)(field.expr);
          let negatedVariable = (0, utils_2.getNegatedVariable)(myMathExpr);
          if (negatedVariable) {
            myMathExpr = (0, utils_2.reorganizeExpression)(myMathExpr, negatedVariable);
            if (myMathExpr instanceof ast_1.TLBBinaryOp) {
              myMathExpr = myMathExpr.right;
            }
            let variable = constructor.variablesMap.get(negatedVariable);
            if (variable) {
              variable.negated = true;
              variable.deriveExpr = myMathExpr;
            } else {
              throw new Error(`Variable ${negatedVariable} not defined`);
            }
          } else {
            constructor.constraints.push(myMathExpr);
          }
        } else {
          constructor.constraints.push((0, utils_2.convertToMathExpr)(field.expr));
        }
      }
    });
  }
  function fillParameterNames(tlbType) {
    var _a2;
    let parameterNames = [];
    (_a2 = tlbType.constructors[0]) === null || _a2 === void 0 ? void 0 : _a2.parameters.forEach((element) => {
      parameterNames.push(element.variable.name);
    });
    tlbType.constructors.forEach((constructor) => {
      var _a3;
      for (let i = 0; i < constructor.parameters.length; i++) {
        if (parameterNames[i] == void 0) {
          let parameterName = (_a3 = constructor.parameters[i]) === null || _a3 === void 0 ? void 0 : _a3.variable.name;
          if (parameterName != void 0) {
            parameterNames[i] = parameterName;
          }
        }
      }
    });
    for (let i = 0; i < parameterNames.length; i++) {
      if (parameterNames[i] == void 0) {
        parameterNames[i] = "arg" + i;
      }
    }
    tlbType.constructors.forEach((constructor) => {
      var _a3;
      for (let i = 0; i < constructor.parameters.length; i++) {
        let parameterName = parameterNames[i];
        if (parameterName != void 0 && ((_a3 = constructor.parameters[i]) === null || _a3 === void 0 ? void 0 : _a3.variable.name) == void 0) {
          constructor.parameters[i].variable.name = parameterName;
        }
      }
    });
  }
  function fillArgNames(tlbType) {
    var _a2;
    let argNames = [];
    (_a2 = tlbType.constructors[0]) === null || _a2 === void 0 ? void 0 : _a2.parameters.forEach((_element) => {
      argNames.push(void 0);
    });
    tlbType.constructors.forEach((constructor) => {
      var _a3;
      for (let i = 0; i < constructor.parameters.length; i++) {
        let argName = (_a3 = constructor.parameters[i]) === null || _a3 === void 0 ? void 0 : _a3.argName;
        if (argName) {
          argNames[i] = argName;
        }
      }
    });
    tlbType.constructors.forEach((constructor) => {
      for (let i = 0; i < constructor.parameters.length; i++) {
        let argName = argNames[i];
        let parameter = constructor.parameters[i];
        if (argName != void 0 && parameter != void 0) {
          parameter.argName = argName;
          if (parameter.paramExpr instanceof ast_1.TLBVarExpr) {
            parameter.variable.deriveExpr = new ast_1.TLBVarExpr(parameter.argName);
            parameter.paramExpr = parameter.variable.deriveExpr;
          }
        }
      }
    });
  }
  function compareConstructors(a2, b2) {
    let aPriority = constructorPriority(a2);
    let bPriority = constructorPriority(b2);
    if (aPriority < bPriority) {
      return 1;
    }
    if (aPriority > bPriority) {
      return -1;
    }
    return 0;
  }
  function constructorPriority(c) {
    let result = 0;
    if (c.tag.bitLen > 0) {
      result++;
    }
    c.parameters.forEach((parameter) => {
      if (parameter.variable.isConst) {
        result++;
      }
    });
    return result;
  }
  function reorganizeWithArg(mathExpr, argName, varName) {
    let reorganized = (0, utils_2.reorganizeExpression)(new ast_1.TLBBinaryOp(new ast_1.TLBVarExpr(argName), mathExpr, "=", /* @__PURE__ */ new Set(), false), varName);
    if (reorganized instanceof ast_1.TLBBinaryOp) {
      return reorganized.right;
    }
    throw new Error(`Couldn't reorganize expression ${mathExpr}`);
  }
  function getConstructorTag(declaration, _input) {
    let tag = declaration.constructorDef.tag;
    if (tag == null && declaration.constructorDef.name == "_" || tag && tag.length > 1 && tag[1] == "_") {
      return {
        bitLen: 0,
        binary: ""
      };
    }
    if (tag == null) {
      let calculatedTag = calculateTag(declaration);
      return {
        bitLen: 32,
        binary: "0x" + calculatedTag
      };
    }
    if (tag[0] == "$") {
      return {
        bitLen: (tag === null || tag === void 0 ? void 0 : tag.length) - 1,
        binary: "0b" + tag.slice(1)
      };
    }
    if (tag[0] == "#") {
      const hasTrailingUnderscore = tag.endsWith("_");
      const hexPart = tag.slice(1, hasTrailingUnderscore ? -1 : void 0);
      if (hasTrailingUnderscore) {
        const binary2 = parseInt(hexPart, 16).toString(2).padStart(hexPart.length * 4, "0");
        const truncatedBinary = binary2.slice(0, -1);
        const truncatedHex = parseInt(truncatedBinary, 2).toString(16).padStart(Math.ceil(truncatedBinary.length / 4), "0");
        return {
          bitLen: truncatedBinary.length,
          binary: "0x" + truncatedHex
        };
      }
      return {
        bitLen: hexPart.length * 4,
        binary: "0x" + hexPart
      };
    }
    throw new Error("Unknown tag " + tag);
  }
  function findConstructorsNaming(tlbType) {
    let constructorNames = /* @__PURE__ */ new Set();
    let constructorIndex = 0;
    tlbType.constructors.forEach((current) => {
      while (constructorNames.has(current.name)) {
        current.name += constructorIndex.toString();
      }
      constructorNames.add(current.name);
      constructorIndex++;
    });
  }
  function checkAndRemovePrimitives(tlbCode, _input, typeDeclarations) {
    let toDelete = [];
    let typesToDelete = /* @__PURE__ */ new Map();
    typesToDelete.set("Bool", ["b814e002", "e95dd78d"]);
    typesToDelete.set("MsgAddressInt", ["9bb90082", "ca70d9f6"]);
    typesToDelete.set("Bit", ["12acf7f6"]);
    typesToDelete.set("Grams", ["31468450"]);
    typesToDelete.set("MsgAddressExt", ["9ccb7139", "ee7b72a3"]);
    typesToDelete.set("MsgAddress", ["21d0382b", "e06aa05e"]);
    typesToDelete.set("VarUInteger", ["988e36b3"]);
    typesToDelete.set("VarInteger", ["225aaee0"]);
    typesToDelete.set("HashmapE", ["1cc05be9", "40b92161"]);
    typesToDelete.set("HashmapAugE", ["af55dae6", "e135d248"]);
    typesToDelete.set("BoolTrue", ["b5311773"]);
    typesToDelete.set("BoolFalse", ["f3214771"]);
    typesToDelete.forEach((opCodesExpected, typeName) => {
      let typeItems = typeDeclarations.get(typeName);
      if (typeItems) {
        let opCodesActual = [];
        typeItems.forEach((typeItem) => {
          opCodesActual.push(calculateTag(typeItem.declaration));
        });
        if (!(0, utils_2.opCodeSetsEqual)(opCodesExpected, opCodesActual)) {
          throw new Error("Bool primitive type is not correct in scheme");
        }
        toDelete.push(typeName);
      }
    });
    toDelete.forEach((name) => {
      tlbCode.types.delete(name);
    });
  }
  function findAvailableVarNamesForCode(tlbCode) {
    tlbCode.types.forEach((tlbType) => {
      tlbType.constructors.forEach((constructor) => {
        let variablesSet = /* @__PURE__ */ new Set();
        findAvailableFieldsNames(constructor.fields, variablesSet);
      });
    });
  }
  function findAvailableFieldsNames(fields, variablesSet) {
    fields.forEach((field) => {
      if (field.subFields.length == 0) {
        findAvailableFieldName(field, variablesSet);
      }
      findAvailableFieldsNames(field.subFields, variablesSet);
    });
  }
  function findAvailableFieldName(field, variablesSet) {
    let index2 = 0;
    field.name = (0, utils_1.findNotReservedName)(field.name);
    while (variablesSet.has(field.name)) {
      field.name = (0, utils_1.findNotReservedName)(field.name + "_" + index2);
      index2++;
    }
    variablesSet.add(field.name);
  }
  function convertCodeToReadonly(tlbCode) {
    let newTypes = /* @__PURE__ */ new Map();
    tlbCode.types.forEach((value, key) => {
      let newConstructors = new Array();
      value.constructors.forEach((value2) => {
        let newVariablesMap = /* @__PURE__ */ new Map();
        value2.variablesMap.forEach((value3, key2) => {
          newVariablesMap.set(key2, convertVariableToReadonly(value3));
        });
        let newParametersMap = /* @__PURE__ */ new Map();
        value2.parametersMap.forEach((value3, key2) => {
          newParametersMap.set(key2, convertParameterToReadonly(value3));
        });
        let newConstructor = new ast_1.TLBConstructor(value2.parameters.map(convertParameterToReadonly), value2.variables.map(convertVariableToReadonly), newVariablesMap, newParametersMap, value2.name, value2.fields, value2.tag, value2.constraints, value2.declaration, value2.tlbType);
        newConstructors.push(newConstructor);
      });
      let newType = new ast_1.TLBType(value.name, newConstructors);
      newTypes.set(key, newType);
    });
    return new ast_1.TLBCode(newTypes);
  }
  fill_constructors.convertCodeToReadonly = convertCodeToReadonly;
  function convertParameterToReadonly(tlbParameter) {
    return new ast_1.TLBParameter(convertVariableToReadonly(tlbParameter.variable), tlbParameter.paramExpr, tlbParameter.argName);
  }
  function convertVariableToReadonly(tlbVariable) {
    if (tlbVariable.name == void 0) {
      throw new Error("Variable is undefined");
    }
    return new ast_1.TLBVariable(tlbVariable.isConst, tlbVariable.negated, tlbVariable.type, tlbVariable.name, tlbVariable.isField, tlbVariable.deriveExpr, tlbVariable.initialExpr);
  }
  function getStringDeclaration(declaration, input) {
    var _a2, _b;
    let result = "";
    let splittedInput = input;
    let currentLine = declaration.locations.line - 1;
    let currentColumn = 0;
    while (!((_a2 = splittedInput[currentLine]) === null || _a2 === void 0 ? void 0 : _a2.includes(";"))) {
      result += ((_b = splittedInput[currentLine]) === null || _b === void 0 ? void 0 : _b.substring(currentColumn)) + "\n";
      currentLine++;
      currentColumn = 0;
    }
    let currentInput = splittedInput[currentLine];
    if (currentInput) {
      result += currentInput.substring(currentColumn, currentInput.indexOf(";") + 1);
    }
    return result;
  }
  function calculateVariables(constructor) {
    constructor.variables.forEach((variable) => {
      (0, utils_2.calculateVariable)(variable, constructor);
    });
    constructor.parameters.forEach((parameter) => {
      (0, utils_2.calculateVariable)(parameter.variable, constructor);
    });
  }
  const TypeGuards = {
    isFieldBuiltinDef: (field) => field instanceof tlb_parser_1.FieldBuiltinDef,
    isFieldCurlyExprDef: (field) => field instanceof tlb_parser_1.FieldCurlyExprDef,
    isFieldAnonymousDef: (field) => field instanceof tlb_parser_1.FieldAnonymousDef,
    isFieldNamedDef: (field) => field instanceof tlb_parser_1.FieldNamedDef,
    isFieldExprDef: (field) => field instanceof tlb_parser_1.FieldExprDef,
    isCompareExpr: (expr) => expr instanceof tlb_parser_1.CompareExpr,
    isMathExpr: (expr) => expr instanceof tlb_parser_1.MathExpr,
    isNegateExpr: (expr) => expr instanceof tlb_parser_1.NegateExpr,
    isNameExpr: (expr) => expr instanceof tlb_parser_1.NameExpr,
    isNumberExpr: (expr) => expr instanceof tlb_parser_1.NumberExpr,
    isCellRefExpr: (expr) => expr instanceof tlb_parser_1.CellRefExpr,
    isBuiltinZeroArgs: (expr) => expr instanceof tlb_parser_1.BuiltinZeroArgs,
    isBuiltinOneArgExpr: (expr) => expr instanceof tlb_parser_1.BuiltinOneArgExpr,
    isCombinatorExpr: (expr) => expr instanceof tlb_parser_1.CombinatorExpr,
    isCondExpr: (expr) => expr instanceof tlb_parser_1.CondExpr
  };
  function calculateTag(declaration) {
    const formattedDeclaration = formatDeclaration(declaration);
    const encoder = new TextEncoder();
    return (0, utils_1.crc32)(encoder.encode(formattedDeclaration)).toString(16);
  }
  function isImplicitOrConstraint(field) {
    const { isFieldBuiltinDef, isFieldCurlyExprDef, isFieldNamedDef, isFieldExprDef, isCompareExpr } = TypeGuards;
    if (isFieldBuiltinDef(field) || isFieldCurlyExprDef(field)) {
      return true;
    }
    if ((isFieldNamedDef(field) || isFieldExprDef(field)) && isCompareExpr(field.expr) && field.expr.op === "=") {
      return true;
    }
    return false;
  }
  function formatDeclaration(declaration) {
    const parts = [declaration.constructorDef.name];
    declaration.fields.forEach((field) => {
      parts.push(formatField(field));
    });
    parts.push("=", declaration.combinator.name);
    declaration.combinator.args.forEach((arg) => {
      parts.push(formatExpression(arg));
    });
    return parts.join(" ");
  }
  function formatField(field) {
    const { isFieldBuiltinDef, isFieldCurlyExprDef, isFieldNamedDef, isFieldExprDef, isFieldAnonymousDef } = TypeGuards;
    const parts = [];
    if (isImplicitOrConstraint(field)) {
      if (isFieldBuiltinDef(field) || isFieldNamedDef(field) || isFieldAnonymousDef(field) && field.name) {
        parts.push(`${field.name}:`);
      }
      if (isFieldBuiltinDef(field)) {
        parts.push(field.type);
      } else if (isFieldCurlyExprDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldNamedDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldExprDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldAnonymousDef(field)) {
        parts.push(formatAnonymousField(field));
      }
      return parts.join("");
    }
    if (isFieldNamedDef(field)) {
      parts.push(`${field.name}:`);
    } else if (isFieldAnonymousDef(field) && field.name) {
      parts.push(`${field.name}:`);
    }
    if (isFieldNamedDef(field)) {
      parts.push(formatExpression(field.expr));
    } else if (isFieldExprDef(field)) {
      parts.push(formatExpression(field.expr));
    } else if (isFieldAnonymousDef(field)) {
      parts.push(formatAnonymousField(field));
    }
    return parts.join("");
  }
  function formatAnonymousField(field) {
    const innerFields = field.fields.map((innerField, index2) => index2 > 0 ? " " + formatField(innerField) : formatField(innerField)).join("");
    return `${field.isRef ? "^[ " : "[ "}${innerFields} ]`;
  }
  function formatExpression(expr) {
    const { isCompareExpr, isMathExpr, isNegateExpr, isNameExpr, isNumberExpr, isCellRefExpr, isBuiltinZeroArgs, isBuiltinOneArgExpr, isCombinatorExpr, isCondExpr } = TypeGuards;
    if (isCompareExpr(expr)) {
      return `${expr.op} ${formatExpression(expr.left)} ${formatExpression(expr.right)}`;
    }
    if (isMathExpr(expr)) {
      return formatMathExpr(expr);
    }
    if (isNegateExpr(expr)) {
      return "~" + formatExpression(expr.expr);
    }
    if (isNumberExpr(expr)) {
      return String(expr.num);
    }
    if (isNameExpr(expr)) {
      return expr.name;
    }
    if (isCellRefExpr(expr)) {
      return "^" + formatExpression(expr.expr);
    }
    if (isBuiltinZeroArgs(expr)) {
      return expr.name;
    }
    if (isBuiltinOneArgExpr(expr)) {
      return `${expr.name} ${formatExpression(expr.arg)}`;
    }
    if (isCombinatorExpr(expr)) {
      const args = expr.args.map((arg) => formatExpression(arg)).join(" ");
      return `${expr.name} ${args}`;
    }
    if (isCondExpr(expr)) {
      let result = formatExpression(expr.left);
      if (expr.dotExpr !== null) {
        result += "." + expr.dotExpr;
      }
      result += "?" + formatExpression(expr.condExpr);
      return result;
    }
    return String(expr);
  }
  function formatMathExpr(expr) {
    const { isNumberExpr } = TypeGuards;
    if (expr.op === "+") {
      return `${formatExpression(expr.left)} + ${formatExpression(expr.right)}`;
    }
    if (expr.op === "*") {
      if (isNumberExpr(expr.right) && !isNumberExpr(expr.left)) {
        return `${formatExpression(expr.right)} * ${formatExpression(expr.left)}`;
      }
      if (isNumberExpr(expr.left) && isNumberExpr(expr.right)) {
        return String(expr.left.num * expr.right.num);
      }
      return `${formatExpression(expr.left)} * ${formatExpression(expr.right)}`;
    }
    return `${formatExpression(expr.left)} ${expr.op} ${formatExpression(expr.right)}`;
  }
  return fill_constructors;
}
var CodeBuilder = {};
var hasRequiredCodeBuilder;
function requireCodeBuilder() {
  if (hasRequiredCodeBuilder) return CodeBuilder;
  hasRequiredCodeBuilder = 1;
  Object.defineProperty(CodeBuilder, "__esModule", { value: true });
  CodeBuilder.CodeBuilder = void 0;
  let CodeBuilder$1 = class CodeBuilder {
    constructor() {
      this.tabLevel = 0;
      this.code = "";
    }
    tab() {
      this.tabLevel++;
    }
    unTab() {
      this.tabLevel--;
    }
    inTab(callback) {
      this.tab();
      callback();
      this.unTab();
    }
    add(text, moveLine = true) {
      if (!text) {
        this.code += "\n";
        return;
      }
      let tab = " ".repeat(this.tabLevel * 4);
      this.code += tab + text + (moveLine ? "\n" : "");
    }
    addMultiline(text, inline = false) {
      let lines = text.split("\n");
      let i = 0;
      for (let line of lines) {
        if (line === "\n" && lines.indexOf(line) === lines.length - 1) {
          continue;
        }
        if (inline && i === 0) {
          this.code += line + "\n";
        } else {
          this.add(line);
        }
        i++;
      }
    }
    append(code) {
      this.addMultiline(code.render());
    }
    appendInline(code) {
      this.addMultiline(code.render(), true);
    }
    render() {
      return this.code;
    }
  };
  CodeBuilder.CodeBuilder = CodeBuilder$1;
  return CodeBuilder;
}
var generator = {};
var complex_expr = {};
var tsgen = {};
var hasRequiredTsgen;
function requireTsgen() {
  if (hasRequiredTsgen) return tsgen;
  hasRequiredTsgen = 1;
  Object.defineProperty(tsgen, "__esModule", { value: true });
  tsgen.id = tsgen.toCode = tsgen.tCodeAsIs = tsgen.tTernaryExpression = tsgen.tComment = tsgen.tMultiStatement = tsgen.tDeclareVariable = tsgen.tArrowFunctionType = tsgen.tBinaryExpression = tsgen.tUnaryOpExpression = tsgen.tIfStatement = tsgen.tExpressionStatement = tsgen.tUnionTypeDeclaration = tsgen.tArrowFunctionExpression = tsgen.tUnionTypeExpression = tsgen.tTypeParametersExpression = tsgen.tBinaryNumericLiteral = tsgen.tNumericLiteral = tsgen.tMemberExpression = tsgen.tFunctionCall = tsgen.tReturnStatement = tsgen.tStructExpression = tsgen.tObjectExpression = tsgen.tForCycle = tsgen.tObjectProperty = tsgen.tStructDeclaration = tsgen.tTypeWithParameters = tsgen.tTypedIdentifier = tsgen.tFunctionDeclaration = tsgen.tImportDeclaration = tsgen.tStringLiteral = tsgen.tIdentifier = void 0;
  const CodeBuilder_1 = requireCodeBuilder();
  function tIdentifier(name) {
    return { type: "Identifier", name };
  }
  tsgen.tIdentifier = tIdentifier;
  function tStringLiteral(value) {
    return { type: "StringLiteral", value };
  }
  tsgen.tStringLiteral = tStringLiteral;
  function tImportDeclaration(importValue, from) {
    return { type: "ImportDeclaration", importValue, from };
  }
  tsgen.tImportDeclaration = tImportDeclaration;
  function tFunctionDeclaration(name, typeParameters, returnType, parameters, body) {
    return {
      type: "FunctionDeclaration",
      name,
      typeParameters,
      returnType,
      parameters,
      body
    };
  }
  tsgen.tFunctionDeclaration = tFunctionDeclaration;
  function tTypedIdentifier(name, typeId, optional = false) {
    return { type: "TypedIdentifier", name, typeId, optional };
  }
  tsgen.tTypedIdentifier = tTypedIdentifier;
  function tTypeWithParameters(name, typeParameters) {
    return {
      type: "TypeWithParameters",
      name,
      typeParameters
    };
  }
  tsgen.tTypeWithParameters = tTypeWithParameters;
  function tStructDeclaration(name, fields, typeParameters) {
    return {
      type: "StructDeclaration",
      name,
      fields,
      typeParametersExpression: typeParameters
    };
  }
  tsgen.tStructDeclaration = tStructDeclaration;
  function tObjectProperty(key, value) {
    return { type: "ObjectProperty", key, value };
  }
  tsgen.tObjectProperty = tObjectProperty;
  function tForCycle(init2, cond, inc, body) {
    return { type: "ForCycle", init: init2, cond, inc, body };
  }
  tsgen.tForCycle = tForCycle;
  function tObjectExpression(objectValues) {
    return { type: "ObjectExpression", objectValues };
  }
  tsgen.tObjectExpression = tObjectExpression;
  function tStructExpression(fields) {
    return { type: "StructExpression", fields };
  }
  tsgen.tStructExpression = tStructExpression;
  function tReturnStatement(returnValue) {
    return { type: "ReturnStatement", returnValue };
  }
  tsgen.tReturnStatement = tReturnStatement;
  function tFunctionCall(functionId, parameters, typeParameters) {
    return {
      type: "FunctionCall",
      functionId,
      parameters,
      typeParameters
    };
  }
  tsgen.tFunctionCall = tFunctionCall;
  function tMemberExpression(thisObject, memberName) {
    return {
      type: "MemberExpression",
      thisObject,
      memberName
    };
  }
  tsgen.tMemberExpression = tMemberExpression;
  function tNumericLiteral(value) {
    return { type: "NumericLiteral", value };
  }
  tsgen.tNumericLiteral = tNumericLiteral;
  function tBinaryNumericLiteral(value) {
    return { type: "BinaryNumericLiteral", value };
  }
  tsgen.tBinaryNumericLiteral = tBinaryNumericLiteral;
  function tTypeParametersExpression(typeParameters) {
    return { type: "TypeParametersExpression", typeParameters };
  }
  tsgen.tTypeParametersExpression = tTypeParametersExpression;
  function tUnionTypeExpression(unionMembers) {
    return { type: "UnionTypeExpression", unionMembers };
  }
  tsgen.tUnionTypeExpression = tUnionTypeExpression;
  function tArrowFunctionExpression(parameters, body) {
    return {
      type: "ArrowFunctionExpression",
      parameters,
      body
    };
  }
  tsgen.tArrowFunctionExpression = tArrowFunctionExpression;
  function tUnionTypeDeclaration(name, union) {
    return { type: "UnionTypeDeclaration", name, union };
  }
  tsgen.tUnionTypeDeclaration = tUnionTypeDeclaration;
  function tExpressionStatement(expression) {
    return { type: "ExpressionStatement", expression };
  }
  tsgen.tExpressionStatement = tExpressionStatement;
  function tIfStatement(condition, body, elseBody) {
    return {
      type: "IfStatement",
      condition,
      body,
      elseBody
    };
  }
  tsgen.tIfStatement = tIfStatement;
  function tUnaryOpExpression(unaryOperator, expr) {
    return {
      type: "UnaryOpExpression",
      unaryOperator,
      expr
    };
  }
  tsgen.tUnaryOpExpression = tUnaryOpExpression;
  function tBinaryExpression(left, binarySign, right) {
    return {
      type: "BinaryExpression",
      binarySign,
      left,
      right
    };
  }
  tsgen.tBinaryExpression = tBinaryExpression;
  function tArrowFunctionType(parameters, returnType) {
    return {
      type: "ArrowFunctionType",
      parameters,
      returnType
    };
  }
  tsgen.tArrowFunctionType = tArrowFunctionType;
  function tDeclareVariable(name, init2, typeName) {
    return {
      type: "DeclareVariable",
      name,
      init: init2,
      typeName
    };
  }
  tsgen.tDeclareVariable = tDeclareVariable;
  function tMultiStatement(statements) {
    return { type: "MultiStatement", statements };
  }
  tsgen.tMultiStatement = tMultiStatement;
  function tComment(value) {
    return { type: "Comment", value };
  }
  tsgen.tComment = tComment;
  function tTernaryExpression(condition, body, elseBody) {
    return {
      type: "TernaryExpression",
      condition,
      body,
      elseBody
    };
  }
  tsgen.tTernaryExpression = tTernaryExpression;
  function tCodeAsIs(code) {
    return { type: "CodeAsIs", code };
  }
  tsgen.tCodeAsIs = tCodeAsIs;
  function toCodeArray(nodeArray, code, delimeter) {
    for (let i = 0; i < nodeArray.length; i++) {
      let currentParam = nodeArray[i];
      if (currentParam != void 0) {
        toCode(currentParam, code);
      }
      if (i + 1 < nodeArray.length) {
        code.add(delimeter, false);
      }
    }
    return code;
  }
  function toCode(node, code = new CodeBuilder_1.CodeBuilder()) {
    if (node.type == "Identifier") {
      code.add(node.name, false);
    }
    if (node.type == "NumericLiteral") {
      code.add(node.value.toString(), false);
    }
    if (node.type == "ImportDeclaration") {
      code.add(`import { ${toCode(node.importValue).render()} } from ${toCode(node.from).render()}`, false);
    }
    if (node.type == "FunctionDeclaration") {
      code.add(`export function ${toCode(node.name).render()}${toCode(node.typeParameters).render()}(`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`)${node.returnType ? ": " + toCode(node.returnType).render() : ""} {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add("}");
    }
    if (node.type == "ArrowFunctionExpression") {
      code.add(`((`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`) => {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add(`})`, false);
    }
    if (node.type == "ArrowFunctionType") {
      code.add(`(${toCodeArray(node.parameters, new CodeBuilder_1.CodeBuilder(), ", ").render()}) => ${node.returnType ? toCode(node.returnType).render() : ""}`, false);
    }
    if (node.type == "TypeWithParameters") {
      code.add(`${toCode(node.name).render()}${toCode(node.typeParameters).render()}`, false);
    }
    if (node.type == "TypedIdentifier") {
      code.add(toCode(node.name).render() + (node.optional ? "?" : "") + ": " + toCode(node.typeId).render(), false);
    }
    if (node.type == "ObjectProperty") {
      code.add(toCode(node.key).render() + ": " + toCode(node.value).render(), false);
    }
    if (node.type == "DeclareVariable") {
      code.add(`let ${toCode(node.name).render()}${node.typeName ? ": " + toCode(node.typeName).render() : ""}`, false);
      if (node.init) {
        code.add(" = ", false);
        toCode(node.init, code);
      }
    }
    if (node.type == "ObjectExpression") {
      code.add("{");
      code.inTab(() => {
        node.objectValues.forEach((objectValue) => {
          code.add(toCode(objectValue).render() + ",");
        });
      });
      code.add("}", false);
    }
    if (node.type == "StructExpression") {
      code.add("{", false);
      toCodeArray(node.fields, code, ", ");
      code.add("}", false);
    }
    if (node.type == "MultiStatement") {
      node.statements.forEach((statement) => {
        code.append(toCode(statement));
      });
    }
    if (node.type == "ReturnStatement") {
      code.add(`return `, false);
      code.appendInline(toCode(node.returnValue));
    }
    if (node.type == "ExpressionStatement") {
      code.add(toCode(node.expression).render() + ";", false);
    }
    if (node.type == "TypeParametersExpression") {
      if (node.typeParameters.length > 0) {
        code.add("<", false);
        toCodeArray(node.typeParameters, code, ", ");
        code.add(">", false);
      }
    }
    if (node.type == "StructDeclaration") {
      code.add(`export interface ${toCode(node.name).render()}${toCode(node.typeParametersExpression).render()} {`);
      code.inTab(() => {
        node.fields.forEach((field) => {
          code.add(`readonly ${toCode(field).render()};`);
        });
      });
      code.add("}");
    }
    if (node.type == "UnionTypeDeclaration") {
      code.add(`export type ${toCode(node.name).render()} = ${toCode(node.union).render()};`);
    }
    if (node.type == "UnionTypeExpression") {
      toCodeArray(node.unionMembers, code, " | ");
    }
    if (node.type == "FunctionCall") {
      code.add(`${toCode(node.functionId).render()}${node.typeParameters ? toCode(node.typeParameters).render() : ""}(`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`)`, false);
    }
    if (node.type == "StringLiteral") {
      code.add(`'${node.value}'`, false);
    }
    if (node.type == "MemberExpression") {
      code.add(toCode(node.thisObject).render() + "." + toCode(node.memberName).render(), false);
    }
    if (node.type == "IfStatement") {
      code.add(`if (${toCode(node.condition).render()}) {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add("}", false);
    }
    if (node.type == "ForCycle") {
      code.add(`for (${toCode(node.init).render()};${toCode(node.cond).render()};${toCode(node.inc).render()}) {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add(`}`, false);
    }
    if (node.type == "UnaryOpExpression") {
      code.add(`(${node.unaryOperator}${toCode(node.expr).render()})`, false);
    }
    if (node.type == "BinaryExpression") {
      code.add(`(${toCode(node.left).render()} ${node.binarySign} ${toCode(node.right).render()})`, false);
    }
    if (node.type == "TernaryExpression") {
      code.add(`(${toCode(node.condition).render()} ? ${toCode(node.body).render()} : ${toCode(node.elseBody).render()})`, false);
    }
    if (node.type == "Comment") {
      let splittedComment = node.value.split("\n");
      if (splittedComment.length == 1) {
        code.add(`// ${splittedComment[0]}`);
      } else {
        code.add(`/*`);
        splittedComment.forEach((line) => {
          code.add(line);
        });
        code.add(`*/`);
      }
    }
    if (node.type == "CodeAsIs") {
      code.add(node.code, false);
    }
    return code;
  }
  tsgen.toCode = toCode;
  tsgen.id = tIdentifier;
  return tsgen;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.useBuffer = utils.isBigInt = utils.isBigIntExpr = utils.getCondition = utils.getTypeParametersExpression = utils.convertToAST = utils.addLoadProperty = utils.getNegationDerivationFunctionBody = utils.getVarExprByName = utils.getParamVarExpr = void 0;
  const ast_1 = requireAst();
  const utils_1 = requireUtils$2();
  const complex_expr_1 = requireComplex_expr();
  const tsgen_1 = requireTsgen();
  function getParamVarExpr(param, constructor) {
    if (param.variable.deriveExpr) {
      return convertToAST(param.variable.deriveExpr, constructor);
    } else {
      throw new Error(`Could not get expression for param ${param.variable.name} for constructor ${constructor.name} of type ${constructor.tlbType}`);
    }
  }
  utils.getParamVarExpr = getParamVarExpr;
  function getVarExprByName(name, constructor) {
    let variable = constructor.variablesMap.get(name);
    if (variable === null || variable === void 0 ? void 0 : variable.deriveExpr) {
      return convertToAST(variable.deriveExpr, constructor);
    }
    return (0, tsgen_1.id)(name);
  }
  utils.getVarExprByName = getVarExprByName;
  function getNegationDerivationFunctionBody(tlbCode, typeName, parameterIndex, parameterName) {
    let result = [];
    let tlbType = tlbCode.types.get(typeName);
    if (!tlbType) {
      throw new Error(`Can not find type ${typeName}`);
    }
    tlbType.constructors.forEach((constructor) => {
      let parameter = constructor.parameters[parameterIndex];
      if (parameter) {
        let getExpression;
        getExpression = convertToAST(parameter.paramExpr, constructor);
        let statements = [];
        if (!parameter.variable.isConst) {
          statements.push((0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(parameter.variable.name), (0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(parameterName), (0, tsgen_1.id)(parameter.variable.name)))));
        }
        statements.push((0, tsgen_1.tReturnStatement)(getExpression));
        if (tlbType) {
          result.push((0, tsgen_1.tIfStatement)((0, complex_expr_1.tEqualExpression)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(parameterName), (0, tsgen_1.id)("kind")), (0, tsgen_1.tStringLiteral)((0, utils_1.getSubStructName)(tlbType, constructor))), statements));
        }
      }
    });
    let exceptionTypesComment = tlbType.constructors.map((constructor) => {
      return `"${tlbType ? (0, utils_1.getSubStructName)(tlbType, constructor) : ""}"`;
    }).join(", ");
    let exceptionComment = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)(`throw new Error('Expected one of ${exceptionTypesComment} for type "${tlbType.name}" while getting "${parameterName}", but data does not satisfy any constructor')`));
    result.push(exceptionComment);
    return result;
  }
  utils.getNegationDerivationFunctionBody = getNegationDerivationFunctionBody;
  function addLoadProperty(name, loadExpr, typeExpr, ctx) {
    let nameId = (0, tsgen_1.id)(name);
    ctx.loadStatements.push((0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)(nameId, loadExpr, typeExpr)));
    ctx.loadProperties.push((0, tsgen_1.tObjectProperty)(nameId, nameId));
  }
  utils.addLoadProperty = addLoadProperty;
  function convertToAST(mathExpr, constructor, objectId) {
    if (mathExpr instanceof ast_1.TLBVarExpr) {
      let varName = mathExpr.x;
      if (objectId != void 0) {
        return (0, tsgen_1.tMemberExpression)(objectId, (0, tsgen_1.id)(varName));
      }
      return (0, tsgen_1.id)(varName);
    }
    if (mathExpr instanceof ast_1.TLBNumberExpr) {
      return (0, tsgen_1.tNumericLiteral)(mathExpr.n);
    }
    if (mathExpr instanceof ast_1.TLBBinaryOp) {
      let operation = mathExpr.operation;
      if (operation == "=") {
        operation = "==";
      }
      return (0, tsgen_1.tBinaryExpression)(convertToAST(mathExpr.left, constructor, objectId), operation, convertToAST(mathExpr.right, constructor, objectId));
    }
    if (mathExpr instanceof ast_1.TLBUnaryOp) {
      if (mathExpr.operation == ".") {
        return (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("bitLen"), [convertToAST(mathExpr.value, constructor, objectId)]);
      }
      return (0, tsgen_1.tUnaryOpExpression)(mathExpr.operation, convertToAST(mathExpr.value, constructor, objectId));
    }
    throw new Error(`Type ${constructor.tlbType}, constructor ${constructor.name}: couldn't convert to math expression: ${mathExpr}`);
  }
  utils.convertToAST = convertToAST;
  function getTypeParametersExpression(parameters) {
    let structTypeParameters = [];
    parameters.forEach((element) => {
      if (element.variable.type == "Type") {
        structTypeParameters.push((0, tsgen_1.id)(element.variable.name));
      }
    });
    let structTypeParametersExpr = (0, tsgen_1.tTypeParametersExpression)(structTypeParameters);
    return structTypeParametersExpr;
  }
  utils.getTypeParametersExpression = getTypeParametersExpression;
  function getCondition(conditions) {
    let cnd = conditions[0];
    if (cnd) {
      if (conditions.length > 1) {
        return (0, tsgen_1.tBinaryExpression)(cnd, "&&", getCondition(conditions.slice(1)));
      } else {
        return cnd;
      }
    } else {
      return (0, tsgen_1.id)("true");
    }
  }
  utils.getCondition = getCondition;
  function isBigIntExpr(fieldType) {
    if (fieldType.expr instanceof ast_1.TLBNumberExpr && fieldType.expr.n <= 32) {
      return false;
    }
    return true;
  }
  utils.isBigIntExpr = isBigIntExpr;
  function isBigInt(fieldType) {
    if (fieldType.bits instanceof ast_1.TLBNumberExpr) {
      if (fieldType.bits.n <= 32) {
        return false;
      }
    }
    if (fieldType.maxBits && fieldType.maxBits <= 32) {
      return false;
    }
    return true;
  }
  utils.isBigInt = isBigInt;
  function useBuffer(bitsType) {
    if (bitsType.bits instanceof ast_1.TLBNumberExpr && bitsType.bits.n % 8 == 0) {
      return true;
    }
    return false;
  }
  utils.useBuffer = useBuffer;
  return utils;
}
var hasRequiredComplex_expr;
function requireComplex_expr() {
  if (hasRequiredComplex_expr) return complex_expr;
  hasRequiredComplex_expr = 1;
  Object.defineProperty(complex_expr, "__esModule", { value: true });
  complex_expr.dictAugTypeExpr = complex_expr.dictAugParse = complex_expr.dictKeyExpr = complex_expr.dictLoadExpr = complex_expr.dictValueStore = complex_expr.dictTypeParamExpr = complex_expr.dictStoreStmt = complex_expr.negationDerivationFuncDecl = complex_expr.inSeparateRef = complex_expr.checkConstraintStmt = complex_expr.newCellStmt = complex_expr.storeRefStmt = complex_expr.loadRefStmt = complex_expr.storeRefObjectStmt = complex_expr.storeExpressionNamedType = complex_expr.storeExprCond = complex_expr.loadTupleExpr = complex_expr.storeTupleStmt = complex_expr.arrayedType = complex_expr.loadFromNewSlice = complex_expr.storeInNewCell = complex_expr.storeCombinator = complex_expr.loadExprForParam = complex_expr.returnSliceFunc = complex_expr.storeExprForParam = complex_expr.coverFuncCall = complex_expr.storeFunctionExpr = complex_expr.checkHasBitsForTag = complex_expr.checkTagExpr = complex_expr.skipTagStmt = complex_expr.loadFunctionParam = complex_expr.storeFunctionParam = complex_expr.simpleCycle = complex_expr.sliceLoad = complex_expr.typedSlice = complex_expr.bitlenFunctionDecl = complex_expr.checkKindStmt = complex_expr.storeFunctionStmt = complex_expr.storeTagExpression = complex_expr.tEqualExpression = void 0;
  const utils_1 = requireUtils$2();
  const tsgen_1 = requireTsgen();
  const utils_2 = requireUtils();
  function tEqualExpression(left, right) {
    return (0, tsgen_1.tBinaryExpression)(left, "==", right);
  }
  complex_expr.tEqualExpression = tEqualExpression;
  function storeTagExpression(tag) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("storeUint")), [(0, tsgen_1.id)(tag.binary), (0, tsgen_1.tNumericLiteral)(tag.bitLen)]));
  }
  complex_expr.storeTagExpression = storeTagExpression;
  function storeFunctionStmt(statements) {
    return (0, tsgen_1.tReturnStatement)((0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], statements));
  }
  complex_expr.storeFunctionStmt = storeFunctionStmt;
  function checkKindStmt(variableCombinatorName, constructorTypeName, storeStatement) {
    return (0, tsgen_1.tIfStatement)(tEqualExpression((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(variableCombinatorName), (0, tsgen_1.id)("kind")), (0, tsgen_1.tStringLiteral)(constructorTypeName)), [storeStatement]);
  }
  complex_expr.checkKindStmt = checkKindStmt;
  function bitlenFunctionDecl() {
    return (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("bitLen"), (0, tsgen_1.tTypeParametersExpression)([]), null, [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("n"), (0, tsgen_1.id)("number"))], [(0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("return n.toString(2).length"))]);
  }
  complex_expr.bitlenFunctionDecl = bitlenFunctionDecl;
  function typedSlice() {
    return [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("Slice"))];
  }
  complex_expr.typedSlice = typedSlice;
  function sliceLoad(slicePrefix, currentSlice) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "slice")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("loadRef")), []), (0, tsgen_1.id)("beginParse")), [(0, tsgen_1.id)("true")])));
  }
  complex_expr.sliceLoad = sliceLoad;
  function simpleCycle(varName, finish) {
    return (0, tsgen_1.tForCycle)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(varName), (0, tsgen_1.tNumericLiteral)(0)), (0, tsgen_1.tBinaryExpression)((0, tsgen_1.id)(varName), "<", finish), (0, tsgen_1.tNumericLiteral)(5), []);
  }
  complex_expr.simpleCycle = simpleCycle;
  function storeFunctionParam(varName) {
    return (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("store" + varName), (0, tsgen_1.tArrowFunctionType)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)((0, utils_1.firstLower)(varName)), (0, tsgen_1.id)(varName))], (0, tsgen_1.tArrowFunctionType)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], (0, tsgen_1.id)("void"))));
  }
  complex_expr.storeFunctionParam = storeFunctionParam;
  function loadFunctionParam(varName) {
    return (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("load" + varName), (0, tsgen_1.tArrowFunctionType)(typedSlice(), (0, tsgen_1.id)(varName)));
  }
  complex_expr.loadFunctionParam = loadFunctionParam;
  function skipTagStmt(bitLen) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("loadUint")), [(0, tsgen_1.tNumericLiteral)(bitLen)]));
  }
  complex_expr.skipTagStmt = skipTagStmt;
  function checkTagExpr(tag) {
    return tEqualExpression((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("preloadUint")), [(0, tsgen_1.tNumericLiteral)(tag.bitLen)]), (0, tsgen_1.id)(tag.binary));
  }
  complex_expr.checkTagExpr = checkTagExpr;
  function checkHasBitsForTag(bitLen) {
    return (0, tsgen_1.tBinaryExpression)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("remainingBits")), ">=", (0, tsgen_1.tNumericLiteral)(bitLen));
  }
  complex_expr.checkHasBitsForTag = checkHasBitsForTag;
  function storeFunctionExpr(typeParamExpr, storeExpr2) {
    return (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr)], [(0, tsgen_1.tReturnStatement)((0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], [storeExpr2]))]);
  }
  complex_expr.storeFunctionExpr = storeFunctionExpr;
  function coverFuncCall(loadExpr) {
    return loadExpr.type == "FunctionCall" ? (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [(0, tsgen_1.tReturnStatement)(loadExpr)]) : loadExpr;
  }
  complex_expr.coverFuncCall = coverFuncCall;
  function storeExprForParam(theCell, exprForParam, insideStoreParameters) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(theCell), (0, tsgen_1.id)("store" + exprForParam.fieldStoreSuffix)), insideStoreParameters));
  }
  complex_expr.storeExprForParam = storeExprForParam;
  function returnSliceFunc() {
    return (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [
      (0, tsgen_1.tReturnStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("asCell")), []))
    ]);
  }
  complex_expr.returnSliceFunc = returnSliceFunc;
  function loadExprForParam(currentSlice, exprForParam) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("load" + exprForParam.fieldLoadSuffix)), exprForParam.argLoadExpr ? [exprForParam.argLoadExpr] : []);
  }
  complex_expr.loadExprForParam = loadExprForParam;
  function storeCombinator(typeName, insideStoreParameters, storeFunctionsArray, currentTypeParameters, theCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("store" + typeName), insideStoreParameters.concat(storeFunctionsArray), currentTypeParameters), [(0, tsgen_1.id)(theCell)]));
  }
  complex_expr.storeCombinator = storeCombinator;
  function storeInNewCell(currentCell, storeExpr) {
    return (0, tsgen_1.tMultiStatement)([
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(currentCell), (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("beginCell"), []))),
      storeExpr,
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("storeRef")), [(0, tsgen_1.id)(currentCell)]))
    ]);
  }
  complex_expr.storeInNewCell = storeInNewCell;
  function loadFromNewSlice(loadExpr) {
    return (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [sliceLoad([1, 0], "slice"), (0, tsgen_1.tReturnStatement)(loadExpr)]);
  }
  complex_expr.loadFromNewSlice = loadFromNewSlice;
  function arrayedType(typeParamExpr) {
    return (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)("Array"), (0, tsgen_1.tTypeParametersExpression)([typeParamExpr]));
  }
  complex_expr.arrayedType = arrayedType;
  function storeTupleStmt(currentParam, storeExpr, typeParamExpr) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(currentParam, (0, tsgen_1.id)("forEach")), [
      (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr)], [storeExpr])
    ]));
  }
  complex_expr.storeTupleStmt = storeTupleStmt;
  function loadTupleExpr(arrayLength, loadExpr) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Array"), (0, tsgen_1.id)("from")), [
      (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("Array"), [arrayLength]), (0, tsgen_1.id)("keys")), [])
    ]), (0, tsgen_1.id)("map")), [(0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), (0, tsgen_1.id)("number"))], [(0, tsgen_1.tReturnStatement)(loadExpr)])]);
  }
  complex_expr.loadTupleExpr = loadTupleExpr;
  function storeExprCond(currentParam, storeExpr) {
    return (0, tsgen_1.tIfStatement)((0, tsgen_1.tBinaryExpression)(currentParam, "!=", (0, tsgen_1.id)("undefined")), [storeExpr]);
  }
  complex_expr.storeExprCond = storeExprCond;
  function storeExpressionNamedType(typeName, insideStoreParameters, currentCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("store" + typeName), insideStoreParameters), [(0, tsgen_1.id)(currentCell)]));
  }
  complex_expr.storeExpressionNamedType = storeExpressionNamedType;
  function storeRefObjectStmt(currentCell, ctx, field) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeRef")), [
      (0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(ctx.typeName), (0, tsgen_1.id)(field.name))
    ]));
  }
  complex_expr.storeRefObjectStmt = storeRefObjectStmt;
  function loadRefStmt(slicePrefix, currentSlice) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("loadRef")), [])));
  }
  complex_expr.loadRefStmt = loadRefStmt;
  function storeRefStmt(slicePrefix, currentCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeRef")), [(0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell"))]));
  }
  complex_expr.storeRefStmt = storeRefStmt;
  function newCellStmt(slicePrefix) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("beginCell"), [])));
  }
  complex_expr.newCellStmt = newCellStmt;
  function checkConstraintStmt(constraintAST, exceptionCommentLastPart) {
    return (0, tsgen_1.tIfStatement)((0, tsgen_1.tUnaryOpExpression)("!", constraintAST), [
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("throw new Error('Condition " + (0, tsgen_1.toCode)(constraintAST).code + exceptionCommentLastPart + "')"))
    ]);
  }
  complex_expr.checkConstraintStmt = checkConstraintStmt;
  function inSeparateRef(slicePrefix, callback) {
    slicePrefix[slicePrefix.length - 1]++;
    slicePrefix.push(0);
    callback();
    slicePrefix.pop();
  }
  complex_expr.inSeparateRef = inSeparateRef;
  function negationDerivationFuncDecl(tlbCode, getParameterFunctionId, fieldName, fieldTypeName, argIndex) {
    return (0, tsgen_1.tFunctionDeclaration)(getParameterFunctionId, (0, tsgen_1.tTypeParametersExpression)([]), (0, tsgen_1.id)("number"), [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)((0, utils_1.findNotReservedName)(fieldName)), (0, tsgen_1.id)(fieldTypeName))], (0, utils_2.getNegationDerivationFunctionBody)(tlbCode, fieldTypeName, argIndex, fieldName));
  }
  complex_expr.negationDerivationFuncDecl = negationDerivationFuncDecl;
  function dictStoreStmt(currentCell, storeParametersInside, keyForStore, valueStore, direct) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeDict" + (direct ? "Direct" : ""))), storeParametersInside.concat([keyForStore, valueStore])));
  }
  complex_expr.dictStoreStmt = dictStoreStmt;
  function dictTypeParamExpr(fieldType, typeParamExpr) {
    return (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)("Dictionary"), (0, tsgen_1.tTypeParametersExpression)([(0, utils_2.isBigIntExpr)(fieldType.key) ? (0, tsgen_1.id)("bigint") : (0, tsgen_1.id)("number"), typeParamExpr]));
  }
  complex_expr.dictTypeParamExpr = dictTypeParamExpr;
  function dictValueStore(typeParamExpr, storeFunctionExpr2, extraStoreFunctionExpr) {
    let subStatements = [
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)(storeFunctionExpr2, [(0, tsgen_1.id)(extraStoreFunctionExpr ? "arg.value" : "arg")]), [
        (0, tsgen_1.id)("builder")
      ]))
    ];
    if (extraStoreFunctionExpr) {
      subStatements = [
        (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)(extraStoreFunctionExpr, [(0, tsgen_1.id)("arg.extra")]), [(0, tsgen_1.id)("builder")]))
      ].concat(subStatements);
    }
    return (0, tsgen_1.tObjectExpression)([
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("serialize"), (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr), (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], subStatements)),
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("parse"), (0, tsgen_1.id)("() => { throw new Error('Not implemented') }"))
    ]);
  }
  complex_expr.dictValueStore = dictValueStore;
  function dictLoadExpr(keyForLoad, loadFunctionExpr, currentSlice, direct) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Dictionary"), (0, tsgen_1.id)("load" + (direct ? "Direct" : ""))), [
      keyForLoad,
      dictValueLoad(loadFunctionExpr),
      (0, tsgen_1.id)(currentSlice)
    ]);
  }
  complex_expr.dictLoadExpr = dictLoadExpr;
  function dictValueLoad(loadFunctionExpr) {
    return (0, tsgen_1.tObjectExpression)([
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("serialize"), (0, tsgen_1.id)("() => { throw new Error('Not implemented') }")),
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("parse"), loadFunctionExpr)
    ]);
  }
  function dictKeyExpr(keyType, ctx, objectId) {
    let param;
    if (objectId) {
      param = (0, utils_2.convertToAST)(keyType.expr, ctx.constructor, (0, tsgen_1.id)(objectId));
    } else {
      param = (0, utils_2.convertToAST)(keyType.expr, ctx.constructor);
    }
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Dictionary.Keys"), (0, utils_2.isBigIntExpr)(keyType) ? (0, tsgen_1.id)("BigUint") : (0, tsgen_1.id)("Uint")), [
      param
    ]);
  }
  complex_expr.dictKeyExpr = dictKeyExpr;
  function dictAugParse(extraLoadExpr, loadExpr) {
    return (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("Slice"))], [
      (0, tsgen_1.tReturnStatement)((0, tsgen_1.tObjectExpression)([
        (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("extra"), extraLoadExpr),
        (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("value"), loadExpr)
      ]))
    ]);
  }
  complex_expr.dictAugParse = dictAugParse;
  function dictAugTypeExpr(typeExpr, extraTypeExpr) {
    return (0, tsgen_1.tStructExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("value"), typeExpr), (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("extra"), extraTypeExpr)]);
  }
  complex_expr.dictAugTypeExpr = dictAugTypeExpr;
  return complex_expr;
}
var hasRequiredGenerator;
function requireGenerator() {
  if (hasRequiredGenerator) return generator;
  hasRequiredGenerator = 1;
  Object.defineProperty(generator, "__esModule", { value: true });
  generator.TypescriptGenerator = void 0;
  const ast_1 = requireAst();
  const utils_1 = requireUtils$2();
  const CodeBuilder_1 = requireCodeBuilder();
  const complex_expr_1 = requireComplex_expr();
  const tsgen_1 = requireTsgen();
  const utils_2 = requireUtils();
  class TypescriptGenerator {
    constructor(tlbCode) {
      this.jsCodeDeclarations = [];
      this.jsCodeConstructorDeclarations = [];
      this.jsCodeFunctionsDeclarations = [];
      this.tlbCode = tlbCode;
    }
    addTonCoreClassUsage(name) {
      this.jsCodeDeclarations.push((0, tsgen_1.tImportDeclaration)((0, tsgen_1.id)(name), (0, tsgen_1.tStringLiteral)("@ton/core")));
    }
    addBuiltinCode() {
      this.addBitLenFunction();
      this.addEmbeddedTypes();
      this.addCopyCellToBuilder();
    }
    addBitLenFunction() {
      this.jsCodeDeclarations.push((0, complex_expr_1.bitlenFunctionDecl)());
    }
    addCopyCellToBuilder() {
      this.jsCodeDeclarations.push((0, tsgen_1.tCodeAsIs)(`export function copyCellToBuilder(from: Cell, to: Builder): void {
    let slice = from.beginParse();
    to.storeBits(slice.loadBits(slice.remainingBits));
    while (slice.remainingRefs) {
        to.storeRef(slice.loadRef());
    }
}`));
    }
    addEmbeddedTypes() {
      this.jsCodeDeclarations.push((0, tsgen_1.tCodeAsIs)(`export interface Bool {
    readonly kind: 'Bool';
    readonly value: boolean;
}

export function loadBool(slice: Slice): Bool {
    if (slice.remainingBits >= 1) {
        let value = slice.loadUint(1);
        return {
            kind: 'Bool',
            value: value == 1
        }

    }
    throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}

export function storeBool(bool: Bool): (builder: Builder) => void {
    return ((builder: Builder) => {
        builder.storeUint(bool.value ? 1: 0, 1);
    })

}



export function loadBoolFalse(slice: Slice): Bool {
  if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
      slice.loadUint(1);
      return {
          kind: 'Bool',
          value: false
      }

  }
  throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}

export function loadBoolTrue(slice: Slice): Bool {
  if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b1))) {
      slice.loadUint(1);
      return {
          kind: 'Bool',
          value: true
      }

  }
  throw new Error('Expected one of "BoolTrue" in loading "BoolTrue", but data does not satisfy any constructor');
}
`));
    }
    addTlbType(tlbType) {
      let typeName = (0, utils_1.findNotReservedName)((0, utils_1.firstLower)(tlbType.name), "0");
      let typeUnion = [];
      let constructorsDeclarations = [];
      let loadStatements = [];
      let storeStatements = [];
      let structTypeParametersExpr = (0, tsgen_1.tTypeParametersExpression)([]);
      tlbType.constructors.forEach((constructor) => {
        let constructorTypeName = (0, utils_1.getSubStructName)(tlbType, constructor);
        let ctx = {
          constructor,
          name: (0, utils_1.findNotReservedName)((0, utils_1.firstLower)(constructorTypeName), "_" + constructor.name),
          typeName,
          loadStatements: [],
          loadProperties: [(0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("kind"), (0, tsgen_1.tStringLiteral)(constructorTypeName))],
          properties: [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("kind"), (0, tsgen_1.tStringLiteral)(constructorTypeName))],
          storeStatements: []
        };
        structTypeParametersExpr = (0, utils_2.getTypeParametersExpression)(constructor.parameters);
        let slicePrefix = [0];
        constructor.variables.forEach((variable) => {
          this.addVarToConstructorLoadProperty(variable, ctx, constructor);
        });
        constructor.fields.forEach((field) => {
          this.handleField(field, slicePrefix, ctx);
        });
        typeUnion.push((0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(constructorTypeName), structTypeParametersExpr));
        let structX = (0, tsgen_1.tStructDeclaration)((0, tsgen_1.id)(constructorTypeName), ctx.properties, structTypeParametersExpr);
        constructor.constraints.forEach((constraint) => {
          this.genCodeForConstraint(constraint, typeName, tlbType, ctx);
        });
        ctx.loadStatements.push((0, tsgen_1.tReturnStatement)((0, tsgen_1.tObjectExpression)(ctx.loadProperties)));
        loadStatements = this.constructorStmtsToTypeStmts(constructor, tlbType, ctx, loadStatements);
        if (constructor.tag.bitLen != 0) {
          ctx.storeStatements.splice(0, 0, (0, complex_expr_1.storeTagExpression)(constructor.tag));
        }
        let storeStatement = (0, complex_expr_1.storeFunctionStmt)(ctx.storeStatements);
        if (tlbType.constructors.length > 1) {
          storeStatement = (0, complex_expr_1.checkKindStmt)(typeName, constructorTypeName, storeStatement);
        }
        storeStatements.push(storeStatement);
        constructorsDeclarations.push(structX);
        this.jsCodeFunctionsDeclarations.push((0, tsgen_1.tComment)(constructor.declaration));
        this.jsCodeConstructorDeclarations.push((0, tsgen_1.tComment)(constructor.declaration));
      });
      this.addExceptionStmts(tlbType, loadStatements, storeStatements);
      let loadFunctionParameters = (0, complex_expr_1.typedSlice)();
      const currentType = (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(tlbType.name), structTypeParametersExpr);
      let storeFunctionParameters = [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(typeName), currentType)];
      this.addFunctionParameters(tlbType, loadFunctionParameters, storeFunctionParameters);
      let loadFunction = (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("load" + tlbType.name), structTypeParametersExpr, currentType, loadFunctionParameters, loadStatements);
      let storeFunction = (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("store" + tlbType.name), structTypeParametersExpr, (0, tsgen_1.id)("(builder: Builder) => void"), storeFunctionParameters, storeStatements);
      if (tlbType.constructors.length > 1) {
        this.jsCodeConstructorDeclarations.push((0, tsgen_1.tUnionTypeDeclaration)(currentType, (0, tsgen_1.tUnionTypeExpression)(typeUnion)));
      }
      constructorsDeclarations.forEach((element) => {
        this.jsCodeConstructorDeclarations.push(element);
      });
      this.jsCodeFunctionsDeclarations.push(loadFunction);
      this.jsCodeFunctionsDeclarations.push(storeFunction);
    }
    addFunctionParameters(tlbType, loadFunctionParameters, storeFunctionParameters) {
      let anyConstructor = tlbType.constructors[0];
      if (anyConstructor) {
        anyConstructor.parameters.forEach((element) => {
          if (element.variable.type == "Type") {
            loadFunctionParameters.push((0, complex_expr_1.loadFunctionParam)(element.variable.name));
            storeFunctionParameters.push((0, complex_expr_1.storeFunctionParam)(element.variable.name));
          }
          if (element.variable.type == "#" && !element.variable.negated) {
            if (element.argName) {
              loadFunctionParameters.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(element.argName), (0, tsgen_1.id)("number")));
            } else {
              loadFunctionParameters.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(element.variable.name), (0, tsgen_1.id)("number")));
            }
          }
        });
      } else {
        throw new Error(`Type ${tlbType.name} should have at least one constructor`);
      }
    }
    addExceptionStmts(tlbType, loadStatements, storeStatements) {
      var _a2;
      let exceptionTypesComment = tlbType.constructors.map((constructor) => {
        return `"${(0, utils_1.getSubStructName)(tlbType, constructor)}"`;
      }).join(", ");
      let exceptionComment = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)(`throw new Error('Expected one of ${exceptionTypesComment} in loading "${tlbType.name}", but data does not satisfy any constructor')`));
      if (tlbType.constructors.length > 1 || ((_a2 = tlbType.constructors.at(0)) === null || _a2 === void 0 ? void 0 : _a2.tag.bitLen) != 0) {
        loadStatements.push(exceptionComment);
      }
      if (tlbType.constructors.length > 1) {
        storeStatements.push(exceptionComment);
      }
    }
    constructorStmtsToTypeStmts(constructor, tlbType, ctx, loadStatements) {
      if (constructor.tag.bitLen != 0 || tlbType.constructors.length > 1) {
        let conditions = [];
        if (constructor.tag.bitLen != 0) {
          conditions.push((0, complex_expr_1.checkHasBitsForTag)(constructor.tag.bitLen));
          conditions.push((0, complex_expr_1.checkTagExpr)(constructor.tag));
          let loadBitsStatement = [(0, complex_expr_1.skipTagStmt)(constructor.tag.bitLen)];
          ctx.loadStatements = loadBitsStatement.concat(ctx.loadStatements);
        }
        constructor.parameters.forEach((param) => {
          if (param.variable.isConst && !param.variable.negated) {
            let argName = param.variable.name;
            if (param.argName) {
              argName = param.argName;
            }
            conditions.push((0, complex_expr_1.tEqualExpression)((0, tsgen_1.id)(argName), (0, utils_2.getParamVarExpr)(param, constructor)));
          }
        });
        loadStatements.push((0, tsgen_1.tIfStatement)((0, utils_2.getCondition)(conditions), ctx.loadStatements));
      } else {
        loadStatements = loadStatements.concat(ctx.loadStatements);
      }
      return loadStatements;
    }
    genCodeForConstraint(constraint, variableCombinatorName, tlbType, ctx) {
      let loadConstraintAST = (0, utils_2.convertToAST)(constraint, ctx.constructor);
      let storeConstraintAST = (0, utils_2.convertToAST)(constraint, ctx.constructor, (0, tsgen_1.id)(variableCombinatorName));
      let exceptionCommentLastPart = ` is not satisfied while loading "${(0, utils_1.getSubStructName)(tlbType, ctx.constructor)}" for type "${tlbType.name}"`;
      ctx.loadStatements.push((0, complex_expr_1.checkConstraintStmt)(loadConstraintAST, exceptionCommentLastPart));
      ctx.storeStatements.push((0, complex_expr_1.checkConstraintStmt)(storeConstraintAST, exceptionCommentLastPart));
    }
    addVarToConstructorLoadProperty(variable, ctx, constructor) {
      let varExpr = void 0;
      if (variable.negated) {
        if (variable.deriveExpr) {
          varExpr = (0, utils_2.convertToAST)(variable.deriveExpr, constructor);
        }
      }
      if (variable.type == "#" && !variable.isField) {
        const isOptional = this.isOptionalVariable(variable, ctx);
        ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(variable.name), (0, tsgen_1.id)("number"), isOptional));
        let parameter = constructor.parametersMap.get(variable.name);
        if (parameter && !parameter.variable.isConst && !parameter.variable.negated) {
          varExpr = (0, utils_2.getParamVarExpr)(parameter, constructor);
        }
      }
      if (varExpr) {
        ctx.loadProperties.push((0, tsgen_1.tObjectProperty)((0, tsgen_1.id)(variable.name), varExpr));
      }
    }
    toCode(node, code = new CodeBuilder_1.CodeBuilder()) {
      return (0, tsgen_1.toCode)(node, code);
    }
    handleField(field, slicePrefix, ctx) {
      let currentSlice = (0, utils_1.getCurrentSlice)(slicePrefix, "slice");
      let currentCell = (0, utils_1.getCurrentSlice)(slicePrefix, "cell");
      if (field.subFields.length > 0) {
        (0, complex_expr_1.inSeparateRef)(slicePrefix, () => {
          ctx.loadStatements.push((0, complex_expr_1.sliceLoad)(slicePrefix, currentSlice));
          ctx.storeStatements.push((0, complex_expr_1.newCellStmt)(slicePrefix));
          field.subFields.forEach((fieldDef) => {
            this.handleField(fieldDef, slicePrefix, ctx);
          });
          ctx.storeStatements.push((0, complex_expr_1.storeRefStmt)(slicePrefix, currentCell));
        });
      }
      if (field.fieldType.kind == "TLBExoticType") {
        (0, complex_expr_1.inSeparateRef)(slicePrefix, () => {
          ctx.loadStatements.push((0, complex_expr_1.loadRefStmt)(slicePrefix, currentSlice));
          (0, utils_2.addLoadProperty)(field.name, (0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), void 0, ctx);
          ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(field.name), (0, tsgen_1.id)("Cell")));
          ctx.storeStatements.push((0, complex_expr_1.storeRefObjectStmt)(currentCell, ctx, field));
        });
      } else if (field.subFields.length == 0) {
        let fieldInfo = this.handleType(field, field.fieldType, true, ctx, slicePrefix, 0);
        if (fieldInfo.loadExpr) {
          (0, utils_2.addLoadProperty)(field.name, fieldInfo.loadExpr, fieldInfo.typeParamExpr, ctx);
        }
        if (fieldInfo.typeParamExpr) {
          ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(field.name), fieldInfo.typeParamExpr));
        }
        if (fieldInfo.storeStmtOutside) {
          ctx.storeStatements.push(fieldInfo.storeStmtOutside);
        }
        fieldInfo.negatedVariablesLoads.forEach((element) => {
          (0, utils_2.addLoadProperty)(element.name, element.expression, void 0, ctx);
        });
      }
    }
    handleType(field, fieldType, isField, ctx, slicePrefix, argIndex) {
      let currentSlice = (0, utils_1.getCurrentSlice)(slicePrefix, "slice");
      let currentCell = (0, utils_1.getCurrentSlice)(slicePrefix, "cell");
      let fieldName = field.name;
      let theSlice = "slice";
      let theCell = "builder";
      if (isField) {
        theSlice = currentSlice;
        theCell = currentCell;
      }
      let result = {
        typeParamExpr: void 0,
        loadExpr: void 0,
        loadFunctionExpr: void 0,
        storeStmtOutside: void 0,
        storeStmtInside: void 0,
        storeFunctionExpr: void 0,
        negatedVariablesLoads: []
      };
      let exprForParam;
      let storeParametersOutside;
      storeParametersOutside = [(0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(ctx.typeName), (0, tsgen_1.id)(fieldName))];
      let storeParametersInside = [(0, tsgen_1.id)("arg")];
      if (fieldType.kind == "TLBNumberType") {
        exprForParam = {
          argLoadExpr: (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor),
          argStoreExpr: (0, utils_2.convertToAST)(fieldType.storeBits, ctx.constructor, (0, tsgen_1.id)(ctx.typeName)),
          paramType: "number",
          fieldLoadSuffix: fieldType.signed ? "Int" : "Uint",
          fieldStoreSuffix: fieldType.signed ? "Int" : "Uint"
        };
        if ((0, utils_2.isBigInt)(fieldType)) {
          exprForParam.fieldLoadSuffix += "Big";
          exprForParam.paramType = "bigint";
        }
      } else if (fieldType.kind == "TLBBitsType") {
        if (fieldType.bits instanceof ast_1.TLBNumberExpr && fieldType.bits.n == 1) {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "boolean",
            fieldLoadSuffix: "Bit",
            fieldStoreSuffix: "Bit"
          };
        } else {
          let isBuffer2 = (0, utils_2.useBuffer)(fieldType);
          let suffix = isBuffer2 ? "Buffer" : "Bits";
          let argLoadExpr = (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor);
          let argStoreExpr = (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor, (0, tsgen_1.id)(ctx.name));
          if (isBuffer2) {
            argLoadExpr = (0, tsgen_1.tBinaryExpression)(argLoadExpr, "/", (0, tsgen_1.tNumericLiteral)(8));
            argStoreExpr = (0, tsgen_1.tBinaryExpression)(argStoreExpr, "/", (0, tsgen_1.tNumericLiteral)(8));
          }
          exprForParam = {
            argLoadExpr,
            argStoreExpr,
            paramType: isBuffer2 ? "Buffer" : "BitString",
            fieldLoadSuffix: suffix,
            fieldStoreSuffix: suffix
          };
        }
      } else if (fieldType.kind == "TLBCellType") {
        exprForParam = {
          argLoadExpr: (0, tsgen_1.id)(theSlice),
          argStoreExpr: (0, tsgen_1.id)(theSlice),
          paramType: "Cell",
          fieldLoadSuffix: "Ref",
          fieldStoreSuffix: "Slice"
        };
        storeParametersOutside[0] = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(storeParametersOutside[0], (0, tsgen_1.id)("beginParse")), [
          (0, tsgen_1.id)("true")
        ]);
        storeParametersInside[0] = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(storeParametersInside[0], (0, tsgen_1.id)("beginParse")), [
          (0, tsgen_1.id)("true")
        ]);
      } else if (fieldType.kind == "TLBCoinsType") {
        exprForParam = {
          argLoadExpr: void 0,
          argStoreExpr: void 0,
          paramType: "bigint",
          fieldLoadSuffix: "Coins",
          fieldStoreSuffix: "Coins"
        };
      } else if (fieldType.kind == "TLBVarIntegerType") {
        exprForParam = {
          argLoadExpr: (0, utils_2.convertToAST)(fieldType.n, ctx.constructor),
          argStoreExpr: (0, utils_2.convertToAST)(fieldType.n, ctx.constructor, (0, tsgen_1.id)(ctx.name)),
          paramType: "bigint",
          fieldLoadSuffix: fieldType.signed ? "VarIntBig" : "VarUintBig",
          fieldStoreSuffix: fieldType.signed ? "VarInt" : "VarUint"
        };
      } else if (fieldType.kind == "TLBTupleType") {
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("parseTuple"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("asCell")), [])
        ]);
        result.typeParamExpr = (0, tsgen_1.id)("TupleItem[]");
        result.storeStmtInside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("copyCellToBuilder"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("serializeTuple"), storeParametersInside),
          (0, tsgen_1.id)("builder")
        ]));
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("copyCellToBuilder"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("serializeTuple"), storeParametersOutside),
          (0, tsgen_1.id)("builder")
        ]));
      } else if (fieldType.kind == "TLBAddressType") {
        if (fieldType.addrType == "Internal") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "Address",
            fieldLoadSuffix: "Address",
            fieldStoreSuffix: "Address"
          };
        } else if (fieldType.addrType == "External") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "ExternalAddress | null",
            fieldLoadSuffix: "MaybeExternalAddress",
            fieldStoreSuffix: "Address"
          };
        } else if (fieldType.addrType == "Any") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "Address | ExternalAddress | null",
            fieldLoadSuffix: "AddressAny",
            fieldStoreSuffix: "Address"
          };
        } else {
          throw new Error("Address has type other than ['Internal', 'External', 'Any']");
        }
      } else if (fieldType.kind == "TLBExprMathType") {
        result.loadExpr = (0, utils_2.convertToAST)(fieldType.expr, ctx.constructor);
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)(result.loadExpr);
      } else if (fieldType.kind == "TLBNegatedType") {
        let getParameterFunctionId = (0, tsgen_1.id)(ctx.name + "_get_" + fieldType.variableName);
        if (field.fieldType.kind == "TLBNamedType") {
          let fieldTypeName = field.fieldType.name;
          this.jsCodeFunctionsDeclarations.push((0, complex_expr_1.negationDerivationFuncDecl)(this.tlbCode, getParameterFunctionId, fieldName, fieldTypeName, argIndex));
        }
        result.negatedVariablesLoads.push({
          name: fieldType.variableName,
          expression: (0, tsgen_1.tFunctionCall)(getParameterFunctionId, [(0, tsgen_1.id)(fieldName)])
        });
      } else if (fieldType.kind == "TLBNamedType" && fieldType.arguments.length == 0) {
        let typeName = fieldType.name;
        result.typeParamExpr = (0, tsgen_1.id)(typeName);
        if (isField) {
          result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("load" + typeName), [(0, tsgen_1.id)(theSlice)]);
          result.storeStmtOutside = (0, complex_expr_1.storeExpressionNamedType)(typeName, storeParametersOutside, currentCell);
          result.storeStmtInside = (0, complex_expr_1.storeExpressionNamedType)(typeName, storeParametersInside, currentCell);
        } else {
          result.loadExpr = (0, tsgen_1.id)("load" + typeName);
          result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("store" + typeName));
        }
      } else if (fieldType.kind == "TLBCondType") {
        let subExprInfo;
        let conditionExpr;
        subExprInfo = this.handleType(field, fieldType.value, true, ctx, slicePrefix, argIndex);
        conditionExpr = (0, utils_2.convertToAST)(fieldType.condition, ctx.constructor);
        if (subExprInfo.typeParamExpr) {
          result.typeParamExpr = (0, tsgen_1.tUnionTypeExpression)([subExprInfo.typeParamExpr, (0, tsgen_1.id)("undefined")]);
        }
        if (subExprInfo.loadExpr) {
          result.loadExpr = (0, tsgen_1.tTernaryExpression)(conditionExpr, subExprInfo.loadExpr, (0, tsgen_1.id)("undefined"));
        }
        let currentParamOutside = storeParametersOutside[0];
        let currentParamInside = storeParametersInside[0];
        if (currentParamOutside && currentParamInside && subExprInfo.storeStmtOutside) {
          result.storeStmtOutside = (0, complex_expr_1.storeExprCond)(currentParamOutside, subExprInfo.storeStmtOutside);
          result.storeStmtInside = (0, complex_expr_1.storeExprCond)(currentParamInside, subExprInfo.storeStmtOutside);
        }
      } else if (fieldType.kind == "TLBMultipleType") {
        let arrayLength;
        let subExprInfo;
        arrayLength = (0, utils_2.convertToAST)(fieldType.times, ctx.constructor);
        subExprInfo = this.handleType(field, fieldType.value, false, ctx, slicePrefix, argIndex);
        let currentParamOutside = storeParametersOutside[0];
        let currentParamInside = storeParametersInside[0];
        if (subExprInfo.loadExpr) {
          result.loadExpr = (0, complex_expr_1.loadTupleExpr)(arrayLength, subExprInfo.loadExpr);
        }
        if (currentParamOutside && currentParamInside && subExprInfo.typeParamExpr && subExprInfo.storeStmtOutside) {
          if (subExprInfo.storeFunctionExpr && subExprInfo.storeStmtInside) {
            result.storeStmtOutside = (0, complex_expr_1.storeTupleStmt)(currentParamOutside, subExprInfo.storeStmtInside, subExprInfo.typeParamExpr);
            result.storeStmtInside = (0, complex_expr_1.storeTupleStmt)(currentParamInside, subExprInfo.storeStmtInside, subExprInfo.typeParamExpr);
          }
        }
        if (subExprInfo.typeParamExpr) {
          result.typeParamExpr = (0, complex_expr_1.arrayedType)(subExprInfo.typeParamExpr);
        }
      } else if (fieldType.kind == "TLBCellInsideType") {
        let currentCell2 = (0, utils_1.getCurrentSlice)([1, 0], "cell");
        let subExprInfo = this.handleType(field, fieldType.value, true, ctx, [1, 0], argIndex);
        if (subExprInfo.loadExpr) {
          result.typeParamExpr = subExprInfo.typeParamExpr;
          result.storeStmtOutside = subExprInfo.storeStmtOutside;
          result.negatedVariablesLoads = subExprInfo.negatedVariablesLoads;
          result.loadFunctionExpr = (0, complex_expr_1.loadFromNewSlice)(subExprInfo.loadExpr);
          result.loadExpr = (0, tsgen_1.tFunctionCall)(result.loadFunctionExpr, [(0, tsgen_1.id)(theSlice)]);
        }
        if (subExprInfo.storeStmtOutside) {
          result.storeStmtOutside = (0, complex_expr_1.storeInNewCell)(currentCell2, subExprInfo.storeStmtOutside);
        }
        if (subExprInfo.storeStmtInside) {
          result.storeStmtInside = (0, complex_expr_1.storeInNewCell)(currentCell2, subExprInfo.storeStmtInside);
        }
      } else if (fieldType.kind == "TLBBoolType") {
        let loadFunction = "load" + (fieldType.value === void 0 ? "Bool" : fieldType.value ? "BoolTrue" : "BoolFalse");
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)(loadFunction), [(0, tsgen_1.id)("slice")]);
        result.typeParamExpr = (0, tsgen_1.id)("Bool");
        result.storeStmtInside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("storeBool"), storeParametersInside), [(0, tsgen_1.id)("builder")]));
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("storeBool"), storeParametersOutside), [(0, tsgen_1.id)("builder")]));
      } else if (fieldType.kind == "TLBHashmapType") {
        let keyForLoad = (0, complex_expr_1.dictKeyExpr)(fieldType.key, ctx);
        let keyForStore = (0, complex_expr_1.dictKeyExpr)(fieldType.key, ctx, ctx.typeName);
        let subExprInfo = this.handleType(field, fieldType.value, fieldType.extra != void 0, ctx, slicePrefix, argIndex);
        if (subExprInfo.typeParamExpr && subExprInfo.loadFunctionExpr && subExprInfo.storeFunctionExpr) {
          let valueStore;
          if (fieldType.extra && subExprInfo.loadExpr) {
            let extraInfo = this.handleType(field, fieldType.extra, true, ctx, slicePrefix, argIndex);
            if (extraInfo.typeParamExpr) {
              subExprInfo.typeParamExpr = (0, complex_expr_1.dictAugTypeExpr)(subExprInfo.typeParamExpr, extraInfo.typeParamExpr);
            }
            valueStore = (0, complex_expr_1.dictValueStore)(subExprInfo.typeParamExpr, subExprInfo.storeFunctionExpr, extraInfo.storeFunctionExpr);
            if (extraInfo.loadExpr) {
              result.loadExpr = (0, complex_expr_1.dictLoadExpr)(keyForLoad, (0, complex_expr_1.dictAugParse)(extraInfo.loadExpr, subExprInfo.loadExpr), currentSlice, fieldType.directStore);
            }
          } else {
            valueStore = (0, complex_expr_1.dictValueStore)(subExprInfo.typeParamExpr, subExprInfo.storeFunctionExpr);
            result.loadExpr = (0, complex_expr_1.dictLoadExpr)(keyForLoad, subExprInfo.loadFunctionExpr, currentSlice, fieldType.directStore);
          }
          result.typeParamExpr = (0, complex_expr_1.dictTypeParamExpr)(fieldType, subExprInfo.typeParamExpr);
          result.storeStmtInside = (0, complex_expr_1.dictStoreStmt)(currentCell, storeParametersInside, keyForStore, valueStore, fieldType.directStore);
          result.storeStmtOutside = (0, complex_expr_1.dictStoreStmt)(currentCell, storeParametersOutside, keyForStore, valueStore, fieldType.directStore);
        }
      } else if (fieldType.kind == "TLBNamedType" && fieldType.arguments.length) {
        let typeName = fieldType.name;
        let typeExpression = (0, tsgen_1.tTypeParametersExpression)([]);
        let loadFunctionsArray = [];
        let storeFunctionsArray = [];
        let argIndex2 = -1;
        fieldType.arguments.forEach((arg) => {
          argIndex2++;
          let subExprInfo = this.handleType(field, arg, false, ctx, slicePrefix, argIndex2);
          if (subExprInfo.typeParamExpr) {
            typeExpression.typeParameters.push(subExprInfo.typeParamExpr);
          }
          if (subExprInfo.loadFunctionExpr) {
            loadFunctionsArray.push(subExprInfo.loadFunctionExpr);
          }
          if (subExprInfo.storeFunctionExpr) {
            storeFunctionsArray.push(subExprInfo.storeFunctionExpr);
          }
          result.negatedVariablesLoads = result.negatedVariablesLoads.concat(subExprInfo.negatedVariablesLoads);
        });
        result.typeParamExpr = (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(typeName), typeExpression);
        let currentTypeParameters = typeExpression;
        let insideLoadParameters = [(0, tsgen_1.id)(theSlice)];
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("load" + typeName), insideLoadParameters.concat(loadFunctionsArray), currentTypeParameters);
        result.storeStmtOutside = (0, complex_expr_1.storeCombinator)(typeName, storeParametersOutside, storeFunctionsArray, currentTypeParameters, theCell);
        result.storeStmtInside = (0, complex_expr_1.storeCombinator)(typeName, storeParametersInside, storeFunctionsArray, currentTypeParameters, theCell);
        if (exprForParam) {
          result.typeParamExpr = (0, tsgen_1.id)(exprForParam.paramType);
        }
      }
      if (exprForParam) {
        if (exprForParam.paramType != "BitString" && exprForParam.paramType != "Cell") {
          if (exprForParam.argStoreExpr) {
            storeParametersOutside.push(exprForParam.argStoreExpr);
            storeParametersInside.push(exprForParam.argStoreExpr);
          }
        }
        result.loadExpr = (0, complex_expr_1.loadExprForParam)(currentSlice, exprForParam);
        if (exprForParam.paramType == "Cell") {
          result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("asCell")), []);
          result.loadFunctionExpr = (0, complex_expr_1.returnSliceFunc)();
        }
        result.typeParamExpr = (0, tsgen_1.id)(exprForParam.paramType);
        result.storeStmtOutside = (0, complex_expr_1.storeExprForParam)(theCell, exprForParam, storeParametersOutside);
        result.storeStmtInside = (0, complex_expr_1.storeExprForParam)(theCell, exprForParam, storeParametersInside);
      }
      if (result.loadExpr && !result.loadFunctionExpr) {
        result.loadFunctionExpr = (0, complex_expr_1.coverFuncCall)(result.loadExpr);
      }
      if (result.storeStmtOutside && !result.storeFunctionExpr) {
        if (!result.storeStmtInside) {
          result.storeStmtInside = result.storeStmtOutside;
        }
        if (result.typeParamExpr) {
          if (result.storeStmtOutside.type == "ExpressionStatement" && result.storeStmtOutside.expression.type == "FunctionCall" || result.storeStmtOutside.type == "MultiStatement") {
            result.storeFunctionExpr = (0, complex_expr_1.storeFunctionExpr)(result.typeParamExpr, result.storeStmtInside);
          } else {
            if (result.storeStmtOutside.type == "ExpressionStatement") {
              result.storeFunctionExpr = result.storeStmtOutside.expression;
            }
          }
        }
      }
      if (result.storeStmtInside) {
        result.storeStmtInside = Object.assign({}, result.storeStmtInside);
      }
      return result;
    }
    isOptionalVariable(variable, ctx) {
      const usedInStore = this.collectFieldsUsedInStore(ctx);
      const isParameter = ctx.constructor.parameters.some((param) => param.variable.name === variable.name || param.argName === variable.name);
      return !usedInStore.has(variable.name) && !isParameter;
    }
    collectFieldsUsedInStore(ctx) {
      const fieldsUsed = /* @__PURE__ */ new Set();
      for (const stmt of ctx.storeStatements) {
        this.extractFieldReferences(stmt, ctx.typeName, fieldsUsed);
      }
      return fieldsUsed;
    }
    extractFieldReferences(node, typeName, fieldsUsed) {
      if (!node)
        return;
      switch (node.type) {
        case "ExpressionStatement":
          this.extractFieldReferences(node.expression, typeName, fieldsUsed);
          break;
        case "IfStatement":
          this.extractFieldReferences(node.condition, typeName, fieldsUsed);
          if (node.body) {
            node.body.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          }
          if (node.elseBody) {
            node.elseBody.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          }
          break;
        case "MultiStatement":
          node.statements.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          break;
        case "ReturnStatement":
          this.extractFieldReferences(node.returnValue, typeName, fieldsUsed);
          break;
        case "MemberExpression":
          if (node.thisObject.type === "Identifier" && node.thisObject.name === typeName && node.memberName.type === "Identifier") {
            fieldsUsed.add(node.memberName.name);
          }
          this.extractFieldReferences(node.thisObject, typeName, fieldsUsed);
          break;
        case "FunctionCall":
          this.extractFieldReferences(node.functionId, typeName, fieldsUsed);
          node.parameters.forEach((param) => this.extractFieldReferences(param, typeName, fieldsUsed));
          break;
        case "BinaryExpression":
          this.extractFieldReferences(node.left, typeName, fieldsUsed);
          this.extractFieldReferences(node.right, typeName, fieldsUsed);
          break;
        case "UnaryOpExpression":
          this.extractFieldReferences(node.expr, typeName, fieldsUsed);
          break;
        case "TernaryExpression":
          this.extractFieldReferences(node.condition, typeName, fieldsUsed);
          this.extractFieldReferences(node.body, typeName, fieldsUsed);
          this.extractFieldReferences(node.elseBody, typeName, fieldsUsed);
          break;
        case "ArrowFunctionExpression":
          node.body.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          break;
        case "ObjectExpression":
          node.objectValues.forEach((prop) => {
            this.extractFieldReferences(prop.key, typeName, fieldsUsed);
            this.extractFieldReferences(prop.value, typeName, fieldsUsed);
          });
          break;
      }
    }
  }
  generator.TypescriptGenerator = TypescriptGenerator;
  return generator;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1;
  Object.defineProperty(main, "__esModule", { value: true });
  main.generateCode = main.generateCodeWithGenerator = main.getTLBCode = main.getGenerator = main.generateCodeByAST = main.getTLBCodeByAST = void 0;
  const tlb_parser_1 = requireDist$1();
  const fill_constructors_1 = requireFill_constructors();
  const fill_constructors_2 = requireFill_constructors();
  const CodeBuilder_1 = requireCodeBuilder();
  const generator_1 = requireGenerator();
  function getTLBCodeByAST(tree, input) {
    let oldTlbCode = { types: /* @__PURE__ */ new Map() };
    let splittedInput = input.split("\n");
    (0, fill_constructors_2.fillConstructors)(tree.declarations, oldTlbCode, splittedInput);
    return (0, fill_constructors_1.convertCodeToReadonly)(oldTlbCode);
  }
  main.getTLBCodeByAST = getTLBCodeByAST;
  function generateCodeByAST(tree, input, getGenerator2) {
    let tlbCode = getTLBCodeByAST(tree, input);
    let codeGenerator = getGenerator2(tlbCode);
    codeGenerator.addTonCoreClassUsage("Builder");
    codeGenerator.addTonCoreClassUsage("Slice");
    codeGenerator.addTonCoreClassUsage("beginCell");
    codeGenerator.addTonCoreClassUsage("BitString");
    codeGenerator.addTonCoreClassUsage("Cell");
    codeGenerator.addTonCoreClassUsage("Address");
    codeGenerator.addTonCoreClassUsage("ExternalAddress");
    codeGenerator.addTonCoreClassUsage("Dictionary");
    codeGenerator.addTonCoreClassUsage("DictionaryValue");
    codeGenerator.addTonCoreClassUsage("TupleItem");
    codeGenerator.addTonCoreClassUsage("parseTuple");
    codeGenerator.addTonCoreClassUsage("serializeTuple");
    codeGenerator.addBuiltinCode();
    let jsCodeDeclarations = [];
    codeGenerator.jsCodeDeclarations.forEach((declaration) => {
      jsCodeDeclarations.push(declaration);
    });
    tlbCode.types.forEach((tlbType) => {
      codeGenerator.addTlbType(tlbType);
    });
    let generatedCode = "";
    codeGenerator.jsCodeConstructorDeclarations.forEach((element) => {
      jsCodeDeclarations.push(element);
    });
    codeGenerator.jsCodeFunctionsDeclarations.forEach((element) => {
      jsCodeDeclarations.push(element);
    });
    jsCodeDeclarations.forEach((element) => {
      generatedCode += codeGenerator.toCode(element, new CodeBuilder_1.CodeBuilder()).render() + "\n";
    });
    return generatedCode;
  }
  main.generateCodeByAST = generateCodeByAST;
  function getGenerator(resultLanguage) {
    return (tlbCode) => {
      if (resultLanguage == "typescript") {
        return new generator_1.TypescriptGenerator(tlbCode);
      } else {
        throw new Error(`Result language ${resultLanguage} is not supported`);
      }
    };
  }
  main.getGenerator = getGenerator;
  function getTLBCode(input) {
    return getTLBCodeByAST((0, tlb_parser_1.ast)(input), input);
  }
  main.getTLBCode = getTLBCode;
  function generateCodeWithGenerator(input, getGenerator2) {
    return generateCodeByAST((0, tlb_parser_1.ast)(input), input, getGenerator2);
  }
  main.generateCodeWithGenerator = generateCodeWithGenerator;
  function generateCode(input, resultLanguage) {
    return generateCodeWithGenerator(input, getGenerator(resultLanguage));
  }
  main.generateCode = generateCode;
  return main;
}
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  (function(exports) {
    var __createBinding = build && build.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = build && build.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypescriptGenerator = exports.isBigIntExpr = exports.isBigInt = exports.generateCode = exports.generateCodeWithGenerator = exports.getTLBCode = exports.generateCodeByAST = exports.getTLBCodeByAST = void 0;
    __exportStar(requireAst(), exports);
    var main_1 = requireMain();
    Object.defineProperty(exports, "getTLBCodeByAST", { enumerable: true, get: function() {
      return main_1.getTLBCodeByAST;
    } });
    Object.defineProperty(exports, "generateCodeByAST", { enumerable: true, get: function() {
      return main_1.generateCodeByAST;
    } });
    Object.defineProperty(exports, "getTLBCode", { enumerable: true, get: function() {
      return main_1.getTLBCode;
    } });
    Object.defineProperty(exports, "generateCodeWithGenerator", { enumerable: true, get: function() {
      return main_1.generateCodeWithGenerator;
    } });
    Object.defineProperty(exports, "generateCode", { enumerable: true, get: function() {
      return main_1.generateCode;
    } });
    var utils_1 = requireUtils();
    Object.defineProperty(exports, "isBigInt", { enumerable: true, get: function() {
      return utils_1.isBigInt;
    } });
    Object.defineProperty(exports, "isBigIntExpr", { enumerable: true, get: function() {
      return utils_1.isBigIntExpr;
    } });
    var generator_1 = requireGenerator();
    Object.defineProperty(exports, "TypescriptGenerator", { enumerable: true, get: function() {
      return generator_1.TypescriptGenerator;
    } });
  })(build);
  return build;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  Object.defineProperty(common, "__esModule", { value: true });
  common.stringToBits = stringToBits;
  common.bitsToString = bitsToString;
  common.normalizeBitString = normalizeBitString;
  common.toCell = toCell;
  const core_1 = requireDist$2();
  const TLBRuntime_1 = requireTLBRuntime();
  function stringToBits(text) {
    const bytes = Buffer.from(text, "utf-8");
    return new core_1.BitString(bytes, 0, bytes.length * 8);
  }
  function bitsToString(bits) {
    if (bits.length % 8 !== 0) {
      throw new Error("Bits must be at least 8 bits");
    }
    let text = "";
    for (let offset = 0; offset < bits.length; offset += 8) {
      text += String.fromCharCode(parseInt(`0x${bits.substring(offset, 8).toString()}`));
    }
    return text;
  }
  function normalizeBitString(bits) {
    const length = bits.length;
    const newBuffer = Buffer.alloc(Math.ceil(length / 8));
    for (let i = 0; i < length; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitIndex = 7 - i % 8;
      if (bits.at(i)) {
        newBuffer[byteIndex] |= 1 << bitIndex;
      }
    }
    return new core_1.BitString(newBuffer, 0, length);
  }
  function toCell(data) {
    try {
      return { success: true, value: core_1.Cell.fromBase64(data) };
    } catch (_) {
      try {
        return { success: true, value: core_1.Cell.fromHex(data) };
      } catch (_2) {
        return { success: false, error: new TLBRuntime_1.TLBDataError("Bad BoC string") };
      }
    }
  }
  return common;
}
var MathExprEvaluator = {};
var hasRequiredMathExprEvaluator;
function requireMathExprEvaluator() {
  if (hasRequiredMathExprEvaluator) return MathExprEvaluator;
  hasRequiredMathExprEvaluator = 1;
  Object.defineProperty(MathExprEvaluator, "__esModule", { value: true });
  MathExprEvaluator.MathExprEvaluator = void 0;
  const tlb_codegen_1 = requireBuild();
  let MathExprEvaluator$1 = class MathExprEvaluator2 {
    variables;
    constructor(variables = /* @__PURE__ */ new Map()) {
      this.variables = variables;
    }
    static calculateBitsForLessThan(n) {
      if (n <= 0)
        return 0;
      if (n === 1)
        return 0;
      const maxValue = n - 1;
      if (maxValue === 0)
        return 0;
      return Math.ceil(Math.log2(maxValue + 1));
    }
    static calculateBitsForLessThanOrEqual(n) {
      if (n < 0)
        return 0;
      if (n === 0)
        return 0;
      return Math.ceil(Math.log2(n + 1));
    }
    evaluate(expr) {
      if (expr instanceof tlb_codegen_1.TLBNumberExpr) {
        return expr.n;
      }
      if (expr instanceof tlb_codegen_1.TLBVarExpr) {
        const value = this.variables.get(expr.x);
        if (value === void 0) {
          throw new Error(`Variable ${expr.x} is not defined`);
        }
        return value;
      }
      if (expr instanceof tlb_codegen_1.TLBBinaryOp) {
        const left = this.evaluate(expr.left);
        const right = this.evaluate(expr.right);
        switch (expr.operation) {
          case "+":
            return left + right;
          case "-":
            return left - right;
          case "*":
            return left * right;
          case "/":
            return Math.floor(left / right);
          case "%":
            return left % right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case "&":
            return left & right;
          case "|":
            return left | right;
          case "^":
            return left ^ right;
          case "==":
            return left === right ? 1 : 0;
          case "!=":
            return left !== right ? 1 : 0;
          case "<":
            return left < right ? 1 : 0;
          case "<=":
            return left <= right ? 1 : 0;
          case ">":
            return left > right ? 1 : 0;
          case ">=":
            return left >= right ? 1 : 0;
          case "=":
            return left === right ? 1 : 0;
          default:
            throw new Error(`Unknown operation: ${expr.operation}`);
        }
      }
      if (expr instanceof tlb_codegen_1.TLBUnaryOp) {
        const operation = expr.operation;
        switch (operation) {
          case ".": {
            const innerExpr = expr.value;
            if (innerExpr instanceof tlb_codegen_1.TLBBinaryOp && innerExpr.operation === "-") {
              const left = this.evaluate(innerExpr.left);
              const right = this.evaluate(innerExpr.right);
              if (right === 1) {
                return MathExprEvaluator2.calculateBitsForLessThan(left);
              }
              return left - right;
            }
            if (innerExpr instanceof tlb_codegen_1.TLBNumberExpr) {
              return MathExprEvaluator2.calculateBitsForLessThanOrEqual(innerExpr.n);
            }
            return this.evaluate(innerExpr);
          }
          case "-":
            return -this.evaluate(expr.value);
          case "~":
            return ~this.evaluate(expr.value);
          case "!":
            return this.evaluate(expr.value) ? 0 : 1;
          default:
            throw new Error(`Unknown unary operation: ${operation}`);
        }
      }
      throw new Error(`Unsupported expression type: ${typeof expr}`);
    }
  };
  MathExprEvaluator.MathExprEvaluator = MathExprEvaluator$1;
  return MathExprEvaluator;
}
var Result = {};
var hasRequiredResult;
function requireResult() {
  if (hasRequiredResult) return Result;
  hasRequiredResult = 1;
  Object.defineProperty(Result, "__esModule", { value: true });
  Result.error = error2;
  Result.unwrap = unwrap;
  function error2(result) {
    return result instanceof Error ? result : new Error(String(result));
  }
  function unwrap(result) {
    if (result.success) {
      return result.value;
    }
    throw error2(result.error);
  }
  return Result;
}
var hasRequiredTLBRuntime;
function requireTLBRuntime() {
  if (hasRequiredTLBRuntime) return TLBRuntime;
  hasRequiredTLBRuntime = 1;
  Object.defineProperty(TLBRuntime, "__esModule", { value: true });
  TLBRuntime.TLBRuntime = TLBRuntime.TLBDataError = TLBRuntime.TLBSchemaError = TLBRuntime.TLBRuntimeError = void 0;
  TLBRuntime.parseTLB = parseTLB;
  const core_1 = requireDist$2();
  const tlb_codegen_1 = requireBuild();
  const tlb_parser_1 = requireDist$1();
  const common_1 = requireCommon();
  const MathExprEvaluator_1 = requireMathExprEvaluator();
  const Result_1 = requireResult();
  class TLBRuntimeError extends Error {
  }
  TLBRuntime.TLBRuntimeError = TLBRuntimeError;
  class TLBSchemaError extends TLBRuntimeError {
  }
  TLBRuntime.TLBSchemaError = TLBSchemaError;
  class TLBDataError extends TLBRuntimeError {
  }
  TLBRuntime.TLBDataError = TLBDataError;
  function tagKey(tag) {
    return `0b${BigInt(tag.binary).toString(2).padStart(tag.bitLen, "0")}`;
  }
  let TLBRuntime$1 = class TLBRuntime2 {
    schema;
    types;
    lastTypeName;
    config;
    tagMap = /* @__PURE__ */ new Map();
    maxSizeTag = 0;
    constructor(schema2, types, lastTypeName, config = {}) {
      this.schema = schema2;
      this.types = types;
      this.lastTypeName = lastTypeName;
      this.config = config;
      config.autoText = config.autoText || true;
      for (const type of this.types.values()) {
        for (const item of type.constructors) {
          if (item.tag.bitLen > 0) {
            if (item.tag.bitLen > this.maxSizeTag) {
              this.maxSizeTag = item.tag.bitLen;
            }
            const key = tagKey(item.tag);
            this.tagMap.set(key, { type, item });
          }
        }
      }
    }
    static from(schema2, config = {}) {
      try {
        const tree = (0, tlb_parser_1.ast)(schema2);
        const code = (0, tlb_codegen_1.getTLBCodeByAST)(tree, schema2);
        const pared = schema2.split("=");
        const lastTypeName = pared[pared.length - 1].split(";")[0].trim().split(" ")[0].trim();
        return {
          success: true,
          value: new TLBRuntime2(schema2, code.types, lastTypeName, config)
        };
      } catch (error2) {
      }
      return { success: false, error: new TLBSchemaError("Bad Schema") };
    }
    changeSchema(schema2) {
      if (this.schema === schema2) {
        return {
          success: true,
          value: this
        };
      }
      return TLBRuntime2.from(schema2, this.config);
    }
    parseCell(data) {
      return (0, Result_1.unwrap)(this.deserialize(data));
    }
    encodeCell(data) {
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      return (0, Result_1.unwrap)(this.serialize(data)).endCell();
    }
    findByTag(slice) {
      const savedBits = slice.remainingBits;
      const maxLen = Math.min(this.maxSizeTag, savedBits);
      for (let len = maxLen; len >= 1; len--) {
        if (savedBits < len)
          continue;
        const tagValue = slice.preloadUint(len);
        const key = tagKey({
          bitLen: len,
          binary: `0x${tagValue.toString(16)}`
        });
        const type = this.tagMap.get(key);
        if (type) {
          return type;
        }
      }
      return null;
    }
    deserialize(data, findByTag = false) {
      if (typeof data === "string") {
        const result = (0, common_1.toCell)(data);
        if (!result.success) {
          return result;
        }
        data = result.value;
      }
      const slice = data.asSlice();
      if (findByTag) {
        const find = this.findByTag(slice);
        if (find) {
          return this.deserializeConstructor(find.type, find.item, slice);
        }
      }
      const types = Array.from(this.types.keys());
      try {
        const result = this.deserializeByTypeName(this.lastTypeName, slice.clone());
        if (result.success) {
          return result;
        }
      } catch (error2) {
        if (error2 instanceof Error) {
          throw error2;
        } else {
          throw new TLBDataError("Failed to deserialize");
        }
      }
      for (const typeName of types.slice().reverse()) {
        if (typeName === this.lastTypeName)
          continue;
        const result = this.deserializeByTypeName(typeName, slice.clone());
        if (result.success) {
          return result;
        }
      }
      return { success: false, error: new TLBDataError("No matching constructor") };
    }
    // Deserialize data from a Slice based on a TL-B type name
    deserializeByTypeName(typeName, slice) {
      const type = this.types.get(typeName);
      if (!type) {
        return {
          success: false,
          error: new TLBDataError(`Type ${typeName} not found in TL-B schema`)
        };
      }
      return this.deserializeType(type, slice);
    }
    serialize(data) {
      const typeKind = data.kind;
      if (!typeKind) {
        return {
          success: false,
          error: new TLBDataError("Data must by typed")
        };
      }
      return this.serializeByTypeName(typeKind, data);
    }
    // Serialize data to a Builder based on a TL-B type name
    serializeByTypeName(typeKind, data) {
      const sep = typeKind.indexOf("_");
      const typeName = sep === -1 ? typeKind : typeKind.slice(0, sep);
      const type = this.types.get(typeName);
      if (!type) {
        return {
          success: false,
          error: new TLBDataError(`Type ${typeName} not found in TL-B schema`)
        };
      }
      const value = (0, core_1.beginCell)();
      this.serializeType(type, data, value);
      return {
        success: true,
        value
      };
    }
    deserializeType(type, data, args = [], initialVariables) {
      for (const constructor of type.constructors) {
        const prev = data.clone();
        const result = this.deserializeConstructor(type, constructor, prev, args, initialVariables);
        if (result.success) {
          const bitsUsed = data.remainingBits - prev.remainingBits;
          const refsUsed = data.remainingRefs - prev.remainingRefs;
          if (bitsUsed > 0) {
            data.skip(bitsUsed);
          }
          for (let i = 0; i < refsUsed; i++) {
            data.loadRef();
          }
          return result;
        }
      }
      return {
        success: false,
        error: new TLBDataError(`Failed to deserialize type ${type.name} no matching constructor found`)
      };
    }
    deserializeConstructor(type, constructor, slice, args = [], initialVariables) {
      const kind = type.constructors.length > 1 ? `${type.name}_${constructor.name}` : type.name;
      if (constructor.tag.bitLen > 0) {
        const len = constructor.tag.bitLen;
        if (slice.remainingBits < len) {
          return {
            success: false,
            error: new TLBDataError(`Not enough bits to read tag for ${kind}`)
          };
        }
        const preloadedTag = `0b${slice.loadUint(len).toString(2).padStart(len, "0")}`;
        const expectedTag = tagKey(constructor.tag);
        if (preloadedTag !== expectedTag) {
          return {
            success: false,
            error: new TLBDataError(`Failed to deserialize type ${kind}`)
          };
        }
      }
      const variables = new Map(initialVariables);
      if (args.length > 0 && constructor.parameters.length > 0) {
        const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
        for (let i = 0; i < Math.min(args.length, constructor.parameters.length); i++) {
          const param = constructor.parameters[i];
          const arg = args[i];
          let argValue = void 0;
          try {
            if (arg.kind === "TLBExprMathType") {
              argValue = evaluator2.evaluate(arg.initialExpr);
            } else if (arg.kind === "TLBNumberType") {
              argValue = evaluator2.evaluate(arg.bits);
            }
          } catch (error2) {
          }
          if (param.argName && typeof argValue === "number") {
            variables.set(param.argName, argValue);
          }
          try {
            if (param.variable?.name && typeof argValue === "number") {
              const varName = param.variable.name;
              let solved = false;
              if (param.paramExpr) {
                const expr = param.paramExpr;
                let found;
                for (let cand = 0; cand <= 1024; cand++) {
                  const trial = new Map(variables);
                  trial.set(varName, cand);
                  const v2 = new MathExprEvaluator_1.MathExprEvaluator(trial).evaluate(expr);
                  if (v2 === argValue) {
                    found = cand;
                    break;
                  }
                }
                if (typeof found === "number") {
                  variables.set(varName, found);
                  solved = true;
                }
              }
              if (!solved && param.variable.deriveExpr) {
                if (variables.get(varName) === void 0) {
                  let found;
                  for (let cand = 0; cand <= 1024; cand++) {
                    const trial = new Map(variables);
                    trial.set(varName, cand);
                    const v2 = new MathExprEvaluator_1.MathExprEvaluator(trial).evaluate(param.variable.deriveExpr);
                    if (v2 === argValue) {
                      found = cand;
                      break;
                    }
                  }
                  if (typeof found === "number") {
                    variables.set(varName, found);
                    solved = true;
                  }
                }
              }
              if (!solved && !param.variable.negated) {
                variables.set(varName, argValue);
              }
            }
          } catch (error2) {
          }
        }
      }
      if (args.length === 0 && constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable?.type === "#" && !param.variable.negated && !param.variable.isConst) {
              if (slice.remainingBits >= 32) {
                const val = Number(slice.loadUint(32));
                variables.set(param.variable.name, val);
              }
            }
          } catch (error2) {
          }
        }
      }
      if (constructor.fields.length === 0 && constructor.parameters.length === 1 && constructor.parameters[0].variable.type === "#" && variables.get(constructor.parameters[0].variable.name) === void 0 && slice.remainingBits >= 32) {
        try {
          const val = Number(slice.loadUint(32));
          variables.set(constructor.parameters[0].variable.name, val);
        } catch (error2) {
        }
      }
      if (args.length > 0 && constructor.parameters.length === 0 && constructor.variables.length > 0) {
        const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
        const numericVars = constructor.variables.filter((v2) => v2.type === "#");
        for (let i = 0; i < Math.min(args.length, numericVars.length); i++) {
          const v2 = numericVars[i];
          const arg = args[i];
          try {
            let argValue;
            if (arg.kind === "TLBExprMathType") {
              argValue = evaluator2.evaluate(arg.initialExpr);
            } else if (arg.kind === "TLBNumberType") {
              argValue = evaluator2.evaluate(arg.bits);
            }
            if (typeof argValue === "number") {
              variables.set(v2.name, argValue);
            }
          } catch (error2) {
          }
        }
      }
      let value = {
        kind
      };
      for (const field of constructor.fields) {
        if (field.subFields.length > 0) {
          if (slice.remainingRefs === 0) {
            return {
              success: false,
              error: new TLBDataError(`No more references available for field ${field.name}`)
            };
          }
          const ref = slice.loadRef();
          if (field.subFields.length === 1) {
            const subfield = field.subFields[0];
            if (subfield.fieldType.kind === "TLBCellType") {
              value[field.name] = ref;
            } else if (subfield.fieldType.kind === "TLBNamedType") {
              const refSlice = ref.beginParse(true);
              const type2 = this.types.get(subfield.fieldType.name);
              if (type2) {
                let initialSeed;
                if (type2.constructors.length > 0) {
                  const nestedCtor = type2.constructors[0];
                  const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
                  const forwardedArgs = subfield.fieldType.arguments ?? [];
                  const merged = new Map(variables);
                  if (nestedCtor.parameters.length > 0) {
                    for (let i = 0; i < Math.min(forwardedArgs.length, nestedCtor.parameters.length); i++) {
                      const param = nestedCtor.parameters[i];
                      const arg = forwardedArgs[i];
                      try {
                        let argValue;
                        if (arg.kind === "TLBExprMathType") {
                          argValue = evaluator2.evaluate(arg.initialExpr);
                        } else if (arg.kind === "TLBNumberType") {
                          argValue = evaluator2.evaluate(arg.bits);
                        }
                        if (typeof argValue === "number" && param.variable.type === "#" && !param.variable.negated) {
                          merged.set(param.variable.name, argValue);
                        }
                      } catch (error2) {
                      }
                    }
                    initialSeed = merged;
                  }
                }
                const result = this.deserializeType(type2, refSlice, subfield.fieldType.arguments, initialSeed);
                if (result.success) {
                  value[field.name] = result.value;
                } else {
                  return result;
                }
              } else {
                return {
                  success: false,
                  error: new TLBDataError(`Type ${subfield.fieldType.name} not found`)
                };
              }
            } else {
              const refSlice = ref.beginParse(true);
              value[field.name] = this.deserializeField(subfield, refSlice, variables, constructor, args);
            }
          } else {
            const refSlice = ref.beginParse(true);
            const subfields = {};
            for (const subfield of field.subFields) {
              subfields[subfield.name] = this.deserializeField(subfield, refSlice, variables, constructor, args);
            }
            value[field.name] = subfields;
          }
        } else {
          value[field.name] = this.deserializeField(field, slice, variables, constructor, args);
        }
      }
      if (constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable?.name && param.variable.deriveExpr && variables.get(param.variable.name) === void 0) {
              const derived = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(param.variable.deriveExpr);
              variables.set(param.variable.name, derived);
            }
          } catch (error2) {
          }
        }
      }
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      for (const constraint of constructor.constraints) {
        if (evaluator.evaluate(constraint) !== 1) {
          return {
            success: false,
            error: new TLBDataError(`Failed to deserialize type ${kind} due to constraint`)
          };
        }
      }
      if (kind === "ExprType" && typeof value["x"] === "number") {
        value["x"] = BigInt(value["x"]);
      }
      const orderedValue = { kind };
      if (constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable.type === "#" && !param.variable.negated && !param.variable.isConst) {
              const val = variables.get(param.variable.name);
              if (typeof val === "number") {
                orderedValue[param.variable.name] = val;
              }
            }
          } catch (error2) {
          }
        }
      } else if (constructor.variables.length > 0) {
        const fieldNamesSet = new Set(constructor.fields.map((f2) => f2.name));
        for (const v2 of constructor.variables) {
          try {
            if (v2.type === "#" && !v2.negated && !v2.isConst && !fieldNamesSet.has(v2.name)) {
              const val = variables.get(v2.name);
              if (typeof val === "number") {
                orderedValue[v2.name] = val;
              }
            }
          } catch (error2) {
          }
        }
      }
      if (Object.keys(orderedValue).length === 1 && constructor.parameters.length === 0 && constructor.variables.filter((v2) => v2.type === "#").length === 1) {
        const v2 = constructor.variables.find((vv) => vv.type === "#");
        const val = variables.get(v2.name);
        if (typeof val === "number") {
          orderedValue[v2.name] = val;
        }
      }
      const fieldNames = constructor.fields.map((f2) => f2.name).sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      for (const name of fieldNames) {
        orderedValue[name] = value[name];
      }
      return {
        success: true,
        value: orderedValue
      };
    }
    deserializeField(field, slice, variables, ctxConstructor, ctxArgs) {
      const value = this.deserializeFieldType(field.fieldType, slice, variables, ctxConstructor, ctxArgs);
      if (field.name && (field.fieldType.kind === "TLBNumberType" || field.fieldType.kind === "TLBVarIntegerType" || field.fieldType.kind === "TLBBoolType")) {
        variables.set(field.name, Number(value));
      }
      if (value && typeof value === "object") {
        for (const param of ctxConstructor.parameters) {
          if (param.variable?.type === "#" && !param.variable.negated && variables.get(param.variable.name) === void 0) {
            const extracted = this.extractNumericProperty(value, param.variable.name);
            if (typeof extracted === "number") {
              variables.set(param.variable.name, extracted);
            }
          }
        }
      }
      return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    extractNumericProperty(obj, name) {
      if (!obj || typeof obj !== "object")
        return void 0;
      if (typeof obj[name] === "number")
        return obj[name];
      for (const key of Object.keys(obj)) {
        const v2 = obj[key];
        if (v2 && typeof v2 === "object") {
          const r = this.extractNumericProperty(v2, name);
          if (typeof r === "number")
            return r;
        }
      }
      return void 0;
    }
    deserializeFieldType(fieldType, slice, variables, ctxConstructor, ctxArgs) {
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      switch (fieldType.kind) {
        case "TLBNumberType": {
          let bits;
          try {
            bits = evaluator.evaluate(fieldType.bits);
          } catch (e) {
            let rebound = false;
            if (ctxConstructor?.parameters?.length && ctxArgs?.length) {
              for (let i = 0; i < Math.min(ctxConstructor.parameters.length, ctxArgs.length); i++) {
                const p2 = ctxConstructor.parameters[i];
                const a2 = ctxArgs[i];
                if (p2.variable?.type === "#") {
                  try {
                    let val2;
                    if (a2.kind === "TLBExprMathType") {
                      val2 = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(a2.initialExpr);
                    } else if (a2.kind === "TLBNumberType") {
                      val2 = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(a2.bits);
                    }
                    if (typeof val2 === "number") {
                      variables.set(p2.variable.name, val2);
                      rebound = true;
                    }
                  } catch {
                  }
                }
              }
              if (rebound) {
                bits = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(fieldType.bits);
              } else {
                throw e;
              }
            } else {
              throw e;
            }
          }
          const val = this.loadBigInt(slice, bits, fieldType.signed);
          const maxBits = fieldType.maxBits;
          const preferNumber = maxBits !== void 0 ? maxBits <= 32 : false;
          if (!preferNumber && bits > 32) {
            return val;
          }
          if (preferNumber || bits <= 32) {
            return Number(val);
          }
          return val;
        }
        case "TLBBoolType": {
          if (fieldType.value !== void 0) {
            return fieldType.value;
          }
          return slice.loadBit();
        }
        case "TLBBitsType": {
          const bits = evaluator.evaluate(fieldType.bits);
          const raw = slice.loadBits(bits);
          if (this.config.autoText && bits % 8 === 0) {
            return (0, common_1.bitsToString)(raw);
          }
          if (bits === 1) {
            return raw.at(0);
          }
          return (0, common_1.normalizeBitString)(raw);
        }
        case "TLBNamedType": {
          const p2 = ctxConstructor.parametersMap.get(fieldType.name);
          if (p2 && p2.variable.type === "Type") {
            const paramIndex = ctxConstructor.parameters.findIndex((pp) => pp.variable.name === p2.variable.name);
            if (paramIndex >= 0 && ctxArgs[paramIndex]) {
              return this.deserializeFieldType(ctxArgs[paramIndex], slice, variables, ctxConstructor, ctxArgs);
            }
          }
          if (fieldType.name === "Bool") {
            return slice.loadBit();
          }
          if (fieldType.name === "Any") {
            const b2 = (0, core_1.beginCell)();
            const bitsLeft = slice.remainingBits;
            if (bitsLeft > 0) {
              b2.storeBits(slice.loadBits(bitsLeft));
            }
            while (slice.remainingRefs > 0) {
              b2.storeRef(slice.loadRef());
            }
            return b2.endCell();
          }
          const type = this.types.get(fieldType.name);
          if (!type) {
            throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
          }
          const forwardedArgs = fieldType.arguments ?? [];
          let childVars = new Map(variables);
          if (type.constructors.length > 0 && forwardedArgs.length > 0) {
            const nestedCtor = type.constructors[0];
            const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(childVars);
            const max = Math.min(forwardedArgs.length, nestedCtor.parameters.length);
            for (let i = 0; i < max; i++) {
              const param = nestedCtor.parameters[i];
              const arg = forwardedArgs[i];
              if (param.variable?.type === "#") {
                try {
                  let val;
                  if (arg.kind === "TLBExprMathType") {
                    val = evaluator2.evaluate(arg.initialExpr);
                  } else if (arg.kind === "TLBNumberType") {
                    val = evaluator2.evaluate(arg.bits);
                  }
                  if (typeof val === "number") {
                    childVars.set(param.variable.name, val);
                  }
                } catch (error2) {
                }
              }
            }
          }
          return (0, Result_1.unwrap)(this.deserializeType(type, slice, forwardedArgs, childVars));
        }
        case "TLBCoinsType": {
          return slice.loadCoins();
        }
        case "TLBAddressType": {
          if (slice.preloadUint(2) !== 2) {
            if (slice.remainingBits === 2) {
              return null;
            }
            const type = slice.loadUint(2);
            if (type === 1) {
              const bits = slice.loadUint(9);
              return new core_1.ExternalAddress(slice.loadUintBig(bits), bits);
            }
          }
          return slice.loadAddress();
        }
        case "TLBCellType": {
          return slice.asCell();
        }
        case "TLBCellInsideType": {
          if (slice.remainingRefs === 0) {
            throw new TLBDataError("No more references available for TLBCellInsideType");
          }
          const ref = slice.loadRef();
          if (fieldType.value.kind === "TLBCellType") {
            return ref;
          }
          const refSlice = ref.beginParse();
          return this.deserializeFieldType(fieldType.value, refSlice, variables, ctxConstructor, ctxArgs);
        }
        case "TLBHashmapType": {
          const keySize = evaluator.evaluate(fieldType.key.expr);
          const parseValue = (sl) => this.deserializeFieldType(fieldType.value, sl, new Map(variables), ctxConstructor, ctxArgs);
          const emptyBig = () => core_1.Dictionary.empty(core_1.Dictionary.Keys.BigUint(keySize));
          const emptyNum = () => core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(keySize));
          if (keySize > 32) {
            const dict = fieldType.directStore ? slice.loadDictDirect(core_1.Dictionary.Keys.BigUint(keySize), {
              serialize: () => {
              },
              parse: parseValue
            }) : slice.loadDict(core_1.Dictionary.Keys.BigUint(keySize), { serialize: () => {
            }, parse: parseValue });
            return dict.size === 0 ? emptyBig() : dict;
          } else {
            const dict = fieldType.directStore ? slice.loadDictDirect(core_1.Dictionary.Keys.Uint(keySize), {
              serialize: () => {
              },
              parse: parseValue
            }) : slice.loadDict(core_1.Dictionary.Keys.Uint(keySize), { serialize: () => {
            }, parse: parseValue });
            return dict.size === 0 ? emptyNum() : dict;
          }
        }
        case "TLBVarIntegerType": {
          const size = evaluator.evaluate(fieldType.n);
          if (fieldType.signed) {
            return slice.loadVarIntBig(size);
          } else {
            return slice.loadVarUintBig(size);
          }
        }
        case "TLBMultipleType": {
          const times = evaluator.evaluate(fieldType.times);
          const result = [];
          for (let i = 0; i < times; i++) {
            result.push(this.deserializeFieldType(fieldType.value, slice, variables, ctxConstructor, ctxArgs));
          }
          return result;
        }
        case "TLBCondType": {
          const condition = evaluator.evaluate(fieldType.condition);
          if (condition) {
            return this.deserializeFieldType(fieldType.value, slice, variables, ctxConstructor, ctxArgs);
          }
          return void 0;
        }
        case "TLBTupleType": {
          const cell = slice.loadRef();
          return (0, core_1.parseTuple)(cell);
        }
        default:
          throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
      }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeType(type, data, builder2) {
      const typeKind = data.kind;
      if (!typeKind) {
        throw new TLBDataError("Data must by typed");
      }
      const constructorName = typeKind.substring(type.name.length + 1);
      let constructor;
      if (constructorName) {
        constructor = type.constructors.find((c) => c.name === constructorName);
      } else if (type.constructors.length > 0) {
        constructor = type.constructors[0];
      }
      if (!constructor) {
        throw new TLBDataError(`Constructor not found for type ${typeKind}`);
      }
      if (constructor.tag.bitLen > 0) {
        const tag = BigInt(constructor.tag.binary);
        builder2.storeUint(tag, constructor.tag.bitLen);
      }
      const variables = /* @__PURE__ */ new Map();
      for (const field of constructor.fields) {
        if (!field.anonymous) {
          this.serializeField(field, data[field.name], builder2, variables);
        } else {
          this.serializeField(field, null, builder2, variables);
        }
      }
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      for (const constraint of constructor.constraints) {
        if (evaluator.evaluate(constraint) !== 1) {
          throw new TLBDataError(`Constraint failed for type ${type.name}, constructor ${constructor.name}`);
        }
      }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeField(field, value, builder2, variables) {
      if (field.name && (field.fieldType.kind === "TLBNumberType" || field.fieldType.kind === "TLBVarIntegerType" || field.fieldType.kind === "TLBBoolType")) {
        variables.set(field.name, Number(value));
      }
      this.serializeFieldType(field.fieldType, value, builder2, variables);
    }
    serializeFieldType(fieldType, value, builder2, variables) {
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      switch (fieldType.kind) {
        case "TLBNumberType": {
          const bits = evaluator.evaluate(fieldType.bits);
          builder2.storeUint(value, bits);
          break;
        }
        case "TLBBoolType": {
          if (fieldType.value !== void 0) {
            break;
          }
          builder2.storeBit(value ? 1 : 0);
          break;
        }
        case "TLBBitsType": {
          if (typeof value === "string") {
            value = (0, common_1.stringToBits)(value);
          }
          if (value instanceof core_1.BitString) {
            builder2.storeBits(value);
          }
          break;
        }
        case "TLBNamedType": {
          const type = this.types.get(fieldType.name);
          if (!type) {
            throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
          }
          this.serializeType(type, value, builder2);
          break;
        }
        case "TLBCoinsType": {
          builder2.storeCoins(value);
          break;
        }
        case "TLBAddressType": {
          if (typeof value === "string") {
            value = core_1.Address.parse(value);
          }
          builder2.storeAddress(value);
          break;
        }
        case "TLBCellType": {
          builder2.storeRef(value);
          break;
        }
        case "TLBCellInsideType": {
          const nestedBuilder = (0, core_1.beginCell)();
          this.serializeFieldType(fieldType.value, value, nestedBuilder, variables);
          builder2.storeRef(nestedBuilder.endCell());
          break;
        }
        case "TLBHashmapType": {
          const keySize = evaluator.evaluate(fieldType.key.expr);
          const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.BigInt(keySize), core_1.Dictionary.Values.Cell());
          if (value) {
            for (const [key, dictValue] of Object.entries(value)) {
              const valueBuilder = (0, core_1.beginCell)();
              this.serializeFieldType(fieldType.value, dictValue, valueBuilder, new Map(variables));
              dict.set(BigInt(key), valueBuilder.endCell());
            }
          }
          builder2.storeDict(dict);
          break;
        }
        case "TLBVarIntegerType": {
          const size = evaluator.evaluate(fieldType.n);
          if (fieldType.signed) {
            builder2.storeVarInt(value, size);
          } else {
            builder2.storeVarUint(value, size);
          }
          break;
        }
        case "TLBMultipleType": {
          const times = evaluator.evaluate(fieldType.times);
          for (let i = 0; i < times; i++) {
            this.serializeFieldType(fieldType.value, value[i], builder2, variables);
          }
          break;
        }
        case "TLBCondType": {
          const condition = evaluator.evaluate(fieldType.condition);
          if (condition) {
            this.serializeFieldType(fieldType.value, value, builder2, variables);
          }
          break;
        }
        case "TLBTupleType": {
          const cell = (0, core_1.serializeTuple)(value);
          builder2.storeRef(cell);
          break;
        }
        default:
          throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
      }
    }
    loadBigInt(slice, bits, signed = false) {
      if (signed) {
        return slice.loadIntBig(bits);
      }
      return slice.loadUintBig(bits);
    }
  };
  TLBRuntime.TLBRuntime = TLBRuntime$1;
  function parseTLB(schema2) {
    return (0, Result_1.unwrap)(TLBRuntime$1.from(schema2));
  }
  return TLBRuntime;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  Object.defineProperty(parser, "__esModule", { value: true });
  parser.parseCell = parseCell;
  parser.encodeCell = encodeCell;
  parser.replacer = replacer;
  const core_1 = requireDist$2();
  const TLBRuntime_1 = requireTLBRuntime();
  function parseCell(schema2, data) {
    return (0, TLBRuntime_1.parseTLB)(schema2).parseCell(data);
  }
  function encodeCell(schema2, data) {
    return (0, TLBRuntime_1.parseTLB)(schema2).encodeCell(data);
  }
  function replacer(_key, value) {
    if (typeof value === "bigint") {
      return value.toString();
    } else if (value instanceof core_1.Address) {
      return value.toString();
    } else if (value instanceof core_1.BitString) {
      return value.toString();
    } else if (value instanceof core_1.Cell) {
      return value.toBoc().toString("base64");
    }
    return value;
  }
  return parser;
}
var schema = {};
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  Object.defineProperty(schema, "__esModule", { value: true });
  schema.blockSchema = void 0;
  schema.blockSchema = `// https://github.com/ton-blockchain/ton/raw/774371bdc9f6107fd05106c1fd559e8903e0513d/crypto/block/block.tlb
unit$_ = Unit;
true$_ = True;
// EMPTY False;
bool_false$0 = Bool;
bool_true$1 = Bool;
bool_false$0 = BoolFalse;
bool_true$1 = BoolTrue;
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;
pair$_ {X:Type} {Y:Type} first:X second:Y = Both X Y;

bit$_ (## 1) = Bit;
/*
 *
 *   FROM hashmap.tlb
 *
 */
// ordinary Hashmap / HashmapE, with fixed length keys
//
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;

// true#_ = True;
_ {n:#} _:(Hashmap n True) = BitstringSet n;

//  HashmapAug, hashmap with an extra value 
//   (augmentation) of type Y at every node
//
ahm_edge#_ {n:#} {X:Type} {Y:Type} {l:#} {m:#} 
  label:(HmLabel ~l n) {n = (~m) + l} 
  node:(HashmapAugNode m X Y) = HashmapAug n X Y;
ahmn_leaf#_ {X:Type} {Y:Type} extra:Y value:X = HashmapAugNode 0 X Y;
ahmn_fork#_ {n:#} {X:Type} {Y:Type} left:^(HashmapAug n X Y)
  right:^(HashmapAug n X Y) extra:Y = HashmapAugNode (n + 1) X Y;

ahme_empty$0 {n:#} {X:Type} {Y:Type} extra:Y 
          = HashmapAugE n X Y;
ahme_root$1 {n:#} {X:Type} {Y:Type} root:^(HashmapAug n X Y) 
  extra:Y = HashmapAugE n X Y;

// VarHashmap / VarHashmapE, with variable-length keys
//
vhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
           {n = (~m) + l} node:(VarHashmapNode m X) 
           = VarHashmap n X;
vhmn_leaf$00 {n:#} {X:Type} value:X = VarHashmapNode n X;
vhmn_fork$01 {n:#} {X:Type} left:^(VarHashmap n X) 
             right:^(VarHashmap n X) value:(Maybe X) 
             = VarHashmapNode (n + 1) X;
vhmn_cont$1 {n:#} {X:Type} branch:Bit child:^(VarHashmap n X) 
            value:X = VarHashmapNode (n + 1) X;

// nothing$0 {X:Type} = Maybe X;
// just$1 {X:Type} value:X = Maybe X;

vhme_empty$0 {n:#} {X:Type} = VarHashmapE n X;
vhme_root$1 {n:#} {X:Type} root:^(VarHashmap n X) 
            = VarHashmapE n X;

//
// PfxHashmap / PfxHashmapE, with variable-length keys
//                           constituting a prefix code
//

phm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
           {n = (~m) + l} node:(PfxHashmapNode m X) 
           = PfxHashmap n X;

phmn_leaf$0 {n:#} {X:Type} value:X = PfxHashmapNode n X;
phmn_fork$1 {n:#} {X:Type} left:^(PfxHashmap n X) 
            right:^(PfxHashmap n X) = PfxHashmapNode (n + 1) X;

phme_empty$0 {n:#} {X:Type} = PfxHashmapE n X;
phme_root$1 {n:#} {X:Type} root:^(PfxHashmap n X) 
            = PfxHashmapE n X;
/*
 *
 *  END hashmap.tlb
 *
 */
//
// TON BLOCK LAYOUT
//
addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len) 
             = MsgAddressExt;
anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;
addr_std$10 anycast:(Maybe Anycast) 
   workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) 
   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;
//
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8)) 
        = VarInteger n;
nanograms$_ amount:(VarUInteger 16) = Grams;

_ grams:Grams = Coins;

//
extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) 
                 = ExtraCurrencyCollection;
currencies$_ grams:Grams other:ExtraCurrencyCollection 
           = CurrencyCollection;
//
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;
ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt 
  import_fee:Grams = CommonMsgInfo;
ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

tick_tock$_ tick:Bool tock:Bool = TickTock;

_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

// StateInitWithLibs is used to validate sent and received messages
_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(HashmapE 256 SimpleLib) = StateInitWithLibs;

simple_lib$_ public:Bool root:^Cell = SimpleLib;

message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

message$_ {X:Type} info:CommonMsgInfoRelaxed
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = MessageRelaxed X;
  
_ (Message Any) = MessageAny;

//
interm_addr_regular$0 use_dest_bits:(#<= 96) 
  = IntermediateAddress;
interm_addr_simple$10 workchain_id:int8 addr_pfx:uint64 
  = IntermediateAddress;
interm_addr_ext$11 workchain_id:int32 addr_pfx:uint64
  = IntermediateAddress;
msg_envelope#4 cur_addr:IntermediateAddress 
  next_addr:IntermediateAddress fwd_fee_remaining:Grams 
  msg:^(Message Any) = MsgEnvelope;
msg_metadata#0 depth:uint32 initiator_addr:MsgAddressInt initiator_lt:uint64 = MsgMetadata;
msg_envelope_v2#5 cur_addr:IntermediateAddress
  next_addr:IntermediateAddress fwd_fee_remaining:Grams
  msg:^(Message Any)
  emitted_lt:(Maybe uint64)
  metadata:(Maybe MsgMetadata) = MsgEnvelope;
//
msg_import_ext$000 msg:^(Message Any) transaction:^Transaction 
              = InMsg;
msg_import_ihr$010 msg:^(Message Any) transaction:^Transaction 
    ihr_fee:Grams proof_created:^Cell = InMsg;
msg_import_imm$011 in_msg:^MsgEnvelope
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_fin$100 in_msg:^MsgEnvelope 
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_tr$101  in_msg:^MsgEnvelope out_msg:^MsgEnvelope 
    transit_fee:Grams = InMsg;
msg_discard_fin$110 in_msg:^MsgEnvelope transaction_id:uint64 
    fwd_fee:Grams = InMsg;
msg_discard_tr$111 in_msg:^MsgEnvelope transaction_id:uint64 
    fwd_fee:Grams proof_delivered:^Cell = InMsg;
msg_import_deferred_fin$00100 in_msg:^MsgEnvelope
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_deferred_tr$00101 in_msg:^MsgEnvelope out_msg:^MsgEnvelope = InMsg;
//
import_fees$_ fees_collected:Grams 
  value_imported:CurrencyCollection = ImportFees;

_ (HashmapAugE 256 InMsg ImportFees) = InMsgDescr;

msg_export_ext$000 msg:^(Message Any)
    transaction:^Transaction = OutMsg;
msg_export_imm$010 out_msg:^MsgEnvelope 
    transaction:^Transaction reimport:^InMsg = OutMsg;
msg_export_new$001 out_msg:^MsgEnvelope 
    transaction:^Transaction = OutMsg;
msg_export_tr$011  out_msg:^MsgEnvelope 
    imported:^InMsg = OutMsg;
msg_export_deq$1100 out_msg:^MsgEnvelope
    import_block_lt:uint63 = OutMsg;
msg_export_deq_short$1101 msg_env_hash:bits256
    next_workchain:int32 next_addr_pfx:uint64
    import_block_lt:uint64 = OutMsg;
msg_export_tr_req$111 out_msg:^MsgEnvelope 
    imported:^InMsg = OutMsg;
msg_export_deq_imm$100 out_msg:^MsgEnvelope 
    reimport:^InMsg = OutMsg;
msg_export_new_defer$10100 out_msg:^MsgEnvelope
    transaction:^Transaction = OutMsg;
msg_export_deferred_tr$10101  out_msg:^MsgEnvelope
    imported:^InMsg = OutMsg;

_ enqueued_lt:uint64 out_msg:^MsgEnvelope = EnqueuedMsg;

_ (HashmapAugE 256 OutMsg CurrencyCollection) = OutMsgDescr;

_ (HashmapAugE 352 EnqueuedMsg uint64) = OutMsgQueue;

processed_upto$_ last_msg_lt:uint64 last_msg_hash:bits256 = ProcessedUpto;
// key is [ shard:uint64 mc_seqno:uint32 ]  
_ (HashmapE 96 ProcessedUpto) = ProcessedInfo;

ihr_pending$_ import_lt:uint64 = IhrPendingSince;
_ (HashmapE 320 IhrPendingSince) = IhrPendingInfo;

// key - created_lt
_ messages:(HashmapE 64 EnqueuedMsg) count:uint48 = AccountDispatchQueue;
// key - sender address, aug - min created_lt
_ (HashmapAugE 256 AccountDispatchQueue uint64) = DispatchQueue;

out_msg_queue_extra#0 dispatch_queue:DispatchQueue out_queue_size:(Maybe uint48) = OutMsgQueueExtra;

_ out_queue:OutMsgQueue proc_info:ProcessedInfo
  extra:(Maybe OutMsgQueueExtra) = OutMsgQueueInfo;

storage_extra_none$000 = StorageExtraInfo;
storage_extra_info$001 dict_hash:uint256 = StorageExtraInfo;

storage_used$_ cells:(VarUInteger 7) bits:(VarUInteger 7) = StorageUsed;

storage_info$_ used:StorageUsed storage_extra:StorageExtraInfo last_paid:uint32
              due_payment:(Maybe Grams) = StorageInfo;

account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;

account_storage$_ last_trans_lt:uint64
    balance:CurrencyCollection state:AccountState 
  = AccountStorage;

account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;

acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;

account_descr$_ account:^Account last_trans_hash:bits256 
  last_trans_lt:uint64 = ShardAccount;

depth_balance$_ split_depth:(#<= 30) balance:CurrencyCollection = DepthBalanceInfo;

_ (HashmapAugE 256 ShardAccount DepthBalanceInfo) = ShardAccounts;

transaction$0111 account_addr:bits256 lt:uint64 
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;

!merkle_update#04 {X:Type} old_hash:bits256 new_hash:bits256 old_depth:uint16 new_depth:uint16
  old:^X new:^X = MERKLE_UPDATE X;
update_hashes#72 {X:Type} old_hash:bits256 new_hash:bits256
  = HASH_UPDATE X;
!merkle_proof#03 {X:Type} virtual_hash:bits256 depth:uint16 virtual_root:^X = MERKLE_PROOF X;

acc_trans#5 account_addr:bits256
            transactions:(HashmapAug 64 ^Transaction CurrencyCollection)
            state_update:^(HASH_UPDATE Account)
          = AccountBlock;

_ (HashmapAugE 256 AccountBlock CurrencyCollection) = ShardAccountBlocks;
//
tr_phase_storage$_ storage_fees_collected:Grams 
  storage_fees_due:(Maybe Grams)
  status_change:AccStatusChange
  = TrStoragePhase;

acst_unchanged$0 = AccStatusChange;  // x -> x
acst_frozen$10 = AccStatusChange;    // init -> frozen
acst_deleted$11 = AccStatusChange;   // frozen -> deleted

tr_phase_credit$_ due_fees_collected:(Maybe Grams)
  credit:CurrencyCollection = TrCreditPhase;

tr_phase_compute_skipped$0 reason:ComputeSkipReason
  = TrComputePhase;
tr_phase_compute_vm$1 success:Bool msg_state_used:Bool 
  account_activated:Bool gas_fees:Grams
  ^[ gas_used:(VarUInteger 7)
  gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
  mode:int8 exit_code:int32 exit_arg:(Maybe int32)
  vm_steps:uint32
  vm_init_state_hash:bits256 vm_final_state_hash:bits256 ]
  = TrComputePhase;
cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10 = ComputeSkipReason;
cskip_suspended$110 = ComputeSkipReason;

tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
  status_change:AccStatusChange
  total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
  result_code:int32 result_arg:(Maybe int32) tot_actions:uint16
  spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16 
  action_list_hash:bits256 tot_msg_size:StorageUsed
  = TrActionPhase;

tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
  req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
  msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
//
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;

trans_storage$0001 storage_ph:TrStoragePhase
  = TransactionDescr;

trans_tick_tock$001 is_tock:Bool storage_ph:TrStoragePhase
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool = TransactionDescr;
//
split_merge_info$_ cur_shard_pfx_len:(## 6)
  acc_split_depth:(## 6) this_addr:bits256 sibling_addr:bits256
  = SplitMergeInfo;
trans_split_prepare$0100 split_info:SplitMergeInfo
  storage_ph:(Maybe TrStoragePhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool
  = TransactionDescr;
trans_split_install$0101 split_info:SplitMergeInfo
  prepare_transaction:^Transaction
  installed:Bool = TransactionDescr;

trans_merge_prepare$0110 split_info:SplitMergeInfo
  storage_ph:TrStoragePhase aborted:Bool
  = TransactionDescr;
trans_merge_install$0111 split_info:SplitMergeInfo
  prepare_transaction:^Transaction
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool
  = TransactionDescr;

smc_info#076ef1ea actions:uint16 msgs_sent:uint16
  unixtime:uint32 block_lt:uint64 trans_lt:uint64 
  rand_seed:bits256 balance_remaining:CurrencyCollection
  myself:MsgAddressInt global_config:(Maybe Cell) = SmartContractInfo;
//
//
out_list_empty$_ = OutList 0;
out_list$_ {n:#} prev:^(OutList n) action:OutAction
  = OutList (n + 1);
action_send_msg#0ec3c86d mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;

out_list_node$_ prev:^Cell action:OutAction = OutListNode;
//
//
shard_ident$00 shard_pfx_bits:(#<= 60) 
  workchain_id:int32 shard_prefix:uint64 = ShardIdent;

ext_blk_ref$_ end_lt:uint64
  seq_no:uint32 root_hash:bits256 file_hash:bits256 
  = ExtBlkRef;

block_id_ext$_ shard_id:ShardIdent seq_no:uint32
  root_hash:bits256 file_hash:bits256 = BlockIdExt;

master_info$_ master:ExtBlkRef = BlkMasterInfo;

shard_state#9023afe2 global_id:int32
  shard_id:ShardIdent 
  seq_no:uint32 vert_seq_no:#
  gen_utime:uint32 gen_lt:uint64
  min_ref_mc_seqno:uint32
  out_msg_queue_info:^OutMsgQueueInfo
  before_split:(## 1)
  accounts:^ShardAccounts
  ^[ overload_history:uint64 underload_history:uint64
  total_balance:CurrencyCollection
  total_validator_fees:CurrencyCollection
  libraries:(HashmapE 256 LibDescr)
  master_ref:(Maybe BlkMasterInfo) ]
  custom:(Maybe ^McStateExtra)
  = ShardStateUnsplit;
  
_ ShardStateUnsplit = ShardState;
split_state#5f327da5 left:^ShardStateUnsplit right:^ShardStateUnsplit = ShardState;

shared_lib_descr$00 lib:^Cell publishers:(Hashmap 256 True)
  = LibDescr;

block_info#9bc7a987 version:uint32 
  not_master:(## 1) 
  after_merge:(## 1) before_split:(## 1) 
  after_split:(## 1) 
  want_split:Bool want_merge:Bool
  key_block:Bool vert_seqno_incr:(## 1)
  flags:(## 8) { flags <= 1 }
  seq_no:# vert_seq_no:# { vert_seq_no >= vert_seqno_incr } 
  { prev_seq_no:# } { ~prev_seq_no + 1 = seq_no } 
  shard:ShardIdent gen_utime:uint32
  start_lt:uint64 end_lt:uint64
  gen_validator_list_hash_short:uint32
  gen_catchain_seqno:uint32
  min_ref_mc_seqno:uint32
  prev_key_block_seqno:uint32
  gen_software:flags . 0?GlobalVersion
  master_ref:not_master?^BlkMasterInfo 
  prev_ref:^(BlkPrevInfo after_merge)
  prev_vert_ref:vert_seqno_incr?^(BlkPrevInfo 0)
  = BlockInfo;

prev_blk_info$_ prev:ExtBlkRef = BlkPrevInfo 0;
prev_blks_info$_ prev1:^ExtBlkRef prev2:^ExtBlkRef = BlkPrevInfo 1;

block#11ef55aa global_id:int32
  info:^BlockInfo value_flow:^ValueFlow
  state_update:^(MERKLE_UPDATE ShardState) 
  extra:^BlockExtra = Block;

block_extra in_msg_descr:^InMsgDescr
  out_msg_descr:^OutMsgDescr
  account_blocks:^ShardAccountBlocks
  rand_seed:bits256
  created_by:bits256
  custom:(Maybe ^McBlockExtra) = BlockExtra;
//
value_flow#b8e48dfb ^[ from_prev_blk:CurrencyCollection 
  to_next_blk:CurrencyCollection
  imported:CurrencyCollection
  exported:CurrencyCollection ]
  fees_collected:CurrencyCollection
  ^[
  fees_imported:CurrencyCollection
  recovered:CurrencyCollection
  created:CurrencyCollection
  minted:CurrencyCollection
  ] = ValueFlow;

value_flow_v2#3ebf98b7 ^[ from_prev_blk:CurrencyCollection
  to_next_blk:CurrencyCollection
  imported:CurrencyCollection
  exported:CurrencyCollection ]
  fees_collected:CurrencyCollection
  burned:CurrencyCollection
  ^[
  fees_imported:CurrencyCollection
  recovered:CurrencyCollection
  created:CurrencyCollection
  minted:CurrencyCollection
  ] = ValueFlow;

//
//
bt_leaf$0 {X:Type} leaf:X = BinTree X;
bt_fork$1 {X:Type} left:^(BinTree X) right:^(BinTree X) 
          = BinTree X;

fsm_none$0 = FutureSplitMerge;
fsm_split$10 split_utime:uint32 interval:uint32 = FutureSplitMerge;
fsm_merge$11 merge_utime:uint32 interval:uint32 = FutureSplitMerge;

shard_descr#b seq_no:uint32 reg_mc_seqno:uint32
  start_lt:uint64 end_lt:uint64
  root_hash:bits256 file_hash:bits256 
  before_split:Bool before_merge:Bool
  want_split:Bool want_merge:Bool
  nx_cc_updated:Bool flags:(## 3) { flags = 0 }
  next_catchain_seqno:uint32 next_validator_shard:uint64
  min_ref_mc_seqno:uint32 gen_utime:uint32
  split_merge_at:FutureSplitMerge
  fees_collected:CurrencyCollection
  funds_created:CurrencyCollection = ShardDescr;

shard_descr_new#a seq_no:uint32 reg_mc_seqno:uint32
  start_lt:uint64 end_lt:uint64
  root_hash:bits256 file_hash:bits256 
  before_split:Bool before_merge:Bool
  want_split:Bool want_merge:Bool
  nx_cc_updated:Bool flags:(## 3) { flags = 0 }
  next_catchain_seqno:uint32 next_validator_shard:uint64
  min_ref_mc_seqno:uint32 gen_utime:uint32
  split_merge_at:FutureSplitMerge
  ^[ fees_collected:CurrencyCollection
     funds_created:CurrencyCollection ] = ShardDescr;

_ (HashmapE 32 ^(BinTree ShardDescr)) = ShardHashes;

bta_leaf$0 {X:Type} {Y:Type} extra:Y leaf:X = BinTreeAug X Y;
bta_fork$1 {X:Type} {Y:Type} left:^(BinTreeAug X Y) 
           right:^(BinTreeAug X Y) extra:Y = BinTreeAug X Y;

_ fees:CurrencyCollection create:CurrencyCollection = ShardFeeCreated;
_ (HashmapAugE 96 ShardFeeCreated ShardFeeCreated) = ShardFees;

_ config_addr:bits256 config:^(Hashmap 32 ^Cell) 
  = ConfigParams;

validator_info$_
  validator_list_hash_short:uint32 
  catchain_seqno:uint32
  nx_cc_updated:Bool
= ValidatorInfo;

validator_base_info$_
  validator_list_hash_short:uint32 
  catchain_seqno:uint32
= ValidatorBaseInfo;

_ key:Bool max_end_lt:uint64 = KeyMaxLt;
_ key:Bool blk_ref:ExtBlkRef = KeyExtBlkRef;

_ (HashmapAugE 32 KeyExtBlkRef KeyMaxLt) = OldMcBlocksInfo;


counters#_ last_updated:uint32 total:uint64 cnt2048:uint64 cnt65536:uint64 = Counters; 
creator_info#4 mc_blocks:Counters shard_blocks:Counters = CreatorStats; 
block_create_stats#17 counters:(HashmapE 256 CreatorStats) = BlockCreateStats;
block_create_stats_ext#34 counters:(HashmapAugE 256 CreatorStats uint32) = BlockCreateStats;

masterchain_state_extra#cc26
  shard_hashes:ShardHashes
  config:ConfigParams
  ^[ flags:(## 16) { flags <= 1 }
     validator_info:ValidatorInfo
     prev_blocks:OldMcBlocksInfo
     after_key_block:Bool
     last_key_block:(Maybe ExtBlkRef)
     block_create_stats:(flags . 0)?BlockCreateStats ]
  global_balance:CurrencyCollection
= McStateExtra;

ed25519_pubkey#8e81278a pubkey:bits256 = SigPubKey;  // 288 bits
ed25519_signature#5 R:bits256 s:bits256 = CryptoSignatureSimple;  // 516 bits
_ CryptoSignatureSimple = CryptoSignature;
sig_pair$_ node_id_short:bits256 sign:CryptoSignature = CryptoSignaturePair;  // 256+x ~ 772 bits

certificate#4 temp_key:SigPubKey valid_since:uint32 valid_until:uint32 = Certificate;  // 356 bits
certificate_env#a419b7d certificate:Certificate = CertificateEnv;  // 384 bits
signed_certificate$_ certificate:Certificate certificate_signature:CryptoSignature
  = SignedCertificate;  // 356+516 = 872 bits
// certificate_signature is the signature of CertificateEnv (with embedded certificate) with persistent key
chained_signature#f signed_cert:^SignedCertificate temp_key_signature:CryptoSignatureSimple
  = CryptoSignature;   // 4+(356+516)+516 = 520 bits+ref (1392 bits total)
// temp_key_signature is the signature of whatever was originally intended to be signed with temp_key from certificate

masterchain_block_extra#cca5
  key_block:(## 1)
  shard_hashes:ShardHashes
  shard_fees:ShardFees
  ^[ prev_blk_signatures:(HashmapE 16 CryptoSignaturePair)
     recover_create_msg:(Maybe ^InMsg)
     mint_msg:(Maybe ^InMsg) ]
  config:key_block?ConfigParams
= McBlockExtra;

//
//  CONFIGURATION PARAMETERS
//

validator#53 public_key:SigPubKey weight:uint64 = ValidatorDescr;
validator_addr#73 public_key:SigPubKey weight:uint64 adnl_addr:bits256 = ValidatorDescr;
validators#11 utime_since:uint32 utime_until:uint32 
  total:(## 16) main:(## 16) { main <= total } { main >= 1 } 
  list:(Hashmap 16 ValidatorDescr) = ValidatorSet;
validators_ext#12 utime_since:uint32 utime_until:uint32 
  total:(## 16) main:(## 16) { main <= total } { main >= 1 } 
  total_weight:uint64 list:(HashmapE 16 ValidatorDescr) = ValidatorSet;

_ config_addr:bits256 = ConfigParam 0;
_ elector_addr:bits256 = ConfigParam 1;
_ minter_addr:bits256 = ConfigParam 2;  // ConfigParam 0 is used if absent
_ fee_collector_addr:bits256 = ConfigParam 3;  // ConfigParam 1 is used if absent
_ dns_root_addr:bits256 = ConfigParam 4;  // root TON DNS resolver

burning_config#01
  blackhole_addr:(Maybe bits256)
  fee_burn_num:# fee_burn_denom:# { fee_burn_num <= fee_burn_denom } { fee_burn_denom >= 1 } = BurningConfig;
_ BurningConfig = ConfigParam 5;

_ mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
_ to_mint:ExtraCurrencyCollection = ConfigParam 7;

capabilities#c4 version:uint32 capabilities:uint64 = GlobalVersion;
_ GlobalVersion = ConfigParam 8;  // all zero if absent
_ mandatory_params:(Hashmap 32 True) = ConfigParam 9;
_ critical_params:(Hashmap 32 True) = ConfigParam 10;

cfg_vote_cfg#36 min_tot_rounds:uint8 max_tot_rounds:uint8 min_wins:uint8 max_losses:uint8 min_store_sec:uint32 max_store_sec:uint32 bit_price:uint32 cell_price:uint32 = ConfigProposalSetup;
cfg_vote_setup#91 normal_params:^ConfigProposalSetup critical_params:^ConfigProposalSetup = ConfigVotingSetup;
_ ConfigVotingSetup = ConfigParam 11;

cfg_proposal#f3 param_id:int32 param_value:(Maybe ^Cell) if_hash_equal:(Maybe uint256) 
  = ConfigProposal;
cfg_proposal_status#ce expires:uint32 proposal:^ConfigProposal is_critical:Bool
  voters:(HashmapE 16 True) remaining_weight:int64 validator_set_id:uint256 
  rounds_remaining:uint8 wins:uint8 losses:uint8 = ConfigProposalStatus;

wfmt_basic#1 vm_version:int32 vm_mode:uint64 = WorkchainFormat 1;
wfmt_ext#0 min_addr_len:(## 12) max_addr_len:(## 12) addr_len_step:(## 12)
  { min_addr_len >= 64 } { min_addr_len <= max_addr_len } 
  { max_addr_len <= 1023 } { addr_len_step <= 1023 }
  workchain_type_id:(## 32) { workchain_type_id >= 1 }
  = WorkchainFormat 0;

wc_split_merge_timings#0
  split_merge_delay:uint32 split_merge_interval:uint32
  min_split_merge_interval:uint32 max_split_merge_delay:uint32
  = WcSplitMergeTimings;

//workchain#a5 enabled_since:uint32 min_split:(## 8) max_split:(## 8)
//  { min_split <= max_split } { max_split <= 60 }

workchain#a6 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  = WorkchainDescr;

workchain_v2#a7 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  split_merge_timings:WcSplitMergeTimings
  persistent_state_split_depth:(## 8) { persistent_state_split_depth <= 63 }
  = WorkchainDescr;

_ workchains:(HashmapE 32 WorkchainDescr) = ConfigParam 12;

complaint_prices#1a deposit:Grams bit_price:Grams cell_price:Grams = ComplaintPricing; 
_ ComplaintPricing = ConfigParam 13;

block_grams_created#6b masterchain_block_fee:Grams basechain_block_fee:Grams
  = BlockCreateFees;
_ BlockCreateFees = ConfigParam 14;

_ validators_elected_for:uint32 elections_start_before:uint32 
  elections_end_before:uint32 stake_held_for:uint32
  = ConfigParam 15;
  
_ max_validators:(## 16) max_main_validators:(## 16) min_validators:(## 16) 
  { max_validators >= max_main_validators } 
  { max_main_validators >= min_validators } 
  { min_validators >= 1 }
  = ConfigParam 16;

_ min_stake:Grams max_stake:Grams min_total_stake:Grams max_stake_factor:uint32 = ConfigParam 17;

_#cc utime_since:uint32 bit_price_ps:uint64 cell_price_ps:uint64 
  mc_bit_price_ps:uint64 mc_cell_price_ps:uint64 = StoragePrices;
_ (Hashmap 32 StoragePrices) = ConfigParam 18;

_ global_id:int32 = ConfigParam 19;

gas_prices#dd gas_price:uint64 gas_limit:uint64 gas_credit:uint64 
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64 
  = GasLimitsPrices;

gas_prices_ext#de gas_price:uint64 gas_limit:uint64 special_gas_limit:uint64 gas_credit:uint64 
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64 
  = GasLimitsPrices;

gas_flat_pfx#d1 flat_gas_limit:uint64 flat_gas_price:uint64 other:GasLimitsPrices
  = GasLimitsPrices;

config_mc_gas_prices#_ GasLimitsPrices = ConfigParam 20;
config_gas_prices#_ GasLimitsPrices = ConfigParam 21;

param_limits#c3 underload:# soft_limit:# { underload <= soft_limit }
  hard_limit:# { soft_limit <= hard_limit } = ParamLimits;
block_limits#5d bytes:ParamLimits gas:ParamLimits lt_delta:ParamLimits
  = BlockLimits;
  
config_mc_block_limits#_ BlockLimits = ConfigParam 22;
config_block_limits#_ BlockLimits = ConfigParam 23;

// msg_fwd_fees = (lump_price + ceil((bit_price * msg.bits + cell_price * msg.cells)/2^16)) nanograms
// ihr_fwd_fees = ceil((msg_fwd_fees * ihr_price_factor)/2^16) nanograms
// bits in the root cell of a message are not included in msg.bits (lump_price pays for them)
msg_forward_prices#ea lump_price:uint64 bit_price:uint64 cell_price:uint64
  ihr_price_factor:uint32 first_frac:uint16 next_frac:uint16 = MsgForwardPrices;

// used for messages to/from masterchain
config_mc_fwd_prices#_ MsgForwardPrices = ConfigParam 24;
// used for all other messages
config_fwd_prices#_ MsgForwardPrices = ConfigParam 25;

catchain_config#c1 mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32 
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;

catchain_config_new#c2 flags:(## 7) { flags = 0 } shuffle_mc_validators:Bool
  mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;

consensus_config#d6 round_candidates:# { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;

consensus_config_new#d7 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;

consensus_config_v3#d8 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 
  proto_version:uint16 = ConsensusConfig;

consensus_config_v4#d9 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32
  proto_version:uint16 catchain_max_blocks_coeff:uint32 = ConsensusConfig;

_ CatchainConfig = ConfigParam 28;
_ ConsensusConfig = ConfigParam 29;

_ fundamental_smc_addr:(HashmapE 256 True) = ConfigParam 31;
_ prev_validators:ValidatorSet = ConfigParam 32;
_ prev_temp_validators:ValidatorSet = ConfigParam 33;
_ cur_validators:ValidatorSet = ConfigParam 34;
_ cur_temp_validators:ValidatorSet = ConfigParam 35;
_ next_validators:ValidatorSet = ConfigParam 36;
_ next_temp_validators:ValidatorSet = ConfigParam 37;

validator_temp_key#3 adnl_addr:bits256 temp_public_key:SigPubKey seqno:# valid_until:uint32 = ValidatorTempKey;
signed_temp_key#4 key:^ValidatorTempKey signature:CryptoSignature = ValidatorSignedTempKey;
_ (HashmapE 256 ValidatorSignedTempKey) = ConfigParam 39;

misbehaviour_punishment_config_v1#01 
  default_flat_fine:Grams default_proportional_fine:uint32
  severity_flat_mult:uint16 severity_proportional_mult:uint16
  unpunishable_interval:uint16
  long_interval:uint16 long_flat_mult:uint16 long_proportional_mult:uint16
  medium_interval:uint16 medium_flat_mult:uint16 medium_proportional_mult:uint16
   = MisbehaviourPunishmentConfig;
_ MisbehaviourPunishmentConfig = ConfigParam 40;

size_limits_config#01 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 = SizeLimitsConfig;
size_limits_config_v2#02 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 max_acc_state_cells:uint32 max_acc_state_bits:uint32
  max_acc_public_libraries:uint32 defer_out_queue_size_limit:uint32 max_msg_extra_currencies:uint32
  max_acc_fixed_prefix_length:uint8 = SizeLimitsConfig;
_ SizeLimitsConfig = ConfigParam 43;

// key is [ wc:int32 addr:uint256 ]
suspended_address_list#00 addresses:(HashmapE 288 Unit) suspended_until:uint32 = SuspendedAddressList;
_ SuspendedAddressList = ConfigParam 44;

precompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc;
precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig;
_ PrecompiledContractsConfig = ConfigParam 45;

oracle_bridge_params#_ bridge_address:bits256 oracle_mutlisig_address:bits256 oracles:(HashmapE 256 uint256) external_chain_address:bits256 = OracleBridgeParams;
_ OracleBridgeParams = ConfigParam 71; // Ethereum bridge
_ OracleBridgeParams = ConfigParam 72; // Binance Smart Chain bridge
_ OracleBridgeParams = ConfigParam 73; // Polygon bridge

// Note that chains in which bridge, minter and jetton-wallet operate are fixated
jetton_bridge_prices#_ bridge_burn_fee:Coins bridge_mint_fee:Coins
                       wallet_min_tons_for_storage:Coins
                       wallet_gas_consumption:Coins
                       minter_min_tons_for_storage:Coins
                       discover_gas_consumption:Coins = JettonBridgePrices;

jetton_bridge_params_v0#00 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 burn_bridge_fee:Coins = JettonBridgeParams;
jetton_bridge_params_v1#01 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 prices:^JettonBridgePrices external_chain_address:bits256 = JettonBridgeParams;

_ JettonBridgeParams = ConfigParam 79; // ETH->TON token bridge
_ JettonBridgeParams = ConfigParam 81; // BNB->TON token bridge
_ JettonBridgeParams = ConfigParam 82; // Polygon->TON token bridge


//
//  PROOFS
//
block_signatures_pure#_ sig_count:uint32 sig_weight:uint64
  signatures:(HashmapE 16 CryptoSignaturePair) = BlockSignaturesPure;
block_signatures#11 validator_info:ValidatorBaseInfo pure_signatures:BlockSignaturesPure = BlockSignatures;
block_proof#c3 proof_for:BlockIdExt root:^Cell signatures:(Maybe ^BlockSignatures) = BlockProof;

chain_empty$_ = ProofChain 0;
chain_link$_ {n:#} root:^Cell prev:n?^(ProofChain n) = ProofChain (n + 1);
top_block_descr#d5 proof_for:BlockIdExt signatures:(Maybe ^BlockSignatures) 
  len:(## 8) { len >= 1 } { len <= 8 } chain:(ProofChain len) = TopBlockDescr;

//
//  COLLATED DATA
//
top_block_descr_set#4ac789f3 collection:(HashmapE 96 ^TopBlockDescr) = TopBlockDescrSet;

//
//  VALIDATOR MISBEHAVIOR COMPLAINTS
//
prod_info#34 utime:uint32 mc_blk_ref:ExtBlkRef state_proof:^(MERKLE_PROOF Block)
  prod_proof:^(MERKLE_PROOF ShardState) = ProducerInfo;
no_blk_gen from_utime:uint32 prod_info:^ProducerInfo = ComplaintDescr;
no_blk_gen_diff prod_info_old:^ProducerInfo prod_info_new:^ProducerInfo = ComplaintDescr;
validator_complaint#bc validator_pubkey:bits256 description:^ComplaintDescr created_at:uint32 severity:uint8 reward_addr:uint256 paid:Grams suggested_fine:Grams suggested_fine_part:uint32 = ValidatorComplaint;
complaint_status#2d complaint:^ValidatorComplaint voters:(HashmapE 16 True) vset_id:uint256 weight_remaining:int64 = ValidatorComplaintStatus;

//
//  TVM REFLECTION
//
vm_stk_null#00 = VmStackValue;
vm_stk_tinyint#01 value:int64 = VmStackValue;
vm_stk_int#0201_ value:int257 = VmStackValue;
vm_stk_nan#02ff = VmStackValue;
vm_stk_cell#03 cell:^Cell = VmStackValue;
_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }
  st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;
vm_stk_slice#04 _:VmCellSlice = VmStackValue;
vm_stk_builder#05 cell:^Cell = VmStackValue;
vm_stk_cont#06 cont:VmCont = VmStackValue;
vm_tupref_nil$_ = VmTupleRef 0;
vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;
vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);
vm_tuple_nil$_ = VmTuple 0;
vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);
vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;

vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;
vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);
vm_stk_nil#_ = VmStackList 0;

_ cregs:(HashmapE 4 VmStackValue) = VmSaveList;
gas_limits#_ remaining:int64 _:^[ max_limit:int64 cur_limit:int64 credit:int64 ]
  = VmGasLimits;
_ libraries:(HashmapE 256 ^Cell) = VmLibraries;

vm_ctl_data$_ nargs:(Maybe uint13) stack:(Maybe VmStack) save:VmSaveList
cp:(Maybe int16) = VmControlData;
vmc_std$00 cdata:VmControlData code:VmCellSlice = VmCont;
vmc_envelope$01 cdata:VmControlData next:^VmCont = VmCont;
vmc_quit$1000 exit_code:int32 = VmCont;
vmc_quit_exc$1001 = VmCont;
vmc_repeat$10100 count:uint63 body:^VmCont after:^VmCont = VmCont; 
vmc_until$110000 body:^VmCont after:^VmCont = VmCont;
vmc_again$110001 body:^VmCont = VmCont;
vmc_while_cond$110010 cond:^VmCont body:^VmCont
after:^VmCont = VmCont;
vmc_while_body$110011 cond:^VmCont body:^VmCont
after:^VmCont = VmCont;
vmc_pushint$1111 value:int32 next:^VmCont = VmCont;

//
//  DNS RECORDS
//
_ (HashmapE 256 ^DNSRecord) = DNS_RecordSet;

chunk_ref$_ {n:#} ref:^(TextChunks (n + 1)) = TextChunkRef (n + 1);
chunk_ref_empty$_ = TextChunkRef 0;
text_chunk$_ {n:#} len:(## 8) data:(bits (len * 8)) next:(TextChunkRef n) = TextChunks (n + 1);
text_chunk_empty$_ = TextChunks 0;
text$_ chunks:(## 8) rest:(TextChunks chunks) = Text;
dns_text#1eda _:Text = DNSRecord;

dns_next_resolver#ba93 resolver:MsgAddressInt = DNSRecord;  // usually in record #-1

dns_adnl_address#ad01 adnl_addr:bits256 flags:(## 8) { flags <= 1 }
  proto_list:flags . 0?ProtoList = DNSRecord;  // often in record #2
proto_list_nil$0 = ProtoList;
proto_list_next$1 head:Protocol tail:ProtoList = ProtoList;
proto_http#4854 = Protocol;

dns_smc_address#9fd3 smc_addr:MsgAddressInt flags:(## 8) { flags <= 1 }
  cap_list:flags . 0?SmcCapList = DNSRecord;   // often in record #1
cap_list_nil$0 = SmcCapList;
cap_list_next$1 head:SmcCapability tail:SmcCapList = SmcCapList;
cap_method_seqno#5371 = SmcCapability;
cap_method_pubkey#71f4 = SmcCapability;
cap_is_wallet#2177 = SmcCapability;
cap_name#ff name:Text = SmcCapability;

dns_storage_address#7473 bag_id:bits256 = DNSRecord;

//
// PAYMENT CHANNELS
//

chan_config$_  init_timeout:uint32 close_timeout:uint32 a_key:bits256 b_key:bits256 
  a_addr:^MsgAddressInt b_addr:^MsgAddressInt channel_id:uint64 min_A_extra:Grams = ChanConfig;

chan_state_init$000  signed_A:Bool signed_B:Bool min_A:Grams min_B:Grams expire_at:uint32 A:Grams B:Grams = ChanState;
chan_state_close$001 signed_A:Bool signed_B:Bool promise_A:Grams promise_B:Grams expire_at:uint32 A:Grams B:Grams = ChanState;
chan_state_payout$010 A:Grams B:Grams = ChanState;

chan_promise$_ channel_id:uint64 promise_A:Grams promise_B:Grams = ChanPromise;
chan_signed_promise#_ sig:(Maybe ^bits512) promise:ChanPromise = ChanSignedPromise;

chan_msg_init#27317822 inc_A:Grams inc_B:Grams min_A:Grams min_B:Grams channel_id:uint64 = ChanMsg;
chan_msg_close#f28ae183 extra_A:Grams extra_B:Grams promise:ChanSignedPromise  = ChanMsg;
chan_msg_timeout#43278a28 = ChanMsg;
chan_msg_payout#37fe7810 = ChanMsg;

chan_signed_msg$_ sig_A:(Maybe ^bits512) sig_B:(Maybe ^bits512) msg:ChanMsg = ChanSignedMsg;

chan_op_cmd#912838d1 msg:ChanSignedMsg = ChanOp;


chan_data$_ config:^ChanConfig state:^ChanState = ChanData;
`;
  return schema;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$2;
  hasRequiredDist = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blockSchema = exports.unwrap = exports.TLBSchemaError = exports.TLBRuntimeError = exports.TLBDataError = exports.parseTLB = exports.TLBRuntime = exports.parseCell = exports.encodeCell = exports.replacer = void 0;
    var parser_1 = requireParser();
    Object.defineProperty(exports, "replacer", { enumerable: true, get: function() {
      return parser_1.replacer;
    } });
    Object.defineProperty(exports, "encodeCell", { enumerable: true, get: function() {
      return parser_1.encodeCell;
    } });
    Object.defineProperty(exports, "parseCell", { enumerable: true, get: function() {
      return parser_1.parseCell;
    } });
    var TLBRuntime_1 = requireTLBRuntime();
    Object.defineProperty(exports, "TLBRuntime", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBRuntime;
    } });
    Object.defineProperty(exports, "parseTLB", { enumerable: true, get: function() {
      return TLBRuntime_1.parseTLB;
    } });
    Object.defineProperty(exports, "TLBDataError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBDataError;
    } });
    Object.defineProperty(exports, "TLBRuntimeError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBRuntimeError;
    } });
    Object.defineProperty(exports, "TLBSchemaError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBSchemaError;
    } });
    var Result_1 = requireResult();
    Object.defineProperty(exports, "unwrap", { enumerable: true, get: function() {
      return Result_1.unwrap;
    } });
    var schema_1 = requireSchema();
    Object.defineProperty(exports, "blockSchema", { enumerable: true, get: function() {
      return schema_1.blockSchema;
    } });
  })(dist$2);
  return dist$2;
}
var distExports$1 = requireDist();
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BOC_PREFIX = "te6cc";
function isValidObject(data) {
  return typeof data === "object" && data !== null;
}
function isValidString(data) {
  return typeof data === "string";
}
function hasExtraProperties(data, allowedKeys) {
  return typeof data === "object" && data !== null && Object.keys(data).some((key) => !allowedKeys.includes(key));
}
function isValidBoc(value) {
  return typeof value === "string" && BASE64_REGEX.test(value) && value.startsWith(BOC_PREFIX);
}
function validateSignDataPayload(data) {
  if (!isValidObject(data)) {
    return "Payload must be an object";
  }
  if (!isValidString(data.type)) {
    return "'type' is required";
  }
  switch (data.type) {
    case "text":
      return validateSignDataPayloadText(data);
    case "binary":
      return validateSignDataPayloadBinary(data);
    case "cell":
      return validateSignDataPayloadCell(data);
    default:
      return "Invalid 'type' value";
  }
}
function validateSignDataPayloadText(data) {
  const allowedKeys = ["type", "text", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Text payload contains extra properties";
  }
  if (!isValidString(data.text)) {
    return "'text' is required";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadBinary(data) {
  const allowedKeys = ["type", "bytes", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Binary payload contains extra properties";
  }
  if (!isValidString(data.bytes)) {
    return "'bytes' is required";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadCell(data) {
  const allowedKeys = ["type", "schema", "cell", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Cell payload contains extra properties";
  }
  if (!isValidString(data.schema)) {
    return "'schema' is required";
  }
  if (!isValidString(data.cell)) {
    return "'cell' is required";
  }
  if (!isValidBoc(data.cell)) {
    return "Invalid 'cell' format (must be valid base64)";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
const log$e = globalLogger.createChild("SignDataHandler");
class SignDataHandler extends BasicHandler {
  analytics;
  walletManager;
  sessionManager;
  constructor(notify, walletManager, sessionManager, analyticsManager) {
    super(notify);
    this.walletManager = walletManager;
    this.sessionManager = sessionManager;
    this.analytics = analyticsManager?.scoped();
  }
  canHandle(event) {
    return event.method === "signData";
  }
  async handle(event) {
    const walletId = event.walletId;
    const walletAddress = event.walletAddress;
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "No wallet ID found in sign data event", void 0, {
        eventId: event.id
      });
    }
    const wallet = walletId ? this.walletManager.getWallet(walletId) : void 0;
    const payload = this.parseDataToSign(event);
    if (!payload) {
      log$e.error("No data to sign found in request", { event });
      throw new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "No data to sign found in request", void 0, {
        eventId: event.id
      });
    }
    const preview = this.createDataPreview(payload.data, event);
    if (!preview) {
      log$e.error("No preview found for data", { data: payload });
      throw new WalletKitError(ERROR_CODES.RESPONSE_CREATION_FAILED, "Failed to create preview for sign data request", void 0, { eventId: event.id, data: payload });
    }
    const signEvent = {
      ...event,
      payload,
      preview: {
        dAppInfo: event.dAppInfo ?? {},
        data: preview
      },
      dAppInfo: event.dAppInfo ?? {},
      walletId: walletId ?? (wallet ? this.walletManager.getWalletId(wallet) : ""),
      walletAddress: walletAddress ?? wallet?.getAddress() ?? void 0
    };
    if (this.analytics) {
      const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
      this.analytics?.emitWalletSignDataRequestReceived({
        trace_id: event.traceId,
        client_id: event.from,
        wallet_id: sessionData?.publicKey,
        dapp_name: event.dAppInfo?.name,
        network_id: wallet?.getNetwork().chainId,
        // manifest_json_url: event.dAppInfo?.url, // todo
        origin_url: event.dAppInfo?.url
      });
    }
    return signEvent;
  }
  /**
   * Parse data to sign from bridge event
   */
  parseDataToSign(event) {
    try {
      const parsed = JSON.parse(event.params[0]);
      const validationResult = validateSignDataPayload(parsed);
      if (validationResult) {
        log$e.error("Invalid data to sign found in request", { validationResult });
        return void 0;
      }
      if (parsed === void 0) {
        return void 0;
      }
      let signData;
      if (parsed.type === "text") {
        signData = {
          type: "text",
          value: {
            content: parsed.text
          }
        };
      } else if (parsed.type === "binary") {
        signData = {
          type: "binary",
          value: {
            content: parsed.bytes
          }
        };
      } else if (parsed.type === "cell") {
        signData = {
          type: "cell",
          value: {
            schema: parsed.schema,
            content: parsed.cell
          }
        };
      } else {
        return void 0;
      }
      return {
        network: parsed.network ? Network.custom(parsed.network) : void 0,
        fromAddress: parsed.from,
        data: signData
      };
    } catch (error2) {
      log$e.error("Invalid data to sign found in request", { error: error2 });
      return void 0;
    }
  }
  /**
   * Create human-readable preview of data to sign
   */
  createDataPreview(data, _event) {
    if (data.type === "text") {
      return {
        type: "text",
        value: {
          content: data.value.content
        }
      };
    }
    if (data.type === "binary") {
      return {
        type: "binary",
        value: {
          content: data.value.content
        }
      };
    }
    if (data.type === "cell") {
      try {
        const parsed = distExports$1.parseTLB(data.value.schema).deserialize(data.value.content);
        return {
          type: "cell",
          value: {
            schema: data.value.schema,
            content: data.value.content,
            parsed
          }
        };
      } catch (error2) {
        log$e.error("Error deserializing cell", { error: error2 });
        return {
          type: "cell",
          value: {
            schema: data.value.schema,
            content: data.value.content
          }
        };
      }
    }
    return void 0;
  }
}
class DisconnectHandler extends BasicHandler {
  sessionManager;
  constructor(notify, sessionManager) {
    super(notify);
    this.sessionManager = sessionManager;
  }
  canHandle(event) {
    return event.method === "disconnect";
  }
  async handle(event) {
    const walletId = event.walletId;
    const walletAddress = event.walletAddress;
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "No wallet ID found in disconnect event", void 0, {
        eventId: event.id
      });
    }
    const reason = this.extractDisconnectReason(event);
    const disconnectEvent = {
      id: event.id,
      preview: {
        reason,
        dAppInfo: event.dAppInfo ?? {}
      },
      walletId: walletId ?? "",
      walletAddress,
      dAppInfo: event.dAppInfo ?? {}
    };
    await this.sessionManager.removeSession(event.from || "");
    return disconnectEvent;
  }
  /**
   * Extract disconnect reason from bridge event
   */
  extractDisconnectReason(event) {
    const params = event.params || {};
    const reason = params.reason;
    if (typeof reason === "string" && reason.length > 0) {
      return reason.slice(0, 200);
    }
    return void 0;
  }
}
const log$d = globalLogger.createChild("EventRouter");
class EventRouter {
  config;
  eventEmitter;
  sessionManager;
  walletManager;
  analyticsManager;
  handlers = [];
  bridgeManager;
  // Event callbacks
  connectRequestCallback = void 0;
  transactionRequestCallback = void 0;
  signDataRequestCallback = void 0;
  disconnectCallback = void 0;
  errorCallback = void 0;
  constructor(config, eventEmitter, sessionManager, walletManager, analyticsManager) {
    this.config = config;
    this.eventEmitter = eventEmitter;
    this.sessionManager = sessionManager;
    this.walletManager = walletManager;
    this.analyticsManager = analyticsManager;
    this.setupHandlers();
  }
  setBridgeManager(bridgeManager) {
    this.bridgeManager = bridgeManager;
  }
  /**
   * Route incoming bridge event to appropriate handler
   */
  async routeEvent(event) {
    const validation = validateBridgeEvent(event);
    if (!validation.isValid) {
      log$d.error("Invalid bridge event", { errors: validation.errors });
      return;
    }
    try {
      for (const handler of this.handlers) {
        if (handler.canHandle(event)) {
          const result = await handler.handle(event);
          if ("error" in result) {
            this.notifyErrorCallback({ id: result.id, data: { ...event }, error: result.error });
            try {
              await this.bridgeManager.sendResponse(event, result);
            } catch (error2) {
              log$d.error("Error sending response for error event", { error: error2, event, result });
            }
            return;
          }
          await handler.notify(result);
          break;
        }
      }
    } catch (error2) {
      log$d.error("Error routing event", { error: error2 });
      throw error2;
    }
  }
  /**
   * Register event callbacks
   */
  onConnectRequest(callback) {
    this.connectRequestCallback = callback;
  }
  onTransactionRequest(callback) {
    this.transactionRequestCallback = callback;
  }
  onSignDataRequest(callback) {
    this.signDataRequestCallback = callback;
  }
  onDisconnect(callback) {
    this.disconnectCallback = callback;
  }
  onRequestError(callback) {
    this.errorCallback = callback;
  }
  /**
   * Remove specific callback
   */
  removeConnectRequestCallback() {
    this.connectRequestCallback = void 0;
  }
  removeTransactionRequestCallback() {
    this.transactionRequestCallback = void 0;
  }
  removeSignDataRequestCallback() {
    this.signDataRequestCallback = void 0;
  }
  removeDisconnectCallback() {
    this.disconnectCallback = void 0;
  }
  removeErrorCallback() {
    this.errorCallback = void 0;
  }
  /**
   * Clear all callbacks
   */
  clearCallbacks() {
    this.connectRequestCallback = void 0;
    this.transactionRequestCallback = void 0;
    this.signDataRequestCallback = void 0;
    this.disconnectCallback = void 0;
    this.errorCallback = void 0;
  }
  /**
   * Setup event handlers
   */
  setupHandlers() {
    this.handlers = [
      new ConnectHandler(this.notifyConnectRequestCallbacks.bind(this), this.analyticsManager),
      new TransactionHandler(this.notifyTransactionRequestCallbacks.bind(this), this.config, this.eventEmitter, this.walletManager, this.sessionManager, this.analyticsManager),
      new SignDataHandler(this.notifySignDataRequestCallbacks.bind(this), this.walletManager, this.sessionManager, this.analyticsManager),
      new DisconnectHandler(this.notifyDisconnectCallbacks.bind(this), this.sessionManager)
    ];
  }
  /**
   * Notify connect request callbacks
   */
  async notifyConnectRequestCallbacks(event) {
    return await this.connectRequestCallback?.(event);
  }
  /**
   * Notify transaction request callbacks
   */
  async notifyTransactionRequestCallbacks(event) {
    return await this.transactionRequestCallback?.(event);
  }
  /**
   * Notify sign data request callbacks
   */
  async notifySignDataRequestCallbacks(event) {
    return await this.signDataRequestCallback?.(event);
  }
  /**
   * Notify disconnect callbacks
   */
  async notifyDisconnectCallbacks(event) {
    return await this.disconnectCallback?.(event);
  }
  /**
   * Notify error callbacks
   */
  async notifyErrorCallback(event) {
    return await this.errorCallback?.(event);
  }
  /**
   * Get enabled event types based on registered callbacks
   */
  getEnabledEventTypes() {
    const enabledTypes = [];
    if (this.connectRequestCallback) {
      enabledTypes.push("connect");
    }
    if (this.transactionRequestCallback) {
      enabledTypes.push("sendTransaction");
    }
    if (this.signDataRequestCallback) {
      enabledTypes.push("signData");
    }
    if (this.disconnectCallback) {
      enabledTypes.push("disconnect");
    }
    return enabledTypes;
  }
}
var distExports = requireDist$4();
const tonProofPrefix = "ton-proof-item-v2/";
const tonConnectPrefix = "ton-connect";
async function CreateTonProofMessageBytes(message) {
  const wc = Buffer.alloc(4);
  wc.writeUInt32BE(message.workchain);
  const ts = Buffer.alloc(8);
  ts.writeBigUInt64LE(BigInt(message.timestamp));
  const dl = Buffer.alloc(4);
  dl.writeUInt32LE(message.domain.lengthBytes);
  const m2 = Buffer.concat([
    Buffer.from(tonProofPrefix),
    wc,
    HexToUint8Array(message.addressHash),
    dl,
    Buffer.from(message.domain.value),
    ts,
    Buffer.from(message.payload)
  ]);
  const messageHash = distExports.sha256_sync(m2);
  const fullMes = Buffer.concat([Buffer.from([255, 255]), Buffer.from(tonConnectPrefix), Buffer.from(messageHash)]);
  const res = distExports.sha256_sync(fullMes);
  return Buffer.from(res);
}
function CreateTonProofMessage({ address, domain, payload, stateInit, timestamp }) {
  const res = {
    workchain: address.workChain,
    addressHash: Uint8ArrayToHex(address.hash),
    domain: {
      lengthBytes: domain.lengthBytes,
      value: domain.value
    },
    payload,
    stateInit,
    timestamp
  };
  return res;
}
function signed_crc_table() {
  var c = 0, table = new Array(256);
  for (var n = 0; n != 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }
  return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
}
var T0 = signed_crc_table();
function slice_by_16_tables(T10) {
  var c = 0, v2 = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
  for (n = 0; n != 256; ++n)
    table[n] = T10[n];
  for (n = 0; n != 256; ++n) {
    v2 = T10[n];
    for (c = 256 + n; c < 4096; c += 256)
      v2 = table[c] = v2 >>> 8 ^ T10[v2 & 255];
  }
  var out = [];
  for (n = 1; n != 16; ++n)
    out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
  return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_buf(B2, seed) {
  var C2 = seed ^ -1, L = B2.length - 15, i = 0;
  for (; i < L; )
    C2 = Tf[B2[i++] ^ C2 & 255] ^ Te[B2[i++] ^ C2 >> 8 & 255] ^ Td[B2[i++] ^ C2 >> 16 & 255] ^ Tc[B2[i++] ^ C2 >>> 24] ^ Tb[B2[i++]] ^ Ta[B2[i++]] ^ T9[B2[i++]] ^ T8[B2[i++]] ^ T7[B2[i++]] ^ T6[B2[i++]] ^ T5[B2[i++]] ^ T4[B2[i++]] ^ T3[B2[i++]] ^ T2[B2[i++]] ^ T1[B2[i++]] ^ T0[B2[i++]];
  L += 15;
  while (i < L)
    C2 = C2 >>> 8 ^ T0[(C2 ^ B2[i++]) & 255];
  return ~C2;
}
const buf = crc32_buf;
function createTextBinaryHash(data, parsedAddr, domain, timestamp) {
  const wcBuffer = Buffer.alloc(4);
  wcBuffer.writeInt32BE(parsedAddr.workChain);
  const domainBuffer = Buffer.from(domain, "utf8");
  const domainLenBuffer = Buffer.alloc(4);
  domainLenBuffer.writeUInt32BE(domainBuffer.length);
  const tsBuffer = Buffer.alloc(8);
  tsBuffer.writeBigUInt64BE(BigInt(timestamp));
  const typePrefix = data.type === "text" ? "txt" : "bin";
  const content = data.value.content;
  const encoding = data.type === "text" ? "utf8" : "base64";
  const payloadPrefix = Buffer.from(typePrefix);
  const payloadBuffer = Buffer.from(content, encoding);
  const payloadLenBuffer = Buffer.alloc(4);
  payloadLenBuffer.writeUInt32BE(payloadBuffer.length);
  const message = Buffer.concat([
    Buffer.from([255, 255]),
    Buffer.from("ton-connect/sign-data/"),
    wcBuffer,
    parsedAddr.hash,
    domainLenBuffer,
    domainBuffer,
    tsBuffer,
    payloadPrefix,
    payloadLenBuffer,
    payloadBuffer
  ]);
  return distExports.sha256_sync(message);
}
function createCellHash(payload, parsedAddr, domain, timestamp) {
  const cell = distExports$2.Cell.fromBase64(payload.content);
  const schemaHash = buf(Buffer.from(payload.schema, "utf8"), void 0) >>> 0;
  const tep81Domain = domain.split(".").reverse().join("\0") + "\0";
  const message = distExports$2.beginCell().storeUint(1968607266, 32).storeUint(schemaHash, 32).storeUint(timestamp, 64).storeAddress(parsedAddr).storeStringRefTail(tep81Domain).storeRef(cell).endCell();
  return Buffer.from(message.hash());
}
function PrepareSignData(data) {
  const { payload, domain, address } = data;
  const timestamp = Math.floor(Date.now() / 1e3);
  const parsedAddr = distExports$2.Address.parse(address);
  const finalHash = payload.data?.type === "cell" ? createCellHash(payload.data.value, parsedAddr, domain, timestamp) : createTextBinaryHash(payload.data, parsedAddr, domain, timestamp);
  return {
    address,
    timestamp,
    domain,
    payload,
    hash: Uint8ArrayToHex(finalHash)
  };
}
const log$c = globalLogger.createChild("RequestProcessor");
class RequestProcessor {
  walletKitOptions;
  sessionManager;
  bridgeManager;
  walletManager;
  analytics;
  constructor(walletKitOptions, sessionManager, bridgeManager, walletManager, analyticsManager) {
    this.walletKitOptions = walletKitOptions;
    this.sessionManager = sessionManager;
    this.bridgeManager = bridgeManager;
    this.walletManager = walletManager;
    this.analytics = analyticsManager?.scoped();
  }
  /**
   * Helper to get wallet from event, supporting both walletId and walletAddress
   */
  getWalletFromEvent(event) {
    if (event.walletId) {
      return this.walletManager.getWallet(event.walletId);
    }
    return void 0;
  }
  /**
   * Helper to get wallet address from event
   */
  getWalletAddressFromEvent(event) {
    if (event.walletAddress) {
      return event.walletAddress;
    }
    if (event.walletId) {
      return this.walletManager.getWallet(event.walletId)?.getAddress();
    }
    return void 0;
  }
  /**
   * Process connect request approval
   */
  async approveConnectRequest(event, response) {
    try {
      const walletId = event.walletId;
      if (!walletId) {
        const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet is required for connect request approval", void 0, { eventId: event.id });
        throw error2;
      }
      const wallet = this.getWalletFromEvent(event);
      if (!wallet) {
        const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect request", void 0, { walletId, eventId: event.id });
        throw error2;
      }
      const newSession = await this.sessionManager.createSession(event.from || (await distExports.getSecureRandomBytes(32)).toString("hex"), {
        name: event.preview.dAppInfo?.name || "",
        url: event.preview.dAppInfo?.url || "",
        iconUrl: event.preview.dAppInfo?.iconUrl || "",
        description: event.preview.dAppInfo?.description || ""
      }, wallet, event.isJsBridge ?? false);
      await this.bridgeManager.createSession(newSession.sessionId);
      const tonConnectResponse = await this.createConnectApprovalResponse(event, response?.proof);
      await this.bridgeManager.sendResponse(event, tonConnectResponse.result);
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(newSession.sessionId) : void 0;
        this.analytics.emitWalletConnectAccepted({
          client_id: event.from,
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          network_id: wallet.getNetwork().chainId,
          origin_url: event.dAppInfo?.url,
          dapp_name: event.dAppInfo?.name,
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          manifest_json_url: event.dAppInfo?.manifestUrl,
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value?.payload?.length
        });
        this.analytics.emitWalletConnectResponseSent({
          client_id: event.from,
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          manifest_json_url: event.preview.dAppInfo?.manifestUrl,
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value.payload?.length,
          network_id: wallet.getNetwork().chainId
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to approve connect request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process connect request rejection
   */
  async rejectConnectRequest(event, reason, errorCode) {
    try {
      log$c.info("Connect request rejected", {
        id: event.id,
        dAppName: event.preview.dAppInfo?.name || "",
        reason: reason || "User rejected connection"
      });
      const response = {
        event: "connect_error",
        id: 1,
        // parseInt(event.id || '') ?? 1,
        payload: {
          code: errorCode ?? CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected connection"
        }
      };
      const sessionId = event.from || "";
      try {
        await this.bridgeManager.sendResponse(event, response, new SessionCrypto());
      } catch (error2) {
        log$c.error("Failed to send connect request rejection response", { error: error2 });
      }
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(sessionId) : void 0;
        this.analytics.emitWalletConnectRejected({
          client_id: event.from,
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.preview.dAppInfo?.name || "",
          origin_url: event.preview.dAppInfo?.url || "",
          manifest_json_url: event.preview.dAppInfo?.manifestUrl || "",
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value.payload?.length
        });
        this.analytics.emitWalletConnectResponseSent({
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.preview.dAppInfo?.name || "",
          origin_url: event.preview.dAppInfo?.url || "",
          manifest_json_url: event.preview.dAppInfo?.manifestUrl || "",
          is_ton_addr: event.requestedItems.some((item) => item.type === "ton_addr"),
          is_ton_proof: event.requestedItems.some((item) => item.type === "ton_proof"),
          proof_payload_size: event.requestedItems.find((item) => item.type === "ton_proof")?.value.payload?.length,
          client_id: event.from
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to reject connect request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process transaction request approval
   */
  async approveTransactionRequest(event, response) {
    try {
      if (response) {
        const tonConnectResponse = {
          result: response.signedBoc,
          id: event.id || ""
        };
        await this.bridgeManager.sendResponse(event, tonConnectResponse);
        this.sendTransactionAnalytics(event, response.signedBoc);
        return response;
      } else {
        const signedBoc = await this.signTransaction(event);
        if (!this.walletKitOptions.dev?.disableNetworkSend) {
          const client = this.getClientForWallet(event.walletId);
          await CallForSuccess(() => client.sendBoc(signedBoc));
        }
        const response2 = {
          result: signedBoc,
          id: event.id || ""
        };
        await this.bridgeManager.sendResponse(event, response2);
        this.sendTransactionAnalytics(event, signedBoc);
        return { signedBoc };
      }
    } catch (error2) {
      log$c.error("Failed to approve transaction request", { error: error2 });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      if (error2?.message?.includes("Ledger device")) {
        throw new WalletKitError(ERROR_CODES.LEDGER_DEVICE_ERROR, "Ledger device error", error2);
      }
      throw error2;
    }
  }
  /**
   * Send transaction analytics events
   */
  sendTransactionAnalytics(event, signedBoc) {
    if (!this.analytics)
      return;
    const wallet = this.getWalletFromEvent(event);
    this.analytics.emitWalletTransactionSent({
      trace_id: event.traceId,
      network_id: wallet?.getNetwork().chainId,
      client_id: event.from,
      signed_boc: signedBoc
    });
  }
  /**
   * Process transaction request rejection
   */
  async rejectTransactionRequest(event, reason) {
    try {
      const response = typeof reason === "string" || typeof reason === "undefined" ? {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected transaction"
        },
        id: event.id
      } : {
        error: reason,
        id: event.id
      };
      await this.bridgeManager.sendResponse(event, response);
      const wallet = this.getWalletFromEvent(event);
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
        this.analytics.emitWalletTransactionDeclined({
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          network_id: wallet?.getNetwork().chainId,
          client_id: event.from,
          decline_reason: typeof reason === "string" ? reason : reason?.message
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to reject transaction request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process sign data request approval
   */
  async approveSignDataRequest(event, response) {
    try {
      if (response) {
        const wallet = this.getWalletFromEvent(event);
        if (!wallet) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet approving for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const tonConnectResponse = {
          id: event.id || "",
          result: {
            signature: HexToBase64(response.signature),
            address: distExports$2.Address.parse(wallet.getAddress()).toRawString(),
            timestamp: response.timestamp,
            domain: response.domain,
            payload: toTonConnectSignDataPayload(event.payload)
          }
        };
        await this.bridgeManager.sendResponse(event, tonConnectResponse);
        if (this.analytics) {
          const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
          this.analytics.emitWalletSignDataAccepted({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            network_id: wallet?.getNetwork().chainId,
            client_id: event.from
          });
          this.analytics.emitWalletSignDataSent({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            network_id: wallet?.getNetwork().chainId,
            client_id: event.from
          });
        }
        return response;
      } else {
        if (!event.domain) {
          const error2 = new WalletKitError(ERROR_CODES.SESSION_DOMAIN_REQUIRED, "Domain is required for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const walletId = event.walletId;
        const walletAddress = this.getWalletAddressFromEvent(event);
        if (!walletId && !walletAddress) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet ID is required for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const wallet = this.getWalletFromEvent(event);
        if (!wallet) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for sign data request", void 0, { walletId, walletAddress, eventId: event.id });
          throw error2;
        }
        let domainUrl = event.domain;
        try {
          domainUrl = new URL(event.domain).host;
        } catch {
        }
        const signData = PrepareSignData({
          payload: event.payload,
          domain: domainUrl,
          address: wallet.getAddress()
        });
        const signature = await wallet.getSignedSignData(signData);
        const signatureBase64 = HexToBase64(signature);
        const response2 = {
          id: event.id,
          result: {
            signature: signatureBase64,
            address: distExports$2.Address.parse(signData.address).toRawString(),
            timestamp: signData.timestamp,
            domain: signData.domain,
            payload: toTonConnectSignDataPayload(signData.payload)
          }
        };
        await this.bridgeManager.sendResponse(event, response2);
        if (this.analytics) {
          const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
          this.analytics.emitWalletSignDataAccepted({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            network_id: wallet.getNetwork().chainId,
            client_id: event.from
          });
          this.analytics.emitWalletSignDataSent({
            wallet_id: sessionData?.publicKey,
            trace_id: event.traceId,
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            network_id: wallet.getNetwork().chainId,
            client_id: event.from
          });
        }
        return {
          timestamp: signData.timestamp,
          domain: signData.domain,
          signature
        };
      }
    } catch (error2) {
      log$c.error("Failed to approve sign data request", {
        error: error2?.message?.toString() ?? error2?.toString()
      });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      throw error2;
    }
  }
  /**
   * Process sign data request rejection
   */
  async rejectSignDataRequest(event, reason) {
    try {
      const response = typeof reason === "string" || typeof reason === "undefined" ? {
        error: {
          code: SIGN_DATA_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected transaction"
        },
        id: event.id
      } : {
        error: reason,
        id: event.id
      };
      await this.bridgeManager.sendResponse(event, response);
      const wallet = this.getWalletFromEvent(event);
      if (this.analytics) {
        const sessionData = event.from ? await this.sessionManager.getSession(event.from) : void 0;
        this.analytics.emitWalletSignDataDeclined({
          wallet_id: sessionData?.publicKey,
          trace_id: event.traceId,
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          network_id: wallet?.getNetwork().chainId,
          client_id: event.from
        });
      }
      return;
    } catch (error2) {
      log$c.error("Failed to reject sign data request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Create connect approval response
   */
  async createConnectApprovalResponse(event, proof) {
    const walletId = event.walletId;
    const walletAddress = this.getWalletAddressFromEvent(event);
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet ID is required for connect approval response", void 0, { eventId: event.id });
    }
    const wallet = this.getWalletFromEvent(event);
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect approval response", void 0, { walletId, walletAddress, eventId: event.id });
    }
    const walletStateInit = await wallet.getStateInit();
    const publicKey = wallet.getPublicKey().replace("0x", "");
    const address = wallet.getAddress();
    const walletNetwork = wallet.getNetwork();
    const deviceInfo = getDeviceInfoForWallet(wallet, this.walletKitOptions.deviceInfo);
    const connectResponse = {
      event: "connect",
      id: Date.now(),
      payload: {
        device: deviceInfo,
        items: [
          {
            name: "ton_addr",
            address: distExports$2.Address.parse(address).toRawString(),
            network: walletNetwork.chainId,
            walletStateInit,
            publicKey
          }
        ]
      }
    };
    const proofRequest = event.requestedItems.find((item) => item.type === "ton_proof");
    if (proofRequest) {
      const tonProofItem = await createTonProofItem({
        wallet,
        address,
        walletStateInit,
        dAppUrl: event.preview.dAppInfo?.url,
        proofPayload: proofRequest.value.payload,
        providedProof: proof
      });
      connectResponse.payload.items.push(tonProofItem);
    }
    return { result: connectResponse };
  }
  /**
   * Sign transaction and return BOC
   */
  async signTransaction(event) {
    const walletId = event.walletId;
    const walletAddress = this.getWalletAddressFromEvent(event);
    if (!walletId && !walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet ID is required for transaction signing", void 0, { eventId: event.id });
    }
    const wallet = this.getWalletFromEvent(event);
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for transaction signing", void 0, { walletId, walletAddress, eventId: event.id });
    }
    const validUntil = event.request.validUntil;
    if (validUntil) {
      const now = Math.floor(Date.now() / 1e3);
      if (validUntil < now) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Transaction valid_until timestamp is in the past", void 0, { validUntil, currentTime: now });
      }
    }
    return await signTransactionInternal(wallet, event.request);
  }
  /**
   * Get API client for a wallet's network
   * Uses the wallet's network to get the appropriate client from NetworkManager
   */
  getClientForWallet(walletId) {
    if (!walletId) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet address is required to get API client");
    }
    const wallet = this.walletManager.getWallet(walletId);
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, `Wallet not found: ${walletId}`);
    }
    return wallet.getClient();
  }
}
async function signTransactionInternal(wallet, request) {
  const signedBoc = await wallet.getSignedSendTransaction(request, {
    fakeSignature: false
  });
  log$c.debug("Signing transaction", {
    messagesNumber: request.messages.length,
    fromAddress: request.fromAddress,
    validUntil: request.validUntil
  });
  return signedBoc;
}
async function createTonProofItem(params) {
  const { wallet, address, walletStateInit, dAppUrl, proofPayload, providedProof } = params;
  if (providedProof) {
    return {
      name: "ton_proof",
      proof: {
        timestamp: providedProof.timestamp,
        domain: {
          lengthBytes: providedProof.domain.lengthBytes,
          value: providedProof.domain.value
        },
        payload: providedProof.payload,
        signature: providedProof.signature
      }
    };
  }
  const domain = parseDomain(dAppUrl);
  const timestamp = Math.floor(Date.now() / 1e3);
  const signMessage = CreateTonProofMessage({
    address: distExports$2.Address.parse(address),
    domain,
    payload: proofPayload,
    stateInit: walletStateInit,
    timestamp
  });
  const signature = await wallet.getSignedTonProof(signMessage);
  const signatureBase64 = HexToBase64(signature);
  return {
    name: "ton_proof",
    proof: {
      timestamp,
      domain: { lengthBytes: domain.lengthBytes, value: domain.value },
      payload: proofPayload,
      signature: signatureBase64
    }
  };
}
function parseDomain(url) {
  if (!url) {
    return { lengthBytes: 0, value: "" };
  }
  try {
    const parsedUrl = new URL(url);
    return {
      lengthBytes: Buffer.from(parsedUrl.host).length,
      value: parsedUrl.host
    };
  } catch (error2) {
    log$c.error("Failed to parse domain", { error: error2 });
    return { lengthBytes: 0, value: "" };
  }
}
function toTonConnectSignDataPayload(payload) {
  let network;
  if (payload.network?.chainId === CHAIN.MAINNET) {
    network = CHAIN.MAINNET;
  } else if (payload.network?.chainId === CHAIN.TESTNET) {
    network = CHAIN.TESTNET;
  } else {
    network = void 0;
  }
  if (payload.data.type === "text") {
    return {
      network,
      from: payload.fromAddress,
      type: "text",
      text: payload.data.value.content
    };
  } else if (payload.data.type === "cell") {
    return {
      network,
      from: payload.fromAddress,
      type: "cell",
      schema: payload.data.value.schema,
      cell: payload.data.value.content
    };
  } else {
    return {
      network,
      from: payload.fromAddress,
      type: "binary",
      bytes: payload.data.value.content
    };
  }
}
const getEventUUID = () => {
  return crypto.randomUUID();
};
const log$b = globalLogger.createChild("EventStore");
const MAX_EVENT_SIZE_BYTES = 100 * 1024;
class StorageEventStore {
  storage;
  storageKey = "durable_events";
  operationLock = /* @__PURE__ */ new Map();
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Store a new event from the bridge
   */
  async storeEvent(_rawEvent) {
    const rawEvent = { ..._rawEvent, wallet: void 0 };
    const validation = validateBridgeEvent(rawEvent);
    if (!validation.isValid) {
      throw new Error(`Invalid bridge event: ${validation.errors.join(", ")}`);
    }
    const eventStr = JSON.stringify(rawEvent);
    const sizeBytes = new TextEncoder().encode(eventStr).length;
    if (sizeBytes > MAX_EVENT_SIZE_BYTES) {
      throw new Error(`Event too large: ${sizeBytes} bytes (max: ${MAX_EVENT_SIZE_BYTES})`);
    }
    const eventType = this.extractEventType(rawEvent.method);
    const storedEvent = {
      id: getEventUUID(),
      sessionId: rawEvent.from,
      eventType,
      rawEvent,
      status: "new",
      createdAt: Date.now(),
      sizeBytes
    };
    await this.saveEvent(storedEvent);
    log$b.info("Event stored", {
      eventId: storedEvent.id,
      eventType,
      sizeBytes,
      sessionId: rawEvent.from
    });
    return storedEvent;
  }
  /**
   * Get events for a wallet that are ready for processing
   */
  async getEventsForWallet(sessionIds, eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must match one of the session IDs
      event.sessionId && sessionIds.includes(event.sessionId) && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a2, b2) => a2.createdAt - b2.createdAt);
  }
  /**
   * Get events that don't require a wallet or session (e.g., connect events)
   */
  async getNoWalletEvents(eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a2, b2) => a2.createdAt - b2.createdAt);
  }
  /**
   * Attempt to acquire exclusive lock on an event for processing
   */
  async acquireLock(eventId, walletId) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        log$b.warn("Cannot lock non-existent event", { eventId });
        return void 0;
      }
      if (event.status !== "new") {
        log$b.debug("Cannot lock event - not in new status", {
          eventId,
          status: event.status,
          lockedBy: event.lockedBy
        });
        return void 0;
      }
      const updatedEvent = {
        ...event,
        status: "processing",
        processingStartedAt: Date.now(),
        lockedBy: walletId
      };
      allEvents[eventId] = updatedEvent;
      await this.storage.set(this.storageKey, allEvents);
      log$b.debug("Event lock acquired", { eventId, walletAddress: walletId });
      return updatedEvent;
    });
  }
  /**
   * Increment retry count and update error message for an event
   */
  async releaseLock(eventId, error2) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        throw new Error(`Event not found: ${eventId}`);
      }
      if (event.status !== "processing") {
        throw new Error(`Event not in processing status: ${eventId}, current status: ${event.status}`);
      }
      const addRetryCount = error2 ? 1 : 0;
      const updatedEvent = {
        ...event,
        retryCount: (event.retryCount || 0) + addRetryCount,
        lastError: error2,
        status: "new",
        lockedBy: void 0,
        processingStartedAt: void 0
      };
      allEvents[eventId] = updatedEvent;
      await this.storage.set(this.storageKey, allEvents);
      log$b.debug("Event retry count incremented", {
        eventId,
        retryCount: updatedEvent.retryCount,
        error: error2
      });
      return updatedEvent;
    });
  }
  /**
   * Update event status and timestamps with optimistic locking
   */
  async updateEventStatus(eventId, status, oldStatus) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        throw new Error(`Event not found: ${eventId}`);
      }
      if (event.status !== oldStatus) {
        throw new Error(`Event status mismatch: expected '${oldStatus}', but current status is '${event.status}'`);
      }
      const updatedEvent = {
        ...event,
        status
      };
      if (status === "completed") {
        updatedEvent.completedAt = Date.now();
      }
      allEvents[eventId] = updatedEvent;
      await this.storage.set(this.storageKey, allEvents);
      log$b.debug("Event status updated", { eventId, oldStatus, newStatus: status });
      return updatedEvent;
    });
  }
  /**
   * Get event by ID
   */
  async getEvent(eventId) {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return allEvents[eventId] || null;
    } catch (error2) {
      log$b.warn("Failed to get event", { eventId, error: error2 });
      return null;
    }
  }
  /**
   * Recover stale events that have been processing too long
   */
  async recoverStaleEvents(processingTimeoutMs) {
    const events = await this.getAllEvents();
    const now = Date.now();
    let recoveredCount = 0;
    for (const event of events) {
      if (event.status === "processing" && event.processingStartedAt && now - event.processingStartedAt > processingTimeoutMs) {
        const recoveredEvent = {
          ...event,
          processingStartedAt: void 0,
          lockedBy: void 0
        };
        await this.saveEvent(recoveredEvent);
        recoveredCount++;
        log$b.info("Recovered stale event", {
          eventId: event.id,
          lockedBy: event.lockedBy,
          staleMinutes: Math.round((now - event.processingStartedAt) / 6e4),
          retryCount: event.retryCount || 0
        });
      }
    }
    if (recoveredCount > 0) {
      log$b.info("Event recovery completed", { recoveredCount });
    }
    return recoveredCount;
  }
  /**
   * Clean up old completed events
   */
  async cleanupOldEvents(retentionMs) {
    const events = await this.getAllEvents();
    const cutoffTime = Date.now() - retentionMs;
    let cleanedUpCount = 0;
    const eventsToRemove = [];
    for (const event of events) {
      if (event.status === "completed" && event.completedAt && event.completedAt < cutoffTime || event.status === "errored" && event.createdAt < cutoffTime) {
        eventsToRemove.push(event.id);
        log$b.debug("Marked event for cleanup", { eventId: event.id, status: event.status });
      }
    }
    if (eventsToRemove.length > 0) {
      await this.withLock("storage", async () => {
        const allEvents = await this.getAllEventsFromStorage();
        for (const eventId of eventsToRemove) {
          delete allEvents[eventId];
          cleanedUpCount++;
        }
        await this.storage.set(this.storageKey, allEvents);
      });
      log$b.info("Event cleanup completed", { cleanedUpCount });
    }
    return cleanedUpCount;
  }
  /**
   * Get all events (for debugging and internal operations)
   */
  async getAllEvents() {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return Object.values(allEvents);
    } catch (error2) {
      log$b.warn("Failed to get all events", { error: error2 });
      return [];
    }
  }
  // Private helper methods
  async withLock(lockKey, operation) {
    const existingLock = this.operationLock.get(lockKey);
    if (existingLock) {
      await existingLock;
    }
    const operationPromise = operation();
    this.operationLock.set(lockKey, operationPromise.then(() => {
    }, () => {
    }));
    try {
      const result = await operationPromise;
      this.operationLock.delete(lockKey);
      return result;
    } catch (error2) {
      this.operationLock.delete(lockKey);
      throw error2;
    }
  }
  async getAllEventsFromStorage() {
    try {
      const eventsData = await this.storage.get(this.storageKey);
      return eventsData || {};
    } catch (error2) {
      log$b.warn("Failed to get events from storage", { error: error2 });
      return {};
    }
  }
  async saveEvent(event) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      allEvents[event.id] = event;
      await this.storage.set(this.storageKey, allEvents);
    });
  }
  async removeEvent(eventId) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      delete allEvents[eventId];
      await this.storage.set(this.storageKey, allEvents);
    });
  }
  extractEventType(method) {
    switch (method) {
      case "connect":
        return "connect";
      case "sendTransaction":
        return "sendTransaction";
      case "signData":
        return "signData";
      case "disconnect":
        return "disconnect";
      case "restoreConnection":
        return "restoreConnection";
      default:
        throw new Error(`Unknown event method: ${method}`);
    }
  }
}
const log$a = globalLogger.createChild("EventProcessor");
class StorageEventProcessor {
  eventStore;
  config;
  sessionManager;
  eventRouter;
  eventEmitter;
  walletManager;
  // Single global processing loop state
  isProcessing = false;
  wakeUpResolver;
  // Track which wallets are registered for processing
  registeredWallets = /* @__PURE__ */ new Set();
  // Recovery and cleanup timeouts
  recoveryTimeoutId;
  cleanupTimeoutId;
  processorConfig;
  constructor(processorConfig = {}, eventStore, config, walletManager, sessionManager, eventRouter, eventEmitter) {
    this.processorConfig = processorConfig;
    this.eventStore = eventStore;
    this.config = config;
    this.sessionManager = sessionManager;
    this.eventRouter = eventRouter;
    this.eventEmitter = eventEmitter;
    this.walletManager = walletManager;
    if (this.processorConfig.disableEvents) {
      return;
    }
    this.eventEmitter.on("bridge-storage-updated", () => {
      this.triggerProcessing();
    });
  }
  /**
   * Start processing events for a wallet
   */
  async startProcessing(walletId) {
    if (this.processorConfig.disableEvents) {
      return;
    }
    if (walletId) {
      if (this.registeredWallets.has(walletId)) {
        log$a.debug("Processing already registered for wallet", { walletId });
      } else {
        this.registeredWallets.add(walletId);
        log$a.info("Registered wallet for event processing", { walletId });
      }
    }
    if (!this.isProcessing) {
      this.isProcessing = true;
      log$a.info("Started global event processing loop");
      this.processEventsLoop();
    } else {
      this.triggerProcessing();
    }
  }
  /**
   * Stop processing events for a wallet
   */
  async stopProcessing(walletId) {
    if (this.processorConfig.disableEvents) {
      return;
    }
    if (walletId) {
      this.registeredWallets.delete(walletId);
      log$a.info("Unregistered wallet from event processing", { walletId });
    }
    if (this.registeredWallets.size === 0 && this.isProcessing && !walletId) {
      this.isProcessing = false;
      if (this.wakeUpResolver) {
        this.wakeUpResolver();
        this.wakeUpResolver = void 0;
      }
      log$a.info("Stopped global event processing loop (no more wallets)");
    }
  }
  async clearRegisteredWallets() {
    this.registeredWallets.clear();
    log$a.info("Cleared registered wallets from event processing");
  }
  /**
   * Process next available event from any source (wallet or no-wallet)
   * This is the main method used by the global processing loop
   */
  async processNextAvailableEvent() {
    try {
      const allLocalSessions = await this.sessionManager.getSessions();
      const allSessions = allLocalSessions.filter((session) => session.walletId && this.registeredWallets.has(session.walletId));
      const enabledEventTypes = this.getEnabledEventTypes();
      const allEvents = [];
      if (allSessions.length > 0) {
        const walletIds = Array.from(new Set(allSessions.map((s2) => s2.walletId).filter(Boolean)));
        for (const walletId2 of walletIds) {
          const walletSessionIds = allSessions.filter((s2) => s2.walletId === walletId2).map((s2) => s2.sessionId);
          const events = await this.eventStore.getEventsForWallet(walletSessionIds, enabledEventTypes);
          allEvents.push(...events);
        }
      }
      const noWalletEventTypes = this.getNoWalletEnabledEventTypes();
      if (noWalletEventTypes.length > 0) {
        const noWalletEvents = await this.eventStore.getNoWalletEvents(noWalletEventTypes);
        allEvents.push(...noWalletEvents);
      }
      allEvents.sort((a2, b2) => a2.createdAt - b2.createdAt);
      if (allEvents.length === 0) {
        return false;
      }
      const eventToUse = allEvents[0];
      const walletId = allSessions.find((s2) => s2.sessionId === eventToUse.sessionId)?.walletId || "no-wallet";
      const processed = await this.processEvent(eventToUse, walletId);
      return processed;
    } catch (error2) {
      log$a.error("Error in processNextAvailableEvent", {
        error: error2.message
      });
      return false;
    }
  }
  /**
   * Mark an event as completed after successful processing
   */
  async completeEvent(eventId) {
    try {
      await this.eventStore.updateEventStatus(eventId, "completed", "processing");
      log$a.debug("Event marked as completed", { eventId });
    } catch (error2) {
      log$a.error("Failed to mark event as completed", {
        eventId,
        error: error2.message
      });
    }
  }
  /**
   * Start the recovery process for stale events
   */
  startRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      log$a.debug("Recovery loop already running");
      return;
    }
    const recoveryLoop = async () => {
      try {
        const recoveredCount = await this.eventStore.recoverStaleEvents(this.config.processingTimeoutMs);
        if (recoveredCount > 0) {
          this.triggerProcessing();
        }
      } catch (error2) {
        log$a.error("Error in recovery loop", { error: error2.message });
      }
      if (this.recoveryTimeoutId !== void 0) {
        this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
      }
    };
    const cleanupLoop = async () => {
      try {
        await this.eventStore.cleanupOldEvents(this.config.retentionMs);
      } catch (error2) {
        log$a.error("Error in cleanup loop", { error: error2.message });
      }
      if (this.cleanupTimeoutId !== void 0) {
        this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
      }
    };
    this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
    this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
    log$a.info("Recovery and cleanup loops started");
  }
  /**
   * Stop the recovery process
   */
  stopRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      clearTimeout(this.recoveryTimeoutId);
      this.recoveryTimeoutId = void 0;
    }
    if (this.cleanupTimeoutId) {
      clearTimeout(this.cleanupTimeoutId);
      this.cleanupTimeoutId = void 0;
    }
    log$a.info("Recovery and cleanup loops stopped");
  }
  // Private helper methods
  /**
   * Process a single event with retry logic
   * Returns true if event was processed successfully, false otherwise
   */
  async processEvent(event, walletId) {
    const acquiredEvent = await this.eventStore.acquireLock(event.id, walletId);
    if (!acquiredEvent) {
      log$a.debug("Failed to acquire lock on event", { eventId: event.id, walletId });
      return false;
    }
    const retryCount = event.retryCount || 0;
    if (retryCount >= this.config.maxRetries) {
      log$a.error("Event exceeded max retries, marking as errored", {
        eventId: event.id,
        retryCount,
        maxRetries: this.config.maxRetries
      });
      try {
        await this.eventStore.updateEventStatus(event.id, "errored", "processing");
      } catch (error2) {
        log$a.error("Failed to mark event as errored", {
          eventId: event.id,
          error: error2.message
        });
      }
      return false;
    }
    log$a.info("Processing event", {
      eventId: event.id,
      eventType: event.eventType,
      walletId,
      sessionId: event.sessionId,
      retryCount
    });
    try {
      let wallet;
      let walletAddress;
      if (walletId) {
        wallet = this.walletManager.getWallet(walletId);
        walletAddress = wallet?.getAddress();
      }
      await this.eventRouter.routeEvent({
        ...event.rawEvent,
        ...walletId ? { walletId } : {},
        ...walletAddress ? { walletAddress } : {}
      });
      await this.eventStore.updateEventStatus(event.id, "completed", "processing");
      log$a.info("Event processing completed", { eventId: event.id });
      return true;
    } catch (error2) {
      const errorMessage = error2.message ?? "Unknown error";
      log$a.error("Error processing event", {
        eventId: event.id,
        error: errorMessage,
        retryCount
      });
      try {
        await this.eventStore.releaseLock(event.id, errorMessage);
      } catch (updateError) {
        log$a.error("Failed to increment retry count", {
          eventId: event.id,
          error: updateError.message
        });
      }
      return false;
    }
  }
  /**
   * Main global processing loop for all events
   */
  async processEventsLoop() {
    while (this.isProcessing) {
      try {
        const processed = await this.processNextAvailableEvent();
        if (!processed) {
          await this.waitForWakeUpOrTimeout(500);
        }
      } catch (error2) {
        log$a.error("Error in global processing loop", {
          error: error2.message
        });
        await this.waitForWakeUpOrTimeout(500);
      }
    }
    this.wakeUpResolver = void 0;
    log$a.debug("Global processing loop ended");
  }
  /**
   * Trigger the global processing loop
   */
  triggerProcessing() {
    if (this.isProcessing && this.wakeUpResolver) {
      log$a.debug("Waking up global processing loop");
      this.wakeUpResolver();
    }
  }
  /**
   * Wait for either a wake-up signal or timeout
   */
  async waitForWakeUpOrTimeout(timeoutMs) {
    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        this.wakeUpResolver = void 0;
        resolve();
      }, timeoutMs);
      const wakeUpResolver = () => {
        clearTimeout(timeoutId);
        this.wakeUpResolver = void 0;
        resolve();
      };
      this.wakeUpResolver = wakeUpResolver;
    });
  }
  /**
   * Get enabled event types based on registered handlers in EventRouter
   */
  getEnabledEventTypes() {
    return this.eventRouter.getEnabledEventTypes();
  }
  /**
   * Get enabled event types for no-wallet processing (currently only connect)
   */
  getNoWalletEnabledEventTypes() {
    const enabledTypes = this.eventRouter.getEnabledEventTypes();
    return enabledTypes.filter((type) => type === "connect" || type === "restoreConnection");
  }
}
const log$9 = globalLogger.createChild("WalletTonClass");
class WalletTonClass {
  async createTransferTonTransaction(param) {
    if (!isValidAddress(param.recipientAddress)) {
      throw new Error(`Invalid to address: ${param.recipientAddress}`);
    }
    if (!isValidNanotonAmount(param.transferAmount)) {
      throw new Error(`Invalid amount: ${param.transferAmount}`);
    }
    let body;
    if (param.payload) {
      body = param.payload;
    } else if (param.comment) {
      body = distExports$2.beginCell().storeUint(0, 32).storeStringTail(param.comment).endCell().toBoc().toString("base64");
    }
    const message = {
      address: param.recipientAddress,
      amount: param.transferAmount,
      payload: body,
      stateInit: param.stateInit,
      extraCurrency: param.extraCurrency,
      mode: param.mode
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
  async createTransferMultiTonTransaction(params) {
    let messages = [];
    for (const param of params) {
      if (!isValidAddress(param.recipientAddress)) {
        throw new Error(`Invalid to address: ${param.recipientAddress}`);
      }
      if (!isValidNanotonAmount(param.transferAmount)) {
        throw new Error(`Invalid amount: ${param.transferAmount}`);
      }
      let body;
      if (param.payload) {
        body = param.payload;
      } else if (param.comment) {
        body = distExports$2.beginCell().storeUint(0, 32).storeStringTail(param.comment).endCell().toBoc().toString("base64");
      }
      const message = {
        address: param.recipientAddress,
        amount: param.transferAmount,
        payload: body,
        stateInit: param.stateInit,
        extraCurrency: param.extraCurrency,
        mode: param.mode
      };
      if (!validateTransactionMessage(message, false).isValid) {
        throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
      }
      messages.push(message);
    }
    return {
      messages,
      fromAddress: this.getAddress()
    };
  }
  async getTransactionPreview(param) {
    const transaction = await param;
    const preview = await CallForSuccess(() => createTransactionPreview(this.client, transaction, this));
    return preview;
  }
  async sendTransaction(request) {
    try {
      const boc = await this.getSignedSendTransaction(request);
      await CallForSuccess(() => this.getClient().sendBoc(boc));
      return { boc };
    } catch (error2) {
      log$9.error("Failed to send transaction", { error: error2 });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      if (error2?.message?.includes("Ledger device")) {
        throw new WalletKitError(ERROR_CODES.LEDGER_DEVICE_ERROR, "Ledger device error", error2);
      }
      throw error2;
    }
  }
  async getBalance() {
    return await CallForSuccess(async () => this.getClient().getBalance(this.getAddress()));
  }
}
function ParseStackItem(item) {
  switch (item.type) {
    case "num":
      if (item.value.startsWith("-")) {
        return { type: "int", value: -BigInt(item.value.slice(1)) };
      } else {
        return { type: "int", value: BigInt(item.value) };
      }
    case "null":
      return { type: "null" };
    case "cell":
      return { type: "cell", cell: distExports$2.Cell.fromBoc(Buffer.from(item.value, "base64"))[0] };
    case "tuple":
    case "list":
      if (item.value.length === 0) {
        return { type: "null" };
      }
      return { type: "tuple", items: item.value.map((value) => ParseStackItem(value)) };
    default:
      throw Error(`Unsupported parse stack item type: ${JSON.stringify(item)}`);
  }
}
function ParseStack(list) {
  let stack = [];
  for (let item of list) {
    stack.push(ParseStackItem(item));
  }
  return stack;
}
function SerializeStackItem(item) {
  switch (item.type) {
    case "int":
      return { type: "num", value: `${item.value < 0 ? "-" : ""}0x${item.value.toString(16)}` };
    case "slice":
      return { type: "slice", value: item.cell.toBoc().toString("base64") };
    case "cell":
      return { type: "cell", value: item.cell.toBoc().toString("base64") };
    default:
      throw Error(`Unsupported serialize stack item type: ${item.type}`);
  }
}
function SerializeStack(list) {
  let stack = [];
  for (let item of list) {
    stack.push(SerializeStackItem(item));
  }
  return stack;
}
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber(n, title = "") {
  if (!Number.isSafeInteger(n) || n < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n}`);
  }
}
function abytes(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function kdfInputToBytes(data, errorTitle = "") {
  if (typeof data === "string")
    return utf8ToBytes(data);
  return abytes(data, void 0, errorTitle);
}
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
const oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
class _HMAC {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = false;
  destroyed = false;
  constructor(hash, key) {
    ahash(hash);
    abytes(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf2) {
    aexists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new _HMAC(hash, key);
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c, "c");
  anumber(dkLen, "dkLen");
  anumber(asyncTick, "asyncTick");
  if (c < 1)
    throw new Error("iterations (c) must be >= 1");
  const password = kdfInputToBytes(_password, "password");
  const salt = kdfInputToBytes(_salt, "salt");
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
async function pbkdf2Async(hash, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
class HashMD {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(blockLen, outputLen, padOffset, isLE) {
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 ||= new this.constructor();
    to2.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to2.destroyed = destroyed;
    to2.finished = finished;
    to2.length = length;
    to2.pos = pos;
    if (length % blockLen)
      to2.buffer.set(buffer2);
    return to2;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le2 = false) {
  if (le2)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h: h2, l } = fromBig(lst[i], le2);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
const shrSH = (h2, _l, s2) => h2 >>> s2;
const shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
const rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
const rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
const rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
const rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA2_64B extends HashMD {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class _SHA512 extends SHA2_64B {
  Ah = SHA512_IV[0] | 0;
  Al = SHA512_IV[1] | 0;
  Bh = SHA512_IV[2] | 0;
  Bl = SHA512_IV[3] | 0;
  Ch = SHA512_IV[4] | 0;
  Cl = SHA512_IV[5] | 0;
  Dh = SHA512_IV[6] | 0;
  Dl = SHA512_IV[7] | 0;
  Eh = SHA512_IV[8] | 0;
  El = SHA512_IV[9] | 0;
  Fh = SHA512_IV[10] | 0;
  Fl = SHA512_IV[11] | 0;
  Gh = SHA512_IV[12] | 0;
  Gl = SHA512_IV[13] | 0;
  Hh = SHA512_IV[14] | 0;
  Hl = SHA512_IV[15] | 0;
  constructor() {
    super(64);
  }
}
const sha512 = /* @__PURE__ */ createHasher(
  () => new _SHA512(),
  /* @__PURE__ */ oidNist(3)
);
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
const psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeed(mnemonic2, passphrase = "") {
  return pbkdf2Async(sha512, normalize(mnemonic2).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}
async function bip39ToPrivateKey(mnemonic2) {
  const seed = await mnemonicToSeed(mnemonic2.join(" "));
  const TON_DERIVATION_PATH = [44, 607, 0];
  const seedContainer = await distExports.deriveEd25519Path(Buffer.from(seed), TON_DERIVATION_PATH);
  return distExports.keyPairFromSeed(seedContainer.subarray(0, 32));
}
async function MnemonicToKeyPair(mnemonic2, mnemonicType = "ton") {
  const mnemonicArray = Array.isArray(mnemonic2) ? mnemonic2 : mnemonic2.split(" ");
  if (mnemonicArray.length !== 12 && mnemonicArray.length !== 24) {
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, `Invalid mnemonic length: expected 12 or 24 words, got ${mnemonicArray.length}`);
  }
  if (mnemonicType === "ton") {
    const key = await distExports.mnemonicToWalletKey(mnemonicArray);
    return {
      publicKey: new Uint8Array(key.publicKey),
      secretKey: new Uint8Array(key.secretKey)
    };
  }
  if (mnemonicType === "bip39") {
    const key = await bip39ToPrivateKey(mnemonicArray);
    return {
      publicKey: new Uint8Array(key.publicKey),
      secretKey: new Uint8Array(key.secretKey)
    };
  }
  throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, `Invalid mnemonic type: expected "ton" or "bip39", got "${mnemonicType}"`, void 0, { receivedType: mnemonicType, supportedTypes: ["ton", "bip39"] });
}
async function CreateTonMnemonic() {
  return distExports.mnemonicNew(24);
}
function DefaultSignature(data, privateKey) {
  let fullKey = privateKey;
  if (fullKey.length === 32) {
    const keyPair = distExports.keyPairFromSeed(Buffer.from(fullKey));
    fullKey = keyPair.secretKey;
  }
  return Uint8ArrayToHex(distExports.sign(Buffer.from(Uint8Array.from(data)), Buffer.from(fullKey)));
}
function createWalletSigner(privateKey) {
  return async (data) => {
    return DefaultSignature(Uint8Array.from(data), privateKey);
  };
}
const fakeKeyPair = distExports.keyPairFromSeed(Buffer.alloc(32, 0));
function FakeSignature(data) {
  return Uint8ArrayToHex([...distExports.sign(Buffer.from(Uint8Array.from(data)), Buffer.from(fakeKeyPair.secretKey))]);
}
class Signer {
  /**
   * Create a signer from a mnemonic phrase
   * @param mnemonic - Mnemonic phrase as string or array of words
   * @param options - Optional configuration for mnemonic type
   * @returns Signer function with publicKey property
   */
  static async fromMnemonic(mnemonic2, options) {
    const keyPair = await MnemonicToKeyPair(mnemonic2, options?.type ?? "ton");
    const signer = createWalletSigner(keyPair.secretKey);
    return {
      sign: signer,
      publicKey: Uint8ArrayToHex(keyPair.publicKey)
    };
  }
  /**
   * Create a signer from a private key
   * @param privateKey - Private key as hex string or Uint8Array
   * @returns Signer function with publicKey property
   */
  static async fromPrivateKey(privateKey) {
    const privateKeyBytes = typeof privateKey === "string" ? Uint8Array.from(Buffer.from(privateKey.replace("0x", ""), "hex")) : privateKey;
    const keyPair = distExports.keyPairFromSeed(Buffer.from(privateKeyBytes));
    const signer = createWalletSigner(keyPair.secretKey);
    return {
      sign: signer,
      publicKey: Uint8ArrayToHex(keyPair.publicKey)
    };
  }
}
function limitString(data, limit) {
  return data.length > limit ? data.substring(0, limit) : data;
}
function toStringTail(data) {
  return distExports$2.beginCell().storeStringTail(limitString(data, 127)).endCell();
}
function getUnixtime() {
  return Math.floor(Date.now() / 1e3);
}
const VERSION = "0.0.3";
function getVersion() {
  return VERSION;
}
function getEventsSubsystem() {
  return "wallet";
}
function createWalletId(network, address) {
  return distExports.sha256_sync(`${network.chainId}:${address}`).toString("base64");
}
function storeJettonTransferMessage(src) {
  return (builder2) => {
    builder2.storeUint(Number(OpCode.JettonTransfer), 32);
    builder2.storeUint(src.queryId, 64);
    builder2.storeCoins(src.amount);
    builder2.storeAddress(src.destination);
    builder2.storeAddress(src.responseDestination);
    builder2.storeMaybeRef(src.customPayload);
    builder2.storeCoins(src.forwardAmount ?? 0);
    builder2.storeMaybeRef(src.forwardPayload);
  };
}
class WalletJettonClass {
  async createTransferJettonTransaction(jettonTransferParams) {
    if (!isValidAddress(jettonTransferParams.recipientAddress)) {
      throw new Error(`Invalid to address: ${jettonTransferParams.recipientAddress}`);
    }
    if (!isValidAddress(jettonTransferParams.jettonAddress)) {
      throw new Error(`Invalid jetton address: ${jettonTransferParams.jettonAddress}`);
    }
    if (!jettonTransferParams.transferAmount || BigInt(jettonTransferParams.transferAmount) <= 0n) {
      throw new Error(`Invalid amount: ${jettonTransferParams.transferAmount}`);
    }
    const jettonWalletAddress = await CallForSuccess(() => this.getJettonWalletAddress(jettonTransferParams.jettonAddress));
    const forwardPayload = jettonTransferParams.comment ? distExports$2.beginCell().storeUint(0, 32).storeStringTail(jettonTransferParams.comment).endCell() : null;
    const jettonPayload = distExports$2.beginCell().store(storeJettonTransferMessage({
      queryId: 0n,
      amount: BigInt(jettonTransferParams.transferAmount),
      destination: distExports$2.Address.parse(jettonTransferParams.recipientAddress),
      responseDestination: distExports$2.Address.parse(this.getAddress()),
      customPayload: null,
      forwardAmount: 1n,
      //1 nanoton default
      forwardPayload
    })).endCell();
    const message = {
      address: jettonWalletAddress,
      amount: "50000000",
      // 0.05 TON for gas fees
      payload: jettonPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: {
        flags: [SendModeFlag.IGNORE_ERRORS, SendModeFlag.PAY_GAS_SEPARATELY]
      }
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
  async getJettonBalance(jettonAddress) {
    const jettonWalletAddress = await this.getJettonWalletAddress(jettonAddress);
    try {
      const result = await this.getClient().runGetMethod(jettonWalletAddress, "get_wallet_data");
      const parsedStack = ParseStack(result.stack);
      const balance = parsedStack[0].type === "int" ? parsedStack[0].value : 0n;
      return balance.toString();
    } catch (_error) {
      return "0";
    }
  }
  async getJettonWalletAddress(jettonAddress) {
    if (!isValidAddress(jettonAddress)) {
      throw new Error(`Invalid jetton address: ${jettonAddress}`);
    }
    try {
      const result = await this.getClient().runGetMethod(jettonAddress, "get_wallet_address", SerializeStack([
        { type: "slice", cell: distExports$2.beginCell().storeAddress(distExports$2.Address.parse(this.getAddress())).endCell() }
      ]));
      const parsedStack = ParseStack(result.stack);
      const jettonWalletAddress = parsedStack[0].type === "slice" || parsedStack[0].type === "cell" ? parsedStack[0].cell.asSlice().loadAddress() : null;
      if (!jettonWalletAddress) {
        throw new Error("Failed to get jetton wallet address");
      }
      return asAddressFriendly(jettonWalletAddress.toString());
    } catch (error2) {
      throw new Error(`Failed to get jetton wallet address for ${jettonAddress}: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async getJettons(params) {
    return this.getClient().jettonsByOwnerAddress({
      ownerAddress: this.getAddress(),
      offset: params?.pagination.offset,
      limit: params?.pagination.limit
    });
  }
}
function storeNftTransferMessage(message) {
  return (builder2) => {
    builder2.storeUint(Number(OpCode.NftTransfer), 32);
    builder2.storeUint(message.queryId, 64);
    builder2.storeAddress(message.newOwner);
    builder2.storeAddress(message.responseDestination);
    builder2.storeMaybeRef(message.customPayload);
    builder2.storeCoins(message.forwardAmount);
    builder2.storeMaybeRef(message.forwardPayload);
  };
}
class WalletNftClass {
  async getNfts(params) {
    const out = await this.getClient().nftItemsByOwner({
      ownerAddress: this.getAddress(),
      pagination: params.pagination
    });
    return out;
  }
  async getNft(address) {
    const result = await this.getClient().nftItemsByAddress({
      address
    });
    if (result.nfts.length > 0) {
      return result.nfts[0];
    }
    return null;
  }
  async createTransferNftTransaction(nftTransferMessage) {
    const forwardPayload = nftTransferMessage.comment ? distExports$2.beginCell().storeUint(0, 32).storeStringTail(nftTransferMessage.comment).endCell() : null;
    const nftPayload = distExports$2.beginCell().store(storeNftTransferMessage({
      customPayload: null,
      forwardAmount: 1n,
      forwardPayload,
      newOwner: distExports$2.Address.parse(nftTransferMessage.recipientAddress),
      queryId: 0n,
      responseDestination: distExports$2.Address.parse(this.getAddress())
    })).endCell();
    const message = {
      address: nftTransferMessage.nftAddress,
      amount: nftTransferMessage.transferAmount?.toString() ?? "100000000",
      // Default 0.1 TON
      payload: nftPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: {
        flags: [SendModeFlag.IGNORE_ERRORS, SendModeFlag.PAY_GAS_SEPARATELY]
      }
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
  async createTransferNftRawTransaction(params) {
    const transferMessage = {
      queryId: BigInt(params.message.queryId),
      newOwner: typeof params.message.newOwner === "string" ? distExports$2.Address.parse(params.message.newOwner) : params.message.newOwner,
      responseDestination: params.message.responseDestination ? typeof params.message.responseDestination === "string" ? distExports$2.Address.parse(params.message.responseDestination) : params.message.responseDestination : null,
      customPayload: params.message.customPayload ? typeof params.message.customPayload === "string" ? distExports$2.Cell.fromBase64(params.message.customPayload) : params.message.customPayload : null,
      forwardAmount: BigInt(params.message.forwardAmount),
      forwardPayload: params.message.forwardPayload ? typeof params.message.forwardPayload === "string" ? distExports$2.Cell.fromBase64(params.message.forwardPayload) : params.message.forwardPayload : null
    };
    const nftPayload = distExports$2.beginCell().store(storeNftTransferMessage(transferMessage)).endCell();
    const message = {
      address: params.nftAddress,
      amount: params.transferAmount.toString(),
      payload: nftPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: {
        flags: [SendModeFlag.IGNORE_ERRORS, SendModeFlag.PAY_GAS_SEPARATELY]
      }
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      fromAddress: this.getAddress()
    };
  }
}
const log$8 = globalLogger.createChild("Initializer");
class Initializer {
  config;
  networkManager;
  eventEmitter;
  analyticsManager;
  constructor(config, eventEmitter, analyticsManager) {
    this.config = config;
    this.eventEmitter = eventEmitter;
    this.analyticsManager = analyticsManager;
  }
  /**
   * Initialize all components
   */
  async initialize(options, networkManager) {
    try {
      log$8.info("Initializing TonWalletKit...");
      this.networkManager = networkManager;
      const storage = this.initializeStorage(options);
      const { walletManager, sessionManager, bridgeManager, eventRouter, eventProcessor } = await this.initializeManagers(options, storage);
      const { requestProcessor } = this.initializeProcessors(sessionManager, bridgeManager, walletManager);
      log$8.info("TonWalletKit initialized successfully");
      return {
        walletManager,
        sessionManager,
        bridgeManager,
        eventRouter,
        requestProcessor,
        storage,
        eventProcessor
      };
    } catch (error2) {
      log$8.error("Failed to initialize TonWalletKit", { error: error2 });
      throw error2;
    }
  }
  /**
   * Initialize storage adapter and wrap it in Storage
   */
  initializeStorage(options) {
    let adapter;
    if (options.storage && "get" in options.storage && typeof options.storage.get === "function" && "set" in options.storage && typeof options.storage.set === "function" && "remove" in options.storage && typeof options.storage.remove === "function" && "clear" in options.storage && typeof options.storage.clear === "function") {
      adapter = options.storage;
    } else {
      const createStorageOptions = {
        prefix: options?.storage?.prefix ?? "tonwalletkit:",
        maxRetries: options?.storage?.maxRetries,
        retryDelay: options?.storage?.retryDelay,
        allowMemory: options?.storage?.allowMemory
      };
      adapter = createStorageAdapter(createStorageOptions);
    }
    return new Storage(adapter);
  }
  /**
   * Initialize core managers
   */
  async initializeManagers(options, storage) {
    const walletManager = new WalletManager(storage);
    await walletManager.initialize();
    let sessionManager;
    if (options.sessionManager) {
      sessionManager = options.sessionManager;
    } else {
      const storedSessionManager = new TONConnectStoredSessionManager(storage, walletManager);
      await storedSessionManager.initialize();
      sessionManager = storedSessionManager;
    }
    const eventStore = new StorageEventStore(storage);
    const eventRouter = new EventRouter(options, this.eventEmitter, sessionManager, walletManager, this.analyticsManager);
    const bridgeManager = new BridgeManager(options?.walletManifest, options?.bridge, sessionManager, storage, eventStore, eventRouter, options, this.eventEmitter, this.analyticsManager);
    eventRouter.setBridgeManager(bridgeManager);
    bridgeManager.start().then(() => {
      log$8.info("Bridge manager started successfully");
    }).catch((e) => {
      log$8.error("Could not start bridge manager", { error: e?.toString?.() });
    });
    const eventProcessor = new StorageEventProcessor(options?.eventProcessor, eventStore, DEFAULT_DURABLE_EVENTS_CONFIG, walletManager, sessionManager, eventRouter, this.eventEmitter);
    return {
      walletManager,
      sessionManager,
      bridgeManager,
      eventRouter,
      eventProcessor
    };
  }
  /**
   * Initialize processors
   */
  initializeProcessors(sessionManager, bridgeManager, walletManager) {
    const requestProcessor = new RequestProcessor(this.config, sessionManager, bridgeManager, walletManager, this.analyticsManager);
    return {
      requestProcessor
    };
  }
  /**
   * Cleanup resources during shutdown
   */
  async cleanup(components) {
    try {
      log$8.info("Cleaning up TonWalletKit components...");
      if (components.eventProcessor) {
        components.eventProcessor.stopRecoveryLoop();
        await components.eventProcessor.clearRegisteredWallets();
        await components.eventProcessor.stopProcessing();
      }
      if (components.bridgeManager) {
        await components.bridgeManager.close();
      }
      if (components.eventRouter) {
        components.eventRouter.clearCallbacks();
      }
      log$8.info("TonWalletKit cleanup completed");
    } catch (error2) {
      log$8.error("Error during cleanup", { error: error2 });
    }
  }
}
async function wrapWalletInterface(wallet) {
  const ourClassesToExtend = [WalletTonClass, WalletJettonClass, WalletNftClass];
  const newProxy = new Proxy(wallet, {
    get: (target, prop) => {
      if (typeof prop === "symbol") {
        return target[prop];
      }
      const ourMethonImplementation = ourClassesToExtend.find((cls) => !!cls.prototype[prop]);
      if (ourMethonImplementation) {
        const value2 = ourMethonImplementation.prototype[prop];
        return (...args) => value2.apply(newProxy, [...args]);
      }
      const value = target[prop];
      return value;
    }
  });
  return newProxy;
}
const defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const warned = /* @__PURE__ */ new Set();
const PROCESS = typeof process === "object" && !!process ? process : {};
const emitWarning = (msg, type, code, fn2) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn2) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn2) {
      this._onabort.push(fn2);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn2 of this.signal._onabort) {
        fn2(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}
class Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s2 = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s2;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  #perf;
  /**
   * {@link LRUCache.OptionsBase.perf}
   */
  get perf() {
    return this.#perf;
  }
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #autopurgeTimers;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      autopurgeTimers: c.#autopurgeTimers,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p2) => c.#isBackgroundFetch(p2),
      backgroundFetch: (k2, index2, options, context) => c.#backgroundFetch(k2, index2, options, context),
      moveToTail: (index2) => c.#moveToTail(index2),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index2) => c.#isStale(index2)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
    if (perf !== void 0) {
      if (typeof perf?.now !== "function") {
        throw new TypeError("perf option must have a now() method if specified");
      }
    }
    this.#perf = perf ?? defaultPerf;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    const purgeTimers = this.ttlAutopurge ? new Array(this.#max) : void 0;
    this.#autopurgeTimers = purgeTimers;
    this.#setItemTTL = (index2, ttl, start = this.#perf.now()) => {
      starts[index2] = ttl !== 0 ? start : 0;
      ttls[index2] = ttl;
      if (purgeTimers?.[index2]) {
        clearTimeout(purgeTimers[index2]);
        purgeTimers[index2] = void 0;
      }
      if (ttl !== 0 && purgeTimers) {
        const t = setTimeout(() => {
          if (this.#isStale(index2)) {
            this.#delete(this.#keyList[index2], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
        purgeTimers[index2] = t;
      }
    };
    this.#updateItemAge = (index2) => {
      starts[index2] = ttls[index2] !== 0 ? this.#perf.now() : 0;
    };
    this.#statusTTL = (status, index2) => {
      if (ttls[index2]) {
        const ttl = ttls[index2];
        const start = starts[index2];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = this.#perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index2 = this.#keyMap.get(key);
      if (index2 === void 0) {
        return 0;
      }
      const ttl = ttls[index2];
      const start = starts[index2];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index2) => {
      const s2 = starts[index2];
      const t = ttls[index2];
      return !!t && !!s2 && (cachedNow || getNow()) - s2 > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index2) => {
      this.#calculatedSize -= sizes[index2];
      sizes[index2] = 0;
    };
    this.#requireSize = (k2, v2, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v2)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v2, k2);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index2, size, status) => {
      sizes[index2] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index2];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index2];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index2) {
    return index2 !== void 0 && this.#keyMap.get(this.#keyList[index2]) === index2;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn2, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      if (fn2(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn2, thisp = this) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn2, thisp = this) {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v2 = this.#valList[i];
    const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (this.#perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = this.#perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = this.#perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k2, v2, setOptions = {}) {
    if (v2 === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k2, v2, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k2, "set");
      return this;
    }
    let index2 = this.#size === 0 ? void 0 : this.#keyMap.get(k2);
    if (index2 === void 0) {
      index2 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index2] = k2;
      this.#valList[index2] = v2;
      this.#keyMap.set(k2, index2);
      this.#next[this.#tail] = index2;
      this.#prev[index2] = this.#tail;
      this.#tail = index2;
      this.#size++;
      this.#addItemSize(index2, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v2, k2, "add");
      }
    } else {
      this.#moveToTail(index2);
      const oldVal = this.#valList[index2];
      if (v2 !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s2 } = oldVal;
          if (s2 !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s2, k2, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s2, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k2, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k2, "set"]);
          }
        }
        this.#removeItemSize(index2);
        this.#addItemSize(index2, size, status);
        this.#valList[index2] = v2;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v2, k2, v2 === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index2, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index2);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt2 = this.#disposed;
        let task;
        while (task = dt2?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k2 = this.#keyList[head];
    const v2 = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v2)) {
      v2.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v2, k2, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v2, k2, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (this.#autopurgeTimers?.[head]) {
      clearTimeout(this.#autopurgeTimers[head]);
      this.#autopurgeTimers[head] = void 0;
    }
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k2);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index2 = this.#keyMap.get(k2);
    if (index2 !== void 0) {
      const v2 = this.#valList[index2];
      if (this.#isBackgroundFetch(v2) && v2.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index2)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index2);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index2);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index2 = this.#keyMap.get(k2);
    if (index2 === void 0 || !allowStale && this.#isStale(index2)) {
      return;
    }
    const v2 = this.#valList[index2];
    return this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
  }
  #backgroundFetch(k2, index2, options, context) {
    const v2 = index2 === void 0 ? void 0 : this.#valList[index2];
    if (this.#isBackgroundFetch(v2)) {
      return v2;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v3, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p2;
      const vl = this.#valList[index2];
      if (vl === p2 || ignoreAbort && updateCache && vl === void 0) {
        if (v3 === void 0) {
          if (bf2.__staleWhileFetching !== void 0) {
            this.#valList[index2] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k2, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v3, fetchOpts.options);
        }
      }
      return v3;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p2;
      if (this.#valList[index2] === p2) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k2, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index2] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k2, v2, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v3) => res(v3 === void 0 ? void 0 : v3), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v3) => cb(v3, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p2 = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p2, {
      __abortController: ac,
      __staleWhileFetching: v2,
      __returned: void 0
    });
    if (index2 === void 0) {
      this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
      index2 = this.#keyMap.get(k2);
    } else {
      this.#valList[index2] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p2) {
    if (!this.#hasFetchMethod)
      return false;
    const b2 = p2;
    return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = this.#keyMap.get(k2);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p2 = this.#backgroundFetch(k2, index2, options, context);
      return p2.__returned = p2;
    } else {
      const v2 = this.#valList[index2];
      if (this.#isBackgroundFetch(v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale = this.#isStale(index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index2);
        if (updateAgeOnGet) {
          this.#updateItemAge(index2);
        }
        if (status)
          this.#statusTTL(status, index2);
        return v2;
      }
      const p2 = this.#backgroundFetch(k2, index2, options, context);
      const hasStale = p2.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  async forceFetch(k2, fetchOptions = {}) {
    const v2 = await this.fetch(k2, fetchOptions);
    if (v2 === void 0)
      throw new Error("fetch() returned undefined");
    return v2;
  }
  memo(k2, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v2 = this.get(k2, options);
    if (!forceRefresh && v2 !== void 0)
      return v2;
    const vv = memoMethod(k2, v2, {
      options,
      context
    });
    this.set(k2, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index2 = this.#keyMap.get(k2);
    if (index2 !== void 0) {
      const value = this.#valList[index2];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index2);
      if (this.#isStale(index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k2, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index2);
        if (updateAgeOnGet) {
          this.#updateItemAge(index2);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p2, n) {
    this.#prev[n] = p2;
    this.#next[p2] = n;
  }
  #moveToTail(index2) {
    if (index2 !== this.#tail) {
      if (index2 === this.#head) {
        this.#head = this.#next[index2];
      } else {
        this.#connect(this.#prev[index2], this.#next[index2]);
      }
      this.#connect(this.#tail, index2);
      this.#tail = index2;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    return this.#delete(k2, "delete");
  }
  #delete(k2, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index2 = this.#keyMap.get(k2);
      if (index2 !== void 0) {
        if (this.#autopurgeTimers?.[index2]) {
          clearTimeout(this.#autopurgeTimers?.[index2]);
          this.#autopurgeTimers[index2] = void 0;
        }
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index2);
          const v2 = this.#valList[index2];
          if (this.#isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v2, k2, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v2, k2, reason]);
            }
          }
          this.#keyMap.delete(k2);
          this.#keyList[index2] = void 0;
          this.#valList[index2] = void 0;
          if (index2 === this.#tail) {
            this.#tail = this.#prev[index2];
          } else if (index2 === this.#head) {
            this.#head = this.#next[index2];
          } else {
            const pi = this.#prev[index2];
            this.#next[pi] = this.#next[index2];
            const ni = this.#next[index2];
            this.#prev[ni] = this.#prev[index2];
          }
          this.#size--;
          this.#free.push(index2);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index2 of this.#rindexes({ allowStale: true })) {
      const v2 = this.#valList[index2];
      if (this.#isBackgroundFetch(v2)) {
        v2.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.#keyList[index2];
        if (this.#hasDispose) {
          this.#dispose?.(v2, k2, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v2, k2, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
      for (const t of this.#autopurgeTimers ?? []) {
        if (t !== void 0)
          clearTimeout(t);
      }
      this.#autopurgeTimers?.fill(void 0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}
const log$7 = globalLogger.createChild("JettonsManager");
function createCacheKey(network, address) {
  return `${network.chainId}:${address}`;
}
class JettonsManager {
  eventEmitter;
  networkManager;
  cache;
  DEFAULT_TIMEOUT = 1e4;
  // 10 seconds
  constructor(cacheSize = 1e4, eventEmitter, networkManager) {
    this.eventEmitter = eventEmitter;
    this.networkManager = networkManager;
    this.cache = new LRUCache({
      max: cacheSize,
      ttl: 1e3 * 60 * 10
      // 10 minutes TTL
    });
    for (const network of this.networkManager.getConfiguredNetworks()) {
      this.addTonToCache(network);
    }
    log$7.info("JettonsManager initialized", { cacheSize });
    this.eventEmitter.on("emulation:result", (emulationResult) => {
      if (emulationResult && typeof emulationResult === "object" && "metadata" in emulationResult && "network" in emulationResult) {
        const network = emulationResult.network;
        this.addJettonsFromEmulationMetadata(Network.custom(network), emulationResult.metadata);
      }
    });
  }
  /**
   * Add TON native token to cache for a specific network
   */
  addTonToCache(network) {
    const cacheKey = createCacheKey(network, "TON");
    this.cache.set(cacheKey, {
      address: "TON",
      name: "TON",
      symbol: "TON",
      description: "The Open Network native token",
      decimals: 9,
      totalSupply: "5000000000000000000",
      image: "https://asset.ston.fi/img/EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c/ee9fb21d17bc8d75c2a5f7b5f5f62d2bacec6b128f58b63cb841e98f7b74c4fc",
      verification: {
        verified: true,
        source: "manual"
      }
    });
  }
  /**
   * Get jetton information by address for a specific network
   * @param jettonAddress - The jetton master address
   * @param network - The network to query (required)
   */
  async getJettonInfo(jettonAddress, network) {
    const targetNetwork = network;
    try {
      const cacheKey = this.normalizedCacheKey(targetNetwork, jettonAddress);
      const cachedInfo = this.cache.get(cacheKey);
      if (cachedInfo) {
        log$7.debug("Jetton info found in cache", { jettonAddress, network: targetNetwork });
        return cachedInfo;
      }
      log$7.debug("Jetton info not found in cache", { jettonAddress, network: targetNetwork });
      const address = asMaybeAddressFriendly(jettonAddress);
      if (!address) {
        log$7.error("Invalid jetton address format", { jettonAddress, network: targetNetwork });
        return null;
      }
      const apiClient = this.networkManager.getClient(targetNetwork);
      const jettonFromApi = await apiClient.jettonsByAddress({
        address,
        offset: 0,
        limit: 1
      });
      if (jettonFromApi && jettonFromApi?.jetton_masters?.length > 0 && jettonFromApi?.jetton_masters?.[0]) {
        const jetton = jettonFromApi?.jetton_masters?.[0];
        const metadata = jettonFromApi?.metadata?.[jetton.address];
        const tokenInfo = metadata?.token_info?.find((t) => t.valid && t.type === "jetton_masters");
        let decimals;
        try {
          decimals = parseInt(tokenInfo?.extra.decimals, 10);
        } catch {
          decimals = 9;
        }
        const result = {
          address: jetton.jetton,
          name: tokenInfo?.name ?? "",
          symbol: tokenInfo?.symbol ?? "",
          description: tokenInfo?.description ?? "",
          decimals,
          image: tokenInfo?.image,
          uri: tokenInfo?.extra?.uri,
          totalSupply: "0"
        };
        this.cache.set(cacheKey, result);
        return result;
      }
      return null;
    } catch (error2) {
      log$7.error("Error getting jetton info", { error: error2, jettonAddress, network: targetNetwork });
      return null;
    }
  }
  /**
   * Get jettons for a specific address on a specific network
   * @param userAddress - The user's wallet address
   * @param network - The network to query (required)
   * @param offset - Pagination offset
   * @param limit - Pagination limit
   */
  async getAddressJettons(userAddress, network, offset = 0, limit = 50) {
    const targetNetwork = network;
    try {
      const apiClient = this.networkManager.getClient(targetNetwork);
      log$7.debug("Getting address jettons", {
        userAddress,
        network: targetNetwork,
        offset,
        limit
      });
      const response = await apiClient.jettonsByOwnerAddress({
        ownerAddress: userAddress,
        offset,
        limit
      });
      if (!response.jettons) {
        return [];
      }
      const addressJettons = [];
      for (const item of response.jettons) {
        addressJettons.push(item);
      }
      log$7.debug("Retrieved address jettons", { count: addressJettons.length, network: targetNetwork });
      return addressJettons;
    } catch (error2) {
      log$7.error("Failed to get address jettons", { error: error2, userAddress, network: targetNetwork });
      throw new JettonError(`Failed to get jettons for address: ${error2 instanceof Error ? error2.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error2);
    }
  }
  /**
   * Add jetton info to cache from emulation data for a specific network
   */
  addJettonFromEmulation(network, jettonAddress, emulationInfo) {
    try {
      const cacheKey = this.normalizedCacheKey(network, jettonAddress);
      const jettonInfo = {
        address: jettonAddress,
        name: emulationInfo.name,
        symbol: emulationInfo.symbol,
        description: emulationInfo.description,
        image: emulationInfo.image,
        decimals: typeof emulationInfo.extra.decimals === "string" ? parseInt(emulationInfo.extra.decimals, 10) : emulationInfo.extra.decimals,
        uri: emulationInfo.extra.uri
      };
      this.cache.set(cacheKey, jettonInfo);
      log$7.debug("Added jetton info from emulation to cache", {
        jettonAddress,
        network,
        name: jettonInfo.name,
        symbol: jettonInfo.symbol
      });
    } catch (error2) {
      log$7.error("Error adding jetton from emulation", { error: error2, jettonAddress, network });
    }
  }
  /**
   * Add multiple jettons from emulation metadata for a specific network
   */
  addJettonsFromEmulationMetadata(network, metadata) {
    try {
      let addedCount = 0;
      for (const [jettonAddress, addressMetadata] of Object.entries(metadata)) {
        if (!addressMetadata.is_indexed || !addressMetadata.token_info) {
          continue;
        }
        const jettonMasterInfo = addressMetadata.token_info.find((info) => typeof info === "object" && info !== null && "type" in info && info.type === "jetton_masters");
        if (jettonMasterInfo) {
          log$7.debug("Adding jetton from emulation metadata", { jettonAddress, network });
          this.addJettonFromEmulation(network, jettonAddress, jettonMasterInfo);
          addedCount++;
        }
      }
      if (addedCount > 0) {
        log$7.info("Added jettons from emulation metadata", { addedCount, network });
      }
    } catch (error2) {
      log$7.error("Error adding jettons from emulation metadata", { error: error2, network });
    }
  }
  /**
   * Normalize jetton address for consistent caching
   */
  normalizedCacheKey(network, address) {
    if (address === "TON") {
      return createCacheKey(network, address);
    }
    return createCacheKey(network, distExports$2.Address.parse(address).toString());
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.cache.size,
      capacity: this.cache.max
    };
  }
  /**
   * Validate jetton address format
   */
  validateJettonAddress(address) {
    try {
      if (address === "TON") {
        return true;
      }
      distExports$2.Address.parse(address);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Clear the jetton cache for all networks or a specific network
   */
  clearCache(network) {
    if (network) {
      for (const key of this.cache.keys()) {
        if (key.startsWith(`${network.chainId}:`)) {
          this.cache.delete(key);
        }
      }
      this.addTonToCache(network);
      log$7.info("Jetton cache cleared for network", { network });
    } else {
      this.cache.clear();
      for (const net of this.networkManager.getConfiguredNetworks()) {
        this.addTonToCache(net);
      }
      log$7.info("Jetton cache cleared for all networks");
    }
  }
}
const log$6 = globalLogger.createChild("EventEmitter");
class EventEmitter {
  listeners = /* @__PURE__ */ new Map();
  /**
   * Subscribe to an event
   */
  on(eventName, listener) {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.listeners.get(eventName).add(listener);
    log$6.debug("Event listener added", { eventName, totalListeners: this.listeners.get(eventName).size });
  }
  /**
   * Subscribe to an event once (automatically removes after first emission)
   */
  once(eventName, listener) {
    const onceListener = (data) => {
      this.off(eventName, onceListener);
      listener(data);
    };
    this.on(eventName, onceListener);
  }
  /**
   * Unsubscribe from an event
   */
  off(eventName, listener) {
    const eventListeners2 = this.listeners.get(eventName);
    if (eventListeners2) {
      eventListeners2.delete(listener);
      log$6.debug("Event listener removed", { eventName, totalListeners: eventListeners2.size });
      if (eventListeners2.size === 0) {
        this.listeners.delete(eventName);
      }
    }
  }
  /**
   * Emit an event to all subscribers
   */
  emit(eventName, data) {
    const eventListeners2 = this.listeners.get(eventName);
    if (eventListeners2) {
      log$6.debug("Emitting event", { eventName, listenerCount: eventListeners2.size });
      eventListeners2.forEach((listener) => {
        try {
          listener(data);
        } catch (error2) {
          log$6.error("Error in event listener", { eventName, error: error2 });
        }
      });
    }
  }
  /**
   * Remove all listeners for a specific event
   */
  removeAllListeners(eventName) {
    if (eventName) {
      this.listeners.delete(eventName);
      log$6.debug("All listeners removed for event", { eventName });
    } else {
      this.listeners.clear();
      log$6.debug("All event listeners cleared");
    }
  }
  /**
   * Get the number of listeners for an event
   */
  listenerCount(eventName) {
    return this.listeners.get(eventName)?.size || 0;
  }
  /**
   * Get all event names that have listeners
   */
  eventNames() {
    return Array.from(this.listeners.keys());
  }
}
var ContentType;
(function(ContentType2) {
  ContentType2["Json"] = "application/json";
  ContentType2["JsonApi"] = "application/vnd.api+json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
  ContentType2["Text"] = "text/plain";
})(ContentType || (ContentType = {}));
class HttpClient {
  baseUrl = "";
  securityData = null;
  securityWorker;
  abortControllers = /* @__PURE__ */ new Map();
  customFetch = (...fetchParams) => fetch(...fetchParams);
  baseApiParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer"
  };
  constructor(apiConfig = {}) {
    Object.assign(this, apiConfig);
  }
  setSecurityData = (data) => {
    this.securityData = data;
  };
  encodeQueryParam(key, value) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }
  addQueryParam(query, key) {
    return this.encodeQueryParam(key, query[key]);
  }
  addArrayQueryParam(query, key) {
    const value = query[key];
    return value.map((v2) => this.encodeQueryParam(key, v2)).join("&");
  }
  toQueryString(rawQuery) {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key) => "undefined" !== typeof query[key]);
    return keys.map((key) => Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join("&");
  }
  addQueryParams(rawQuery) {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  contentFormatters = {
    [ContentType.Json]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.JsonApi]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.Text]: (input) => input !== null && typeof input !== "string" ? JSON.stringify(input) : input,
    [ContentType.FormData]: (input) => {
      if (input instanceof FormData) {
        return input;
      }
      return Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(key, property instanceof Blob ? property : typeof property === "object" && property !== null ? JSON.stringify(property) : `${property}`);
        return formData;
      }, new FormData());
    },
    [ContentType.UrlEncoded]: (input) => this.toQueryString(input)
  };
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
  createAbortSignal = (cancelToken) => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController2 = this.abortControllers.get(cancelToken);
      if (abortController2) {
        return abortController2.signal;
      }
      return void 0;
    }
    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };
  abortRequest = (cancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);
    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };
  request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
    const secureParams = (typeof secure === "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;
    return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
      ...requestParams,
      headers: {
        ...requestParams.headers || {},
        ...type && type !== ContentType.FormData ? { "Content-Type": type } : {}
      },
      signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) || null,
      body: typeof body === "undefined" || body === null ? null : payloadFormatter(body)
    }).then(async (response) => {
      const r = response;
      r.data = null;
      r.error = null;
      const responseToParse = responseFormat ? response.clone() : response;
      const data = !responseFormat ? r : await responseToParse[responseFormat]().then((data2) => {
        if (r.ok) {
          r.data = data2;
        } else {
          r.error = data2;
        }
        return r;
      }).catch((e) => {
        r.error = e;
        return r;
      });
      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }
      if (!response.ok)
        throw data;
      return data;
    });
  };
}
class Api extends HttpClient {
  events = {
    /**
     * No description
     *
     * @name EventsCreate
     * @request POST:/events
     */
    eventsCreate: (events, params = {}) => this.request({
      path: `/events`,
      method: "POST",
      body: events,
      type: ContentType.Json,
      ...params
    })
  };
}
function pascalToKebab(value) {
  return value.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
const log$5 = globalLogger.createChild("AnalyticsManager");
class AnalyticsManager {
  api;
  baseEvent;
  appInfo;
  events = [];
  timeoutId = null;
  isProcessing = false;
  backoff = 1;
  currentBatchTimeoutMs;
  batchTimeoutMs;
  maxBatchSize;
  maxQueueSize;
  static HTTP_STATUS = {
    TOO_MANY_REQUESTS: 429,
    CLIENT_ERROR_START: 400,
    SERVER_ERROR_START: 500
  };
  static MAX_BACKOFF_ATTEMPTS = 5;
  static BACKOFF_MULTIPLIER = 2;
  constructor(options) {
    this.batchTimeoutMs = options.batchTimeoutMs ?? 5e3;
    this.currentBatchTimeoutMs = this.batchTimeoutMs;
    this.maxBatchSize = options.maxBatchSize ?? 100;
    this.maxQueueSize = options.maxQueueSize ?? 1e3;
    this.appInfo = options.appInfo;
    this.api = new Api({
      baseUrl: options.endpoint ?? "https://analytics.ton.org"
    });
    this.baseEvent = {
      version: getVersion(),
      subsystem: getEventsSubsystem(),
      client_environment: options.appInfo?.env ?? "wallet",
      platform: options.appInfo?.platform,
      browser: options.appInfo?.browser,
      wallet_app_name: options.appInfo?.appName,
      wallet_app_version: options.appInfo?.appVersion
    };
  }
  scoped(sharedData) {
    return new Proxy(this, {
      get(target, prop) {
        const propName = prop.toString();
        if (propName.startsWith("emit")) {
          const eventNamePascal = propName.replace("emit", "");
          const eventNameKebab = pascalToKebab(eventNamePascal);
          return function(event) {
            const executedData = Object.fromEntries(Object.entries(sharedData ?? {}).map(([key, value]) => [
              key,
              typeof value === "function" ? value() : value
            ]));
            return target.emit({
              event_name: eventNameKebab,
              ...executedData,
              ...event
            });
          };
        }
        return Reflect.get(target, prop);
      }
    });
  }
  emit(event) {
    const enhancedEvent = {
      ...this.baseEvent,
      ...event,
      event_id: v7(),
      trace_id: event.trace_id ?? v7(),
      client_timestamp: getUnixtime()
    };
    if (this.appInfo?.getLocale) {
      enhancedEvent.locale = this.appInfo.getLocale();
    }
    if (this.appInfo?.getCurrentUserId) {
      enhancedEvent.user_id = this.appInfo.getCurrentUserId();
    }
    log$5.debug("Analytics event emitted", { event: enhancedEvent });
    this.events.push(enhancedEvent);
    if (this.events.length > this.maxQueueSize) {
      const removed = this.events.length - this.maxQueueSize;
      this.events = this.events.slice(removed);
      log$5.warn("Analytics queue overflow, dropped oldest events", { count: removed });
    }
    if (this.events.length >= this.maxBatchSize) {
      void this.flush();
      return;
    }
    this.startTimeout();
  }
  startTimeout() {
    if (this.timeoutId || this.isProcessing) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      void this.flush();
    }, this.currentBatchTimeoutMs);
  }
  async flush() {
    if (this.isProcessing || this.events.length === 0) {
      return;
    }
    this.clearTimeout();
    this.isProcessing = true;
    const eventsToSend = this.extractEventsToSend();
    try {
      await this.processEventsBatch(eventsToSend);
      log$5.debug("Analytics events sent successfully");
    } catch (error2) {
      this.restoreEvents(eventsToSend);
      log$5.error("Failed to send analytics events", { error: error2 });
    } finally {
      this.isProcessing = false;
      this.scheduleNextFlushIfNeeded();
    }
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  extractEventsToSend() {
    const eventsToSend = this.events.slice(0, this.maxBatchSize);
    this.events = this.events.slice(this.maxBatchSize);
    return eventsToSend;
  }
  async processEventsBatch(eventsToSend) {
    log$5.debug("Sending analytics events", { count: eventsToSend.length });
    try {
      const response = await this.sendEvents(eventsToSend);
      this.handleResponse(response);
    } catch (err) {
      this.handleUnknownError(err);
    }
  }
  handleResponse(response) {
    const { status, statusText } = response;
    if (this.isTooManyRequests(status)) {
      this.handleTooManyRequests(status, statusText);
    } else if (this.isClientError(status)) {
      this.handleClientError(status, statusText);
    } else if (this.isServerError(status)) {
      this.handleUnknownError({ status, statusText });
    }
  }
  restoreEvents(eventsToSend) {
    this.events.unshift(...eventsToSend);
    if (this.events.length > this.maxQueueSize) {
      const removed = this.events.length - this.maxQueueSize;
      this.events = this.events.slice(0, this.maxQueueSize);
      log$5.warn("Analytics queue overflow after restore, dropped oldest events", { count: removed });
    }
  }
  scheduleNextFlushIfNeeded() {
    if (this.events.length > 0) {
      this.startTimeout();
    }
  }
  async sendEvents(events) {
    return await this.api.events.eventsCreate(events);
  }
  isClientError(status) {
    return status >= AnalyticsManager.HTTP_STATUS.CLIENT_ERROR_START && status < AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START;
  }
  isServerError(status) {
    return status >= AnalyticsManager.HTTP_STATUS.SERVER_ERROR_START;
  }
  isTooManyRequests(status) {
    return status === AnalyticsManager.HTTP_STATUS.TOO_MANY_REQUESTS;
  }
  handleClientError(status, statusText) {
    log$5.error("Analytics API client error", { status, statusText });
  }
  handleUnknownError(error2) {
    if (this.backoff < AnalyticsManager.MAX_BACKOFF_ATTEMPTS) {
      this.backoff++;
      this.currentBatchTimeoutMs *= AnalyticsManager.BACKOFF_MULTIPLIER;
      throw new Error(`Unknown analytics API error: ${error2}`);
    } else {
      this.currentBatchTimeoutMs = this.batchTimeoutMs;
      this.backoff = 1;
      return;
    }
  }
  handleTooManyRequests(status, statusText) {
    throw new Error(`Analytics API error: ${status} ${statusText}`);
  }
}
function toNftCollection(address, data) {
  if (!data) {
    if (address) {
      return { address: asAddressFriendly(address) };
    } else {
      return null;
    }
  }
  const out = {
    address: asAddressFriendly(data.address),
    codeHash: data.code_hash ? Base64ToHex(data.code_hash) : void 0,
    dataHash: data.data_hash ? Base64ToHex(data.data_hash) : void 0,
    nextItemIndex: data.next_item_index.toString(),
    ownerAddress: asMaybeAddressFriendly(data.owner_address) ?? void 0
  };
  if (data.collection_content)
    out.extra = data.collection_content;
  return out;
}
function tokenMetaToNftCollection(address, data) {
  if (!data) {
    return { address: asAddressFriendly(address) };
  }
  const image = data?.extra?.cover_image ?? data?.image;
  const out = {
    address: asAddressFriendly(address),
    name: data.name,
    description: data.description,
    image: {
      url: image,
      smallUrl: data?.extra?._image_small,
      mediumUrl: data?.extra?._image_medium,
      largeUrl: data?.extra?._image_big
    },
    extra: data.extra
  };
  return out;
}
function toNftItem(data) {
  const out = {
    address: asAddressFriendly(data.address),
    index: data.index.toString(),
    collection: toNftCollection(data.collection_address, data.collection) ?? void 0,
    auctionContractAddress: asMaybeAddressFriendly(data.auction_contract_address) ?? void 0,
    ownerAddress: asMaybeAddressFriendly(data.owner_address) ?? void 0,
    realOwnerAddress: asMaybeAddressFriendly(data.real_owner) ?? void 0,
    saleContractAddress: asMaybeAddressFriendly(data.sale_contract_address) ?? void 0,
    codeHash: data.code_hash ? Base64ToHex(data.code_hash) : void 0,
    dataHash: data.data_hash ? Base64ToHex(data.data_hash) : void 0,
    isInited: data.init,
    isSoulbound: data.is_sbt,
    isOnSale: data.on_sale
  };
  if (data.content)
    out.extra = data.content;
  return out;
}
function toTokenInfo(data) {
  const result = {
    valid: data.valid,
    type: data.type,
    name: data.name,
    description: data.description,
    image: data.image,
    extra: data.extra,
    animation: data?.extra?.animation_url
  };
  if (data.lottie) {
    result.lottie = data.lottie;
  } else if (data.extra && typeof data.extra === "object" && "lottie" in data.extra) {
    const lottieValue = data.extra.lottie;
    if (typeof lottieValue === "string") {
      result.lottie = lottieValue;
    }
  }
  if (data?.extra?.animation_url) {
    result.animation = data.extra.animation_url;
  } else if (data?.extra?.content_url && data.extra.content_url.includes("mp4")) {
    result.animation = data.extra.content_url;
  }
  return result;
}
function toApiTokenInfo(data) {
  var lottie;
  var animationUrl;
  if (data?.extra?.animation_url) {
    animationUrl = data.extra.animation_url;
  } else if (data?.extra?.content_url && data.extra.content_url.includes("mp4")) {
    animationUrl = data.extra.content_url;
  }
  if (data.lottie) {
    lottie = data.lottie;
  } else if (data.extra && typeof data.extra === "object" && "lottie" in data.extra) {
    const lottieValue = data.extra.lottie;
    if (typeof lottieValue === "string") {
      lottie = lottieValue;
    }
  }
  const result = {
    name: data.name,
    description: data.description,
    image: {
      url: data.image ?? data.extra?._image_medium,
      smallUrl: data.extra?._image_small,
      mediumUrl: data.extra?._image_medium,
      largeUrl: data.extra?._image_big
    },
    animation: {
      url: animationUrl,
      lottie
    },
    symbol: data.symbol
  };
  return result;
}
function toNftItemsResponse(data) {
  const metadata = {};
  const collections = {};
  if (data.metadata) {
    for (const address of Object.keys(data.metadata)) {
      if (!data.metadata[address].token_info || data.metadata[address].token_info.length === 0) {
        continue;
      }
      const tokenInfo = data.metadata[address].token_info[0];
      if (tokenInfo.type === "nft_items") {
        metadata[asAddressFriendly(address)] = {
          isIndexed: data.metadata[address].is_indexed,
          tokenInfo: [toTokenInfo(tokenInfo)]
        };
      } else if (tokenInfo.type === "nft_collections") {
        const collection = tokenMetaToNftCollection(address, tokenInfo);
        if (collection) {
          collections[asAddressFriendly(address)] = collection;
        }
      }
    }
  }
  const out = {
    addressBook: {},
    // metadata,
    nfts: (data.nft_items ?? []).map((data2) => {
      const item = toNftItem(data2);
      const meta = metadata[item.address];
      if (meta) {
        const tokenInfo = meta.tokenInfo.filter((it2) => it2.valid);
        if (tokenInfo.length > 0) {
          item.info = toApiTokenInfo(tokenInfo[0]);
        }
      }
      const itemCollection = item.collection;
      const itemCollectionMeta = item.collection?.address ? collections[asAddressFriendly(item.collection?.address)] : void 0;
      if (itemCollection || itemCollectionMeta) {
        item.collection = {
          ...itemCollection,
          ...itemCollectionMeta
        };
      }
      return item;
    })
  };
  if (data.address_book) {
    for (const address of Object.keys(data.address_book)) {
      if (out.addressBook) {
        out.addressBook[asAddressFriendly(address)] = {
          address: asAddressFriendly(address),
          domain: data.address_book[address].domain ?? void 0,
          interfaces: data.address_book[address].interfaces ?? []
        };
      }
    }
  }
  return out;
}
function toDnsRecord(data) {
  return {
    dnsNextResolver: data.dns_next_resolver,
    dnsSiteAdnl: data.dns_site_adnl,
    dnsStorageBagId: data.dns_storage_bag_id,
    dnsWallet: asMaybeAddressFriendly(data.dns_wallet),
    domain: data.domain,
    nftItemAddress: asAddressFriendly(data.nft_item_address),
    nftItemOwner: asAddressFriendly(data.nft_item_owner)
  };
}
function toDnsRecords(data) {
  const out = {
    addressBook: {},
    records: data.records ? data.records.map(toDnsRecord) : []
  };
  for (const key of Object.keys(data.address_book)) {
    out.addressBook[asAddressFriendly(key)] = {
      domain: data.address_book[key].domain
    };
  }
  return out;
}
const ROOT_DNS_RESOLVER_MAINNET = "Ef_lZ1T4NCb2mwkme9h2rJfESCE0W34ma9lWp7-_uY3zXDvq";
const ROOT_DNS_RESOLVER_TESTNET = "kf_v5x0Thgr6pq6ur2NvkWhIf4DxAxsL-Nk5rknT6n99oEkd";
var DnsCategory;
(function(DnsCategory2) {
  DnsCategory2["DnsNextResolver"] = "dns_next_resolver";
  DnsCategory2["Wallet"] = "wallet";
  DnsCategory2["Site"] = "site";
  DnsCategory2["BagId"] = "storage";
  DnsCategory2[DnsCategory2["All"] = 0] = "All";
})(DnsCategory || (DnsCategory = {}));
var DnsRecord;
(function(DnsRecord2) {
  DnsRecord2[DnsRecord2["SmcAddress"] = 40915] = "SmcAddress";
  DnsRecord2[DnsRecord2["NextResolver"] = 47763] = "NextResolver";
  DnsRecord2[DnsRecord2["AdnlAddress"] = 44289] = "AdnlAddress";
  DnsRecord2[DnsRecord2["StorageAddress"] = 29811] = "StorageAddress";
})(DnsRecord || (DnsRecord = {}));
function toDnsInternal(domain) {
  domain = domain.toLowerCase().normalize("NFC");
  return domain.split(".").filter(Boolean).reverse().join("\0") + "\0";
}
function toTonDnsCategory(category) {
  category = category ?? DnsCategory.All;
  if (typeof category === "number") {
    return BigInt(category);
  }
  return BigInt("0x" + distExports.sha256_sync(category).toString("hex"));
}
async function dnsResolve(client, domain, category, resolver) {
  let currentResolver = resolver ?? ROOT_DNS_RESOLVER_MAINNET;
  let unresolved = domain;
  let maxResolveDepth = 100;
  while (maxResolveDepth > 0) {
    maxResolveDepth--;
    const step = await dnsLookup(client, unresolved, DnsCategory.DnsNextResolver, currentResolver);
    if (step == null) {
      return null;
    }
    if (step.unresolved) {
      if (!step.value) {
        return null;
      }
      currentResolver = step.value;
      unresolved = step.unresolved;
      continue;
    }
    if (step.record === "NextResolver" && step.value) {
      if (category !== void 0) {
        return dnsLookup(client, ".", category, step.value);
      }
      currentResolver = step.value;
      unresolved = ".";
      continue;
    }
    if (category !== void 0) {
      return dnsLookup(client, ".", category, currentResolver);
    }
    return step;
  }
  return null;
}
async function dnsLookup(client, domain, category, resolver) {
  category = category ?? DnsCategory.DnsNextResolver;
  resolver = resolver ?? ROOT_DNS_RESOLVER_MAINNET;
  const result = {
    resolved: "",
    unresolved: ""
  };
  const isSelf = domain === "." || domain === "";
  const internal = toDnsInternal(domain);
  const param = [
    { type: "slice", cell: toStringTail(internal) },
    { type: "int", value: toTonDnsCategory(category) }
  ];
  const { stack, exitCode } = await client.runGetMethod(asAddressFriendly(resolver), "dnsresolve", SerializeStack(param));
  if (stack?.length !== 2) {
    return null;
  }
  const parsedStack = ParseStack(stack);
  if (exitCode !== 0) {
    return null;
  }
  const resolvedBit = parsedStack[0].type === "int" ? Number(parsedStack[0].value) : 0;
  if (resolvedBit === 0 || resolvedBit % 8 !== 0) {
    return null;
  }
  const resolvedByte = resolvedBit / 8;
  const part = isSelf ? [] : domain.split(".").filter(Boolean);
  const level = internal.slice(0, Number(resolvedByte)).split(".").filter(Boolean).length;
  result.unresolved = part.slice(0, part.length - level).join(".");
  result.resolved = part.slice(part.length - level).join(".");
  if (category === DnsCategory.All) {
    throw new Error("not implemented all categories are requested");
  }
  const cell = parsedStack[1].type === "cell" ? parsedStack[1].cell : null;
  if (!cell) {
    return result;
  }
  const slice = cell.asSlice();
  const tag = slice.loadUint(16);
  if (tag == DnsRecord.NextResolver || tag == DnsRecord.SmcAddress) {
    result.value = slice.loadAddress().toString();
  } else if (tag == DnsRecord.AdnlAddress || tag == DnsRecord.StorageAddress) {
    result.value = toHexString(slice.loadBuffer(32));
  } else {
    result.value = cell.toBoc().toString("base64");
  }
  if (result.value) {
    result.record = DnsRecord[tag];
  }
  return result;
}
const log$4 = globalLogger.createChild("ApiClientToncenter");
class TonClientError extends Error {
  status;
  details;
  constructor(message, status, details) {
    super(message);
    this.name = "TonClientError";
    this.status = status;
    this.details = details;
  }
}
class ApiClientToncenter {
  dnsResolver;
  endpoint;
  apiKey;
  timeout;
  fetchApi;
  network;
  disableNetworkSend;
  constructor(config = {}) {
    this.network = config.network;
    const dnsResolver = this.network?.chainId === CHAIN.MAINNET ? ROOT_DNS_RESOLVER_MAINNET : ROOT_DNS_RESOLVER_TESTNET;
    const defaultEndpoint = this.network?.chainId === CHAIN.MAINNET ? "https://toncenter.com" : "https://testnet.toncenter.com";
    this.dnsResolver = config.dnsResolver ?? dnsResolver;
    this.endpoint = config.endpoint ?? defaultEndpoint;
    this.apiKey = config.apiKey;
    this.timeout = config.timeout ?? 3e4;
    this.fetchApi = config.fetchApi ?? fetch;
    this.disableNetworkSend = config.disableNetworkSend ?? false;
  }
  async nftItemsByAddress(request) {
    const props = {
      address: request.address
    };
    const response = await this.getJson("/api/v3/nft/items", props);
    return toNftItemsResponse(response);
  }
  async nftItemsByOwner(request) {
    const props = {
      owner_address: request.ownerAddress,
      limit: request.pagination?.limit ?? 10,
      offset: request.pagination?.offset ?? 0
    };
    const response = await this.getJson("/api/v3/nft/items", props);
    const formattedResponse = toNftItemsResponse(response);
    return formattedResponse;
  }
  async fetchEmulation(messageBoc, ignoreSignature) {
    const props = {
      boc: messageBoc,
      ignore_chksig: ignoreSignature === true,
      include_code_data: true,
      include_address_book: true,
      include_metadata: true,
      with_actions: true
    };
    const response = await this.postJson("/api/emulate/v1/emulateTrace", props);
    return {
      result: "success",
      emulationResult: response
    };
  }
  async sendBoc(boc) {
    if (this.disableNetworkSend) {
      return "";
    }
    const response = await this.postJson("/api/v3/message", { boc });
    return Base64ToBigInt(response.message_hash_norm).toString(16);
  }
  async runGetMethod(address, method, stack = [], seqno) {
    const props = {
      address,
      method,
      stack
      //serializeStack(stack),
    };
    if (typeof seqno === "number")
      props.seqno = seqno;
    const raw = await this.postJson("/api/v3/runGetMethod", props);
    return {
      gasUsed: raw.gas_used,
      stack: raw.stack,
      exitCode: raw.exit_code
    };
  }
  async getAccountState(address, seqno) {
    const query = { include_boc: true, address: [address] };
    if (typeof seqno === "number")
      query.seqno = seqno.toString();
    const raw = await this.getJson("/api/v3/addressInformation", query);
    const balance = BigInt(raw.balance);
    const extraCurrencies = {};
    for (const currency of raw.extra_currencies || []) {
      extraCurrencies[currency.id] = BigInt(currency.amount);
    }
    const out = {
      status: raw.status,
      balance: balance.toString(),
      extraCurrencies,
      code: raw.code,
      data: raw.data,
      lastTransaction: parseInternalTransactionId({
        hash: raw.last_transaction_hash,
        lt: raw.last_transaction_lt
      })
    };
    if (raw.frozen_hash) {
      out.frozenHash = Base64ToHex(raw.frozen_hash) ?? void 0;
    }
    return out;
  }
  async getBalance(address, seqno) {
    return (await this.getAccountState(address, seqno)).balance;
  }
  async doRequest(url, init2 = {}) {
    const fetchFn = this.fetchApi;
    if (!this.timeout || this.timeout <= 0) {
      return fetchFn(url, init2);
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      return await fetchFn(url, { ...init2, signal: controller.signal });
    } finally {
      clearTimeout(timeoutId);
    }
  }
  async fetch(url, props = {}) {
    const headers = new Headers(props.headers);
    headers.set("accept", "application/json");
    if (this.apiKey)
      headers.set("x-api-key", this.apiKey);
    props = { ...props, headers };
    const response = await this.doRequest(url, props);
    if (!response.ok) {
      throw await this.buildError(response);
    }
    const contentType = response.headers.get("content-type") || "";
    if (!contentType.includes("application/json")) {
      const text = await response.text();
      throw new TonClientError("Unexpected non-JSON response", response.status, text.slice(0, 200));
    }
    const json = await response.json();
    return json;
  }
  async getJson(path, query) {
    return this.fetch(this.buildUrl(path, query), { method: "GET" });
  }
  async postJson(path, props) {
    return this.fetch(this.buildUrl(path), {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(props)
    });
  }
  buildUrl(path, query = {}) {
    const url = new URL(path.replace(/^\/*/, "/"), this.endpoint);
    for (const [key, value] of Object.entries(query)) {
      if (typeof value === "string")
        url.searchParams.set(key, value);
      else if (Array.isArray(value)) {
        for (const item of value) {
          if (typeof item === "string")
            url.searchParams.set(key, item);
          else if (item != null && typeof item.toString === "function") {
            url.searchParams.set(key, item.toString());
          }
        }
      } else if (value != null && typeof value.toString === "function") {
        url.searchParams.set(key, value.toString());
      }
    }
    return url;
  }
  async buildError(response) {
    const message = response.statusText || "HTTP Error";
    const code = response.status ?? 500;
    let detail;
    try {
      detail = await response.json();
    } catch {
    }
    return new TonClientError(`HTTP ${response.status}: ${message}`, code, detail);
  }
  async getAccountTransactions(request) {
    const accounts = request.address?.map(prepareAddress);
    let offset = request.offset ?? 0;
    let limit = request.limit ?? 10;
    if (limit > 100) {
      limit = 100;
    } else if (limit < 0) {
      limit = 0;
    }
    if (offset < 0) {
      offset = 0;
    }
    const response = await this.getJson("/api/v3/transactions", {
      account: accounts,
      limit,
      offset
    });
    return toTransactionsResponse(response);
  }
  async getTransactionsByHash(request) {
    const msgHash = "msgHash" in request ? padBase64(request.msgHash) : void 0;
    const bodyHash = "bodyHash" in request ? padBase64(request.bodyHash) : void 0;
    const response = await this.getJson("/api/v3/transactionsByMessage", {
      msg_hash: msgHash ? [msgHash] : void 0,
      body_hash: bodyHash ? [bodyHash] : void 0
    });
    return toTransactionsResponse(response);
  }
  async getPendingTransactions(request) {
    const accounts = "accounts" in request ? request.accounts?.map(prepareAddress) : void 0;
    const traceId = "traceId" in request ? request.traceId : void 0;
    const response = await this.getJson("/api/v3/pendingTransactions", {
      account: accounts,
      trace_id: traceId
    });
    return toTransactionsResponse(response);
  }
  async getTrace(request) {
    const inTraceId = request.traceId ? request.traceId[0] : void 0;
    const traceId = padBase64(Base64Normalize(inTraceId || "").replace(/=/g, ""));
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        tx_hash: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching trace", { error: error2 });
    }
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        trace_id: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching trace", { error: error2 });
    }
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        msg_hash: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching pending trace", { error: error2 });
    }
    throw new Error("Failed to fetch trace");
  }
  async getPendingTrace(request) {
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/pendingTraces", {
        ext_msg_hash: request.externalMessageHash
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$4.error("Error fetching pending trace", { error: error2 });
    }
    throw new Error("Failed to fetch pending trace");
  }
  async resolveDnsWallet(domain) {
    const result = await dnsResolve(this, domain, DnsCategory.Wallet, this.dnsResolver);
    if (result && result.value) {
      return result.value;
    }
    return null;
  }
  async backResolveDnsWallet(wallet) {
    if (wallet instanceof distExports$2.Address) {
      wallet = wallet.toString();
    }
    const response = toDnsRecords(await this.getJson("/api/v3/dns/records", {
      wallet,
      limit: 1,
      offset: 0
    }));
    if (response.records.length > 0) {
      return response.records[0].domain;
    }
    return null;
  }
  async jettonsByAddress(request) {
    return this.getJson("/api/v3/jetton/masters", {
      address: request.address,
      offset: request.offset,
      limit: request.limit
    });
  }
  async jettonsByOwnerAddress(request) {
    const offset = request.offset ?? 0;
    const limit = request.limit ?? 50;
    const rawResponse = await this.getJson("/api/v3/jetton/wallets", {
      owner_address: request.ownerAddress,
      offset,
      limit
    });
    return this.mapToResponseUserJettons(rawResponse);
  }
  mapToResponseUserJettons(rawResponse) {
    const verifiedJettonsMasters = /* @__PURE__ */ new Set([
      "0:B113A994B5024A16719F69139328EB759596C38A25F59028B146FECDC3621DFE"
    ]);
    const userJettons = rawResponse.jetton_wallets.map((wallet) => {
      const jettonInfo = this.extractJettonInfoFromMetadata(wallet.jetton, rawResponse.metadata);
      const jetton = {
        address: asAddressFriendly(wallet.jetton),
        walletAddress: asAddressFriendly(wallet.address),
        balance: wallet.balance,
        info: {
          name: jettonInfo.name,
          description: jettonInfo.description,
          image: {
            url: jettonInfo.image,
            data: jettonInfo.image_data
          },
          symbol: jettonInfo.symbol
        },
        decimalsNumber: jettonInfo.decimals,
        // For future use, currently prices are not provided by toncenter
        prices: [
          {
            value: "0",
            currency: "USD"
          }
        ],
        isVerified: verifiedJettonsMasters.has(wallet.jetton)
        // ????
        // extra: rawResponse.metadata[wallet.jetton]?.token_info,
      };
      return jetton;
    });
    return {
      jettons: userJettons,
      addressBook: {}
    };
  }
  extractJettonInfoFromMetadata(jettonAddress, metadata) {
    const jettonMetadata = metadata[jettonAddress];
    const metadataJettonInfo = jettonMetadata?.token_info?.find((info) => typeof info === "object" && info !== null && "type" in info && info.type === "jetton_masters");
    if (metadataJettonInfo) {
      const decimals = typeof metadataJettonInfo.extra.decimals === "string" ? parseInt(metadataJettonInfo.extra.decimals, 10) : metadataJettonInfo.extra.decimals;
      return {
        address: jettonAddress,
        name: metadataJettonInfo.name ?? "",
        symbol: metadataJettonInfo.symbol ?? "",
        description: metadataJettonInfo.description ?? "",
        decimals,
        image: metadataJettonInfo.image,
        image_data: metadataJettonInfo.extra.image_data,
        uri: metadataJettonInfo.extra.uri
      };
    }
    return {
      address: jettonAddress,
      name: "",
      symbol: "",
      description: "",
      decimals: 9
    };
  }
  async getEvents(request) {
    const account = request.account instanceof distExports$2.Address ? request.account.toString() : request.account;
    const limit = request.limit ?? 20;
    const offset = request.offset ?? 0;
    const query = {
      account,
      limit,
      offset
    };
    const list = await this.getJson("/api/v3/traces", query);
    const out = { events: [], limit, offset, hasNext: list.traces.length >= limit };
    const addressBook = toAddressBook$1(list);
    for (const trace of list.traces) {
      out.events.push(toEvent(trace, account, addressBook));
    }
    return out;
  }
}
const padBase64 = (data) => {
  return data.padEnd(data.length + (4 - data.length % 4), "=");
};
function prepareAddress(address) {
  if (address instanceof distExports$2.Address) {
    address = address.toString();
  }
  return address;
}
function parseInternalTransactionId(data) {
  if (data.hash !== "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") {
    return {
      lt: data.lt,
      hash: Base64ToHex(data.hash)
    };
  }
  return null;
}
const log$3 = globalLogger.createChild("NetworkManager");
class NetworkManager {
  clients = /* @__PURE__ */ new Map();
  constructor(options) {
    this.initializeClients(options);
    const configuredNetworks = this.getConfiguredNetworks();
    if (configuredNetworks.length === 0) {
      throw new WalletKitError(ERROR_CODES.CONFIGURATION_ERROR, "At least one network must be configured in TonWalletKitOptions.networks");
    }
  }
  /**
   * Initialize API clients from configuration
   */
  initializeClients(options) {
    const networks = options.networks;
    if (!networks) {
      log$3.warn("No networks configured in TonWalletKitOptions");
      return;
    }
    for (const [chainId, networkConfig] of Object.entries(networks)) {
      const network = Network.custom(chainId);
      if (!networkConfig)
        continue;
      const client = this.createClient(network, networkConfig.apiClient, options);
      this.clients.set(network.chainId, client);
      log$3.info("Initialized network client", { chainId });
    }
  }
  /**
   * Create an API client for a specific network
   */
  createClient(network, apiClientConfig, options) {
    if (this.isApiClient(apiClientConfig)) {
      return apiClientConfig;
    }
    const defaultEndpoint = network.chainId === CHAIN.MAINNET ? "https://toncenter.com" : "https://testnet.toncenter.com";
    const endpoint = apiClientConfig?.url || defaultEndpoint;
    return new ApiClientToncenter({
      endpoint,
      apiKey: apiClientConfig?.key,
      network,
      disableNetworkSend: options.dev?.disableNetworkSend
    });
  }
  /**
   * Type guard to check if value is a full ApiClient instance
   */
  isApiClient(value) {
    return !!value && "nftItemsByAddress" in value && "nftItemsByOwner" in value && "fetchEmulation" in value && "sendBoc" in value && "runGetMethod" in value && "getAccountState" in value && "getBalance" in value;
  }
  /**
   * Get API client for a specific network
   * @param chainId - The chain ID (CHAIN.MAINNET or CHAIN.TESTNET)
   * @returns The API client for the specified network
   * @throws WalletKitError if no client is configured for the network
   */
  getClient(network) {
    const client = this.clients.get(network.chainId);
    if (!client) {
      throw new WalletKitError(ERROR_CODES.NETWORK_NOT_CONFIGURED, `No API client configured for network ${network.chainId}`, void 0, {
        network,
        configuredNetworks: Array.from(this.clients.keys())
      });
    }
    return client;
  }
  /**
   * Check if a network is configured
   */
  hasNetwork(network) {
    return this.clients.has(network.chainId);
  }
  /**
   * Get all configured networks
   */
  getConfiguredNetworks() {
    return Array.from(this.clients.keys()).map((chainId) => Network.custom(chainId));
  }
  /**
   * Add or update a network client dynamically
   */
  setClient(network, client) {
    this.clients.set(network.chainId, client);
    log$3.info("Added/updated network client", { network });
  }
}
const log$2 = globalLogger.createChild("TonWalletKit");
class TonWalletKit {
  // Component references
  walletManager;
  sessionManager;
  eventRouter;
  requestProcessor;
  // private responseHandler!: ResponseHandler;
  networkManager;
  jettonsManager;
  initializer;
  eventProcessor;
  bridgeManager;
  config;
  // Event emitter for this kit instance
  eventEmitter;
  // State
  isInitialized = false;
  initializationPromise;
  analyticsManager;
  constructor(options) {
    this.config = options;
    if (options?.analytics?.enabled) {
      this.analyticsManager = new AnalyticsManager({
        ...options?.analytics,
        appInfo: {
          appName: options?.deviceInfo?.appName,
          appVersion: options?.deviceInfo?.appVersion,
          ...options?.analytics?.appInfo
        }
      });
    }
    this.networkManager = new NetworkManager(options);
    this.eventEmitter = new EventEmitter();
    this.initializer = new Initializer(options, this.eventEmitter, this.analyticsManager);
    this.initializationPromise = this.initialize();
    this.jettonsManager = new JettonsManager(1e4, this.eventEmitter, this.networkManager);
    this.eventEmitter.on("restoreConnection", async (event) => {
      if (!event.domain) {
        log$2.error("Domain is required for restore connection");
        return;
      }
      const session = await this.sessionManager.getSessionByDomain(event.domain);
      if (!session) {
        log$2.error("Session not found for domain", { domain: event.domain });
        return;
      }
      const wallet = session.walletId ? this.walletManager?.getWallet(session.walletId) : void 0;
      if (!wallet) {
        log$2.error("Wallet not found for session", { walletId: session.walletId });
        return;
      }
      const walletAddress = wallet.getAddress();
      const walletStateInit = await wallet.getStateInit();
      const publicKey = wallet.getPublicKey().replace("0x", "");
      const deviceInfo = getDeviceInfoForWallet(wallet, this.config.deviceInfo);
      const connectResponse = {
        event: "connect",
        id: Date.now(),
        payload: {
          device: deviceInfo,
          items: [
            {
              name: "ton_addr",
              address: distExports$2.Address.parse(walletAddress).toRawString(),
              // TODO: Support multiple networks
              network: wallet.getNetwork().chainId === CHAIN.MAINNET ? CHAIN.MAINNET : CHAIN.TESTNET,
              walletStateInit,
              publicKey
            }
          ]
        }
      };
      this.bridgeManager.sendJsBridgeResponse(event?.tabId?.toString() || "", true, event?.id ?? event?.messageId, connectResponse);
    });
  }
  // === Initialization ===
  /**
   * Initialize all components
   */
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      const components = await this.initializer.initialize(this.config, this.networkManager);
      this.assignComponents(components);
      await this.setupEventRouting();
      this.eventProcessor.startRecoveryLoop();
      await this.eventProcessor.startProcessing();
      this.isInitialized = true;
    } catch (error2) {
      log$2.error("TonWalletKit initialization failed", { error: error2?.toString() });
      throw error2;
    }
  }
  /**
   * Assign initialized components
   */
  assignComponents(components) {
    this.walletManager = components.walletManager;
    this.sessionManager = components.sessionManager;
    this.eventRouter = components.eventRouter;
    this.requestProcessor = components.requestProcessor;
    this.eventProcessor = components.eventProcessor;
    this.bridgeManager = components.bridgeManager;
  }
  /**
   * Setup event routing from bridge to handlers
   */
  async setupEventRouting() {
    await this.startProcessingForExistingWallets();
  }
  /**
   * Start event processing for all existing wallets
   */
  async startProcessingForExistingWallets() {
    const wallets = this.walletManager.getWallets();
    for (const wallet of wallets) {
      try {
        const walletId = wallet.getWalletId();
        await this.eventProcessor.startProcessing(walletId);
      } catch (error2) {
        log$2.error("Failed to start event processing for wallet", {
          walletAddress: wallet.getAddress(),
          error: error2
        });
      }
    }
  }
  /**
   * Ensure initialization is complete
   */
  async ensureInitialized() {
    if (this.initializationPromise) {
      await this.initializationPromise;
    }
  }
  /**
   * Get all configured networks
   */
  getConfiguredNetworks() {
    return this.networkManager.getConfiguredNetworks();
  }
  // === Wallet Management API (Delegated) ===
  getWallets() {
    if (!this.isInitialized) {
      log$2.warn("TonWalletKit not yet initialized, returning empty array");
      return [];
    }
    return this.walletManager.getWallets();
  }
  /**
   * Get wallet by wallet ID (network:address format)
   */
  getWallet(walletId) {
    if (!this.isInitialized) {
      log$2.warn("TonWalletKit not yet initialized, returning undefined");
      return void 0;
    }
    return this.walletManager.getWallet(walletId);
  }
  async addWallet(adapter) {
    await this.ensureInitialized();
    const walletNetwork = adapter.getNetwork();
    if (!this.networkManager.hasNetwork(walletNetwork)) {
      throw new WalletKitError(ERROR_CODES.NETWORK_NOT_CONFIGURED, `No API client configured for wallet network ${walletNetwork}`, void 0, { walletNetwork, configuredNetworks: this.networkManager.getConfiguredNetworks() });
    }
    const wallet = await wrapWalletInterface(adapter);
    const walletId = await this.walletManager.addWallet(wallet);
    await this.eventProcessor.startProcessing(walletId);
    return wallet;
  }
  async removeWallet(walletIdOrAdapter) {
    await this.ensureInitialized();
    let wallet;
    let walletId;
    if (typeof walletIdOrAdapter === "string") {
      walletId = walletIdOrAdapter;
      wallet = this.walletManager.getWallet(walletIdOrAdapter);
    } else {
      walletId = this.walletManager.getWalletId(walletIdOrAdapter);
      wallet = this.walletManager.getWallet(walletId);
    }
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for removal", void 0, {
        walletId
      });
    }
    await this.eventProcessor.stopProcessing(wallet.getAddress());
    await this.walletManager.removeWallet(walletId);
    await this.sessionManager.removeSessionsForWallet(walletId);
  }
  async clearWallets() {
    await this.ensureInitialized();
    const wallets = this.walletManager.getWallets();
    for (const wallet of wallets) {
      await this.eventProcessor.stopProcessing(wallet.getAddress());
    }
    await this.walletManager.clearWallets();
    await this.sessionManager.clearSessions();
  }
  // === Session Management API (Delegated) ===
  async disconnect(sessionId) {
    await this.ensureInitialized();
    const removeSession = async (sessionId2) => {
      const session = await this.sessionManager.getSession(sessionId2);
      if (session) {
        try {
          const sessionCrypto = new SessionCrypto({
            publicKey: session.publicKey,
            secretKey: session.privateKey
          });
          await CallForSuccess(() => this.bridgeManager.sendResponse({
            sessionId: sessionId2,
            isJsBridge: session?.isJsBridge,
            id: Date.now(),
            from: sessionId2
          }, {
            event: "disconnect",
            id: Date.now(),
            payload: {}
          }, sessionCrypto), 10, 100);
        } catch (error2) {
          log$2.error("Failed to send disconnect to bridge", { sessionId: sessionId2, error: error2 });
        }
      }
      await this.sessionManager.removeSession(sessionId2);
    };
    if (sessionId) {
      try {
        await removeSession(sessionId);
      } catch (error2) {
        log$2.error("Failed to remove session", { sessionId, error: error2 });
      }
    } else {
      const sessions = await this.sessionManager.getSessions();
      if (sessions.length > 0) {
        for (const session of sessions) {
          try {
            await removeSession(session.sessionId);
          } catch (error2) {
            log$2.error("Failed to remove session", { sessionId: session.sessionId, error: error2 });
          }
        }
      }
    }
  }
  async listSessions() {
    await this.ensureInitialized();
    return await this.sessionManager.getSessions();
  }
  // === Event Handler Registration (Delegated) ===
  onConnectRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onConnectRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onConnectRequest(cb);
      });
    }
  }
  onTransactionRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onTransactionRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onTransactionRequest(cb);
      });
    }
  }
  onSignDataRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onSignDataRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onSignDataRequest(cb);
      });
    }
  }
  onDisconnect(cb) {
    if (this.eventRouter) {
      this.eventRouter.onDisconnect(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onDisconnect(cb);
      });
    }
  }
  removeConnectRequestCallback() {
    this.eventRouter.removeConnectRequestCallback();
  }
  removeTransactionRequestCallback() {
    this.eventRouter.removeTransactionRequestCallback();
  }
  removeSignDataRequestCallback() {
    this.eventRouter.removeSignDataRequestCallback();
  }
  removeDisconnectCallback() {
    this.eventRouter.removeDisconnectCallback();
  }
  onRequestError(cb) {
    if (this.eventRouter) {
      this.eventRouter.onRequestError(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onRequestError(cb);
      });
    }
  }
  removeErrorCallback() {
    this.eventRouter.removeErrorCallback();
  }
  // === URL Processing API ===
  /**
   * Handle pasted TON Connect URL/link
   * Parses the URL and creates a connect request event
   */
  async handleTonConnectUrl(url) {
    await this.ensureInitialized();
    try {
      const parsedUrl = this.parseTonConnectUrl(url);
      if (!parsedUrl) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid TON Connect URL format", void 0, {
          url
        });
      }
      const bridgeEvent = this.createConnectEventFromUrl(parsedUrl);
      if (!bridgeEvent) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid TON Connect URL - unable to create bridge event", void 0, { parsedUrl });
      }
      await this.eventRouter.routeEvent(bridgeEvent);
    } catch (error2) {
      log$2.error("Failed to handle TON Connect URL", { error: error2, url });
      throw error2;
    }
  }
  async handleNewTransaction(wallet, data) {
    await this.ensureInitialized();
    data.validUntil ??= Math.floor(Date.now() / 1e3) + 300;
    data.network ??= wallet.getNetwork();
    const walletId = wallet.getWalletId();
    const bridgeEvent = {
      id: Date.now().toString(),
      method: "sendTransaction",
      params: [JSON.stringify(toConnectTransactionParamContent(data))],
      from: "",
      domain: "",
      isLocal: true,
      walletId,
      walletAddress: asAddressFriendly(wallet.getAddress())
    };
    await this.eventRouter.routeEvent(bridgeEvent);
  }
  /**
   * Parse TON Connect URL to extract connection parameters
   */
  parseTonConnectUrl(url) {
    try {
      let parsedUrl;
      parsedUrl = new URL(url);
      const params = {};
      for (const [key, value] of parsedUrl.searchParams.entries()) {
        params[key] = value;
      }
      if (!params.v || !params.id || !params.r) {
        log$2.warn("Missing required TON Connect URL parameters");
        return null;
      }
      return {
        version: params.v,
        clientId: params.id,
        requestId: params.id,
        returnStrategy: params.ret || "back",
        r: params.r,
        ...params
      };
    } catch (error2) {
      log$2.error("Failed to parse TON Connect URL", { error: error2, url });
      return null;
    }
  }
  /**
   * Create bridge event from parsed URL parameters
   */
  createConnectEventFromUrl(params) {
    const rString = params.r;
    const r = rString ? JSON.parse(rString) : void 0;
    if (!r?.manifestUrl || !params.clientId) {
      return void 0;
    }
    return {
      from: params.clientId,
      id: params.requestId,
      method: "connect",
      params: {
        manifest: {
          url: r.manifestUrl
        },
        items: r.items,
        returnStrategy: params.returnStrategy
      },
      timestamp: Date.now(),
      domain: ""
    };
  }
  // === Request Processing API (Delegated) ===
  async approveConnectRequest(event, response) {
    await this.ensureInitialized();
    return this.requestProcessor.approveConnectRequest(event, response);
  }
  async rejectConnectRequest(event, reason, errorCode) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectConnectRequest(event, reason, errorCode);
  }
  async approveTransactionRequest(event, response) {
    await this.ensureInitialized();
    return this.requestProcessor.approveTransactionRequest(event, response);
  }
  async rejectTransactionRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectTransactionRequest(event, reason);
  }
  async approveSignDataRequest(event, response) {
    await this.ensureInitialized();
    return this.requestProcessor.approveSignDataRequest(event, response);
  }
  async rejectSignDataRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectSignDataRequest(event, reason);
  }
  // === TON Client Access ===
  /**
   * Get API client for a specific network
   * @param network - The network object
   * @returns The API client for the specified network
   * @throws WalletKitError if no client is configured for the network
   */
  getApiClient(network) {
    if (!this.isInitialized) {
      throw new WalletKitError(ERROR_CODES.INITIALIZATION_ERROR, "TonWalletKit not yet initialized - call initialize() first");
    }
    return this.networkManager.getClient(network);
  }
  /**
   * Get the NetworkManager instance
   * Provides access to all configured network clients
   */
  getNetworkManager() {
    return this.networkManager;
  }
  // === Lifecycle Management ===
  /**
   * Check if kit is ready for use
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * Wait for initialization to complete
   */
  async waitForReady() {
    await this.ensureInitialized();
  }
  /**
   * Get initialization status
   */
  getStatus() {
    return {
      initialized: this.isInitialized,
      ready: this.isInitialized
    };
  }
  /**
   * Clean shutdown
   */
  async close() {
    if (this.initializer) {
      await this.initializer.cleanup({
        walletManager: this.walletManager,
        bridgeManager: this.bridgeManager,
        sessionManager: this.sessionManager,
        eventRouter: this.eventRouter,
        requestProcessor: this.requestProcessor,
        eventProcessor: this.eventProcessor
      });
    }
    this.isInitialized = false;
  }
  // === Jettons API ===
  /**
   * Jettons API access
   */
  get jettons() {
    return this.jettonsManager;
  }
  /**
   * Get jettons manager for internal use
   */
  getJettonsManager() {
    return this.jettonsManager;
  }
  /**
   * Get the event emitter for this kit instance
   * Allows external components to listen to and emit events
   */
  getEventEmitter() {
    return this.eventEmitter;
  }
  /**
   * Process a bridge request from injected JS Bridge
   * This method is called by extension content scripts
   * @param request - The bridge request to process
   * @returns Promise resolving to the response data
   */
  async processInjectedBridgeRequest(messageInfo, request) {
    await this.ensureInitialized();
    return this.bridgeManager.queueJsBridgeEvent(messageInfo, request);
  }
}
const WalletV5R1CodeBoc = "b5ee9c7201021401000281000114ff00f4a413f4bcf2c80b01020120020302014804050102f20e02dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120060702012008090019be5f0f6a2684080a0eb90fa02c02016e0a0b0201480c0d0019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00017b325fb51341c75c875c2c7e00011b262fb513435c28020011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0";
const WalletV5R1CodeCell = distExports$2.Cell.fromBoc(Buffer.from(WalletV5R1CodeBoc, "hex"))[0];
class ActionSendMsg {
  mode;
  outMsg;
  static tag = 247711853;
  tag = ActionSendMsg.tag;
  constructor(mode, outMsg) {
    this.mode = mode;
    this.outMsg = outMsg;
  }
  serialize() {
    return distExports$2.beginCell().storeUint(this.tag, 32).storeUint(this.mode | distExports$2.SendMode.IGNORE_ERRORS, 8).storeRef(distExports$2.beginCell().store(distExports$2.storeMessageRelaxed(this.outMsg)).endCell()).endCell();
  }
}
class ActionAddExtension {
  address;
  static tag = 2;
  tag = ActionAddExtension.tag;
  constructor(address) {
    this.address = address;
  }
  serialize() {
    return distExports$2.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
  }
}
class ActionRemoveExtension {
  address;
  static tag = 3;
  tag = ActionRemoveExtension.tag;
  constructor(address) {
    this.address = address;
  }
  serialize() {
    return distExports$2.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
  }
}
class ActionSetSignatureAuthAllowed {
  allowed;
  static tag = 4;
  tag = ActionSetSignatureAuthAllowed.tag;
  constructor(allowed) {
    this.allowed = allowed;
  }
  serialize() {
    return distExports$2.beginCell().storeUint(this.tag, 8).storeUint(this.allowed ? 1 : 0, 1).endCell();
  }
}
function isExtendedAction(action) {
  return action.tag === ActionAddExtension.tag || action.tag === ActionRemoveExtension.tag || action.tag === ActionSetSignatureAuthAllowed.tag;
}
function packActionsListOut(actions) {
  if (actions.length === 0) {
    return distExports$2.beginCell().endCell();
  }
  const [action, ...rest] = actions;
  if (isExtendedAction(action)) {
    throw new Error("Actions bust be in an order: all extended actions, all out actions");
  }
  return distExports$2.beginCell().storeRef(packActionsListOut(rest)).storeSlice(action.serialize().beginParse()).endCell();
}
function packExtendedActions(extendedActions) {
  const first = extendedActions[0];
  const rest = extendedActions.slice(1);
  let builder2 = distExports$2.beginCell().storeSlice(first.serialize().beginParse());
  if (rest.length > 0) {
    builder2 = builder2.storeRef(packExtendedActions(extendedActions.slice(1)));
  }
  return builder2.endCell();
}
function packActionsListExtended(actions) {
  const extendedActions = [];
  const outActions = [];
  actions.forEach((action) => {
    if (isExtendedAction(action)) {
      extendedActions.push(action);
    } else {
      outActions.push(action);
    }
  });
  let builder2 = distExports$2.beginCell();
  if (outActions.length === 0) {
    builder2 = builder2.storeUint(0, 1);
  } else {
    builder2 = builder2.storeMaybeRef(packActionsListOut(outActions.slice().reverse()));
  }
  if (extendedActions.length === 0) {
    builder2 = builder2.storeUint(0, 1);
  } else {
    const first = extendedActions[0];
    const rest = extendedActions.slice(1);
    builder2 = builder2.storeUint(1, 1).storeSlice(first.serialize().beginParse());
    if (rest.length > 0) {
      builder2 = builder2.storeRef(packExtendedActions(rest));
    }
  }
  return builder2.endCell();
}
function packActionsList(actions) {
  return packActionsListExtended(actions);
}
const log$1 = globalLogger.createChild("WalletV5R1Adapter");
const defaultWalletIdV5R1 = 2147483409;
class WalletV5R1Adapter {
  // private keyPair: { publicKey: Uint8Array; secretKey: Uint8Array };
  signer;
  config;
  walletContract;
  client;
  publicKey;
  version = "v5r1";
  /**
   * Static factory method to create a WalletV5R1Adapter
   * @param signer - Signer function with publicKey property (from Signer utility)
   * @param options - Configuration options for the wallet
   */
  static async create(signer, options) {
    return new WalletV5R1Adapter({
      signer,
      publicKey: signer.publicKey,
      tonClient: options.client,
      network: options.network,
      walletId: options.walletId,
      workchain: options.workchain
    });
  }
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    this.signer = config.signer;
    this.publicKey = this.config.publicKey;
    this.walletContract = WalletV5.createFromConfig({
      publicKey: HexToBigInt(this.publicKey),
      seqno: 0,
      signatureAllowed: true,
      walletId: typeof config.walletId === "bigint" ? Number(config.walletId) : config.walletId ?? defaultWalletIdV5R1,
      extensions: distExports$2.Dictionary.empty()
    }, {
      code: WalletV5R1CodeCell,
      workchain: config.workchain ?? 0,
      client: this.client
    });
  }
  getPublicKey() {
    return this.publicKey;
  }
  getClient() {
    return this.client;
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return this.signer.sign(bytes);
  }
  getNetwork() {
    return this.config.network;
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  getWalletId() {
    return createWalletId(this.getNetwork(), this.getAddress());
  }
  async getSignedSendTransaction(input, options) {
    const actions = packActionsList(input.messages.map((m2) => {
      let bounce = true;
      const parsedAddress = distExports$2.Address.parseFriendly(m2.address);
      if (parsedAddress.isBounceable === false) {
        bounce = false;
      }
      const msg = distExports$2.internal({
        to: m2.address,
        value: BigInt(m2.amount),
        bounce,
        extracurrency: m2.extraCurrency ? Object.fromEntries(Object.entries(m2.extraCurrency).map(([k2, v2]) => [Number(k2), BigInt(v2)])) : void 0
      });
      if (m2.payload) {
        try {
          msg.body = distExports$2.Cell.fromBase64(m2.payload);
        } catch (error2) {
          log$1.warn("Failed to load payload", { error: error2 });
          throw WalletKitError.fromError(ERROR_CODES.CONTRACT_VALIDATION_FAILED, "Failed to parse transaction payload", error2);
        }
      }
      if (m2.stateInit) {
        try {
          msg.init = distExports$2.loadStateInit(distExports$2.Cell.fromBase64(m2.stateInit).asSlice());
        } catch (error2) {
          log$1.warn("Failed to load state init", { error: error2 });
          throw WalletKitError.fromError(ERROR_CODES.CONTRACT_VALIDATION_FAILED, "Failed to parse state init", error2);
        }
      }
      return new ActionSendMsg(distExports$2.SendMode.PAY_GAS_SEPARATELY + distExports$2.SendMode.IGNORE_ERRORS, msg);
    }));
    const createBodyOptions = {
      ...options,
      validUntil: void 0
    };
    if (input.validUntil) {
      const now = Math.floor(Date.now() / 1e3);
      const maxValidUntil = now + 600;
      if (input.validUntil < now) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Transaction valid_until timestamp is in the past", void 0, { validUntil: input.validUntil, currentTime: now });
      } else if (input.validUntil > maxValidUntil) {
        createBodyOptions.validUntil = maxValidUntil;
      } else {
        createBodyOptions.validUntil = input.validUntil;
      }
    }
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const walletId = (await this.walletContract.walletId).serialized;
    if (!walletId) {
      throw new Error("Failed to get seqno or walletId");
    }
    const transfer = await this.createBodyV5(seqno, walletId, actions, createBodyOptions);
    const ext = distExports$2.external({
      to: this.walletContract.address,
      init: this.walletContract.init,
      body: transfer
    });
    return distExports$2.beginCell().store(distExports$2.storeMessage(ext)).endCell().toBoc().toString("base64");
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$2.beginCell().store(distExports$2.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV5 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      return await this.walletContract.seqno;
    } catch (error2) {
      log$1.warn("Failed to get seqno", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet ID
   */
  async getWalletV5R1Id() {
    try {
      return this.walletContract.walletId;
    } catch (error2) {
      log$1.warn("Failed to get wallet ID", { error: error2 });
      const walletId = this.config.walletId;
      const subwalletNumber = typeof walletId === "bigint" ? Number(walletId) : walletId || 0;
      return new WalletV5R1Id({ subwalletNumber });
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getAccountState(asAddressFriendly(this.walletContract.address));
      return state.status === "active";
    } catch (error2) {
      log$1.warn("Failed to check deployment status", { error: error2 });
      return false;
    }
  }
  async createBodyV5(seqno, walletId, actionsList, options) {
    const Opcodes2 = {
      auth_signed: 1936287598
    };
    const expireAt = options.validUntil ?? Math.floor(Date.now() / 1e3) + 300;
    const payload = distExports$2.beginCell().storeUint(Opcodes2.auth_signed, 32).storeUint(walletId, 32).storeUint(expireAt, 32).storeUint(seqno, 32).storeSlice(actionsList.beginParse()).endCell();
    const signingData = payload.hash();
    const signature = options.fakeSignature ? FakeSignature(signingData) : await this.sign(signingData);
    return distExports$2.beginCell().storeSlice(payload.beginParse()).storeBuffer(Buffer.from(HexToUint8Array(signature))).endCell();
  }
  async getSignedSignData(input) {
    const signature = await this.sign(HexToUint8Array(input.hash));
    return signature;
  }
  async getSignedTonProof(input) {
    const message = await CreateTonProofMessageBytes(input);
    const signature = await this.sign(message);
    return signature;
  }
  getSupportedFeatures() {
    return [
      {
        name: "SendTransaction",
        maxMessages: 255
      },
      {
        name: "SignData",
        types: ["binary", "cell", "text"]
      }
    ];
  }
}
function walletV5ConfigToCell(config) {
  return distExports$2.beginCell().storeBit(config.signatureAllowed).storeUint(config.seqno, 32).storeUint(config.walletId, 32).storeUint(config.publicKey, 256).storeDict(config.extensions, distExports$2.Dictionary.Keys.BigUint(256), distExports$2.Dictionary.Values.BigInt(1)).endCell();
}
const Opcodes = {
  action_send_msg: 247711853,
  action_set_code: 2907562126,
  action_extended_set_data: 536406539,
  action_extended_add_extension: 2,
  action_extended_remove_extension: 3,
  action_extended_set_signature_auth_allowed: 4,
  auth_extension: 1702392942,
  auth_signed: 1936287598,
  auth_signed_internal: 1936289396
};
class WalletV5R1Id {
  static deserialize(walletId) {
    return new WalletV5R1Id({
      subwalletNumber: walletId
    });
  }
  subwalletNumber;
  serialized;
  constructor(args) {
    this.subwalletNumber = args?.subwalletNumber ?? 0;
    this.serialized = BigInt(this.subwalletNumber);
  }
}
class WalletV5 {
  client;
  address;
  init;
  subwalletId;
  constructor(client, address, init2) {
    this.client = client;
    this.address = address;
    this.init = init2;
  }
  static createFromAddress(client, address) {
    return new WalletV5(client, address);
  }
  static createFromConfig(config, options) {
    const data = walletV5ConfigToCell(config);
    const init2 = { code: options.code, data };
    const wallet = new WalletV5(options.client, distExports$2.contractAddress(options.workchain, init2), init2);
    wallet.subwalletId = config.walletId;
    return wallet;
  }
  async sendDeploy(provider, via, value) {
    await provider.internal(via, {
      value,
      sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$2.beginCell().endCell()
    });
  }
  async sendInternalSignedMessage(provider, via, opts) {
    await provider.internal(via, {
      value: opts.value,
      sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$2.beginCell().storeSlice(opts.body.beginParse()).endCell()
    });
  }
  async sendInternalMessageFromExtension(provider, via, opts) {
    await provider.internal(via, {
      value: opts.value,
      sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$2.beginCell().storeUint(Opcodes.auth_extension, 32).storeUint(0, 64).storeSlice(opts.body.beginParse()).endCell()
    });
  }
  async sendInternal(provider, via, opts) {
    await provider.internal(via, opts);
  }
  async sendExternalSignedMessage(provider, body) {
    await provider.external(body);
  }
  async sendExternal(provider, body) {
    await provider.external(body);
  }
  get publicKey() {
    return this.client.runGetMethod(asAddressFriendly(this.address), "get_public_key").then((data) => {
      if (data.exitCode === 0) {
        const parsedStack = ParseStack(data.stack);
        if (parsedStack[0]?.type === "int") {
          return parsedStack[0].value;
        } else {
          throw new Error("Stack is not an int");
        }
      } else if (this.init) {
        return this.init.data.asSlice().skip(1 + 32 + 32).loadUintBig(256);
      } else {
        return 0n;
      }
    });
  }
  get status() {
    return this.client.getAccountState(asAddressFriendly(this.address)).then((state) => state.status);
  }
  get seqno() {
    return this.client.runGetMethod(asAddressFriendly(this.address), "seqno").then((data) => {
      if (data.exitCode === 0) {
        const parsedStack = ParseStack(data.stack);
        if (parsedStack[0]?.type === "int") {
          return Number(parsedStack[0].value);
        } else {
          throw new Error("Stack is not an int");
        }
      } else {
        return 0;
      }
    });
  }
  get isSignatureAuthAllowed() {
    return this.client.runGetMethod(asAddressFriendly(this.address), "is_signature_allowed").then((data) => {
      if (data.exitCode === 0) {
        const parsedStack = ParseStack(data.stack);
        if (parsedStack[0]?.type === "int") {
          return Boolean(parsedStack[0].value);
        } else {
          throw new Error("Stack is not an int");
        }
      } else {
        return false;
      }
    });
  }
  get walletId() {
    if (this.subwalletId !== void 0) {
      return new Promise((resolve) => {
        resolve(WalletV5R1Id.deserialize(this.subwalletId));
      });
    } else {
      return this.client.runGetMethod(asAddressFriendly(this.address), "get_subwallet_id").then((data) => {
        if (data.exitCode === 0) {
          const parsedStack = ParseStack(data.stack);
          if (parsedStack[0]?.type === "int") {
            this.subwalletId = Number(parsedStack[0].value);
          } else {
            throw new Error("Stack is not an int");
          }
          return WalletV5R1Id.deserialize(this.subwalletId);
        } else {
          return WalletV5R1Id.deserialize(defaultWalletIdV5R1);
        }
      });
    }
  }
}
class WalletV4R2 {
  address;
  init;
  workchain;
  publicKey;
  subwalletId;
  client;
  constructor(address, init2, options) {
    this.address = address;
    this.init = init2 ?? void 0;
    this.workchain = options.workchain;
    this.client = options.client;
    if (init2) {
      const dataSlice = init2.data.beginParse();
      dataSlice.loadUint(32);
      this.subwalletId = dataSlice.loadUint(32);
      this.publicKey = dataSlice.loadUintBig(256);
    } else {
      this.subwalletId = 0;
      this.publicKey = 0n;
    }
  }
  static createFromConfig(config, options) {
    const data = distExports$2.beginCell().storeUint(config.seqno, 32).storeUint(config.subwalletId, 32).storeUint(config.publicKey, 256).storeBit(0).endCell();
    const init2 = { code: options.code, data };
    const address = distExports$2.contractAddress(options.workchain, init2);
    return new WalletV4R2(address, init2, options);
  }
  static createFromAddress(address, options) {
    return new WalletV4R2(address, null, options);
  }
  async sendDeploy(provider, via, value) {
    await provider.internal(via, {
      value,
      sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$2.beginCell().endCell()
    });
  }
  /**
   * Get wallet's current sequence number
   */
  async getSeqno() {
    try {
      const state = await this.client.runGetMethod(asAddressFriendly(this.address), "seqno");
      if (state.exitCode !== 0) {
        return 0;
      }
      const parsedStack = ParseStack(state.stack);
      if (parsedStack[0]?.type === "int") {
        return Number(parsedStack[0].value);
      } else {
        throw new Error("Stack is not an int");
      }
    } catch (error2) {
      return 0;
    }
  }
  /**
   * Get wallet's current sequence number (async getter)
   */
  get seqno() {
    return this.getSeqno();
  }
  /**
   * Get wallet's subwallet ID
   */
  async getSubwalletId() {
    try {
      const state = await this.client.runGetMethod(asAddressFriendly(this.address), "get_subwallet_id");
      if (state.exitCode !== 0) {
        return this.subwalletId;
      }
      const parsedStack = ParseStack(state.stack);
      if (parsedStack[0]?.type === "int") {
        return Number(parsedStack[0].value);
      } else {
        throw new Error("Stack is not an int");
      }
    } catch (error2) {
      return this.subwalletId;
    }
  }
  /**
   * Create transfer message body
   */
  createTransfer(args) {
    const timeout = args.timeout ?? Math.floor(Date.now() / 1e3) + 60;
    let body = distExports$2.beginCell().storeUint(this.subwalletId, 32).storeUint(timeout, 32).storeUint(args.seqno, 32).storeUint(0, 8).storeUint(args.sendMode, 8);
    for (const message of args.messages) {
      body = body.storeRef(distExports$2.beginCell().store(distExports$2.storeMessageRelaxed(message)));
    }
    return body.endCell();
  }
  /**
   * Send internal transfer
   */
  async sendTransfer(provider, via, args) {
    const transfer = this.createTransfer(args);
    await provider.internal(via, {
      sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
      body: transfer,
      value: 0n
    });
  }
}
const WalletV4R2CodeCell = distExports$2.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
const defaultWalletIdV4R2 = 698983191;
const log = globalLogger.createChild("WalletV4R2Adapter");
class WalletV4R2Adapter {
  signer;
  config;
  walletContract;
  client;
  publicKey;
  version = "v4r2";
  /**
   * Static factory method to create a WalletV4R2Adapter
   * @param signer - Signer function with publicKey property (from Signer utility)
   * @param options - Configuration options for the wallet
   */
  static async create(signer, options) {
    return new WalletV4R2Adapter({
      signer,
      publicKey: signer.publicKey,
      tonClient: options.client,
      network: options.network,
      walletId: typeof options.walletId === "bigint" ? Number(options.walletId) : options.walletId,
      workchain: options.workchain
    });
  }
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    this.signer = config.signer;
    this.publicKey = this.config.publicKey;
    const walletConfig = {
      publicKey: HexToBigInt(this.publicKey),
      workchain: config.workchain ?? 0,
      seqno: 0,
      subwalletId: config.walletId ?? defaultWalletIdV4R2
    };
    this.walletContract = WalletV4R2.createFromConfig(walletConfig, {
      code: WalletV4R2CodeCell,
      workchain: config.workchain ?? 0,
      client: this.client
    });
  }
  getPublicKey() {
    return this.publicKey;
  }
  getClient() {
    return this.client;
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return this.signer.sign(bytes);
  }
  getNetwork() {
    return this.config.network;
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  getWalletId() {
    return createWalletId(this.getNetwork(), this.getAddress());
  }
  async getSignedSendTransaction(input, _options) {
    if (input.messages.length === 0) {
      throw new Error("Ledger does not support empty messages");
    }
    if (input.messages.length > 4) {
      throw new Error("WalletV4R2 does not support more than 4 messages");
    }
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const timeout = input.validUntil ? Math.min(input.validUntil, Math.floor(Date.now() / 1e3) + 600) : Math.floor(Date.now() / 1e3) + 60;
    try {
      const messages = input.messages.map((m2) => {
        let bounce = true;
        const parsedAddress = distExports$2.Address.parseFriendly(m2.address);
        if (parsedAddress.isBounceable === false) {
          bounce = false;
        }
        return distExports$2.internal({
          to: distExports$2.Address.parse(m2.address),
          value: BigInt(m2.amount),
          bounce,
          extracurrency: m2.extraCurrency ? Object.fromEntries(Object.entries(m2.extraCurrency).map(([k2, v2]) => [Number(k2), BigInt(v2)])) : void 0,
          body: m2.payload ? distExports$2.Cell.fromBase64(m2.payload) : void 0,
          init: m2.stateInit ? distExports$2.loadStateInit(distExports$2.Cell.fromBase64(m2.stateInit).asSlice()) : void 0
        });
      });
      const data = this.walletContract.createTransfer({
        seqno,
        sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY + distExports$2.SendMode.IGNORE_ERRORS,
        messages,
        timeout
      });
      const signature = await this.sign(Uint8Array.from(data.hash()));
      const signedCell = distExports$2.beginCell().storeBuffer(Buffer.from(HexToUint8Array(signature))).storeSlice(data.asSlice()).endCell();
      const ext = distExports$2.external({
        to: this.walletContract.address,
        init: this.walletContract.init,
        body: signedCell
      });
      return distExports$2.beginCell().store(distExports$2.storeMessage(ext)).endCell().toBoc().toString("base64");
    } catch (error2) {
      log.warn("Failed to get signed send transaction", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$2.beginCell().store(distExports$2.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV4R2 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      return await this.walletContract.getSeqno();
    } catch (error2) {
      log.warn("Failed to get seqno", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet's subwallet ID
   */
  async getSubwalletId() {
    try {
      return await this.walletContract.getSubwalletId();
    } catch (error2) {
      log.warn("Failed to get subwallet ID", { error: error2 });
      return this.config.walletId ?? defaultWalletIdV4R2;
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getAccountState(asAddressFriendly(this.walletContract.address));
      return state.status === "active";
    } catch (error2) {
      log.warn("Failed to check deployment status", { error: error2 });
      return false;
    }
  }
  async getSignedSignData(input) {
    const signature = await this.sign(HexToUint8Array(input.hash));
    return signature;
  }
  async getSignedTonProof(input) {
    const message = await CreateTonProofMessageBytes(input);
    const signature = await this.sign(message);
    return signature;
  }
  getSupportedFeatures() {
    return [
      {
        name: "SendTransaction",
        maxMessages: 4
      },
      {
        name: "SignData",
        types: ["binary", "cell", "text"]
      }
    ];
  }
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApiClientToncenter,
  get AssetType() {
    return AssetType;
  },
  Base64Normalize,
  Base64NormalizeUrl,
  Base64ToBigInt,
  Base64ToHex,
  Base64ToUint8Array,
  BigIntToBase64,
  BridgeError,
  BridgeManager,
  CallForSuccess,
  ConnectHandler,
  CreateTonMnemonic,
  CreateTonProofMessageBytes,
  DEFAULT_DURABLE_EVENTS_CONFIG,
  DEFAULT_REQUEST_TIMEOUT,
  DefaultSignature,
  DisconnectHandler,
  ERROR_CODES,
  EventEmitter,
  EventRouter,
  EventStoreError,
  ExtensionStorageAdapter,
  FakeSignature,
  HexToBase64,
  HexToBigInt,
  HexToUint8Array,
  Initializer,
  JettonError,
  get JettonErrorCode() {
    return JettonErrorCode;
  },
  JettonsManager,
  LocalStorageAdapter,
  MemoryStorageAdapter,
  MnemonicToKeyPair,
  Network,
  NetworkManager,
  Opcodes,
  ParseBase64,
  ParseStack,
  RESTORE_CONNECTION_TIMEOUT,
  RequestProcessor,
  get Result() {
    return Result$1;
  },
  get SEND_TRANSACTION_ERROR_CODES() {
    return SEND_TRANSACTION_ERROR_CODES;
  },
  get SendModeBase() {
    return SendModeBase;
  },
  get SendModeFlag() {
    return SendModeFlag;
  },
  SerializeStack,
  SessionError,
  SignDataHandler,
  Signer,
  Storage,
  StorageError,
  StorageEventProcessor,
  StorageEventStore,
  TONCONNECT_BRIDGE_EVENT,
  TONConnectStoredSessionManager,
  TonWalletKit,
  TransactionHandler,
  Uint8ArrayToBase64,
  Uint8ArrayToBigInt,
  Uint8ArrayToHex,
  WalletKitError,
  WalletManager,
  WalletV4R2,
  WalletV4R2Adapter,
  WalletV4R2CodeCell,
  WalletV5,
  WalletV5R1Adapter,
  WalletV5R1CodeBoc,
  WalletV5R1CodeCell,
  WalletV5R1Id,
  createDeviceInfo,
  createWalletId,
  createWalletManifest,
  defaultWalletIdV4R2,
  defaultWalletIdV5R1,
  emulationEvent,
  formatWalletAddress,
  getErrorCodeName,
  isValidAddress,
  wrapWalletInterface
}, Symbol.toStringTag, { value: "Module" }));
let walletKit = null;
function setWalletKit(instance) {
  walletKit = instance;
}
const internalBrowserGlobal = globalThis;
function getInternalBrowserResolverMap() {
  return internalBrowserGlobal.__internalBrowserResponseResolvers;
}
function ensureInternalBrowserResolverMap() {
  if (!internalBrowserGlobal.__internalBrowserResponseResolvers) {
    internalBrowserGlobal.__internalBrowserResponseResolvers = /* @__PURE__ */ new Map();
  }
  return internalBrowserGlobal.__internalBrowserResponseResolvers;
}
var __async$d = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function hasAndroidSessionManager() {
  var _a2, _b;
  const win = window;
  return ((_b = (_a2 = win.WalletKitNative) == null ? void 0 : _a2.hasSessionManager) == null ? void 0 : _b.call(_a2)) === true;
}
class AndroidTONConnectSessionsManager {
  constructor() {
    var _a2;
    const win = window;
    if (!((_a2 = win.WalletKitNative) == null ? void 0 : _a2.sessionCreate)) {
      throw new Error("Android native session manager bridge not available");
    }
    this.bridge = win.WalletKitNative;
    log$l("[AndroidSessionManager] Initialized with native bridge");
  }
  initialize() {
    return __async$d(this, null, function* () {
      log$l("[AndroidSessionManager] initialize() called - no-op for Android");
    });
  }
  createSession(sessionId, dAppInfo, wallet, isJsBridge) {
    return __async$d(this, null, function* () {
      var _a2, _b, _c, _d;
      try {
        log$l("[AndroidSessionManager] createSession:", sessionId);
        const walletId = (_b = (_a2 = wallet.getWalletId) == null ? void 0 : _a2.call(wallet)) != null ? _b : "";
        const walletAddress = (_d = (_c = wallet.getAddress) == null ? void 0 : _c.call(wallet)) != null ? _d : "";
        const dAppInfoJson = JSON.stringify({
          name: dAppInfo.name,
          url: dAppInfo.url,
          iconUrl: dAppInfo.iconUrl,
          description: dAppInfo.description
        });
        const resultJson = this.bridge.sessionCreate(sessionId, dAppInfoJson, walletId, walletAddress, isJsBridge);
        const session = JSON.parse(resultJson);
        log$l("[AndroidSessionManager] Session created:", session.sessionId);
        return session;
      } catch (err) {
        error("[AndroidSessionManager] Failed to create session:", err);
        throw err;
      }
    });
  }
  getSession(sessionId) {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] getSession:", sessionId);
        const resultJson = this.bridge.sessionGet(sessionId);
        if (!resultJson) {
          return void 0;
        }
        return JSON.parse(resultJson);
      } catch (err) {
        warn("[AndroidSessionManager] Failed to get session:", err);
        return void 0;
      }
    });
  }
  getSessionByDomain(domain) {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] getSessionByDomain:", domain);
        const resultJson = this.bridge.sessionGetByDomain(domain);
        if (!resultJson) {
          return void 0;
        }
        return JSON.parse(resultJson);
      } catch (err) {
        warn("[AndroidSessionManager] Failed to get session by domain:", err);
        return void 0;
      }
    });
  }
  getSessions() {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] getSessions");
        const resultJson = this.bridge.sessionGetAll();
        return JSON.parse(resultJson);
      } catch (err) {
        warn("[AndroidSessionManager] Failed to get sessions:", err);
        return [];
      }
    });
  }
  getSessionsForWallet(walletId) {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] getSessionsForWallet:", walletId);
        const resultJson = this.bridge.sessionGetForWallet(walletId);
        return JSON.parse(resultJson);
      } catch (err) {
        warn("[AndroidSessionManager] Failed to get sessions for wallet:", err);
        return [];
      }
    });
  }
  removeSession(sessionId) {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] removeSession:", sessionId);
        this.bridge.sessionRemove(sessionId);
      } catch (err) {
        error("[AndroidSessionManager] Failed to remove session:", err);
        throw err;
      }
    });
  }
  removeSessionsForWallet(walletId) {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] removeSessionsForWallet:", walletId);
        this.bridge.sessionRemoveForWallet(walletId);
      } catch (err) {
        error("[AndroidSessionManager] Failed to remove sessions for wallet:", err);
        throw err;
      }
    });
  }
  clearSessions() {
    return __async$d(this, null, function* () {
      try {
        log$l("[AndroidSessionManager] clearSessions");
        this.bridge.sessionClear();
      } catch (err) {
        error("[AndroidSessionManager] Failed to clear sessions:", err);
        throw err;
      }
    });
  }
}
var __async$c = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
class AndroidAPIClientAdapter {
  constructor(network) {
    const androidWindow = window;
    if (!androidWindow.WalletKitNative) {
      throw new Error("WalletKitNative bridge not available");
    }
    this.androidBridge = androidWindow.WalletKitNative;
    this.network = network;
  }
  /**
   * Check if native API clients are available.
   */
  static isAvailable() {
    var _a2;
    const androidWindow = window;
    return typeof ((_a2 = androidWindow.WalletKitNative) == null ? void 0 : _a2.apiGetNetworks) === "function";
  }
  /**
   * Get all networks that have native API clients configured.
   */
  static getAvailableNetworks() {
    var _a2;
    const androidWindow = window;
    if (!((_a2 = androidWindow.WalletKitNative) == null ? void 0 : _a2.apiGetNetworks)) {
      return [];
    }
    try {
      const networksJson = androidWindow.WalletKitNative.apiGetNetworks();
      return JSON.parse(networksJson);
    } catch (err) {
      error("[AndroidAPIClientAdapter] Failed to get available networks:", err);
      return [];
    }
  }
  sendBoc(boc) {
    return __async$c(this, null, function* () {
      log$l("[AndroidAPIClientAdapter] sendBoc:", boc.substring(0, 50) + "...");
      try {
        const networkJson = JSON.stringify(this.network);
        const result = this.androidBridge.apiSendBoc(networkJson, boc);
        log$l("[AndroidAPIClientAdapter] sendBoc result:", result);
        return result;
      } catch (err) {
        error("[AndroidAPIClientAdapter] sendBoc failed:", err);
        throw err;
      }
    });
  }
  runGetMethod(address, method, stack, seqno) {
    return __async$c(this, null, function* () {
      log$l("[AndroidAPIClientAdapter] runGetMethod:", address, method);
      try {
        const networkJson = JSON.stringify(this.network);
        const stackJson = stack ? JSON.stringify(stack) : null;
        const seqnoArg = seqno != null ? seqno : -1;
        const resultJson = this.androidBridge.apiRunGetMethod(networkJson, address, method, stackJson, seqnoArg);
        const result = JSON.parse(resultJson);
        log$l("[AndroidAPIClientAdapter] runGetMethod result:", result);
        return result;
      } catch (err) {
        error("[AndroidAPIClientAdapter] runGetMethod failed:", err);
        throw err;
      }
    });
  }
  // Methods not implemented - will throw if called
  // These are optional for mobile usage
  nftItemsByAddress(_request) {
    return __async$c(this, null, function* () {
      throw new Error("nftItemsByAddress is not implemented yet");
    });
  }
  nftItemsByOwner(_request) {
    return __async$c(this, null, function* () {
      throw new Error("nftItemsByOwner is not implemented yet");
    });
  }
  fetchEmulation(_messageBoc, _ignoreSignature) {
    return __async$c(this, null, function* () {
      throw new Error("fetchEmulation is not implemented yet");
    });
  }
  getAccountState(_address, _seqno) {
    return __async$c(this, null, function* () {
      throw new Error("getAccountState is not implemented yet");
    });
  }
  getBalance(address, seqno) {
    return __async$c(this, null, function* () {
      log$l("[AndroidAPIClientAdapter] getBalance:", address);
      try {
        const networkJson = JSON.stringify(this.network);
        const seqnoArg = seqno != null ? seqno : -1;
        const result = this.androidBridge.apiGetBalance(networkJson, address, seqnoArg);
        log$l("[AndroidAPIClientAdapter] getBalance result:", result);
        return result;
      } catch (err) {
        error("[AndroidAPIClientAdapter] getBalance failed:", err);
        throw err;
      }
    });
  }
  getAccountTransactions(_request) {
    return __async$c(this, null, function* () {
      throw new Error("getAccountTransactions is not implemented yet");
    });
  }
  getTransactionsByHash(_request) {
    return __async$c(this, null, function* () {
      throw new Error("getTransactionsByHash is not implemented yet");
    });
  }
  getPendingTransactions(_request) {
    return __async$c(this, null, function* () {
      throw new Error("getPendingTransactions is not implemented yet");
    });
  }
  getTrace(_request) {
    return __async$c(this, null, function* () {
      throw new Error("getTrace is not implemented yet");
    });
  }
  getPendingTrace(_request) {
    return __async$c(this, null, function* () {
      throw new Error("getPendingTrace is not implemented yet");
    });
  }
  resolveDnsWallet(_domain) {
    return __async$c(this, null, function* () {
      throw new Error("resolveDnsWallet is not implemented yet");
    });
  }
  backResolveDnsWallet(_address) {
    return __async$c(this, null, function* () {
      throw new Error("backResolveDnsWallet is not implemented yet");
    });
  }
  jettonsByAddress(_request) {
    return __async$c(this, null, function* () {
      throw new Error("jettonsByAddress is not implemented yet");
    });
  }
  jettonsByOwnerAddress(_request) {
    return __async$c(this, null, function* () {
      throw new Error("jettonsByOwnerAddress is not implemented yet");
    });
  }
  getEvents(_request) {
    return __async$c(this, null, function* () {
      throw new Error("getEvents is not implemented yet");
    });
  }
}
var __async$b = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function initTonWalletKit(config, deps) {
  return __async$b(this, null, function* () {
    var _a2, _b, _c;
    if (walletKit) {
      return { ok: true };
    }
    yield ensureWalletKitLoaded();
    log$l("[walletkitBridge] initTonWalletKit config:", JSON.stringify(config, null, 2));
    const networksConfig = {};
    if ((config == null ? void 0 : config.networkConfigurations) && Array.isArray(config.networkConfigurations)) {
      for (const netConfig of config.networkConfigurations) {
        networksConfig[netConfig.network.chainId] = {
          apiClient: netConfig.apiClientConfiguration
        };
        log$l("[walletkitBridge] Added network from networkConfigurations:", netConfig.network.chainId);
      }
    }
    if (AndroidAPIClientAdapter.isAvailable()) {
      log$l("[walletkitBridge] Native API clients available, checking for configured networks");
      const availableNetworks = AndroidAPIClientAdapter.getAvailableNetworks();
      log$l("[walletkitBridge] Available native API networks:", JSON.stringify(availableNetworks));
      for (const nativeNetwork of availableNetworks) {
        log$l("[walletkitBridge] Using native API client for network:", nativeNetwork.chainId);
        networksConfig[nativeNetwork.chainId] = {
          apiClient: new AndroidAPIClientAdapter(nativeNetwork)
        };
      }
    }
    const kitOptions = {
      networks: networksConfig
    };
    if (config == null ? void 0 : config.disableNetworkSend) {
      kitOptions.dev = { disableNetworkSend: true };
      log$l("[walletkitBridge]  disableNetworkSend is enabled - transactions will be simulated only");
    }
    if (config == null ? void 0 : config.deviceInfo) {
      kitOptions.deviceInfo = config.deviceInfo;
    }
    if (config == null ? void 0 : config.walletManifest) {
      kitOptions.walletManifest = config.walletManifest;
    }
    if (config == null ? void 0 : config.bridgeUrl) {
      kitOptions.bridge = {
        bridgeUrl: config.bridgeUrl,
        jsBridgeTransport: (sessionId, message) => __async$b(null, null, function* () {
          var _a22, _b2;
          log$l("[walletkitBridge]  jsBridgeTransport called:", {
            sessionId,
            messageType: message.type,
            messageId: message.messageId,
            hasPayload: !!message.payload,
            payloadEvent: (_a22 = message.payload) == null ? void 0 : _a22.event
          });
          log$l("[walletkitBridge]  Full message:", JSON.stringify(message, null, 2));
          let bridgeMessage = message;
          if (bridgeMessage.type === TONCONNECT_BRIDGE_RESPONSE && ((_b2 = bridgeMessage.payload) == null ? void 0 : _b2.event) === "disconnect" && !bridgeMessage.messageId) {
            log$l("[walletkitBridge]  Transforming disconnect response to event");
            bridgeMessage = {
              type: TONCONNECT_BRIDGE_EVENT,
              source: bridgeMessage.source,
              event: bridgeMessage.payload,
              traceId: bridgeMessage.traceId
            };
            log$l("[walletkitBridge]  Transformed message:", JSON.stringify(bridgeMessage, null, 2));
          }
          if (bridgeMessage.messageId) {
            log$l("[walletkitBridge]  Message has messageId, checking for pending promise");
            const resolvers = getInternalBrowserResolverMap();
            const resolver = resolvers == null ? void 0 : resolvers.get(bridgeMessage.messageId);
            if (resolver) {
              log$l("[walletkitBridge]  Resolving response promise for messageId:", bridgeMessage.messageId);
              resolvers == null ? void 0 : resolvers.delete(bridgeMessage.messageId);
              resolver.resolve(bridgeMessage);
            } else {
              warn("[walletkitBridge]  No pending promise for messageId:", bridgeMessage.messageId);
            }
          }
          if (bridgeMessage.type === TONCONNECT_BRIDGE_EVENT) {
            log$l("[walletkitBridge]  Sending event to WebView for session:", sessionId);
            deps.postToNative({
              kind: "jsBridgeEvent",
              sessionId,
              event: bridgeMessage
            });
            log$l("[walletkitBridge]  Event sent successfully");
          }
          return Promise.resolve();
        })
      };
    }
    if (window.WalletKitNative) {
      log$l("[walletkitBridge] Using Android native storage adapter");
      kitOptions.storage = new deps.AndroidStorageAdapter();
    } else if (config == null ? void 0 : config.allowMemoryStorage) {
      log$l("[walletkitBridge] Using memory storage (sessions will not persist)");
      kitOptions.storage = {
        allowMemory: true
      };
    }
    if (hasAndroidSessionManager()) {
      log$l("[walletkitBridge] Using Android native session manager");
      kitOptions.sessionManager = new AndroidTONConnectSessionsManager();
    } else {
      log$l("[walletkitBridge] Using default WalletKit session manager");
    }
    if (!TonWalletKit$1) {
      throw new Error("TonWalletKit module not loaded");
    }
    setWalletKit(new TonWalletKit$1(kitOptions));
    if ((_a2 = walletKit) == null ? void 0 : _a2.ensureInitialized) {
      yield (_c = (_b = walletKit) == null ? void 0 : _b.ensureInitialized) == null ? void 0 : _c.call(_b);
    }
    deps.emit("ready", {});
    deps.postToNative({ kind: "ready" });
    log$l("[walletkitBridge] WalletKit ready");
    return { ok: true };
  });
}
function requireWalletKit() {
  if (!walletKit) {
    throw new Error("WalletKit not initialized");
  }
  return walletKit;
}
function bigIntReplacer(_key, value) {
  if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}
function resolveNativeBridge(scope) {
  const candidate = scope.WalletKitNative;
  if (candidate && typeof candidate.postMessage === "function") {
    return candidate.postMessage.bind(candidate);
  }
  const windowRef = typeof scope.window === "object" && scope.window ? scope.window : void 0;
  const windowCandidate = windowRef == null ? void 0 : windowRef.WalletKitNative;
  if (windowCandidate && typeof windowCandidate.postMessage === "function") {
    return windowCandidate.postMessage.bind(windowCandidate);
  }
  return null;
}
function resolveAndroidBridge(scope) {
  const candidate = scope.AndroidBridge;
  if (candidate && typeof candidate.postMessage === "function") {
    return candidate.postMessage.bind(candidate);
  }
  const windowRef = typeof scope.window === "object" && scope.window ? scope.window : void 0;
  const windowCandidate = windowRef == null ? void 0 : windowRef.AndroidBridge;
  if (windowCandidate && typeof windowCandidate.postMessage === "function") {
    return windowCandidate.postMessage.bind(windowCandidate);
  }
  return null;
}
function postToNative(payload) {
  if (payload === null || typeof payload !== "object" && typeof payload !== "function") {
    const diagnostic = {
      type: typeof payload,
      value: payload,
      stack: new Error("postToNative non-object payload").stack
    };
    error("[walletkitBridge] postToNative received non-object payload", diagnostic);
    throw new Error("Invalid payload - must be an object");
  }
  const json = JSON.stringify(payload, bigIntReplacer);
  const nativePostMessage = resolveNativeBridge(window);
  if (nativePostMessage) {
    nativePostMessage(json);
    return;
  }
  const androidPostMessage = resolveAndroidBridge(window);
  if (androidPostMessage) {
    androidPostMessage(json);
    return;
  }
  if (payload.kind === "event") {
    throw new Error("Native bridge not available - cannot deliver event");
  }
  log$l("[walletkitBridge]  native (no handler)", payload);
}
function emitCallDiagnostic(id, method, stage, message) {
  postToNative({
    kind: "diagnostic-call",
    id,
    method,
    stage,
    timestamp: Date.now(),
    message
  });
}
var __async$a = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
let apiRef;
function emit(type, data) {
  const event = { type, data };
  postToNative({ kind: "event", event });
}
function respond(id, result, error2) {
  log$l("[walletkitBridge]  respond() called with:");
  log$l("[walletkitBridge]  id:", id);
  log$l("[walletkitBridge]  result:", result);
  log$l("[walletkitBridge]  error:", error2);
  log$l("[walletkitBridge]  About to call postToNative...");
  postToNative({ kind: "response", id, result, error: error2 });
  log$l("[walletkitBridge]  postToNative completed");
}
function setBridgeApi(api2) {
  apiRef = api2;
}
function invokeApiMethod(api2, method, params, context) {
  return __async$a(this, null, function* () {
    log$l(`[walletkitBridge] handleCall ${method}, looking up api[${method}]`);
    const fn2 = api2[method];
    log$l(`[walletkitBridge] fn found:`, typeof fn2);
    if (typeof fn2 !== "function") {
      throw new Error(`Unknown method ${String(method)}`);
    }
    log$l(`[walletkitBridge] about to call fn for ${method}`);
    const value = yield fn2.call(
      api2,
      params,
      context
    );
    log$l(`[walletkitBridge] fn returned for ${method}`);
    log$l(`[walletkitBridge]  fn returned value:`, value);
    log$l(`[walletkitBridge]  value type:`, typeof value);
    return value;
  });
}
function handleCall(id, method, params) {
  return __async$a(this, null, function* () {
    if (!apiRef) {
      throw new Error("Bridge API not registered");
    }
    emitCallDiagnostic(id, method, "start");
    try {
      const context = { id, method };
      const value = yield invokeApiMethod(apiRef, method, params, context);
      emitCallDiagnostic(id, method, "success");
      respond(id, value);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      error(`[walletkitBridge] handleCall error for ${method}:`, err);
      error(`[walletkitBridge] error type:`, typeof err);
      error(`[walletkitBridge] error message:`, message);
      error(`[walletkitBridge] error stack:`, err instanceof Error ? err.stack : "no stack");
      emitCallDiagnostic(id, method, "error", message);
      respond(id, void 0, { message });
    }
  });
}
function registerNativeCallHandler() {
  window.__walletkitCall = (id, method, paramsJson) => {
    let params = void 0;
    if (paramsJson && paramsJson !== "null") {
      try {
        params = JSON.parse(paramsJson);
      } catch (e) {
        respond(id, void 0, { message: "Invalid params JSON" });
        return;
      }
    }
    void handleCall(id, method, params);
  };
}
const eventListeners = {
  onConnectListener: null,
  onTransactionListener: null,
  onSignDataListener: null,
  onDisconnectListener: null,
  onErrorListener: null
};
var __async$9 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
class AndroidStorageAdapter {
  constructor() {
    const androidWindow = window;
    if (!androidWindow.WalletKitNative) {
      throw new Error("WalletKitNative bridge not available");
    }
    this.androidBridge = androidWindow.WalletKitNative;
  }
  get(key) {
    return __async$9(this, null, function* () {
      try {
        const value = this.androidBridge.storageGet(key);
        log$l("[AndroidStorageAdapter] get:", key, "=", value ? `${value.substring(0, 100)}...` : "null");
        if (!value) {
          return null;
        }
        return JSON.parse(value);
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to get key:", key, err);
        return null;
      }
    });
  }
  set(key, value) {
    return __async$9(this, null, function* () {
      try {
        const serialized = JSON.stringify(value);
        log$l("[AndroidStorageAdapter] set:", key, "=", serialized.substring(0, 100) + "...");
        this.androidBridge.storageSet(key, serialized);
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to set key:", key, err);
      }
    });
  }
  remove(key) {
    return __async$9(this, null, function* () {
      try {
        log$l("[AndroidStorageAdapter] remove:", key);
        this.androidBridge.storageRemove(key);
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to remove key:", key, err);
      }
    });
  }
  clear() {
    return __async$9(this, null, function* () {
      try {
        log$l("[AndroidStorageAdapter] clear: clearing all storage");
        this.androidBridge.storageClear();
      } catch (err) {
        error("[AndroidStorageAdapter] Failed to clear storage:", err);
      }
    });
  }
}
var __async$8 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function init(config) {
  return __async$8(this, null, function* () {
    yield ensureWalletKitLoaded();
    return yield initTonWalletKit(config, {
      emit,
      postToNative,
      AndroidStorageAdapter
    });
  });
}
function setEventsListeners(args) {
  var _a2;
  const kit = requireWalletKit();
  const callback = (_a2 = args == null ? void 0 : args.callback) != null ? _a2 : ((type, event) => {
    emit(type, event);
  });
  if (eventListeners.onConnectListener) {
    kit.removeConnectRequestCallback();
  }
  eventListeners.onConnectListener = (event) => {
    callback("connectRequest", event);
  };
  kit.onConnectRequest(eventListeners.onConnectListener);
  if (eventListeners.onTransactionListener) {
    kit.removeTransactionRequestCallback();
  }
  eventListeners.onTransactionListener = (event) => {
    callback("transactionRequest", event);
  };
  kit.onTransactionRequest(eventListeners.onTransactionListener);
  if (eventListeners.onSignDataListener) {
    kit.removeSignDataRequestCallback();
  }
  eventListeners.onSignDataListener = (event) => {
    callback("signDataRequest", event);
  };
  kit.onSignDataRequest(eventListeners.onSignDataListener);
  if (eventListeners.onDisconnectListener) {
    kit.removeDisconnectCallback();
  }
  eventListeners.onDisconnectListener = (event) => {
    callback("disconnect", event);
  };
  kit.onDisconnect(eventListeners.onDisconnectListener);
  if (eventListeners.onErrorListener) {
    kit.removeErrorCallback();
  }
  eventListeners.onErrorListener = (event) => {
    callback("requestError", event);
  };
  kit.onRequestError(eventListeners.onErrorListener);
  return { ok: true };
}
function removeEventListeners() {
  const kit = requireWalletKit();
  if (eventListeners.onConnectListener) {
    kit.removeConnectRequestCallback();
    eventListeners.onConnectListener = null;
  }
  if (eventListeners.onTransactionListener) {
    kit.removeTransactionRequestCallback();
    eventListeners.onTransactionListener = null;
  }
  if (eventListeners.onSignDataListener) {
    kit.removeSignDataRequestCallback();
    eventListeners.onSignDataListener = null;
  }
  if (eventListeners.onDisconnectListener) {
    kit.removeDisconnectCallback();
    eventListeners.onDisconnectListener = null;
  }
  if (eventListeners.onErrorListener) {
    kit.removeErrorCallback();
    eventListeners.onErrorListener = null;
  }
  return { ok: true };
}
var __async$7 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function callBridge(_method, operation) {
  return __async$7(this, null, function* () {
    if (!walletKit) {
      throw new Error("WalletKit not initialized");
    }
    if (walletKit.ensureInitialized) {
      yield walletKit.ensureInitialized();
    }
    return yield operation(walletKit);
  });
}
function callOnWalletBridge(walletId, method, args) {
  return __async$7(this, null, function* () {
    return callBridge(`wallet.${method}`, (kit) => __async$7(null, null, function* () {
      var _a2;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, walletId);
      const methodRef = wallet == null ? void 0 : wallet[method];
      return yield methodRef.call(wallet, args);
    }));
  });
}
var __async$6 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function signWithCustomSigner(signerId, bytes) {
  return __async$6(this, null, function* () {
    const result = yield callBridge("signWithCustomSigner", () => __async$6(null, null, function* () {
      var _a2, _b;
      return (_b = (_a2 = window.WalletKitNative) == null ? void 0 : _a2.signWithCustomSigner) == null ? void 0 : _b.call(_a2, signerId, Array.from(bytes));
    }));
    return result;
  });
}
function mnemonicToKeyPair(args) {
  return __async$6(this, null, function* () {
    return callBridge("mnemonicToKeyPair", () => __async$6(null, null, function* () {
      var _a2;
      return yield MnemonicToKeyPair$1(args.mnemonic, (_a2 = args.mnemonicType) != null ? _a2 : "ton");
    }));
  });
}
function sign(args) {
  return __async$6(this, null, function* () {
    return callBridge("sign", () => __async$6(null, null, function* () {
      const dataBytes = Uint8Array.from(args.data);
      const secretKeyBytes = Uint8Array.from(args.secretKey);
      return DefaultSignature$1(dataBytes, secretKeyBytes);
    }));
  });
}
function createTonMnemonic() {
  return __async$6(this, arguments, function* (_args = { count: 24 }) {
    return callBridge("createTonMnemonic", () => __async$6(null, null, function* () {
      const mnemonicResult = yield CreateTonMnemonic$1();
      return Array.isArray(mnemonicResult) ? mnemonicResult : `${mnemonicResult}`.split(" ").filter(Boolean);
    }));
  });
}
var __async$5 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function getWallets() {
  return __async$5(this, null, function* () {
    return callBridge("getWallets", (kit) => __async$5(null, null, function* () {
      var _a2, _b;
      const wallets = (_b = (_a2 = kit.getWallets) == null ? void 0 : _a2.call(kit)) != null ? _b : [];
      return wallets.map((w2) => {
        var _a22;
        return {
          walletId: (_a22 = w2.getWalletId) == null ? void 0 : _a22.call(w2),
          wallet: w2
        };
      });
    }));
  });
}
function getWallet(args) {
  return __async$5(this, null, function* () {
    return callBridge("getWallet", (kit) => __async$5(null, null, function* () {
      var _a2, _b;
      const w2 = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      if (!w2) return null;
      return { walletId: (_b = w2.getWalletId) == null ? void 0 : _b.call(w2), wallet: w2 };
    }));
  });
}
function getWalletAddress(args) {
  return __async$5(this, null, function* () {
    return callBridge("getWalletAddress", (kit) => __async$5(null, null, function* () {
      var _a2, _b, _c;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      return (_c = (_b = wallet == null ? void 0 : wallet.getAddress) == null ? void 0 : _b.call(wallet)) != null ? _c : null;
    }));
  });
}
function removeWallet(args) {
  return __async$5(this, null, function* () {
    return callBridge("removeWallet", (kit) => __async$5(null, null, function* () {
      var _a2;
      return yield (_a2 = kit.removeWallet) == null ? void 0 : _a2.call(kit, args.walletId);
    }));
  });
}
function getBalance(args) {
  return __async$5(this, null, function* () {
    return callBridge("getBalance", (kit) => __async$5(null, null, function* () {
      var _a2, _b;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      return yield (_b = wallet == null ? void 0 : wallet.getBalance) == null ? void 0 : _b.call(wallet);
    }));
  });
}
const signerStore = /* @__PURE__ */ new Map();
const adapterStore = /* @__PURE__ */ new Map();
function getSigner(args) {
  return __async$5(this, null, function* () {
    if (args.isCustom && args.publicKey) {
      return {
        sign: (bytes) => __async$5(null, null, function* () {
          return yield signWithCustomSigner(args.signerId, Uint8Array.from(bytes));
        }),
        publicKey: args.publicKey
      };
    }
    const storedSigner = signerStore.get(args.signerId);
    if (!storedSigner) {
      throw new Error(`Signer not found: ${args.signerId}`);
    }
    return storedSigner;
  });
}
function createSigner(args) {
  return __async$5(this, null, function* () {
    return callBridge("createSigner", (_kit) => __async$5(null, null, function* () {
      const signer = args.mnemonic && args.mnemonic.length > 0 ? yield Signer$1.fromMnemonic(args.mnemonic, { type: args.mnemonicType || "ton" }) : yield Signer$1.fromPrivateKey(args.secretKey);
      const tempId = `signer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      signerStore.set(tempId, signer);
      return { _tempId: tempId, signer };
    }));
  });
}
function createAdapter(args) {
  return __async$5(this, null, function* () {
    return callBridge("createAdapter", (kit) => __async$5(null, null, function* () {
      const signer = yield getSigner(args);
      const AdapterClass = args.walletVersion === "v5r1" ? WalletV5R1Adapter$1 : WalletV4R2Adapter$1;
      const adapter = yield AdapterClass.create(signer, {
        client: kit.getApiClient(args.network),
        network: args.network,
        workchain: args.workchain,
        walletId: args.walletId
      });
      const tempId = `adapter_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      adapterStore.set(tempId, adapter);
      return { _tempId: tempId, adapter };
    }));
  });
}
function getAdapterAddress(args) {
  return __async$5(this, null, function* () {
    return callBridge("getAdapterAddress", (_kit) => __async$5(null, null, function* () {
      const adapter = adapterStore.get(args.adapterId);
      if (!adapter) {
        throw new Error(`Adapter not found: ${args.adapterId}`);
      }
      return adapter.getAddress();
    }));
  });
}
function addWallet(args) {
  return __async$5(this, null, function* () {
    return callBridge("addWallet", (kit) => __async$5(null, null, function* () {
      var _a2;
      const adapter = adapterStore.get(args.adapterId);
      if (!adapter) {
        throw new Error(`Adapter not found: ${args.adapterId}`);
      }
      const wallet = yield kit.addWallet(adapter);
      adapterStore.delete(args.adapterId);
      if (!wallet) return null;
      return { walletId: (_a2 = wallet.getWalletId) == null ? void 0 : _a2.call(wallet), wallet };
    }));
  });
}
var __async$4 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function getRecentTransactions(args) {
  return __async$4(this, null, function* () {
    return callBridge("getRecentTransactions", (kit) => __async$4(null, null, function* () {
      var _a2, _b, _c;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      const address = (_c = (_b = wallet == null ? void 0 : wallet.getAddress) == null ? void 0 : _b.call(wallet)) != null ? _c : args.walletId.split(":")[1];
      const response = yield wallet.getClient().getAccountTransactions({
        address: [address],
        limit: args.limit || 10
      });
      return (response == null ? void 0 : response.transactions) || [];
    }));
  });
}
function createTransferTonTransaction(args) {
  return __async$4(this, null, function* () {
    return callBridge("createTransferTonTransaction", (kit) => __async$4(null, null, function* () {
      var _a2;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      if (!wallet) {
        throw new Error(`Wallet not found: ${args.walletId}`);
      }
      const transaction = yield wallet.createTransferTonTransaction(args);
      if (wallet.getTransactionPreview) {
        try {
          const preview = yield wallet.getTransactionPreview(transaction);
          return { transaction, preview };
        } catch (err) {
          warn("[walletkitBridge] getTransactionPreview failed", err);
        }
      }
      return { transaction };
    }));
  });
}
function createTransferMultiTonTransaction(args) {
  return __async$4(this, null, function* () {
    return callBridge("createTransferMultiTonTransaction", (kit) => __async$4(null, null, function* () {
      var _a2;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      if (!wallet) {
        throw new Error(`Wallet not found: ${args.walletId}`);
      }
      const transaction = yield wallet.createTransferMultiTonTransaction(args);
      if (wallet.getTransactionPreview) {
        try {
          const preview = yield wallet.getTransactionPreview(transaction);
          return { transaction, preview };
        } catch (err) {
          warn("[walletkitBridge] getTransactionPreview failed", err);
        }
      }
      return { transaction };
    }));
  });
}
function getTransactionPreview(args) {
  return __async$4(this, null, function* () {
    return callBridge("getTransactionPreview", (kit) => __async$4(null, null, function* () {
      var _a2;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      if (!wallet) {
        throw new Error(`Wallet not found: ${args.walletId}`);
      }
      const transaction = typeof args.transactionContent === "string" ? JSON.parse(args.transactionContent) : args.transactionContent;
      if (!wallet.getTransactionPreview) {
        throw new Error("getTransactionPreview not available on wallet");
      }
      return yield wallet.getTransactionPreview(transaction);
    }));
  });
}
function handleNewTransaction(args) {
  return __async$4(this, null, function* () {
    return callBridge("handleNewTransaction", (kit) => __async$4(null, null, function* () {
      var _a2;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      if (!wallet) {
        throw new Error(`Wallet not found: ${args.walletId}`);
      }
      const transaction = typeof args.transactionContent === "string" ? JSON.parse(args.transactionContent) : args.transactionContent;
      yield kit.handleNewTransaction(wallet, transaction);
      return { success: true };
    }));
  });
}
function sendTransaction(args) {
  return __async$4(this, null, function* () {
    return callBridge("sendTransaction", (kit) => __async$4(null, null, function* () {
      var _a2;
      const wallet = (_a2 = kit.getWallet) == null ? void 0 : _a2.call(kit, args.walletId);
      if (!wallet) {
        throw new Error(`Wallet not found: ${args.walletId}`);
      }
      const transaction = typeof args.transactionContent === "string" ? JSON.parse(args.transactionContent) : args.transactionContent;
      return yield wallet.sendTransaction(transaction);
    }));
  });
}
var __async$3 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function approveConnectRequest(args) {
  return __async$3(this, null, function* () {
    return callBridge("approveConnectRequest", (kit) => __async$3(null, null, function* () {
      log$l("approveConnectRequest walletId:", args.walletId);
      const event = args.event;
      if (!event) {
        throw new Error("Event is required for connect request approval");
      }
      event.walletId = args.walletId;
      const result = yield kit.approveConnectRequest(event, args.response);
      return result;
    }));
  });
}
function rejectConnectRequest(args) {
  return __async$3(this, null, function* () {
    return callBridge("rejectConnectRequest", (kit) => __async$3(null, null, function* () {
      const event = args.event;
      if (!event) {
        throw new Error("Event is required for connect request rejection");
      }
      const result = yield kit.rejectConnectRequest(event, args.reason, args.errorCode);
      return result != null ? result : { success: true };
    }));
  });
}
function approveTransactionRequest(args) {
  return __async$3(this, null, function* () {
    return callBridge("approveTransactionRequest", (kit) => __async$3(null, null, function* () {
      const event = args.event;
      if (!event) {
        throw new Error("Event is required for transaction request approval");
      }
      if (args.walletId) {
        event.walletId = args.walletId;
      }
      const result = yield kit.approveTransactionRequest(event, args.response);
      return result;
    }));
  });
}
function rejectTransactionRequest(args) {
  return __async$3(this, null, function* () {
    return callBridge("rejectTransactionRequest", (kit) => __async$3(null, null, function* () {
      const event = args.event;
      if (!event) {
        throw new Error("Event is required for transaction request rejection");
      }
      const reason = args.errorCode !== void 0 ? { code: args.errorCode, message: args.reason || "Transaction rejected" } : args.reason;
      const result = yield kit.rejectTransactionRequest(event, reason);
      return result != null ? result : { success: true };
    }));
  });
}
function approveSignDataRequest(args) {
  return __async$3(this, null, function* () {
    return callBridge("approveSignDataRequest", (kit) => __async$3(null, null, function* () {
      log$l("approveSignDataRequest args:", args);
      const event = args.event;
      if (!event) {
        throw new Error("Event is required for sign-data request approval");
      }
      log$l("approveSignDataRequest event:", event);
      if (args.walletId) {
        event.walletId = args.walletId;
      }
      log$l("approveSignDataRequest calling kit.approveSignDataRequest with event:", event, "response:", args.response);
      const result = yield kit.approveSignDataRequest(event, args.response);
      log$l("approveSignDataRequest result:", result);
      return result;
    }));
  });
}
function rejectSignDataRequest(args) {
  return __async$3(this, null, function* () {
    return callBridge("rejectSignDataRequest", (kit) => __async$3(null, null, function* () {
      const event = args.event;
      if (!event) {
        throw new Error("Event is required for sign-data request rejection");
      }
      const reason = args.errorCode !== void 0 ? { code: args.errorCode, message: args.reason || "Sign data rejected" } : args.reason;
      const result = yield kit.rejectSignDataRequest(event, reason);
      return result != null ? result : { success: true };
    }));
  });
}
var __async$2 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function handleTonConnectUrl(args) {
  return __async$2(this, null, function* () {
    return callBridge("handleTonConnectUrl", (kit) => __async$2(null, null, function* () {
      return yield kit.handleTonConnectUrl(args.url);
    }));
  });
}
function listSessions() {
  return __async$2(this, null, function* () {
    return callBridge("listSessions", (kit) => __async$2(null, null, function* () {
      const fetchedSessions = kit.listSessions ? yield kit.listSessions() : [];
      const sessions = Array.isArray(fetchedSessions) ? fetchedSessions : [];
      return { items: sessions };
    }));
  });
}
function disconnectSession(args) {
  return __async$2(this, null, function* () {
    return callBridge("disconnectSession", (kit) => __async$2(null, null, function* () {
      if (kit.disconnect) {
        yield kit.disconnect(args == null ? void 0 : args.sessionId);
      }
      return { ok: true };
    }));
  });
}
function processInternalBrowserRequest(args) {
  return __async$2(this, null, function* () {
    return callBridge("processInternalBrowserRequest", (kit) => __async$2(null, null, function* () {
      const domain = args.url ? new URL(args.url).origin : "internal-browser";
      const messageInfo = {
        messageId: args.messageId,
        tabId: args.messageId,
        domain
      };
      const request = {
        id: args.messageId,
        method: args.method,
        params: args.params
      };
      if (kit.processInjectedBridgeRequest) {
        yield kit.processInjectedBridgeRequest(messageInfo, request);
      } else {
        throw new Error("processInjectedBridgeRequest not available");
      }
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error(`Request timeout: ${args.messageId}`));
        }, 6e4);
        const resolverMap = ensureInternalBrowserResolverMap();
        resolverMap.set(args.messageId, {
          resolve: (response) => {
            var _a2;
            clearTimeout(timeoutId);
            if (response && typeof response === "object" && "payload" in response) {
              resolve((_a2 = response.payload) != null ? _a2 : response);
            } else {
              resolve(response);
            }
          },
          reject: (error2) => {
            clearTimeout(timeoutId);
            reject(error2);
          }
        });
      });
    }));
  });
}
var __async$1 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function getNfts(args) {
  return __async$1(this, null, function* () {
    return callBridge("getNfts", () => __async$1(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "getNfts", {
        pagination: args.pagination,
        collectionAddress: args.collectionAddress,
        indirectOwnership: args.indirectOwnership
      });
    }));
  });
}
function getNft(args) {
  return __async$1(this, null, function* () {
    return callBridge("getNft", () => __async$1(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "getNft", args.nftAddress);
    }));
  });
}
function createTransferNftTransaction(args) {
  return __async$1(this, null, function* () {
    return callBridge("createTransferNftTransaction", () => __async$1(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "createTransferNftTransaction", {
        nftAddress: args.nftAddress,
        toAddress: args.toAddress,
        transferAmount: args.transferAmount,
        comment: args.comment
      });
    }));
  });
}
function createTransferNftRawTransaction(args) {
  return __async$1(this, null, function* () {
    return callBridge("createTransferNftRawTransaction", () => __async$1(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "createTransferNftRawTransaction", {
        nftAddress: args.nftAddress,
        transferAmount: args.transferAmount,
        transferMessage: args.transferMessage
      });
    }));
  });
}
var __async = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
function getJettons(args) {
  return __async(this, null, function* () {
    return callBridge("getJettons", () => __async(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "getJettons", {
        pagination: args.pagination
      });
    }));
  });
}
function createTransferJettonTransaction(args) {
  return __async(this, null, function* () {
    return callBridge("createTransferJettonTransaction", () => __async(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "createTransferJettonTransaction", {
        jettonAddress: args.jettonAddress,
        amount: args.amount,
        toAddress: args.toAddress,
        comment: args.comment
      });
    }));
  });
}
function getJettonBalance(args) {
  return __async(this, null, function* () {
    return callBridge("getJettonBalance", () => __async(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "getJettonBalance", args.jettonAddress);
    }));
  });
}
function getJettonWalletAddress(args) {
  return __async(this, null, function* () {
    return callBridge("getJettonWalletAddress", () => __async(null, null, function* () {
      return yield callOnWalletBridge(args.walletId, "getJettonWalletAddress", args.jettonAddress);
    }));
  });
}
function emitBrowserPageStarted(args) {
  emit("browserPageStarted", { url: args.url });
  return { success: true };
}
function emitBrowserPageFinished(args) {
  emit("browserPageFinished", { url: args.url });
  return { success: true };
}
function emitBrowserError(args) {
  emit("browserError", { message: args.message });
  return { success: true };
}
function emitBrowserBridgeRequest(args) {
  emit("browserBridgeRequest", {
    messageId: args.messageId,
    method: args.method,
    request: args.request
  });
  return { success: true };
}
const apiImpl = {
  // Initialization
  init,
  setEventsListeners,
  removeEventListeners,
  // Cryptography
  mnemonicToKeyPair,
  sign,
  createTonMnemonic,
  // Wallets
  createSigner,
  createAdapter,
  getAdapterAddress,
  addWallet,
  getWallets,
  getWallet,
  getWalletAddress,
  removeWallet,
  getBalance,
  // Transactions
  getRecentTransactions,
  createTransferTonTransaction,
  createTransferMultiTonTransaction,
  getTransactionPreview,
  handleNewTransaction,
  sendTransaction,
  // Requests
  approveConnectRequest,
  rejectConnectRequest,
  approveTransactionRequest,
  rejectTransactionRequest,
  approveSignDataRequest,
  rejectSignDataRequest,
  // TonConnect & sessions
  handleTonConnectUrl,
  listSessions,
  disconnectSession,
  processInternalBrowserRequest,
  // NFTs
  getNfts,
  getNft,
  createTransferNftTransaction,
  createTransferNftRawTransaction,
  // Jettons
  getJettons,
  createTransferJettonTransaction,
  getJettonBalance,
  getJettonWalletAddress,
  // Browser events
  emitBrowserPageStarted,
  emitBrowserPageFinished,
  emitBrowserError,
  emitBrowserBridgeRequest
};
const api = apiImpl;
setBridgeApi(api);
registerNativeCallHandler();
window.walletkitBridge = api;
log$l("[walletkitBridge] bootstrap complete");
//# sourceMappingURL=walletkit-android-bridge.mjs.map
